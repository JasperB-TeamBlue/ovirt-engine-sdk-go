//
// Copyright (c) 2017 Red Hat, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package ovirtsdk4

import (
	"bytes"
	"encoding/base64"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

//
// This annotation is intended to specify what oVirt area is the annotated concept related to. Currently the following
// areas are in use, and they are closely related to the oVirt teams, but not necessarily the same:
// - Infrastructure
// - Network
// - SLA
// - Storage
// - Virtualization
// A concept may be associated to more than one area, or to no area.
// The value of this annotation is intended for reporting only, and it doesn't affect at all the generated code or the
// validity of the model
//
type AreaService struct {
	BaseService
}

func NewAreaService(connection *Connection, path string) *AreaService {
	var result AreaService
	result.Connection = connection
	result.Path = path
	return &result
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AreaService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AreaService) String() string {
	return fmt.Sprintf("AreaService:%s", op.Path)
}

//
// This service manages the collection of all vNIC profiles.
//
type VnicProfilesService struct {
	BaseService
}

func NewVnicProfilesService(connection *Connection, path string) *VnicProfilesService {
	var result VnicProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VnicProfilesServiceAddRequest struct {
	vnicProfilesService *VnicProfilesService
	header              map[string]string
	query               map[string]string
	profile             *VnicProfile
}

func (p *VnicProfilesServiceAddRequest) Header(key, value string) *VnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfilesServiceAddRequest) Query(key, value string) *VnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *VnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *VnicProfilesServiceAddRequest) Send() (*VnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.Connection.URL(), p.vnicProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfilesService.Connection.username, p.vnicProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vnicProfilesServiceAddResponse VnicProfilesServiceAddResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	vnicProfilesServiceAddResponse.profile = &profileVar
	return &vnicProfilesServiceAddResponse, nil
}

type VnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *VnicProfilesServiceAddResponse) Profile() *VnicProfile {
	return p.profile
}
func (p *VnicProfilesService) Add() *VnicProfilesServiceAddRequest {
	return &VnicProfilesServiceAddRequest{vnicProfilesService: p}
}

type VnicProfilesServiceListRequest struct {
	vnicProfilesService *VnicProfilesService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *VnicProfilesServiceListRequest) Header(key, value string) *VnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfilesServiceListRequest) Query(key, value string) *VnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfilesServiceListRequest) Max(max int64) *VnicProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *VnicProfilesServiceListRequest) Send() (*VnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.Connection.URL(), p.vnicProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfilesService.Connection.username, p.vnicProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vnicProfilesServiceListResponse VnicProfilesServiceListResponse
	var profilesVar VnicProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	vnicProfilesServiceListResponse.profiles = profilesVar.VnicProfiles
	return &vnicProfilesServiceListResponse, nil
}

type VnicProfilesServiceListResponse struct {
	profiles []VnicProfile
}

func (p *VnicProfilesServiceListResponse) Profiles() []VnicProfile {
	return p.profiles
}
func (p *VnicProfilesService) List() *VnicProfilesServiceListRequest {
	return &VnicProfilesServiceListRequest{vnicProfilesService: p}
}

//
//
func (op *VnicProfilesService) ProfileService(id string) *VnicProfileService {
	return NewVnicProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VnicProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *VnicProfilesService) String() string {
	return fmt.Sprintf("VnicProfilesService:%s", op.Path)
}

//
//
type SchedulingPolicyUnitService struct {
	BaseService
}

func NewSchedulingPolicyUnitService(connection *Connection, path string) *SchedulingPolicyUnitService {
	var result SchedulingPolicyUnitService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPolicyUnitServiceGetRequest struct {
	schedulingPolicyUnitService *SchedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	filter                      *bool
}

func (p *SchedulingPolicyUnitServiceGetRequest) Header(key, value string) *SchedulingPolicyUnitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Query(key, value string) *SchedulingPolicyUnitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Filter(filter bool) *SchedulingPolicyUnitServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPolicyUnitServiceGetRequest) Send() (*SchedulingPolicyUnitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitService.Connection.URL(), p.schedulingPolicyUnitService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyUnitService.Connection.username, p.schedulingPolicyUnitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var schedulingPolicyUnitServiceGetResponse SchedulingPolicyUnitServiceGetResponse
	var unitVar SchedulingPolicyUnit
	xml.Unmarshal(respBodyBytes, &unitVar)
	schedulingPolicyUnitServiceGetResponse.unit = &unitVar
	return &schedulingPolicyUnitServiceGetResponse, nil
}

type SchedulingPolicyUnitServiceGetResponse struct {
	unit *SchedulingPolicyUnit
}

func (p *SchedulingPolicyUnitServiceGetResponse) Unit() *SchedulingPolicyUnit {
	return p.unit
}
func (p *SchedulingPolicyUnitService) Get() *SchedulingPolicyUnitServiceGetRequest {
	return &SchedulingPolicyUnitServiceGetRequest{schedulingPolicyUnitService: p}
}

type SchedulingPolicyUnitServiceRemoveRequest struct {
	schedulingPolicyUnitService *SchedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Header(key, value string) *SchedulingPolicyUnitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Query(key, value string) *SchedulingPolicyUnitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Async(async bool) *SchedulingPolicyUnitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SchedulingPolicyUnitServiceRemoveRequest) Send() (*SchedulingPolicyUnitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitService.Connection.URL(), p.schedulingPolicyUnitService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyUnitService.Connection.username, p.schedulingPolicyUnitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SchedulingPolicyUnitServiceRemoveResponse), nil
}

type SchedulingPolicyUnitServiceRemoveResponse struct {
}

func (p *SchedulingPolicyUnitService) Remove() *SchedulingPolicyUnitServiceRemoveRequest {
	return &SchedulingPolicyUnitServiceRemoveRequest{schedulingPolicyUnitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyUnitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SchedulingPolicyUnitService) String() string {
	return fmt.Sprintf("SchedulingPolicyUnitService:%s", op.Path)
}

//
//
type VirtualFunctionAllowedNetworkService struct {
	BaseService
}

func NewVirtualFunctionAllowedNetworkService(connection *Connection, path string) *VirtualFunctionAllowedNetworkService {
	var result VirtualFunctionAllowedNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type VirtualFunctionAllowedNetworkServiceGetRequest struct {
	virtualFunctionAllowedNetworkService *VirtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Header(key, value string) *VirtualFunctionAllowedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Query(key, value string) *VirtualFunctionAllowedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Send() (*VirtualFunctionAllowedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworkService.Connection.URL(), p.virtualFunctionAllowedNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.virtualFunctionAllowedNetworkService.Connection.username, p.virtualFunctionAllowedNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var virtualFunctionAllowedNetworkServiceGetResponse VirtualFunctionAllowedNetworkServiceGetResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	virtualFunctionAllowedNetworkServiceGetResponse.network = &networkVar
	return &virtualFunctionAllowedNetworkServiceGetResponse, nil
}

type VirtualFunctionAllowedNetworkServiceGetResponse struct {
	network *Network
}

func (p *VirtualFunctionAllowedNetworkServiceGetResponse) Network() *Network {
	return p.network
}
func (p *VirtualFunctionAllowedNetworkService) Get() *VirtualFunctionAllowedNetworkServiceGetRequest {
	return &VirtualFunctionAllowedNetworkServiceGetRequest{virtualFunctionAllowedNetworkService: p}
}

type VirtualFunctionAllowedNetworkServiceRemoveRequest struct {
	virtualFunctionAllowedNetworkService *VirtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Header(key, value string) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Query(key, value string) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Async(async bool) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Send() (*VirtualFunctionAllowedNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworkService.Connection.URL(), p.virtualFunctionAllowedNetworkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.virtualFunctionAllowedNetworkService.Connection.username, p.virtualFunctionAllowedNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VirtualFunctionAllowedNetworkServiceRemoveResponse), nil
}

type VirtualFunctionAllowedNetworkServiceRemoveResponse struct {
}

func (p *VirtualFunctionAllowedNetworkService) Remove() *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	return &VirtualFunctionAllowedNetworkServiceRemoveRequest{virtualFunctionAllowedNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VirtualFunctionAllowedNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VirtualFunctionAllowedNetworkService) String() string {
	return fmt.Sprintf("VirtualFunctionAllowedNetworkService:%s", op.Path)
}

//
//
type TemplateNicsService struct {
	BaseService
}

func NewTemplateNicsService(connection *Connection, path string) *TemplateNicsService {
	var result TemplateNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateNicsServiceAddRequest struct {
	templateNicsService *TemplateNicsService
	header              map[string]string
	query               map[string]string
	nic                 *Nic
}

func (p *TemplateNicsServiceAddRequest) Header(key, value string) *TemplateNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicsServiceAddRequest) Query(key, value string) *TemplateNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicsServiceAddRequest) Nic(nic *Nic) *TemplateNicsServiceAddRequest {
	p.nic = nic
	return p
}
func (p *TemplateNicsServiceAddRequest) Send() (*TemplateNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.Connection.URL(), p.templateNicsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicsService.Connection.username, p.templateNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateNicsServiceAddResponse TemplateNicsServiceAddResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	templateNicsServiceAddResponse.nic = &nicVar
	return &templateNicsServiceAddResponse, nil
}

type TemplateNicsServiceAddResponse struct {
	nic *Nic
}

func (p *TemplateNicsServiceAddResponse) Nic() *Nic {
	return p.nic
}
func (p *TemplateNicsService) Add() *TemplateNicsServiceAddRequest {
	return &TemplateNicsServiceAddRequest{templateNicsService: p}
}

type TemplateNicsServiceListRequest struct {
	templateNicsService *TemplateNicsService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *TemplateNicsServiceListRequest) Header(key, value string) *TemplateNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicsServiceListRequest) Query(key, value string) *TemplateNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicsServiceListRequest) Max(max int64) *TemplateNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateNicsServiceListRequest) Send() (*TemplateNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.Connection.URL(), p.templateNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicsService.Connection.username, p.templateNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateNicsServiceListResponse TemplateNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	templateNicsServiceListResponse.nics = nicsVar.Nics
	return &templateNicsServiceListResponse, nil
}

type TemplateNicsServiceListResponse struct {
	nics []Nic
}

func (p *TemplateNicsServiceListResponse) Nics() []Nic {
	return p.nics
}
func (p *TemplateNicsService) List() *TemplateNicsServiceListRequest {
	return &TemplateNicsServiceListRequest{templateNicsService: p}
}

//
//
func (op *TemplateNicsService) NicService(id string) *TemplateNicService {
	return NewTemplateNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *TemplateNicsService) String() string {
	return fmt.Sprintf("TemplateNicsService:%s", op.Path)
}

//
// The details of a single affinity label.
//
type AffinityLabelService struct {
	BaseService
}

func NewAffinityLabelService(connection *Connection, path string) *AffinityLabelService {
	var result AffinityLabelService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelServiceGetRequest struct {
	affinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
}

func (p *AffinityLabelServiceGetRequest) Header(key, value string) *AffinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceGetRequest) Query(key, value string) *AffinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceGetRequest) Send() (*AffinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.Connection.URL(), p.affinityLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelService.Connection.username, p.affinityLabelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelServiceGetResponse AffinityLabelServiceGetResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	affinityLabelServiceGetResponse.label = &labelVar
	return &affinityLabelServiceGetResponse, nil
}

type AffinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelServiceGetResponse) Label() *AffinityLabel {
	return p.label
}
func (p *AffinityLabelService) Get() *AffinityLabelServiceGetRequest {
	return &AffinityLabelServiceGetRequest{affinityLabelService: p}
}

type AffinityLabelServiceRemoveRequest struct {
	affinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
}

func (p *AffinityLabelServiceRemoveRequest) Header(key, value string) *AffinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceRemoveRequest) Query(key, value string) *AffinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceRemoveRequest) Send() (*AffinityLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.Connection.URL(), p.affinityLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelService.Connection.username, p.affinityLabelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityLabelServiceRemoveResponse), nil
}

type AffinityLabelServiceRemoveResponse struct {
}

func (p *AffinityLabelService) Remove() *AffinityLabelServiceRemoveRequest {
	return &AffinityLabelServiceRemoveRequest{affinityLabelService: p}
}

type AffinityLabelServiceUpdateRequest struct {
	affinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
	label                *AffinityLabel
}

func (p *AffinityLabelServiceUpdateRequest) Header(key, value string) *AffinityLabelServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceUpdateRequest) Query(key, value string) *AffinityLabelServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceUpdateRequest) Label(label *AffinityLabel) *AffinityLabelServiceUpdateRequest {
	p.label = label
	return p
}
func (p *AffinityLabelServiceUpdateRequest) Send() (*AffinityLabelServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.Connection.URL(), p.affinityLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.label)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelService.Connection.username, p.affinityLabelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelServiceUpdateResponse AffinityLabelServiceUpdateResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	affinityLabelServiceUpdateResponse.label = &labelVar
	return &affinityLabelServiceUpdateResponse, nil
}

type AffinityLabelServiceUpdateResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelServiceUpdateResponse) Label() *AffinityLabel {
	return p.label
}
func (p *AffinityLabelService) Update() *AffinityLabelServiceUpdateRequest {
	return &AffinityLabelServiceUpdateRequest{affinityLabelService: p}
}

//
// List all hosts with this label.
//
func (op *AffinityLabelService) HostsService() *AffinityLabelHostsService {
	return NewAffinityLabelHostsService(op.Connection, fmt.Sprintf("%s/hosts", op.Path))
}

//
// List all virtual machines with this label.
//
func (op *AffinityLabelService) VmsService() *AffinityLabelVmsService {
	return NewAffinityLabelVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelService) String() string {
	return fmt.Sprintf("AffinityLabelService:%s", op.Path)
}

//
// A service to manage bookmarks.
//
type BookmarksService struct {
	BaseService
}

func NewBookmarksService(connection *Connection, path string) *BookmarksService {
	var result BookmarksService
	result.Connection = connection
	result.Path = path
	return &result
}

type BookmarksServiceAddRequest struct {
	bookmarksService *BookmarksService
	header           map[string]string
	query            map[string]string
	bookmark         *Bookmark
}

func (p *BookmarksServiceAddRequest) Header(key, value string) *BookmarksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarksServiceAddRequest) Query(key, value string) *BookmarksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarksServiceAddRequest) Bookmark(bookmark *Bookmark) *BookmarksServiceAddRequest {
	p.bookmark = bookmark
	return p
}
func (p *BookmarksServiceAddRequest) Send() (*BookmarksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.Connection.URL(), p.bookmarksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bookmark)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarksService.Connection.username, p.bookmarksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var bookmarksServiceAddResponse BookmarksServiceAddResponse
	var bookmarkVar Bookmark
	xml.Unmarshal(respBodyBytes, &bookmarkVar)
	bookmarksServiceAddResponse.bookmark = &bookmarkVar
	return &bookmarksServiceAddResponse, nil
}

type BookmarksServiceAddResponse struct {
	bookmark *Bookmark
}

func (p *BookmarksServiceAddResponse) Bookmark() *Bookmark {
	return p.bookmark
}
func (p *BookmarksService) Add() *BookmarksServiceAddRequest {
	return &BookmarksServiceAddRequest{bookmarksService: p}
}

type BookmarksServiceListRequest struct {
	bookmarksService *BookmarksService
	header           map[string]string
	query            map[string]string
	max              *int64
}

func (p *BookmarksServiceListRequest) Header(key, value string) *BookmarksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarksServiceListRequest) Query(key, value string) *BookmarksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarksServiceListRequest) Max(max int64) *BookmarksServiceListRequest {
	p.max = &max
	return p
}
func (p *BookmarksServiceListRequest) Send() (*BookmarksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.Connection.URL(), p.bookmarksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarksService.Connection.username, p.bookmarksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var bookmarksServiceListResponse BookmarksServiceListResponse
	var bookmarksVar Bookmarks
	xml.Unmarshal(respBodyBytes, &bookmarksVar)
	bookmarksServiceListResponse.bookmarks = bookmarksVar.Bookmarks
	return &bookmarksServiceListResponse, nil
}

type BookmarksServiceListResponse struct {
	bookmarks []Bookmark
}

func (p *BookmarksServiceListResponse) Bookmarks() []Bookmark {
	return p.bookmarks
}
func (p *BookmarksService) List() *BookmarksServiceListRequest {
	return &BookmarksServiceListRequest{bookmarksService: p}
}

//
// A reference to the service managing a specific bookmark.
//
func (op *BookmarksService) BookmarkService(id string) *BookmarkService {
	return NewBookmarkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BookmarksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.BookmarkService(path)), nil
	}
	return op.BookmarkService(path[:index]).Service(path[index+1:])
}

func (op *BookmarksService) String() string {
	return fmt.Sprintf("BookmarksService:%s", op.Path)
}

//
//
type NetworkAttachmentsService struct {
	BaseService
}

func NewNetworkAttachmentsService(connection *Connection, path string) *NetworkAttachmentsService {
	var result NetworkAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkAttachmentsServiceAddRequest struct {
	networkAttachmentsService *NetworkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	attachment                *NetworkAttachment
}

func (p *NetworkAttachmentsServiceAddRequest) Header(key, value string) *NetworkAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentsServiceAddRequest) Query(key, value string) *NetworkAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentsServiceAddRequest) Attachment(attachment *NetworkAttachment) *NetworkAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}
func (p *NetworkAttachmentsServiceAddRequest) Send() (*NetworkAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.Connection.URL(), p.networkAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.attachment)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentsService.Connection.username, p.networkAttachmentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkAttachmentsServiceAddResponse NetworkAttachmentsServiceAddResponse
	var attachmentVar NetworkAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	networkAttachmentsServiceAddResponse.attachment = &attachmentVar
	return &networkAttachmentsServiceAddResponse, nil
}

type NetworkAttachmentsServiceAddResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentsServiceAddResponse) Attachment() *NetworkAttachment {
	return p.attachment
}
func (p *NetworkAttachmentsService) Add() *NetworkAttachmentsServiceAddRequest {
	return &NetworkAttachmentsServiceAddRequest{networkAttachmentsService: p}
}

type NetworkAttachmentsServiceListRequest struct {
	networkAttachmentsService *NetworkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *NetworkAttachmentsServiceListRequest) Header(key, value string) *NetworkAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Query(key, value string) *NetworkAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Max(max int64) *NetworkAttachmentsServiceListRequest {
	p.max = &max
	return p
}
func (p *NetworkAttachmentsServiceListRequest) Send() (*NetworkAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.Connection.URL(), p.networkAttachmentsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentsService.Connection.username, p.networkAttachmentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkAttachmentsServiceListResponse NetworkAttachmentsServiceListResponse
	var attachmentsVar NetworkAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	networkAttachmentsServiceListResponse.attachments = attachmentsVar.NetworkAttachments
	return &networkAttachmentsServiceListResponse, nil
}

type NetworkAttachmentsServiceListResponse struct {
	attachments []NetworkAttachment
}

func (p *NetworkAttachmentsServiceListResponse) Attachments() []NetworkAttachment {
	return p.attachments
}
func (p *NetworkAttachmentsService) List() *NetworkAttachmentsServiceListRequest {
	return &NetworkAttachmentsServiceListRequest{networkAttachmentsService: p}
}

//
//
func (op *NetworkAttachmentsService) AttachmentService(id string) *NetworkAttachmentService {
	return NewNetworkAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *NetworkAttachmentsService) String() string {
	return fmt.Sprintf("NetworkAttachmentsService:%s", op.Path)
}

//
//
type OperatingSystemService struct {
	BaseService
}

func NewOperatingSystemService(connection *Connection, path string) *OperatingSystemService {
	var result OperatingSystemService
	result.Connection = connection
	result.Path = path
	return &result
}

type OperatingSystemServiceGetRequest struct {
	operatingSystemService *OperatingSystemService
	header                 map[string]string
	query                  map[string]string
}

func (p *OperatingSystemServiceGetRequest) Header(key, value string) *OperatingSystemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OperatingSystemServiceGetRequest) Query(key, value string) *OperatingSystemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OperatingSystemServiceGetRequest) Send() (*OperatingSystemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemService.Connection.URL(), p.operatingSystemService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.operatingSystemService.Connection.username, p.operatingSystemService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.operatingSystemService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var operatingSystemServiceGetResponse OperatingSystemServiceGetResponse
	var operatingSystemVar OperatingSystemInfo
	xml.Unmarshal(respBodyBytes, &operatingSystemVar)
	operatingSystemServiceGetResponse.operatingSystem = &operatingSystemVar
	return &operatingSystemServiceGetResponse, nil
}

type OperatingSystemServiceGetResponse struct {
	operatingSystem *OperatingSystemInfo
}

func (p *OperatingSystemServiceGetResponse) OperatingSystem() *OperatingSystemInfo {
	return p.operatingSystem
}
func (p *OperatingSystemService) Get() *OperatingSystemServiceGetRequest {
	return &OperatingSystemServiceGetRequest{operatingSystemService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OperatingSystemService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OperatingSystemService) String() string {
	return fmt.Sprintf("OperatingSystemService:%s", op.Path)
}

//
//
type TemplateDisksService struct {
	BaseService
}

func NewTemplateDisksService(connection *Connection, path string) *TemplateDisksService {
	var result TemplateDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDisksServiceListRequest struct {
	templateDisksService *TemplateDisksService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *TemplateDisksServiceListRequest) Header(key, value string) *TemplateDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDisksServiceListRequest) Query(key, value string) *TemplateDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDisksServiceListRequest) Max(max int64) *TemplateDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateDisksServiceListRequest) Send() (*TemplateDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDisksService.Connection.URL(), p.templateDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDisksService.Connection.username, p.templateDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateDisksServiceListResponse TemplateDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	templateDisksServiceListResponse.disks = disksVar.Disks
	return &templateDisksServiceListResponse, nil
}

type TemplateDisksServiceListResponse struct {
	disks []Disk
}

func (p *TemplateDisksServiceListResponse) Disks() []Disk {
	return p.disks
}
func (p *TemplateDisksService) List() *TemplateDisksServiceListRequest {
	return &TemplateDisksServiceListRequest{templateDisksService: p}
}

//
//
func (op *TemplateDisksService) DiskService(id string) *TemplateDiskService {
	return NewTemplateDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *TemplateDisksService) String() string {
	return fmt.Sprintf("TemplateDisksService:%s", op.Path)
}

//
// This service doesn't add any new methods, it is just a placeholder for the annotation that specifies the path of the
// resource that manages the permissions assigned to the system object.
//
type SystemPermissionsService struct {
	BaseService
}

func NewSystemPermissionsService(connection *Connection, path string) *SystemPermissionsService {
	var result SystemPermissionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SystemPermissionsServiceAddRequest struct {
	systemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddRequest) Header(key, value string) *SystemPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddRequest) Query(key, value string) *SystemPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddRequest) Permission(permission *Permission) *SystemPermissionsServiceAddRequest {
	p.permission = permission
	return p
}
func (p *SystemPermissionsServiceAddRequest) Send() (*SystemPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.Connection.URL(), p.systemPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.permission)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.systemPermissionsService.Connection.username, p.systemPermissionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var systemPermissionsServiceAddResponse SystemPermissionsServiceAddResponse
	var permissionVar Permission
	xml.Unmarshal(respBodyBytes, &permissionVar)
	systemPermissionsServiceAddResponse.permission = &permissionVar
	return &systemPermissionsServiceAddResponse, nil
}

type SystemPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddResponse) Permission() *Permission {
	return p.permission
}
func (p *SystemPermissionsService) Add() *SystemPermissionsServiceAddRequest {
	return &SystemPermissionsServiceAddRequest{systemPermissionsService: p}
}

type SystemPermissionsServiceListRequest struct {
	systemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
}

func (p *SystemPermissionsServiceListRequest) Header(key, value string) *SystemPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceListRequest) Query(key, value string) *SystemPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceListRequest) Send() (*SystemPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.Connection.URL(), p.systemPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.systemPermissionsService.Connection.username, p.systemPermissionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var systemPermissionsServiceListResponse SystemPermissionsServiceListResponse
	var permissionsVar Permissions
	xml.Unmarshal(respBodyBytes, &permissionsVar)
	systemPermissionsServiceListResponse.permissions = permissionsVar.Permissions
	return &systemPermissionsServiceListResponse, nil
}

type SystemPermissionsServiceListResponse struct {
	permissions []Permission
}

func (p *SystemPermissionsServiceListResponse) Permissions() []Permission {
	return p.permissions
}
func (p *SystemPermissionsService) List() *SystemPermissionsServiceListRequest {
	return &SystemPermissionsServiceListRequest{systemPermissionsService: p}
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *SystemPermissionsService) PermissionService(id string) *PermissionService {
	return NewPermissionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemPermissionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PermissionService(path)), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *SystemPermissionsService) String() string {
	return fmt.Sprintf("SystemPermissionsService:%s", op.Path)
}

//
//
type VmReportedDeviceService struct {
	BaseService
}

func NewVmReportedDeviceService(connection *Connection, path string) *VmReportedDeviceService {
	var result VmReportedDeviceService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmReportedDeviceServiceGetRequest struct {
	vmReportedDeviceService *VmReportedDeviceService
	header                  map[string]string
	query                   map[string]string
}

func (p *VmReportedDeviceServiceGetRequest) Header(key, value string) *VmReportedDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmReportedDeviceServiceGetRequest) Query(key, value string) *VmReportedDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmReportedDeviceServiceGetRequest) Send() (*VmReportedDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDeviceService.Connection.URL(), p.vmReportedDeviceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmReportedDeviceService.Connection.username, p.vmReportedDeviceService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmReportedDeviceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmReportedDeviceServiceGetResponse VmReportedDeviceServiceGetResponse
	var reportedDeviceVar ReportedDevice
	xml.Unmarshal(respBodyBytes, &reportedDeviceVar)
	vmReportedDeviceServiceGetResponse.reportedDevice = &reportedDeviceVar
	return &vmReportedDeviceServiceGetResponse, nil
}

type VmReportedDeviceServiceGetResponse struct {
	reportedDevice *ReportedDevice
}

func (p *VmReportedDeviceServiceGetResponse) ReportedDevice() *ReportedDevice {
	return p.reportedDevice
}
func (p *VmReportedDeviceService) Get() *VmReportedDeviceServiceGetRequest {
	return &VmReportedDeviceServiceGetRequest{vmReportedDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmReportedDeviceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmReportedDeviceService) String() string {
	return fmt.Sprintf("VmReportedDeviceService:%s", op.Path)
}

//
//
type SnapshotNicsService struct {
	BaseService
}

func NewSnapshotNicsService(connection *Connection, path string) *SnapshotNicsService {
	var result SnapshotNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotNicsServiceListRequest struct {
	snapshotNicsService *SnapshotNicsService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *SnapshotNicsServiceListRequest) Header(key, value string) *SnapshotNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotNicsServiceListRequest) Query(key, value string) *SnapshotNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotNicsServiceListRequest) Max(max int64) *SnapshotNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotNicsServiceListRequest) Send() (*SnapshotNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicsService.Connection.URL(), p.snapshotNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotNicsService.Connection.username, p.snapshotNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotNicsServiceListResponse SnapshotNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	snapshotNicsServiceListResponse.nics = nicsVar.Nics
	return &snapshotNicsServiceListResponse, nil
}

type SnapshotNicsServiceListResponse struct {
	nics []Nic
}

func (p *SnapshotNicsServiceListResponse) Nics() []Nic {
	return p.nics
}
func (p *SnapshotNicsService) List() *SnapshotNicsServiceListRequest {
	return &SnapshotNicsServiceListRequest{snapshotNicsService: p}
}

//
//
func (op *SnapshotNicsService) NicService(id string) *SnapshotNicService {
	return NewSnapshotNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotNicsService) String() string {
	return fmt.Sprintf("SnapshotNicsService:%s", op.Path)
}

//
//
type AssignedVnicProfilesService struct {
	BaseService
}

func NewAssignedVnicProfilesService(connection *Connection, path string) *AssignedVnicProfilesService {
	var result AssignedVnicProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedVnicProfilesServiceAddRequest struct {
	assignedVnicProfilesService *AssignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *VnicProfile
}

func (p *AssignedVnicProfilesServiceAddRequest) Header(key, value string) *AssignedVnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceAddRequest) Query(key, value string) *AssignedVnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *AssignedVnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *AssignedVnicProfilesServiceAddRequest) Send() (*AssignedVnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.Connection.URL(), p.assignedVnicProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedVnicProfilesService.Connection.username, p.assignedVnicProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedVnicProfilesServiceAddResponse AssignedVnicProfilesServiceAddResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedVnicProfilesServiceAddResponse.profile = &profileVar
	return &assignedVnicProfilesServiceAddResponse, nil
}

type AssignedVnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *AssignedVnicProfilesServiceAddResponse) Profile() *VnicProfile {
	return p.profile
}
func (p *AssignedVnicProfilesService) Add() *AssignedVnicProfilesServiceAddRequest {
	return &AssignedVnicProfilesServiceAddRequest{assignedVnicProfilesService: p}
}

type AssignedVnicProfilesServiceListRequest struct {
	assignedVnicProfilesService *AssignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	max                         *int64
}

func (p *AssignedVnicProfilesServiceListRequest) Header(key, value string) *AssignedVnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Query(key, value string) *AssignedVnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Max(max int64) *AssignedVnicProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedVnicProfilesServiceListRequest) Send() (*AssignedVnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.Connection.URL(), p.assignedVnicProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedVnicProfilesService.Connection.username, p.assignedVnicProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedVnicProfilesServiceListResponse AssignedVnicProfilesServiceListResponse
	var profilesVar VnicProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	assignedVnicProfilesServiceListResponse.profiles = profilesVar.VnicProfiles
	return &assignedVnicProfilesServiceListResponse, nil
}

type AssignedVnicProfilesServiceListResponse struct {
	profiles []VnicProfile
}

func (p *AssignedVnicProfilesServiceListResponse) Profiles() []VnicProfile {
	return p.profiles
}
func (p *AssignedVnicProfilesService) List() *AssignedVnicProfilesServiceListRequest {
	return &AssignedVnicProfilesServiceListRequest{assignedVnicProfilesService: p}
}

//
//
func (op *AssignedVnicProfilesService) ProfileService(id string) *AssignedVnicProfileService {
	return NewAssignedVnicProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedVnicProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedVnicProfilesService) String() string {
	return fmt.Sprintf("AssignedVnicProfilesService:%s", op.Path)
}

//
//
type QuotaClusterLimitsService struct {
	BaseService
}

func NewQuotaClusterLimitsService(connection *Connection, path string) *QuotaClusterLimitsService {
	var result QuotaClusterLimitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaClusterLimitsServiceAddRequest struct {
	quotaClusterLimitsService *QuotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceAddRequest) Header(key, value string) *QuotaClusterLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceAddRequest) Query(key, value string) *QuotaClusterLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceAddRequest) Limit(limit *QuotaClusterLimit) *QuotaClusterLimitsServiceAddRequest {
	p.limit = limit
	return p
}
func (p *QuotaClusterLimitsServiceAddRequest) Send() (*QuotaClusterLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.Connection.URL(), p.quotaClusterLimitsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.limit)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaClusterLimitsService.Connection.username, p.quotaClusterLimitsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaClusterLimitsServiceAddResponse QuotaClusterLimitsServiceAddResponse
	var limitVar QuotaClusterLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaClusterLimitsServiceAddResponse.limit = &limitVar
	return &quotaClusterLimitsServiceAddResponse, nil
}

type QuotaClusterLimitsServiceAddResponse struct {
	limit *QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceAddResponse) Limit() *QuotaClusterLimit {
	return p.limit
}
func (p *QuotaClusterLimitsService) Add() *QuotaClusterLimitsServiceAddRequest {
	return &QuotaClusterLimitsServiceAddRequest{quotaClusterLimitsService: p}
}

type QuotaClusterLimitsServiceListRequest struct {
	quotaClusterLimitsService *QuotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *QuotaClusterLimitsServiceListRequest) Header(key, value string) *QuotaClusterLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Query(key, value string) *QuotaClusterLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Max(max int64) *QuotaClusterLimitsServiceListRequest {
	p.max = &max
	return p
}
func (p *QuotaClusterLimitsServiceListRequest) Send() (*QuotaClusterLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.Connection.URL(), p.quotaClusterLimitsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaClusterLimitsService.Connection.username, p.quotaClusterLimitsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaClusterLimitsServiceListResponse QuotaClusterLimitsServiceListResponse
	var limitsVar QuotaClusterLimits
	xml.Unmarshal(respBodyBytes, &limitsVar)
	quotaClusterLimitsServiceListResponse.limits = limitsVar.QuotaClusterLimits
	return &quotaClusterLimitsServiceListResponse, nil
}

type QuotaClusterLimitsServiceListResponse struct {
	limits []QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceListResponse) Limits() []QuotaClusterLimit {
	return p.limits
}
func (p *QuotaClusterLimitsService) List() *QuotaClusterLimitsServiceListRequest {
	return &QuotaClusterLimitsServiceListRequest{quotaClusterLimitsService: p}
}

//
//
func (op *QuotaClusterLimitsService) LimitService(id string) *QuotaClusterLimitService {
	return NewQuotaClusterLimitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaClusterLimitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LimitService(path)), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *QuotaClusterLimitsService) String() string {
	return fmt.Sprintf("QuotaClusterLimitsService:%s", op.Path)
}

//
// Manages logical networks.
// The engine creates a default `ovirtmgmt` network on installation. This network acts as the management network for
// access to hypervisor hosts. This network is associated with the `Default` cluster and is a member of the `Default`
// data center.
//
type NetworksService struct {
	BaseService
}

func NewNetworksService(connection *Connection, path string) *NetworksService {
	var result NetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworksServiceAddRequest struct {
	networksService *NetworksService
	header          map[string]string
	query           map[string]string
	network         *Network
}

func (p *NetworksServiceAddRequest) Header(key, value string) *NetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworksServiceAddRequest) Query(key, value string) *NetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworksServiceAddRequest) Network(network *Network) *NetworksServiceAddRequest {
	p.network = network
	return p
}
func (p *NetworksServiceAddRequest) Send() (*NetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networksService.Connection.URL(), p.networksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networksService.Connection.username, p.networksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networksServiceAddResponse NetworksServiceAddResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	networksServiceAddResponse.network = &networkVar
	return &networksServiceAddResponse, nil
}

type NetworksServiceAddResponse struct {
	network *Network
}

func (p *NetworksServiceAddResponse) Network() *Network {
	return p.network
}
func (p *NetworksService) Add() *NetworksServiceAddRequest {
	return &NetworksServiceAddRequest{networksService: p}
}

type NetworksServiceListRequest struct {
	networksService *NetworksService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	max             *int64
	search          *string
}

func (p *NetworksServiceListRequest) Header(key, value string) *NetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworksServiceListRequest) Query(key, value string) *NetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworksServiceListRequest) CaseSensitive(caseSensitive bool) *NetworksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *NetworksServiceListRequest) Max(max int64) *NetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *NetworksServiceListRequest) Search(search string) *NetworksServiceListRequest {
	p.search = &search
	return p
}
func (p *NetworksServiceListRequest) Send() (*NetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networksService.Connection.URL(), p.networksService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networksService.Connection.username, p.networksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networksServiceListResponse NetworksServiceListResponse
	var networksVar Networks
	xml.Unmarshal(respBodyBytes, &networksVar)
	networksServiceListResponse.networks = networksVar.Networks
	return &networksServiceListResponse, nil
}

type NetworksServiceListResponse struct {
	networks []Network
}

func (p *NetworksServiceListResponse) Networks() []Network {
	return p.networks
}
func (p *NetworksService) List() *NetworksServiceListRequest {
	return &NetworksServiceListRequest{networksService: p}
}

//
// Reference to the service that manages a specific network.
//
func (op *NetworksService) NetworkService(id string) *NetworkService {
	return NewNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *NetworksService) String() string {
	return fmt.Sprintf("NetworksService:%s", op.Path)
}

//
// The affinity groups service manages virtual machine relationships and dependencies.
//
type AffinityGroupsService struct {
	BaseService
}

func NewAffinityGroupsService(connection *Connection, path string) *AffinityGroupsService {
	var result AffinityGroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupsServiceAddRequest struct {
	affinityGroupsService *AffinityGroupsService
	header                map[string]string
	query                 map[string]string
	group                 *AffinityGroup
}

func (p *AffinityGroupsServiceAddRequest) Header(key, value string) *AffinityGroupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupsServiceAddRequest) Query(key, value string) *AffinityGroupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupsServiceAddRequest) Group(group *AffinityGroup) *AffinityGroupsServiceAddRequest {
	p.group = group
	return p
}
func (p *AffinityGroupsServiceAddRequest) Send() (*AffinityGroupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.Connection.URL(), p.affinityGroupsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.group)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupsService.Connection.username, p.affinityGroupsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityGroupsServiceAddResponse AffinityGroupsServiceAddResponse
	var groupVar AffinityGroup
	xml.Unmarshal(respBodyBytes, &groupVar)
	affinityGroupsServiceAddResponse.group = &groupVar
	return &affinityGroupsServiceAddResponse, nil
}

type AffinityGroupsServiceAddResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupsServiceAddResponse) Group() *AffinityGroup {
	return p.group
}
func (p *AffinityGroupsService) Add() *AffinityGroupsServiceAddRequest {
	return &AffinityGroupsServiceAddRequest{affinityGroupsService: p}
}

type AffinityGroupsServiceListRequest struct {
	affinityGroupsService *AffinityGroupsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *AffinityGroupsServiceListRequest) Header(key, value string) *AffinityGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupsServiceListRequest) Query(key, value string) *AffinityGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupsServiceListRequest) Max(max int64) *AffinityGroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *AffinityGroupsServiceListRequest) Send() (*AffinityGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.Connection.URL(), p.affinityGroupsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupsService.Connection.username, p.affinityGroupsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityGroupsServiceListResponse AffinityGroupsServiceListResponse
	var groupsVar AffinityGroups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	affinityGroupsServiceListResponse.groups = groupsVar.AffinityGroups
	return &affinityGroupsServiceListResponse, nil
}

type AffinityGroupsServiceListResponse struct {
	groups []AffinityGroup
}

func (p *AffinityGroupsServiceListResponse) Groups() []AffinityGroup {
	return p.groups
}
func (p *AffinityGroupsService) List() *AffinityGroupsServiceListRequest {
	return &AffinityGroupsServiceListRequest{affinityGroupsService: p}
}

//
// Access the affinity group service that manages the affinity group specified by an ID.
//
func (op *AffinityGroupsService) GroupService(id string) *AffinityGroupService {
	return NewAffinityGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupsService) String() string {
	return fmt.Sprintf("AffinityGroupsService:%s", op.Path)
}

//
//
type DiskSnapshotService struct {
	BaseService
}

func NewDiskSnapshotService(connection *Connection, path string) *DiskSnapshotService {
	var result DiskSnapshotService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskSnapshotServiceGetRequest struct {
	diskSnapshotService *DiskSnapshotService
	header              map[string]string
	query               map[string]string
}

func (p *DiskSnapshotServiceGetRequest) Header(key, value string) *DiskSnapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotServiceGetRequest) Query(key, value string) *DiskSnapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotServiceGetRequest) Send() (*DiskSnapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotService.Connection.URL(), p.diskSnapshotService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskSnapshotService.Connection.username, p.diskSnapshotService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskSnapshotService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskSnapshotServiceGetResponse DiskSnapshotServiceGetResponse
	var snapshotVar DiskSnapshot
	xml.Unmarshal(respBodyBytes, &snapshotVar)
	diskSnapshotServiceGetResponse.snapshot = &snapshotVar
	return &diskSnapshotServiceGetResponse, nil
}

type DiskSnapshotServiceGetResponse struct {
	snapshot *DiskSnapshot
}

func (p *DiskSnapshotServiceGetResponse) Snapshot() *DiskSnapshot {
	return p.snapshot
}
func (p *DiskSnapshotService) Get() *DiskSnapshotServiceGetRequest {
	return &DiskSnapshotServiceGetRequest{diskSnapshotService: p}
}

type DiskSnapshotServiceRemoveRequest struct {
	diskSnapshotService *DiskSnapshotService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *DiskSnapshotServiceRemoveRequest) Header(key, value string) *DiskSnapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotServiceRemoveRequest) Query(key, value string) *DiskSnapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotServiceRemoveRequest) Async(async bool) *DiskSnapshotServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DiskSnapshotServiceRemoveRequest) Send() (*DiskSnapshotServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotService.Connection.URL(), p.diskSnapshotService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskSnapshotService.Connection.username, p.diskSnapshotService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskSnapshotService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskSnapshotServiceRemoveResponse), nil
}

type DiskSnapshotServiceRemoveResponse struct {
}

func (p *DiskSnapshotService) Remove() *DiskSnapshotServiceRemoveRequest {
	return &DiskSnapshotServiceRemoveRequest{diskSnapshotService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskSnapshotService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskSnapshotService) String() string {
	return fmt.Sprintf("DiskSnapshotService:%s", op.Path)
}

//
//
type SchedulingPolicyService struct {
	BaseService
}

func NewSchedulingPolicyService(connection *Connection, path string) *SchedulingPolicyService {
	var result SchedulingPolicyService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPolicyServiceGetRequest struct {
	schedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	filter                  *bool
}

func (p *SchedulingPolicyServiceGetRequest) Header(key, value string) *SchedulingPolicyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Query(key, value string) *SchedulingPolicyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Filter(filter bool) *SchedulingPolicyServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPolicyServiceGetRequest) Send() (*SchedulingPolicyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.Connection.URL(), p.schedulingPolicyService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyService.Connection.username, p.schedulingPolicyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var schedulingPolicyServiceGetResponse SchedulingPolicyServiceGetResponse
	var policyVar SchedulingPolicy
	xml.Unmarshal(respBodyBytes, &policyVar)
	schedulingPolicyServiceGetResponse.policy = &policyVar
	return &schedulingPolicyServiceGetResponse, nil
}

type SchedulingPolicyServiceGetResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPolicyServiceGetResponse) Policy() *SchedulingPolicy {
	return p.policy
}
func (p *SchedulingPolicyService) Get() *SchedulingPolicyServiceGetRequest {
	return &SchedulingPolicyServiceGetRequest{schedulingPolicyService: p}
}

type SchedulingPolicyServiceRemoveRequest struct {
	schedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *SchedulingPolicyServiceRemoveRequest) Header(key, value string) *SchedulingPolicyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceRemoveRequest) Query(key, value string) *SchedulingPolicyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceRemoveRequest) Async(async bool) *SchedulingPolicyServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SchedulingPolicyServiceRemoveRequest) Send() (*SchedulingPolicyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.Connection.URL(), p.schedulingPolicyService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyService.Connection.username, p.schedulingPolicyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SchedulingPolicyServiceRemoveResponse), nil
}

type SchedulingPolicyServiceRemoveResponse struct {
}

func (p *SchedulingPolicyService) Remove() *SchedulingPolicyServiceRemoveRequest {
	return &SchedulingPolicyServiceRemoveRequest{schedulingPolicyService: p}
}

type SchedulingPolicyServiceUpdateRequest struct {
	schedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	policy                  *SchedulingPolicy
}

func (p *SchedulingPolicyServiceUpdateRequest) Header(key, value string) *SchedulingPolicyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Query(key, value string) *SchedulingPolicyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Async(async bool) *SchedulingPolicyServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *SchedulingPolicyServiceUpdateRequest) Policy(policy *SchedulingPolicy) *SchedulingPolicyServiceUpdateRequest {
	p.policy = policy
	return p
}
func (p *SchedulingPolicyServiceUpdateRequest) Send() (*SchedulingPolicyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.Connection.URL(), p.schedulingPolicyService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.policy)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyService.Connection.username, p.schedulingPolicyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var schedulingPolicyServiceUpdateResponse SchedulingPolicyServiceUpdateResponse
	var policyVar SchedulingPolicy
	xml.Unmarshal(respBodyBytes, &policyVar)
	schedulingPolicyServiceUpdateResponse.policy = &policyVar
	return &schedulingPolicyServiceUpdateResponse, nil
}

type SchedulingPolicyServiceUpdateResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPolicyServiceUpdateResponse) Policy() *SchedulingPolicy {
	return p.policy
}
func (p *SchedulingPolicyService) Update() *SchedulingPolicyServiceUpdateRequest {
	return &SchedulingPolicyServiceUpdateRequest{schedulingPolicyService: p}
}

//
//
func (op *SchedulingPolicyService) BalancesService() *BalancesService {
	return NewBalancesService(op.Connection, fmt.Sprintf("%s/balances", op.Path))
}

//
//
func (op *SchedulingPolicyService) FiltersService() *FiltersService {
	return NewFiltersService(op.Connection, fmt.Sprintf("%s/filters", op.Path))
}

//
//
func (op *SchedulingPolicyService) WeightsService() *WeightsService {
	return NewWeightsService(op.Connection, fmt.Sprintf("%s/weights", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "balances" {
		return op.BalancesService(), nil
	}
	if strings.HasPrefix(path, "balances/") {
		return op.BalancesService().Service(path[9:])
	}
	if path == "filters" {
		return op.FiltersService(), nil
	}
	if strings.HasPrefix(path, "filters/") {
		return op.FiltersService().Service(path[8:])
	}
	if path == "weights" {
		return op.WeightsService(), nil
	}
	if strings.HasPrefix(path, "weights/") {
		return op.WeightsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SchedulingPolicyService) String() string {
	return fmt.Sprintf("SchedulingPolicyService:%s", op.Path)
}

//
//
type NetworkAttachmentService struct {
	BaseService
}

func NewNetworkAttachmentService(connection *Connection, path string) *NetworkAttachmentService {
	var result NetworkAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkAttachmentServiceGetRequest struct {
	networkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
}

func (p *NetworkAttachmentServiceGetRequest) Header(key, value string) *NetworkAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceGetRequest) Query(key, value string) *NetworkAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceGetRequest) Send() (*NetworkAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.Connection.URL(), p.networkAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentService.Connection.username, p.networkAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkAttachmentServiceGetResponse NetworkAttachmentServiceGetResponse
	var attachmentVar NetworkAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	networkAttachmentServiceGetResponse.attachment = &attachmentVar
	return &networkAttachmentServiceGetResponse, nil
}

type NetworkAttachmentServiceGetResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentServiceGetResponse) Attachment() *NetworkAttachment {
	return p.attachment
}
func (p *NetworkAttachmentService) Get() *NetworkAttachmentServiceGetRequest {
	return &NetworkAttachmentServiceGetRequest{networkAttachmentService: p}
}

type NetworkAttachmentServiceRemoveRequest struct {
	networkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *NetworkAttachmentServiceRemoveRequest) Header(key, value string) *NetworkAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceRemoveRequest) Query(key, value string) *NetworkAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceRemoveRequest) Async(async bool) *NetworkAttachmentServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *NetworkAttachmentServiceRemoveRequest) Send() (*NetworkAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.Connection.URL(), p.networkAttachmentService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentService.Connection.username, p.networkAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NetworkAttachmentServiceRemoveResponse), nil
}

type NetworkAttachmentServiceRemoveResponse struct {
}

func (p *NetworkAttachmentService) Remove() *NetworkAttachmentServiceRemoveRequest {
	return &NetworkAttachmentServiceRemoveRequest{networkAttachmentService: p}
}

type NetworkAttachmentServiceUpdateRequest struct {
	networkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	attachment               *NetworkAttachment
}

func (p *NetworkAttachmentServiceUpdateRequest) Header(key, value string) *NetworkAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Query(key, value string) *NetworkAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Async(async bool) *NetworkAttachmentServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *NetworkAttachmentServiceUpdateRequest) Attachment(attachment *NetworkAttachment) *NetworkAttachmentServiceUpdateRequest {
	p.attachment = attachment
	return p
}
func (p *NetworkAttachmentServiceUpdateRequest) Send() (*NetworkAttachmentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.Connection.URL(), p.networkAttachmentService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.attachment)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentService.Connection.username, p.networkAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkAttachmentServiceUpdateResponse NetworkAttachmentServiceUpdateResponse
	var attachmentVar NetworkAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	networkAttachmentServiceUpdateResponse.attachment = &attachmentVar
	return &networkAttachmentServiceUpdateResponse, nil
}

type NetworkAttachmentServiceUpdateResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentServiceUpdateResponse) Attachment() *NetworkAttachment {
	return p.attachment
}
func (p *NetworkAttachmentService) Update() *NetworkAttachmentServiceUpdateRequest {
	return &NetworkAttachmentServiceUpdateRequest{networkAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkAttachmentService) String() string {
	return fmt.Sprintf("NetworkAttachmentService:%s", op.Path)
}

//
//
type DiskProfilesService struct {
	BaseService
}

func NewDiskProfilesService(connection *Connection, path string) *DiskProfilesService {
	var result DiskProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskProfilesServiceAddRequest struct {
	diskProfilesService *DiskProfilesService
	header              map[string]string
	query               map[string]string
	profile             *DiskProfile
}

func (p *DiskProfilesServiceAddRequest) Header(key, value string) *DiskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfilesServiceAddRequest) Query(key, value string) *DiskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfilesServiceAddRequest) Profile(profile *DiskProfile) *DiskProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *DiskProfilesServiceAddRequest) Send() (*DiskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.Connection.URL(), p.diskProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfilesService.Connection.username, p.diskProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskProfilesServiceAddResponse DiskProfilesServiceAddResponse
	var profileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	diskProfilesServiceAddResponse.profile = &profileVar
	return &diskProfilesServiceAddResponse, nil
}

type DiskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *DiskProfilesServiceAddResponse) Profile() *DiskProfile {
	return p.profile
}
func (p *DiskProfilesService) Add() *DiskProfilesServiceAddRequest {
	return &DiskProfilesServiceAddRequest{diskProfilesService: p}
}

type DiskProfilesServiceListRequest struct {
	diskProfilesService *DiskProfilesService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *DiskProfilesServiceListRequest) Header(key, value string) *DiskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfilesServiceListRequest) Query(key, value string) *DiskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfilesServiceListRequest) Max(max int64) *DiskProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *DiskProfilesServiceListRequest) Send() (*DiskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.Connection.URL(), p.diskProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfilesService.Connection.username, p.diskProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskProfilesServiceListResponse DiskProfilesServiceListResponse
	var profileVar DiskProfiles
	xml.Unmarshal(respBodyBytes, &profileVar)
	diskProfilesServiceListResponse.profile = profileVar.DiskProfiles
	return &diskProfilesServiceListResponse, nil
}

type DiskProfilesServiceListResponse struct {
	profile []DiskProfile
}

func (p *DiskProfilesServiceListResponse) Profile() []DiskProfile {
	return p.profile
}
func (p *DiskProfilesService) List() *DiskProfilesServiceListRequest {
	return &DiskProfilesServiceListRequest{diskProfilesService: p}
}

//
//
func (op *DiskProfilesService) DiskProfileService(id string) *DiskProfileService {
	return NewDiskProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskProfileService(path)), nil
	}
	return op.DiskProfileService(path[:index]).Service(path[index+1:])
}

func (op *DiskProfilesService) String() string {
	return fmt.Sprintf("DiskProfilesService:%s", op.Path)
}

//
// A service to manage an icon (read-only).
//
type IconService struct {
	BaseService
}

func NewIconService(connection *Connection, path string) *IconService {
	var result IconService
	result.Connection = connection
	result.Path = path
	return &result
}

type IconServiceGetRequest struct {
	iconService *IconService
	header      map[string]string
	query       map[string]string
}

func (p *IconServiceGetRequest) Header(key, value string) *IconServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IconServiceGetRequest) Query(key, value string) *IconServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IconServiceGetRequest) Send() (*IconServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iconService.Connection.URL(), p.iconService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iconService.Connection.username, p.iconService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iconService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var iconServiceGetResponse IconServiceGetResponse
	var iconVar Icon
	xml.Unmarshal(respBodyBytes, &iconVar)
	iconServiceGetResponse.icon = &iconVar
	return &iconServiceGetResponse, nil
}

type IconServiceGetResponse struct {
	icon *Icon
}

func (p *IconServiceGetResponse) Icon() *Icon {
	return p.icon
}
func (p *IconService) Get() *IconServiceGetRequest {
	return &IconServiceGetRequest{iconService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IconService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *IconService) String() string {
	return fmt.Sprintf("IconService:%s", op.Path)
}

//
// This service represents one label to entity assignment
// when accessed using the entities/affinitylabels subcollection.
//
type AssignedAffinityLabelService struct {
	BaseService
}

func NewAssignedAffinityLabelService(connection *Connection, path string) *AssignedAffinityLabelService {
	var result AssignedAffinityLabelService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedAffinityLabelServiceGetRequest struct {
	assignedAffinityLabelService *AssignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
}

func (p *AssignedAffinityLabelServiceGetRequest) Header(key, value string) *AssignedAffinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceGetRequest) Query(key, value string) *AssignedAffinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceGetRequest) Send() (*AssignedAffinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelService.Connection.URL(), p.assignedAffinityLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedAffinityLabelService.Connection.username, p.assignedAffinityLabelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedAffinityLabelServiceGetResponse AssignedAffinityLabelServiceGetResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	assignedAffinityLabelServiceGetResponse.label = &labelVar
	return &assignedAffinityLabelServiceGetResponse, nil
}

type AssignedAffinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *AssignedAffinityLabelServiceGetResponse) Label() *AffinityLabel {
	return p.label
}
func (p *AssignedAffinityLabelService) Get() *AssignedAffinityLabelServiceGetRequest {
	return &AssignedAffinityLabelServiceGetRequest{assignedAffinityLabelService: p}
}

type AssignedAffinityLabelServiceRemoveRequest struct {
	assignedAffinityLabelService *AssignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Header(key, value string) *AssignedAffinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Query(key, value string) *AssignedAffinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Send() (*AssignedAffinityLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelService.Connection.URL(), p.assignedAffinityLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedAffinityLabelService.Connection.username, p.assignedAffinityLabelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedAffinityLabelServiceRemoveResponse), nil
}

type AssignedAffinityLabelServiceRemoveResponse struct {
}

func (p *AssignedAffinityLabelService) Remove() *AssignedAffinityLabelServiceRemoveRequest {
	return &AssignedAffinityLabelServiceRemoveRequest{assignedAffinityLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedAffinityLabelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedAffinityLabelService) String() string {
	return fmt.Sprintf("AssignedAffinityLabelService:%s", op.Path)
}

//
//
type CpuProfilesService struct {
	BaseService
}

func NewCpuProfilesService(connection *Connection, path string) *CpuProfilesService {
	var result CpuProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type CpuProfilesServiceAddRequest struct {
	cpuProfilesService *CpuProfilesService
	header             map[string]string
	query              map[string]string
	profile            *CpuProfile
}

func (p *CpuProfilesServiceAddRequest) Header(key, value string) *CpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfilesServiceAddRequest) Query(key, value string) *CpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *CpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *CpuProfilesServiceAddRequest) Send() (*CpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.Connection.URL(), p.cpuProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfilesService.Connection.username, p.cpuProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var cpuProfilesServiceAddResponse CpuProfilesServiceAddResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	cpuProfilesServiceAddResponse.profile = &profileVar
	return &cpuProfilesServiceAddResponse, nil
}

type CpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *CpuProfilesServiceAddResponse) Profile() *CpuProfile {
	return p.profile
}
func (p *CpuProfilesService) Add() *CpuProfilesServiceAddRequest {
	return &CpuProfilesServiceAddRequest{cpuProfilesService: p}
}

type CpuProfilesServiceListRequest struct {
	cpuProfilesService *CpuProfilesService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *CpuProfilesServiceListRequest) Header(key, value string) *CpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfilesServiceListRequest) Query(key, value string) *CpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfilesServiceListRequest) Max(max int64) *CpuProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *CpuProfilesServiceListRequest) Send() (*CpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.Connection.URL(), p.cpuProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfilesService.Connection.username, p.cpuProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var cpuProfilesServiceListResponse CpuProfilesServiceListResponse
	var profileVar CpuProfiles
	xml.Unmarshal(respBodyBytes, &profileVar)
	cpuProfilesServiceListResponse.profile = profileVar.CpuProfiles
	return &cpuProfilesServiceListResponse, nil
}

type CpuProfilesServiceListResponse struct {
	profile []CpuProfile
}

func (p *CpuProfilesServiceListResponse) Profile() []CpuProfile {
	return p.profile
}
func (p *CpuProfilesService) List() *CpuProfilesServiceListRequest {
	return &CpuProfilesServiceListRequest{cpuProfilesService: p}
}

//
//
func (op *CpuProfilesService) ProfileService(id string) *CpuProfileService {
	return NewCpuProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CpuProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *CpuProfilesService) String() string {
	return fmt.Sprintf("CpuProfilesService:%s", op.Path)
}

//
//
type MacPoolsService struct {
	BaseService
}

func NewMacPoolsService(connection *Connection, path string) *MacPoolsService {
	var result MacPoolsService
	result.Connection = connection
	result.Path = path
	return &result
}

type MacPoolsServiceAddRequest struct {
	macPoolsService *MacPoolsService
	header          map[string]string
	query           map[string]string
	pool            *MacPool
}

func (p *MacPoolsServiceAddRequest) Header(key, value string) *MacPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolsServiceAddRequest) Query(key, value string) *MacPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolsServiceAddRequest) Pool(pool *MacPool) *MacPoolsServiceAddRequest {
	p.pool = pool
	return p
}
func (p *MacPoolsServiceAddRequest) Send() (*MacPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.Connection.URL(), p.macPoolsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.pool)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolsService.Connection.username, p.macPoolsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var macPoolsServiceAddResponse MacPoolsServiceAddResponse
	var poolVar MacPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	macPoolsServiceAddResponse.pool = &poolVar
	return &macPoolsServiceAddResponse, nil
}

type MacPoolsServiceAddResponse struct {
	pool *MacPool
}

func (p *MacPoolsServiceAddResponse) Pool() *MacPool {
	return p.pool
}
func (p *MacPoolsService) Add() *MacPoolsServiceAddRequest {
	return &MacPoolsServiceAddRequest{macPoolsService: p}
}

type MacPoolsServiceListRequest struct {
	macPoolsService *MacPoolsService
	header          map[string]string
	query           map[string]string
	max             *int64
}

func (p *MacPoolsServiceListRequest) Header(key, value string) *MacPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolsServiceListRequest) Query(key, value string) *MacPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolsServiceListRequest) Max(max int64) *MacPoolsServiceListRequest {
	p.max = &max
	return p
}
func (p *MacPoolsServiceListRequest) Send() (*MacPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.Connection.URL(), p.macPoolsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolsService.Connection.username, p.macPoolsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var macPoolsServiceListResponse MacPoolsServiceListResponse
	var poolsVar MacPools
	xml.Unmarshal(respBodyBytes, &poolsVar)
	macPoolsServiceListResponse.pools = poolsVar.MacPools
	return &macPoolsServiceListResponse, nil
}

type MacPoolsServiceListResponse struct {
	pools []MacPool
}

func (p *MacPoolsServiceListResponse) Pools() []MacPool {
	return p.pools
}
func (p *MacPoolsService) List() *MacPoolsServiceListRequest {
	return &MacPoolsServiceListRequest{macPoolsService: p}
}

//
//
func (op *MacPoolsService) MacPoolService(id string) *MacPoolService {
	return NewMacPoolService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MacPoolsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.MacPoolService(path)), nil
	}
	return op.MacPoolService(path[:index]).Service(path[index+1:])
}

func (op *MacPoolsService) String() string {
	return fmt.Sprintf("MacPoolsService:%s", op.Path)
}

//
// This service manages a collection of all the virtual machines assigned to an affinity group.
//
type AffinityGroupVmsService struct {
	BaseService
}

func NewAffinityGroupVmsService(connection *Connection, path string) *AffinityGroupVmsService {
	var result AffinityGroupVmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupVmsServiceAddRequest struct {
	affinityGroupVmsService *AffinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *AffinityGroupVmsServiceAddRequest) Header(key, value string) *AffinityGroupVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmsServiceAddRequest) Query(key, value string) *AffinityGroupVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmsServiceAddRequest) Vm(vm *Vm) *AffinityGroupVmsServiceAddRequest {
	p.vm = vm
	return p
}
func (p *AffinityGroupVmsServiceAddRequest) Send() (*AffinityGroupVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.Connection.URL(), p.affinityGroupVmsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.vm)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupVmsService.Connection.username, p.affinityGroupVmsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityGroupVmsServiceAddResponse AffinityGroupVmsServiceAddResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	affinityGroupVmsServiceAddResponse.vm = &vmVar
	return &affinityGroupVmsServiceAddResponse, nil
}

type AffinityGroupVmsServiceAddResponse struct {
	vm *Vm
}

func (p *AffinityGroupVmsServiceAddResponse) Vm() *Vm {
	return p.vm
}
func (p *AffinityGroupVmsService) Add() *AffinityGroupVmsServiceAddRequest {
	return &AffinityGroupVmsServiceAddRequest{affinityGroupVmsService: p}
}

type AffinityGroupVmsServiceListRequest struct {
	affinityGroupVmsService *AffinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *AffinityGroupVmsServiceListRequest) Header(key, value string) *AffinityGroupVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Query(key, value string) *AffinityGroupVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Max(max int64) *AffinityGroupVmsServiceListRequest {
	p.max = &max
	return p
}
func (p *AffinityGroupVmsServiceListRequest) Send() (*AffinityGroupVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.Connection.URL(), p.affinityGroupVmsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupVmsService.Connection.username, p.affinityGroupVmsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityGroupVmsServiceListResponse AffinityGroupVmsServiceListResponse
	var vmsVar Vms
	xml.Unmarshal(respBodyBytes, &vmsVar)
	affinityGroupVmsServiceListResponse.vms = vmsVar.Vms
	return &affinityGroupVmsServiceListResponse, nil
}

type AffinityGroupVmsServiceListResponse struct {
	vms []Vm
}

func (p *AffinityGroupVmsServiceListResponse) Vms() []Vm {
	return p.vms
}
func (p *AffinityGroupVmsService) List() *AffinityGroupVmsServiceListRequest {
	return &AffinityGroupVmsServiceListRequest{affinityGroupVmsService: p}
}

//
// Access the service that manages the virtual machine assignment to this affinity group.
//
func (op *AffinityGroupVmsService) VmService(id string) *AffinityGroupVmService {
	return NewAffinityGroupVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupVmsService) String() string {
	return fmt.Sprintf("AffinityGroupVmsService:%s", op.Path)
}

//
//
type QosService struct {
	BaseService
}

func NewQosService(connection *Connection, path string) *QosService {
	var result QosService
	result.Connection = connection
	result.Path = path
	return &result
}

type QosServiceGetRequest struct {
	qosService *QosService
	header     map[string]string
	query      map[string]string
}

func (p *QosServiceGetRequest) Header(key, value string) *QosServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceGetRequest) Query(key, value string) *QosServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceGetRequest) Send() (*QosServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qosService.Connection.URL(), p.qosService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qosService.Connection.username, p.qosService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qosService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var qosServiceGetResponse QosServiceGetResponse
	var qosVar Qos
	xml.Unmarshal(respBodyBytes, &qosVar)
	qosServiceGetResponse.qos = &qosVar
	return &qosServiceGetResponse, nil
}

type QosServiceGetResponse struct {
	qos *Qos
}

func (p *QosServiceGetResponse) Qos() *Qos {
	return p.qos
}
func (p *QosService) Get() *QosServiceGetRequest {
	return &QosServiceGetRequest{qosService: p}
}

type QosServiceRemoveRequest struct {
	qosService *QosService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *QosServiceRemoveRequest) Header(key, value string) *QosServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceRemoveRequest) Query(key, value string) *QosServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceRemoveRequest) Async(async bool) *QosServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QosServiceRemoveRequest) Send() (*QosServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qosService.Connection.URL(), p.qosService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qosService.Connection.username, p.qosService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qosService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QosServiceRemoveResponse), nil
}

type QosServiceRemoveResponse struct {
}

func (p *QosService) Remove() *QosServiceRemoveRequest {
	return &QosServiceRemoveRequest{qosService: p}
}

type QosServiceUpdateRequest struct {
	qosService *QosService
	header     map[string]string
	query      map[string]string
	async      *bool
	qos        *Qos
}

func (p *QosServiceUpdateRequest) Header(key, value string) *QosServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceUpdateRequest) Query(key, value string) *QosServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceUpdateRequest) Async(async bool) *QosServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *QosServiceUpdateRequest) Qos(qos *Qos) *QosServiceUpdateRequest {
	p.qos = qos
	return p
}
func (p *QosServiceUpdateRequest) Send() (*QosServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qosService.Connection.URL(), p.qosService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.qos)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qosService.Connection.username, p.qosService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qosService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var qosServiceUpdateResponse QosServiceUpdateResponse
	var qosVar Qos
	xml.Unmarshal(respBodyBytes, &qosVar)
	qosServiceUpdateResponse.qos = &qosVar
	return &qosServiceUpdateResponse, nil
}

type QosServiceUpdateResponse struct {
	qos *Qos
}

func (p *QosServiceUpdateResponse) Qos() *Qos {
	return p.qos
}
func (p *QosService) Update() *QosServiceUpdateRequest {
	return &QosServiceUpdateRequest{qosService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QosService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QosService) String() string {
	return fmt.Sprintf("QosService:%s", op.Path)
}

//
// Represents a service to manage collection of the tags in the system.
//
type TagsService struct {
	BaseService
}

func NewTagsService(connection *Connection, path string) *TagsService {
	var result TagsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TagsServiceAddRequest struct {
	tagsService *TagsService
	header      map[string]string
	query       map[string]string
	tag         *Tag
}

func (p *TagsServiceAddRequest) Header(key, value string) *TagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagsServiceAddRequest) Query(key, value string) *TagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagsServiceAddRequest) Tag(tag *Tag) *TagsServiceAddRequest {
	p.tag = tag
	return p
}
func (p *TagsServiceAddRequest) Send() (*TagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.Connection.URL(), p.tagsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.tag)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagsService.Connection.username, p.tagsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var tagsServiceAddResponse TagsServiceAddResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	tagsServiceAddResponse.tag = &tagVar
	return &tagsServiceAddResponse, nil
}

type TagsServiceAddResponse struct {
	tag *Tag
}

func (p *TagsServiceAddResponse) Tag() *Tag {
	return p.tag
}
func (p *TagsService) Add() *TagsServiceAddRequest {
	return &TagsServiceAddRequest{tagsService: p}
}

type TagsServiceListRequest struct {
	tagsService *TagsService
	header      map[string]string
	query       map[string]string
	max         *int64
}

func (p *TagsServiceListRequest) Header(key, value string) *TagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagsServiceListRequest) Query(key, value string) *TagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagsServiceListRequest) Max(max int64) *TagsServiceListRequest {
	p.max = &max
	return p
}
func (p *TagsServiceListRequest) Send() (*TagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.Connection.URL(), p.tagsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagsService.Connection.username, p.tagsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var tagsServiceListResponse TagsServiceListResponse
	var tagsVar Tags
	xml.Unmarshal(respBodyBytes, &tagsVar)
	tagsServiceListResponse.tags = tagsVar.Tags
	return &tagsServiceListResponse, nil
}

type TagsServiceListResponse struct {
	tags []Tag
}

func (p *TagsServiceListResponse) Tags() []Tag {
	return p.tags
}
func (p *TagsService) List() *TagsServiceListRequest {
	return &TagsServiceListRequest{tagsService: p}
}

//
// Reference to the service that manages a specific tag.
//
func (op *TagsService) TagService(id string) *TagService {
	return NewTagService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TagsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TagService(path)), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *TagsService) String() string {
	return fmt.Sprintf("TagsService:%s", op.Path)
}

//
//
type ExternalProviderCertificateService struct {
	BaseService
}

func NewExternalProviderCertificateService(connection *Connection, path string) *ExternalProviderCertificateService {
	var result ExternalProviderCertificateService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalProviderCertificateServiceGetRequest struct {
	externalProviderCertificateService *ExternalProviderCertificateService
	header                             map[string]string
	query                              map[string]string
}

func (p *ExternalProviderCertificateServiceGetRequest) Header(key, value string) *ExternalProviderCertificateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderCertificateServiceGetRequest) Query(key, value string) *ExternalProviderCertificateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderCertificateServiceGetRequest) Send() (*ExternalProviderCertificateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificateService.Connection.URL(), p.externalProviderCertificateService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalProviderCertificateService.Connection.username, p.externalProviderCertificateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalProviderCertificateServiceGetResponse ExternalProviderCertificateServiceGetResponse
	var certificateVar Certificate
	xml.Unmarshal(respBodyBytes, &certificateVar)
	externalProviderCertificateServiceGetResponse.certificate = &certificateVar
	return &externalProviderCertificateServiceGetResponse, nil
}

type ExternalProviderCertificateServiceGetResponse struct {
	certificate *Certificate
}

func (p *ExternalProviderCertificateServiceGetResponse) Certificate() *Certificate {
	return p.certificate
}
func (p *ExternalProviderCertificateService) Get() *ExternalProviderCertificateServiceGetRequest {
	return &ExternalProviderCertificateServiceGetRequest{externalProviderCertificateService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderCertificateService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalProviderCertificateService) String() string {
	return fmt.Sprintf("ExternalProviderCertificateService:%s", op.Path)
}

//
// A service to manage events in the system.
//
type EventsService struct {
	BaseService
}

func NewEventsService(connection *Connection, path string) *EventsService {
	var result EventsService
	result.Connection = connection
	result.Path = path
	return &result
}

type EventsServiceAddRequest struct {
	eventsService *EventsService
	header        map[string]string
	query         map[string]string
	event         *Event
}

func (p *EventsServiceAddRequest) Header(key, value string) *EventsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceAddRequest) Query(key, value string) *EventsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceAddRequest) Event(event *Event) *EventsServiceAddRequest {
	p.event = event
	return p
}
func (p *EventsServiceAddRequest) Send() (*EventsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.Connection.URL(), p.eventsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.event)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventsService.Connection.username, p.eventsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var eventsServiceAddResponse EventsServiceAddResponse
	var eventVar Event
	xml.Unmarshal(respBodyBytes, &eventVar)
	eventsServiceAddResponse.event = &eventVar
	return &eventsServiceAddResponse, nil
}

type EventsServiceAddResponse struct {
	event *Event
}

func (p *EventsServiceAddResponse) Event() *Event {
	return p.event
}
func (p *EventsService) Add() *EventsServiceAddRequest {
	return &EventsServiceAddRequest{eventsService: p}
}

type EventsServiceListRequest struct {
	eventsService *EventsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	from          *int64
	max           *int64
	search        *string
}

func (p *EventsServiceListRequest) Header(key, value string) *EventsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceListRequest) Query(key, value string) *EventsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceListRequest) CaseSensitive(caseSensitive bool) *EventsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *EventsServiceListRequest) From(from int64) *EventsServiceListRequest {
	p.from = &from
	return p
}
func (p *EventsServiceListRequest) Max(max int64) *EventsServiceListRequest {
	p.max = &max
	return p
}
func (p *EventsServiceListRequest) Search(search string) *EventsServiceListRequest {
	p.search = &search
	return p
}
func (p *EventsServiceListRequest) Send() (*EventsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.Connection.URL(), p.eventsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.from != nil {
		values["from"] = []string{fmt.Sprintf("%v", *p.from)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventsService.Connection.username, p.eventsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var eventsServiceListResponse EventsServiceListResponse
	var eventsVar Events
	xml.Unmarshal(respBodyBytes, &eventsVar)
	eventsServiceListResponse.events = eventsVar.Events
	return &eventsServiceListResponse, nil
}

type EventsServiceListResponse struct {
	events []Event
}

func (p *EventsServiceListResponse) Events() []Event {
	return p.events
}
func (p *EventsService) List() *EventsServiceListRequest {
	return &EventsServiceListRequest{eventsService: p}
}

type EventsServiceUndeleteRequest struct {
	eventsService *EventsService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *EventsServiceUndeleteRequest) Header(key, value string) *EventsServiceUndeleteRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceUndeleteRequest) Query(key, value string) *EventsServiceUndeleteRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceUndeleteRequest) Async(async bool) *EventsServiceUndeleteRequest {
	p.async = &async
	return p
}
func (p *EventsServiceUndeleteRequest) Send() (*EventsServiceUndeleteResponse, error) {
	rawURL := fmt.Sprintf("%s%s/undelete", p.eventsService.Connection.URL(), p.eventsService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventsService.Connection.username, p.eventsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(EventsServiceUndeleteResponse), nil
}

type EventsServiceUndeleteResponse struct {
}

func (p *EventsService) Undelete() *EventsServiceUndeleteRequest {
	return &EventsServiceUndeleteRequest{eventsService: p}
}

//
// Reference to the service that manages a specific event.
//
func (op *EventsService) EventService(id string) *EventService {
	return NewEventService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.EventService(path)), nil
	}
	return op.EventService(path[:index]).Service(path[index+1:])
}

func (op *EventsService) String() string {
	return fmt.Sprintf("EventsService:%s", op.Path)
}

//
// A service managing a watchdog on virtual machines.
//
type VmWatchdogService struct {
	BaseService
}

func NewVmWatchdogService(connection *Connection, path string) *VmWatchdogService {
	var result VmWatchdogService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmWatchdogServiceGetRequest struct {
	vmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
}

func (p *VmWatchdogServiceGetRequest) Header(key, value string) *VmWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceGetRequest) Query(key, value string) *VmWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceGetRequest) Send() (*VmWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.Connection.URL(), p.vmWatchdogService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogService.Connection.username, p.vmWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmWatchdogServiceGetResponse VmWatchdogServiceGetResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	vmWatchdogServiceGetResponse.watchdog = &watchdogVar
	return &vmWatchdogServiceGetResponse, nil
}

type VmWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogServiceGetResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *VmWatchdogService) Get() *VmWatchdogServiceGetRequest {
	return &VmWatchdogServiceGetRequest{vmWatchdogService: p}
}

type VmWatchdogServiceRemoveRequest struct {
	vmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *VmWatchdogServiceRemoveRequest) Header(key, value string) *VmWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceRemoveRequest) Query(key, value string) *VmWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceRemoveRequest) Async(async bool) *VmWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmWatchdogServiceRemoveRequest) Send() (*VmWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.Connection.URL(), p.vmWatchdogService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogService.Connection.username, p.vmWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmWatchdogServiceRemoveResponse), nil
}

type VmWatchdogServiceRemoveResponse struct {
}

func (p *VmWatchdogService) Remove() *VmWatchdogServiceRemoveRequest {
	return &VmWatchdogServiceRemoveRequest{vmWatchdogService: p}
}

type VmWatchdogServiceUpdateRequest struct {
	vmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
	watchdog          *Watchdog
}

func (p *VmWatchdogServiceUpdateRequest) Header(key, value string) *VmWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Query(key, value string) *VmWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Async(async bool) *VmWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *VmWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}
func (p *VmWatchdogServiceUpdateRequest) Send() (*VmWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.Connection.URL(), p.vmWatchdogService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogService.Connection.username, p.vmWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmWatchdogServiceUpdateResponse VmWatchdogServiceUpdateResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	vmWatchdogServiceUpdateResponse.watchdog = &watchdogVar
	return &vmWatchdogServiceUpdateResponse, nil
}

type VmWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogServiceUpdateResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *VmWatchdogService) Update() *VmWatchdogServiceUpdateRequest {
	return &VmWatchdogServiceUpdateRequest{vmWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmWatchdogService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmWatchdogService) String() string {
	return fmt.Sprintf("VmWatchdogService:%s", op.Path)
}

//
//
type AttachedStorageDomainService struct {
	BaseService
}

func NewAttachedStorageDomainService(connection *Connection, path string) *AttachedStorageDomainService {
	var result AttachedStorageDomainService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainServiceActivateRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceActivateRequest) Header(key, value string) *AttachedStorageDomainServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceActivateRequest) Query(key, value string) *AttachedStorageDomainServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceActivateRequest) Async(async bool) *AttachedStorageDomainServiceActivateRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainServiceActivateRequest) Send() (*AttachedStorageDomainServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.attachedStorageDomainService.Connection.URL(), p.attachedStorageDomainService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainService.Connection.username, p.attachedStorageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainServiceActivateResponse), nil
}

type AttachedStorageDomainServiceActivateResponse struct {
}

func (p *AttachedStorageDomainService) Activate() *AttachedStorageDomainServiceActivateRequest {
	return &AttachedStorageDomainServiceActivateRequest{attachedStorageDomainService: p}
}

type AttachedStorageDomainServiceDeactivateRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Header(key, value string) *AttachedStorageDomainServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Query(key, value string) *AttachedStorageDomainServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Async(async bool) *AttachedStorageDomainServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainServiceDeactivateRequest) Send() (*AttachedStorageDomainServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.attachedStorageDomainService.Connection.URL(), p.attachedStorageDomainService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainService.Connection.username, p.attachedStorageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainServiceDeactivateResponse), nil
}

type AttachedStorageDomainServiceDeactivateResponse struct {
}

func (p *AttachedStorageDomainService) Deactivate() *AttachedStorageDomainServiceDeactivateRequest {
	return &AttachedStorageDomainServiceDeactivateRequest{attachedStorageDomainService: p}
}

type AttachedStorageDomainServiceGetRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
}

func (p *AttachedStorageDomainServiceGetRequest) Header(key, value string) *AttachedStorageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceGetRequest) Query(key, value string) *AttachedStorageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceGetRequest) Send() (*AttachedStorageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainService.Connection.URL(), p.attachedStorageDomainService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainService.Connection.username, p.attachedStorageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var attachedStorageDomainServiceGetResponse AttachedStorageDomainServiceGetResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	attachedStorageDomainServiceGetResponse.storageDomain = &storageDomainVar
	return &attachedStorageDomainServiceGetResponse, nil
}

type AttachedStorageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *AttachedStorageDomainServiceGetResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}
func (p *AttachedStorageDomainService) Get() *AttachedStorageDomainServiceGetRequest {
	return &AttachedStorageDomainServiceGetRequest{attachedStorageDomainService: p}
}

type AttachedStorageDomainServiceRemoveRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceRemoveRequest) Header(key, value string) *AttachedStorageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceRemoveRequest) Query(key, value string) *AttachedStorageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceRemoveRequest) Async(async bool) *AttachedStorageDomainServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainServiceRemoveRequest) Send() (*AttachedStorageDomainServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainService.Connection.URL(), p.attachedStorageDomainService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainService.Connection.username, p.attachedStorageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AttachedStorageDomainServiceRemoveResponse), nil
}

type AttachedStorageDomainServiceRemoveResponse struct {
}

func (p *AttachedStorageDomainService) Remove() *AttachedStorageDomainServiceRemoveRequest {
	return &AttachedStorageDomainServiceRemoveRequest{attachedStorageDomainService: p}
}

//
//
func (op *AttachedStorageDomainService) DisksService() *AttachedStorageDomainDisksService {
	return NewAttachedStorageDomainDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AttachedStorageDomainService) String() string {
	return fmt.Sprintf("AttachedStorageDomainService:%s", op.Path)
}

//
//
type AttachedStorageDomainsService struct {
	BaseService
}

func NewAttachedStorageDomainsService(connection *Connection, path string) *AttachedStorageDomainsService {
	var result AttachedStorageDomainsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainsServiceAddRequest struct {
	attachedStorageDomainsService *AttachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	storageDomain                 *StorageDomain
}

func (p *AttachedStorageDomainsServiceAddRequest) Header(key, value string) *AttachedStorageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceAddRequest) Query(key, value string) *AttachedStorageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainsServiceAddRequest) Send() (*AttachedStorageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.Connection.URL(), p.attachedStorageDomainsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.storageDomain)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainsService.Connection.username, p.attachedStorageDomainsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var attachedStorageDomainsServiceAddResponse AttachedStorageDomainsServiceAddResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	attachedStorageDomainsServiceAddResponse.storageDomain = &storageDomainVar
	return &attachedStorageDomainsServiceAddResponse, nil
}

type AttachedStorageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *AttachedStorageDomainsServiceAddResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}
func (p *AttachedStorageDomainsService) Add() *AttachedStorageDomainsServiceAddRequest {
	return &AttachedStorageDomainsServiceAddRequest{attachedStorageDomainsService: p}
}

type AttachedStorageDomainsServiceListRequest struct {
	attachedStorageDomainsService *AttachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	max                           *int64
}

func (p *AttachedStorageDomainsServiceListRequest) Header(key, value string) *AttachedStorageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Query(key, value string) *AttachedStorageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Max(max int64) *AttachedStorageDomainsServiceListRequest {
	p.max = &max
	return p
}
func (p *AttachedStorageDomainsServiceListRequest) Send() (*AttachedStorageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.Connection.URL(), p.attachedStorageDomainsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainsService.Connection.username, p.attachedStorageDomainsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var attachedStorageDomainsServiceListResponse AttachedStorageDomainsServiceListResponse
	var storageDomainsVar StorageDomains
	xml.Unmarshal(respBodyBytes, &storageDomainsVar)
	attachedStorageDomainsServiceListResponse.storageDomains = storageDomainsVar.StorageDomains
	return &attachedStorageDomainsServiceListResponse, nil
}

type AttachedStorageDomainsServiceListResponse struct {
	storageDomains []StorageDomain
}

func (p *AttachedStorageDomainsServiceListResponse) StorageDomains() []StorageDomain {
	return p.storageDomains
}
func (p *AttachedStorageDomainsService) List() *AttachedStorageDomainsServiceListRequest {
	return &AttachedStorageDomainsServiceListRequest{attachedStorageDomainsService: p}
}

//
//
func (op *AttachedStorageDomainsService) StorageDomainService(id string) *AttachedStorageDomainService {
	return NewAttachedStorageDomainService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageDomainService(path)), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *AttachedStorageDomainsService) String() string {
	return fmt.Sprintf("AttachedStorageDomainsService:%s", op.Path)
}

//
//
type InstanceTypeWatchdogService struct {
	BaseService
}

func NewInstanceTypeWatchdogService(connection *Connection, path string) *InstanceTypeWatchdogService {
	var result InstanceTypeWatchdogService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeWatchdogServiceGetRequest struct {
	instanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
}

func (p *InstanceTypeWatchdogServiceGetRequest) Header(key, value string) *InstanceTypeWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceGetRequest) Query(key, value string) *InstanceTypeWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceGetRequest) Send() (*InstanceTypeWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.Connection.URL(), p.instanceTypeWatchdogService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogService.Connection.username, p.instanceTypeWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeWatchdogServiceGetResponse InstanceTypeWatchdogServiceGetResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	instanceTypeWatchdogServiceGetResponse.watchdog = &watchdogVar
	return &instanceTypeWatchdogServiceGetResponse, nil
}

type InstanceTypeWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogServiceGetResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *InstanceTypeWatchdogService) Get() *InstanceTypeWatchdogServiceGetRequest {
	return &InstanceTypeWatchdogServiceGetRequest{instanceTypeWatchdogService: p}
}

type InstanceTypeWatchdogServiceRemoveRequest struct {
	instanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Header(key, value string) *InstanceTypeWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Query(key, value string) *InstanceTypeWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Async(async bool) *InstanceTypeWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeWatchdogServiceRemoveRequest) Send() (*InstanceTypeWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.Connection.URL(), p.instanceTypeWatchdogService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogService.Connection.username, p.instanceTypeWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeWatchdogServiceRemoveResponse), nil
}

type InstanceTypeWatchdogServiceRemoveResponse struct {
}

func (p *InstanceTypeWatchdogService) Remove() *InstanceTypeWatchdogServiceRemoveRequest {
	return &InstanceTypeWatchdogServiceRemoveRequest{instanceTypeWatchdogService: p}
}

type InstanceTypeWatchdogServiceUpdateRequest struct {
	instanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	watchdog                    *Watchdog
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Header(key, value string) *InstanceTypeWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Query(key, value string) *InstanceTypeWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Async(async bool) *InstanceTypeWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *InstanceTypeWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}
func (p *InstanceTypeWatchdogServiceUpdateRequest) Send() (*InstanceTypeWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.Connection.URL(), p.instanceTypeWatchdogService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogService.Connection.username, p.instanceTypeWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeWatchdogServiceUpdateResponse InstanceTypeWatchdogServiceUpdateResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	instanceTypeWatchdogServiceUpdateResponse.watchdog = &watchdogVar
	return &instanceTypeWatchdogServiceUpdateResponse, nil
}

type InstanceTypeWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogServiceUpdateResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *InstanceTypeWatchdogService) Update() *InstanceTypeWatchdogServiceUpdateRequest {
	return &InstanceTypeWatchdogServiceUpdateRequest{instanceTypeWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeWatchdogService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeWatchdogService) String() string {
	return fmt.Sprintf("InstanceTypeWatchdogService:%s", op.Path)
}

//
//
type QuotaStorageLimitService struct {
	BaseService
}

func NewQuotaStorageLimitService(connection *Connection, path string) *QuotaStorageLimitService {
	var result QuotaStorageLimitService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaStorageLimitServiceGetRequest struct {
	quotaStorageLimitService *QuotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
}

func (p *QuotaStorageLimitServiceGetRequest) Header(key, value string) *QuotaStorageLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitServiceGetRequest) Query(key, value string) *QuotaStorageLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitServiceGetRequest) Send() (*QuotaStorageLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitService.Connection.URL(), p.quotaStorageLimitService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaStorageLimitService.Connection.username, p.quotaStorageLimitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaStorageLimitServiceGetResponse QuotaStorageLimitServiceGetResponse
	var limitVar QuotaStorageLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaStorageLimitServiceGetResponse.limit = &limitVar
	return &quotaStorageLimitServiceGetResponse, nil
}

type QuotaStorageLimitServiceGetResponse struct {
	limit *QuotaStorageLimit
}

func (p *QuotaStorageLimitServiceGetResponse) Limit() *QuotaStorageLimit {
	return p.limit
}
func (p *QuotaStorageLimitService) Get() *QuotaStorageLimitServiceGetRequest {
	return &QuotaStorageLimitServiceGetRequest{quotaStorageLimitService: p}
}

type QuotaStorageLimitServiceRemoveRequest struct {
	quotaStorageLimitService *QuotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *QuotaStorageLimitServiceRemoveRequest) Header(key, value string) *QuotaStorageLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitServiceRemoveRequest) Query(key, value string) *QuotaStorageLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitServiceRemoveRequest) Async(async bool) *QuotaStorageLimitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QuotaStorageLimitServiceRemoveRequest) Send() (*QuotaStorageLimitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitService.Connection.URL(), p.quotaStorageLimitService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaStorageLimitService.Connection.username, p.quotaStorageLimitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QuotaStorageLimitServiceRemoveResponse), nil
}

type QuotaStorageLimitServiceRemoveResponse struct {
}

func (p *QuotaStorageLimitService) Remove() *QuotaStorageLimitServiceRemoveRequest {
	return &QuotaStorageLimitServiceRemoveRequest{quotaStorageLimitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaStorageLimitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaStorageLimitService) String() string {
	return fmt.Sprintf("QuotaStorageLimitService:%s", op.Path)
}

//
//
type RoleService struct {
	BaseService
}

func NewRoleService(connection *Connection, path string) *RoleService {
	var result RoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type RoleServiceGetRequest struct {
	roleService *RoleService
	header      map[string]string
	query       map[string]string
}

func (p *RoleServiceGetRequest) Header(key, value string) *RoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceGetRequest) Query(key, value string) *RoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceGetRequest) Send() (*RoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.roleService.Connection.URL(), p.roleService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.roleService.Connection.username, p.roleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.roleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var roleServiceGetResponse RoleServiceGetResponse
	var roleVar Role
	xml.Unmarshal(respBodyBytes, &roleVar)
	roleServiceGetResponse.role = &roleVar
	return &roleServiceGetResponse, nil
}

type RoleServiceGetResponse struct {
	role *Role
}

func (p *RoleServiceGetResponse) Role() *Role {
	return p.role
}
func (p *RoleService) Get() *RoleServiceGetRequest {
	return &RoleServiceGetRequest{roleService: p}
}

type RoleServiceRemoveRequest struct {
	roleService *RoleService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *RoleServiceRemoveRequest) Header(key, value string) *RoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceRemoveRequest) Query(key, value string) *RoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceRemoveRequest) Async(async bool) *RoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *RoleServiceRemoveRequest) Send() (*RoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.roleService.Connection.URL(), p.roleService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.roleService.Connection.username, p.roleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.roleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(RoleServiceRemoveResponse), nil
}

type RoleServiceRemoveResponse struct {
}

func (p *RoleService) Remove() *RoleServiceRemoveRequest {
	return &RoleServiceRemoveRequest{roleService: p}
}

type RoleServiceUpdateRequest struct {
	roleService *RoleService
	header      map[string]string
	query       map[string]string
	async       *bool
	role        *Role
}

func (p *RoleServiceUpdateRequest) Header(key, value string) *RoleServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceUpdateRequest) Query(key, value string) *RoleServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceUpdateRequest) Async(async bool) *RoleServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *RoleServiceUpdateRequest) Role(role *Role) *RoleServiceUpdateRequest {
	p.role = role
	return p
}
func (p *RoleServiceUpdateRequest) Send() (*RoleServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.roleService.Connection.URL(), p.roleService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.role)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.roleService.Connection.username, p.roleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.roleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var roleServiceUpdateResponse RoleServiceUpdateResponse
	var roleVar Role
	xml.Unmarshal(respBodyBytes, &roleVar)
	roleServiceUpdateResponse.role = &roleVar
	return &roleServiceUpdateResponse, nil
}

type RoleServiceUpdateResponse struct {
	role *Role
}

func (p *RoleServiceUpdateResponse) Role() *Role {
	return p.role
}
func (p *RoleService) Update() *RoleServiceUpdateRequest {
	return &RoleServiceUpdateRequest{roleService: p}
}

//
// Sub-resource locator method, returns permits service.
//
func (op *RoleService) PermitsService() *PermitsService {
	return NewPermitsService(op.Connection, fmt.Sprintf("%s/permits", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *RoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permits" {
		return op.PermitsService(), nil
	}
	if strings.HasPrefix(path, "permits/") {
		return op.PermitsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *RoleService) String() string {
	return fmt.Sprintf("RoleService:%s", op.Path)
}

//
//
type AssignedNetworkService struct {
	BaseService
}

func NewAssignedNetworkService(connection *Connection, path string) *AssignedNetworkService {
	var result AssignedNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedNetworkServiceGetRequest struct {
	assignedNetworkService *AssignedNetworkService
	header                 map[string]string
	query                  map[string]string
}

func (p *AssignedNetworkServiceGetRequest) Header(key, value string) *AssignedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworkServiceGetRequest) Query(key, value string) *AssignedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworkServiceGetRequest) Send() (*AssignedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworkService.Connection.URL(), p.assignedNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworkService.Connection.username, p.assignedNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedNetworkServiceGetResponse AssignedNetworkServiceGetResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	assignedNetworkServiceGetResponse.network = &networkVar
	return &assignedNetworkServiceGetResponse, nil
}

type AssignedNetworkServiceGetResponse struct {
	network *Network
}

func (p *AssignedNetworkServiceGetResponse) Network() *Network {
	return p.network
}
func (p *AssignedNetworkService) Get() *AssignedNetworkServiceGetRequest {
	return &AssignedNetworkServiceGetRequest{assignedNetworkService: p}
}

type AssignedNetworkServiceRemoveRequest struct {
	assignedNetworkService *AssignedNetworkService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *AssignedNetworkServiceRemoveRequest) Header(key, value string) *AssignedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworkServiceRemoveRequest) Query(key, value string) *AssignedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworkServiceRemoveRequest) Async(async bool) *AssignedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedNetworkServiceRemoveRequest) Send() (*AssignedNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworkService.Connection.URL(), p.assignedNetworkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworkService.Connection.username, p.assignedNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedNetworkServiceRemoveResponse), nil
}

type AssignedNetworkServiceRemoveResponse struct {
}

func (p *AssignedNetworkService) Remove() *AssignedNetworkServiceRemoveRequest {
	return &AssignedNetworkServiceRemoveRequest{assignedNetworkService: p}
}

type AssignedNetworkServiceUpdateRequest struct {
	assignedNetworkService *AssignedNetworkService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	network                *Network
}

func (p *AssignedNetworkServiceUpdateRequest) Header(key, value string) *AssignedNetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworkServiceUpdateRequest) Query(key, value string) *AssignedNetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworkServiceUpdateRequest) Async(async bool) *AssignedNetworkServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *AssignedNetworkServiceUpdateRequest) Network(network *Network) *AssignedNetworkServiceUpdateRequest {
	p.network = network
	return p
}
func (p *AssignedNetworkServiceUpdateRequest) Send() (*AssignedNetworkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworkService.Connection.URL(), p.assignedNetworkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworkService.Connection.username, p.assignedNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedNetworkServiceUpdateResponse AssignedNetworkServiceUpdateResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	assignedNetworkServiceUpdateResponse.network = &networkVar
	return &assignedNetworkServiceUpdateResponse, nil
}

type AssignedNetworkServiceUpdateResponse struct {
	network *Network
}

func (p *AssignedNetworkServiceUpdateResponse) Network() *Network {
	return p.network
}
func (p *AssignedNetworkService) Update() *AssignedNetworkServiceUpdateRequest {
	return &AssignedNetworkServiceUpdateRequest{assignedNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedNetworkService) String() string {
	return fmt.Sprintf("AssignedNetworkService:%s", op.Path)
}

//
// Returns the details of the disks attached to a virtual machine in the export domain.
//
type StorageDomainVmDiskAttachmentService struct {
	BaseService
}

func NewStorageDomainVmDiskAttachmentService(connection *Connection, path string) *StorageDomainVmDiskAttachmentService {
	var result StorageDomainVmDiskAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmDiskAttachmentServiceGetRequest struct {
	storageDomainVmDiskAttachmentService *StorageDomainVmDiskAttachmentService
	header                               map[string]string
	query                                map[string]string
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Header(key, value string) *StorageDomainVmDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Query(key, value string) *StorageDomainVmDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Send() (*StorageDomainVmDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentService.Connection.URL(), p.storageDomainVmDiskAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmDiskAttachmentService.Connection.username, p.storageDomainVmDiskAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainVmDiskAttachmentServiceGetResponse StorageDomainVmDiskAttachmentServiceGetResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	storageDomainVmDiskAttachmentServiceGetResponse.attachment = &attachmentVar
	return &storageDomainVmDiskAttachmentServiceGetResponse, nil
}

type StorageDomainVmDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *StorageDomainVmDiskAttachmentServiceGetResponse) Attachment() *DiskAttachment {
	return p.attachment
}
func (p *StorageDomainVmDiskAttachmentService) Get() *StorageDomainVmDiskAttachmentServiceGetRequest {
	return &StorageDomainVmDiskAttachmentServiceGetRequest{storageDomainVmDiskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmDiskAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainVmDiskAttachmentService) String() string {
	return fmt.Sprintf("StorageDomainVmDiskAttachmentService:%s", op.Path)
}

//
// A service to manage the network interfaces of a host.
//
type HostNicsService struct {
	BaseService
}

func NewHostNicsService(connection *Connection, path string) *HostNicsService {
	var result HostNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNicsServiceListRequest struct {
	hostNicsService *HostNicsService
	header          map[string]string
	query           map[string]string
	max             *int64
}

func (p *HostNicsServiceListRequest) Header(key, value string) *HostNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicsServiceListRequest) Query(key, value string) *HostNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicsServiceListRequest) Max(max int64) *HostNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *HostNicsServiceListRequest) Send() (*HostNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNicsService.Connection.URL(), p.hostNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNicsService.Connection.username, p.hostNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostNicsServiceListResponse HostNicsServiceListResponse
	var nicsVar HostNics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	hostNicsServiceListResponse.nics = nicsVar.HostNics
	return &hostNicsServiceListResponse, nil
}

type HostNicsServiceListResponse struct {
	nics []HostNic
}

func (p *HostNicsServiceListResponse) Nics() []HostNic {
	return p.nics
}
func (p *HostNicsService) List() *HostNicsServiceListRequest {
	return &HostNicsServiceListRequest{hostNicsService: p}
}

//
// Reference to the service that manages a single network interface.
//
func (op *HostNicsService) NicService(id string) *HostNicService {
	return NewHostNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *HostNicsService) String() string {
	return fmt.Sprintf("HostNicsService:%s", op.Path)
}

//
//
type VmNumaNodeService struct {
	BaseService
}

func NewVmNumaNodeService(connection *Connection, path string) *VmNumaNodeService {
	var result VmNumaNodeService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNumaNodeServiceGetRequest struct {
	vmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
}

func (p *VmNumaNodeServiceGetRequest) Header(key, value string) *VmNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceGetRequest) Query(key, value string) *VmNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceGetRequest) Send() (*VmNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.Connection.URL(), p.vmNumaNodeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodeService.Connection.username, p.vmNumaNodeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNumaNodeServiceGetResponse VmNumaNodeServiceGetResponse
	var nodeVar VirtualNumaNode
	xml.Unmarshal(respBodyBytes, &nodeVar)
	vmNumaNodeServiceGetResponse.node = &nodeVar
	return &vmNumaNodeServiceGetResponse, nil
}

type VmNumaNodeServiceGetResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodeServiceGetResponse) Node() *VirtualNumaNode {
	return p.node
}
func (p *VmNumaNodeService) Get() *VmNumaNodeServiceGetRequest {
	return &VmNumaNodeServiceGetRequest{vmNumaNodeService: p}
}

type VmNumaNodeServiceRemoveRequest struct {
	vmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *VmNumaNodeServiceRemoveRequest) Header(key, value string) *VmNumaNodeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceRemoveRequest) Query(key, value string) *VmNumaNodeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceRemoveRequest) Async(async bool) *VmNumaNodeServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmNumaNodeServiceRemoveRequest) Send() (*VmNumaNodeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.Connection.URL(), p.vmNumaNodeService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodeService.Connection.username, p.vmNumaNodeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmNumaNodeServiceRemoveResponse), nil
}

type VmNumaNodeServiceRemoveResponse struct {
}

func (p *VmNumaNodeService) Remove() *VmNumaNodeServiceRemoveRequest {
	return &VmNumaNodeServiceRemoveRequest{vmNumaNodeService: p}
}

type VmNumaNodeServiceUpdateRequest struct {
	vmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
	node              *VirtualNumaNode
}

func (p *VmNumaNodeServiceUpdateRequest) Header(key, value string) *VmNumaNodeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Query(key, value string) *VmNumaNodeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Async(async bool) *VmNumaNodeServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmNumaNodeServiceUpdateRequest) Node(node *VirtualNumaNode) *VmNumaNodeServiceUpdateRequest {
	p.node = node
	return p
}
func (p *VmNumaNodeServiceUpdateRequest) Send() (*VmNumaNodeServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.Connection.URL(), p.vmNumaNodeService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.node)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodeService.Connection.username, p.vmNumaNodeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNumaNodeServiceUpdateResponse VmNumaNodeServiceUpdateResponse
	var nodeVar VirtualNumaNode
	xml.Unmarshal(respBodyBytes, &nodeVar)
	vmNumaNodeServiceUpdateResponse.node = &nodeVar
	return &vmNumaNodeServiceUpdateResponse, nil
}

type VmNumaNodeServiceUpdateResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodeServiceUpdateResponse) Node() *VirtualNumaNode {
	return p.node
}
func (p *VmNumaNodeService) Update() *VmNumaNodeServiceUpdateRequest {
	return &VmNumaNodeServiceUpdateRequest{vmNumaNodeService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNumaNodeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmNumaNodeService) String() string {
	return fmt.Sprintf("VmNumaNodeService:%s", op.Path)
}

//
// Lists the CD-ROM devices of a template.
//
type TemplateCdromsService struct {
	BaseService
}

func NewTemplateCdromsService(connection *Connection, path string) *TemplateCdromsService {
	var result TemplateCdromsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateCdromsServiceListRequest struct {
	templateCdromsService *TemplateCdromsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *TemplateCdromsServiceListRequest) Header(key, value string) *TemplateCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateCdromsServiceListRequest) Query(key, value string) *TemplateCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateCdromsServiceListRequest) Max(max int64) *TemplateCdromsServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateCdromsServiceListRequest) Send() (*TemplateCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromsService.Connection.URL(), p.templateCdromsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateCdromsService.Connection.username, p.templateCdromsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateCdromsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateCdromsServiceListResponse TemplateCdromsServiceListResponse
	var cdromsVar Cdroms
	xml.Unmarshal(respBodyBytes, &cdromsVar)
	templateCdromsServiceListResponse.cdroms = cdromsVar.Cdroms
	return &templateCdromsServiceListResponse, nil
}

type TemplateCdromsServiceListResponse struct {
	cdroms []Cdrom
}

func (p *TemplateCdromsServiceListResponse) Cdroms() []Cdrom {
	return p.cdroms
}
func (p *TemplateCdromsService) List() *TemplateCdromsServiceListRequest {
	return &TemplateCdromsServiceListRequest{templateCdromsService: p}
}

//
// Returns a reference to the service that manages a specific CD-ROM device.
//
func (op *TemplateCdromsService) CdromService(id string) *TemplateCdromService {
	return NewTemplateCdromService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateCdromsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CdromService(path)), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *TemplateCdromsService) String() string {
	return fmt.Sprintf("TemplateCdromsService:%s", op.Path)
}

//
//
type SnapshotService struct {
	BaseService
}

func NewSnapshotService(connection *Connection, path string) *SnapshotService {
	var result SnapshotService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotServiceGetRequest struct {
	snapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
}

func (p *SnapshotServiceGetRequest) Header(key, value string) *SnapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceGetRequest) Query(key, value string) *SnapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceGetRequest) Send() (*SnapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotService.Connection.URL(), p.snapshotService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotService.Connection.username, p.snapshotService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotServiceGetResponse SnapshotServiceGetResponse
	var snapshotVar Snapshot
	xml.Unmarshal(respBodyBytes, &snapshotVar)
	snapshotServiceGetResponse.snapshot = &snapshotVar
	return &snapshotServiceGetResponse, nil
}

type SnapshotServiceGetResponse struct {
	snapshot *Snapshot
}

func (p *SnapshotServiceGetResponse) Snapshot() *Snapshot {
	return p.snapshot
}
func (p *SnapshotService) Get() *SnapshotServiceGetRequest {
	return &SnapshotServiceGetRequest{snapshotService: p}
}

type SnapshotServiceRemoveRequest struct {
	snapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
	allContent      *bool
	async           *bool
}

func (p *SnapshotServiceRemoveRequest) Header(key, value string) *SnapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceRemoveRequest) Query(key, value string) *SnapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceRemoveRequest) AllContent(allContent bool) *SnapshotServiceRemoveRequest {
	p.allContent = &allContent
	return p
}
func (p *SnapshotServiceRemoveRequest) Async(async bool) *SnapshotServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SnapshotServiceRemoveRequest) Send() (*SnapshotServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotService.Connection.URL(), p.snapshotService.Path)
	values := make(url.Values)
	if p.allContent != nil {
		values["allContent"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotService.Connection.username, p.snapshotService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SnapshotServiceRemoveResponse), nil
}

type SnapshotServiceRemoveResponse struct {
}

func (p *SnapshotService) Remove() *SnapshotServiceRemoveRequest {
	return &SnapshotServiceRemoveRequest{snapshotService: p}
}

type SnapshotServiceRestoreRequest struct {
	snapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
	async           *bool
	disks           []Disk
	restoreMemory   *bool
}

func (p *SnapshotServiceRestoreRequest) Header(key, value string) *SnapshotServiceRestoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceRestoreRequest) Query(key, value string) *SnapshotServiceRestoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceRestoreRequest) Async(async bool) *SnapshotServiceRestoreRequest {
	p.async = &async
	return p
}
func (p *SnapshotServiceRestoreRequest) Disks(disks []Disk) *SnapshotServiceRestoreRequest {
	p.disks = disks
	return p
}
func (p *SnapshotServiceRestoreRequest) RestoreMemory(restoreMemory bool) *SnapshotServiceRestoreRequest {
	p.restoreMemory = &restoreMemory
	return p
}
func (p *SnapshotServiceRestoreRequest) Send() (*SnapshotServiceRestoreResponse, error) {
	rawURL := fmt.Sprintf("%s%s/restore", p.snapshotService.Connection.URL(), p.snapshotService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Disks(p.disks)
	actionBuilder.RestoreMemory(*p.restoreMemory)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotService.Connection.username, p.snapshotService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(SnapshotServiceRestoreResponse), nil
}

type SnapshotServiceRestoreResponse struct {
}

func (p *SnapshotService) Restore() *SnapshotServiceRestoreRequest {
	return &SnapshotServiceRestoreRequest{snapshotService: p}
}

//
//
func (op *SnapshotService) CdromsService() *SnapshotCdromsService {
	return NewSnapshotCdromsService(op.Connection, fmt.Sprintf("%s/cdroms", op.Path))
}

//
//
func (op *SnapshotService) DisksService() *SnapshotDisksService {
	return NewSnapshotDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
//
func (op *SnapshotService) NicsService() *SnapshotNicsService {
	return NewSnapshotNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotService) String() string {
	return fmt.Sprintf("SnapshotService:%s", op.Path)
}

//
//
type SchedulingPoliciesService struct {
	BaseService
}

func NewSchedulingPoliciesService(connection *Connection, path string) *SchedulingPoliciesService {
	var result SchedulingPoliciesService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPoliciesServiceAddRequest struct {
	schedulingPoliciesService *SchedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	policy                    *SchedulingPolicy
}

func (p *SchedulingPoliciesServiceAddRequest) Header(key, value string) *SchedulingPoliciesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPoliciesServiceAddRequest) Query(key, value string) *SchedulingPoliciesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPoliciesServiceAddRequest) Policy(policy *SchedulingPolicy) *SchedulingPoliciesServiceAddRequest {
	p.policy = policy
	return p
}
func (p *SchedulingPoliciesServiceAddRequest) Send() (*SchedulingPoliciesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.Connection.URL(), p.schedulingPoliciesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.policy)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPoliciesService.Connection.username, p.schedulingPoliciesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var schedulingPoliciesServiceAddResponse SchedulingPoliciesServiceAddResponse
	var policyVar SchedulingPolicy
	xml.Unmarshal(respBodyBytes, &policyVar)
	schedulingPoliciesServiceAddResponse.policy = &policyVar
	return &schedulingPoliciesServiceAddResponse, nil
}

type SchedulingPoliciesServiceAddResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPoliciesServiceAddResponse) Policy() *SchedulingPolicy {
	return p.policy
}
func (p *SchedulingPoliciesService) Add() *SchedulingPoliciesServiceAddRequest {
	return &SchedulingPoliciesServiceAddRequest{schedulingPoliciesService: p}
}

type SchedulingPoliciesServiceListRequest struct {
	schedulingPoliciesService *SchedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	filter                    *bool
	max                       *int64
}

func (p *SchedulingPoliciesServiceListRequest) Header(key, value string) *SchedulingPoliciesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Query(key, value string) *SchedulingPoliciesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Filter(filter bool) *SchedulingPoliciesServiceListRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPoliciesServiceListRequest) Max(max int64) *SchedulingPoliciesServiceListRequest {
	p.max = &max
	return p
}
func (p *SchedulingPoliciesServiceListRequest) Send() (*SchedulingPoliciesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.Connection.URL(), p.schedulingPoliciesService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPoliciesService.Connection.username, p.schedulingPoliciesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var schedulingPoliciesServiceListResponse SchedulingPoliciesServiceListResponse
	var policiesVar SchedulingPolicys
	xml.Unmarshal(respBodyBytes, &policiesVar)
	schedulingPoliciesServiceListResponse.policies = policiesVar.SchedulingPolicys
	return &schedulingPoliciesServiceListResponse, nil
}

type SchedulingPoliciesServiceListResponse struct {
	policies []SchedulingPolicy
}

func (p *SchedulingPoliciesServiceListResponse) Policies() []SchedulingPolicy {
	return p.policies
}
func (p *SchedulingPoliciesService) List() *SchedulingPoliciesServiceListRequest {
	return &SchedulingPoliciesServiceListRequest{schedulingPoliciesService: p}
}

//
//
func (op *SchedulingPoliciesService) PolicyService(id string) *SchedulingPolicyService {
	return NewSchedulingPolicyService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPoliciesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PolicyService(path)), nil
	}
	return op.PolicyService(path[:index]).Service(path[index+1:])
}

func (op *SchedulingPoliciesService) String() string {
	return fmt.Sprintf("SchedulingPoliciesService:%s", op.Path)
}

//
//
type WeightsService struct {
	BaseService
}

func NewWeightsService(connection *Connection, path string) *WeightsService {
	var result WeightsService
	result.Connection = connection
	result.Path = path
	return &result
}

type WeightsServiceAddRequest struct {
	weightsService *WeightsService
	header         map[string]string
	query          map[string]string
	weight         *Weight
}

func (p *WeightsServiceAddRequest) Header(key, value string) *WeightsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightsServiceAddRequest) Query(key, value string) *WeightsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightsServiceAddRequest) Weight(weight *Weight) *WeightsServiceAddRequest {
	p.weight = weight
	return p
}
func (p *WeightsServiceAddRequest) Send() (*WeightsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.Connection.URL(), p.weightsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.weight)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.weightsService.Connection.username, p.weightsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.weightsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var weightsServiceAddResponse WeightsServiceAddResponse
	var weightVar Weight
	xml.Unmarshal(respBodyBytes, &weightVar)
	weightsServiceAddResponse.weight = &weightVar
	return &weightsServiceAddResponse, nil
}

type WeightsServiceAddResponse struct {
	weight *Weight
}

func (p *WeightsServiceAddResponse) Weight() *Weight {
	return p.weight
}
func (p *WeightsService) Add() *WeightsServiceAddRequest {
	return &WeightsServiceAddRequest{weightsService: p}
}

type WeightsServiceListRequest struct {
	weightsService *WeightsService
	header         map[string]string
	query          map[string]string
	filter         *bool
	max            *int64
}

func (p *WeightsServiceListRequest) Header(key, value string) *WeightsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightsServiceListRequest) Query(key, value string) *WeightsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightsServiceListRequest) Filter(filter bool) *WeightsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *WeightsServiceListRequest) Max(max int64) *WeightsServiceListRequest {
	p.max = &max
	return p
}
func (p *WeightsServiceListRequest) Send() (*WeightsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.Connection.URL(), p.weightsService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.weightsService.Connection.username, p.weightsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.weightsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var weightsServiceListResponse WeightsServiceListResponse
	var weightsVar Weights
	xml.Unmarshal(respBodyBytes, &weightsVar)
	weightsServiceListResponse.weights = weightsVar.Weights
	return &weightsServiceListResponse, nil
}

type WeightsServiceListResponse struct {
	weights []Weight
}

func (p *WeightsServiceListResponse) Weights() []Weight {
	return p.weights
}
func (p *WeightsService) List() *WeightsServiceListRequest {
	return &WeightsServiceListRequest{weightsService: p}
}

//
//
func (op *WeightsService) WeightService(id string) *WeightService {
	return NewWeightService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *WeightsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WeightService(path)), nil
	}
	return op.WeightService(path[:index]).Service(path[index+1:])
}

func (op *WeightsService) String() string {
	return fmt.Sprintf("WeightsService:%s", op.Path)
}

//
// A service to manage host devices attached to a virtual machine.
//
type VmHostDevicesService struct {
	BaseService
}

func NewVmHostDevicesService(connection *Connection, path string) *VmHostDevicesService {
	var result VmHostDevicesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmHostDevicesServiceAddRequest struct {
	vmHostDevicesService *VmHostDevicesService
	header               map[string]string
	query                map[string]string
	device               *HostDevice
}

func (p *VmHostDevicesServiceAddRequest) Header(key, value string) *VmHostDevicesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDevicesServiceAddRequest) Query(key, value string) *VmHostDevicesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDevicesServiceAddRequest) Device(device *HostDevice) *VmHostDevicesServiceAddRequest {
	p.device = device
	return p
}
func (p *VmHostDevicesServiceAddRequest) Send() (*VmHostDevicesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.Connection.URL(), p.vmHostDevicesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.device)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmHostDevicesService.Connection.username, p.vmHostDevicesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmHostDevicesServiceAddResponse VmHostDevicesServiceAddResponse
	var deviceVar HostDevice
	xml.Unmarshal(respBodyBytes, &deviceVar)
	vmHostDevicesServiceAddResponse.device = &deviceVar
	return &vmHostDevicesServiceAddResponse, nil
}

type VmHostDevicesServiceAddResponse struct {
	device *HostDevice
}

func (p *VmHostDevicesServiceAddResponse) Device() *HostDevice {
	return p.device
}
func (p *VmHostDevicesService) Add() *VmHostDevicesServiceAddRequest {
	return &VmHostDevicesServiceAddRequest{vmHostDevicesService: p}
}

type VmHostDevicesServiceListRequest struct {
	vmHostDevicesService *VmHostDevicesService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *VmHostDevicesServiceListRequest) Header(key, value string) *VmHostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDevicesServiceListRequest) Query(key, value string) *VmHostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDevicesServiceListRequest) Max(max int64) *VmHostDevicesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmHostDevicesServiceListRequest) Send() (*VmHostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.Connection.URL(), p.vmHostDevicesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmHostDevicesService.Connection.username, p.vmHostDevicesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmHostDevicesServiceListResponse VmHostDevicesServiceListResponse
	var deviceVar HostDevices
	xml.Unmarshal(respBodyBytes, &deviceVar)
	vmHostDevicesServiceListResponse.device = deviceVar.HostDevices
	return &vmHostDevicesServiceListResponse, nil
}

type VmHostDevicesServiceListResponse struct {
	device []HostDevice
}

func (p *VmHostDevicesServiceListResponse) Device() []HostDevice {
	return p.device
}
func (p *VmHostDevicesService) List() *VmHostDevicesServiceListRequest {
	return &VmHostDevicesServiceListRequest{vmHostDevicesService: p}
}

//
// Returns a reference to the service that manages a specific host device attached to given virtual machine.
//
func (op *VmHostDevicesService) DeviceService(id string) *VmHostDeviceService {
	return NewVmHostDeviceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmHostDevicesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DeviceService(path)), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *VmHostDevicesService) String() string {
	return fmt.Sprintf("VmHostDevicesService:%s", op.Path)
}

//
//
type AssignedCpuProfileService struct {
	BaseService
}

func NewAssignedCpuProfileService(connection *Connection, path string) *AssignedCpuProfileService {
	var result AssignedCpuProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedCpuProfileServiceGetRequest struct {
	assignedCpuProfileService *AssignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
}

func (p *AssignedCpuProfileServiceGetRequest) Header(key, value string) *AssignedCpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfileServiceGetRequest) Query(key, value string) *AssignedCpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfileServiceGetRequest) Send() (*AssignedCpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfileService.Connection.URL(), p.assignedCpuProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedCpuProfileService.Connection.username, p.assignedCpuProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedCpuProfileServiceGetResponse AssignedCpuProfileServiceGetResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedCpuProfileServiceGetResponse.profile = &profileVar
	return &assignedCpuProfileServiceGetResponse, nil
}

type AssignedCpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *AssignedCpuProfileServiceGetResponse) Profile() *CpuProfile {
	return p.profile
}
func (p *AssignedCpuProfileService) Get() *AssignedCpuProfileServiceGetRequest {
	return &AssignedCpuProfileServiceGetRequest{assignedCpuProfileService: p}
}

type AssignedCpuProfileServiceRemoveRequest struct {
	assignedCpuProfileService *AssignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
	async                     *bool
}

func (p *AssignedCpuProfileServiceRemoveRequest) Header(key, value string) *AssignedCpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfileServiceRemoveRequest) Query(key, value string) *AssignedCpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfileServiceRemoveRequest) Async(async bool) *AssignedCpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedCpuProfileServiceRemoveRequest) Send() (*AssignedCpuProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfileService.Connection.URL(), p.assignedCpuProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedCpuProfileService.Connection.username, p.assignedCpuProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedCpuProfileServiceRemoveResponse), nil
}

type AssignedCpuProfileServiceRemoveResponse struct {
}

func (p *AssignedCpuProfileService) Remove() *AssignedCpuProfileServiceRemoveRequest {
	return &AssignedCpuProfileServiceRemoveRequest{assignedCpuProfileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedCpuProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedCpuProfileService) String() string {
	return fmt.Sprintf("AssignedCpuProfileService:%s", op.Path)
}

//
//
type SnapshotNicService struct {
	BaseService
}

func NewSnapshotNicService(connection *Connection, path string) *SnapshotNicService {
	var result SnapshotNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotNicServiceGetRequest struct {
	snapshotNicService *SnapshotNicService
	header             map[string]string
	query              map[string]string
}

func (p *SnapshotNicServiceGetRequest) Header(key, value string) *SnapshotNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotNicServiceGetRequest) Query(key, value string) *SnapshotNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotNicServiceGetRequest) Send() (*SnapshotNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicService.Connection.URL(), p.snapshotNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotNicService.Connection.username, p.snapshotNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotNicServiceGetResponse SnapshotNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	snapshotNicServiceGetResponse.nic = &nicVar
	return &snapshotNicServiceGetResponse, nil
}

type SnapshotNicServiceGetResponse struct {
	nic *Nic
}

func (p *SnapshotNicServiceGetResponse) Nic() *Nic {
	return p.nic
}
func (p *SnapshotNicService) Get() *SnapshotNicServiceGetRequest {
	return &SnapshotNicServiceGetRequest{snapshotNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotNicService) String() string {
	return fmt.Sprintf("SnapshotNicService:%s", op.Path)
}

//
// A service to access a particular device of a host.
//
type HostDeviceService struct {
	BaseService
}

func NewHostDeviceService(connection *Connection, path string) *HostDeviceService {
	var result HostDeviceService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostDeviceServiceGetRequest struct {
	hostDeviceService *HostDeviceService
	header            map[string]string
	query             map[string]string
}

func (p *HostDeviceServiceGetRequest) Header(key, value string) *HostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostDeviceServiceGetRequest) Query(key, value string) *HostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostDeviceServiceGetRequest) Send() (*HostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostDeviceService.Connection.URL(), p.hostDeviceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostDeviceService.Connection.username, p.hostDeviceService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostDeviceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostDeviceServiceGetResponse HostDeviceServiceGetResponse
	var deviceVar HostDevice
	xml.Unmarshal(respBodyBytes, &deviceVar)
	hostDeviceServiceGetResponse.device = &deviceVar
	return &hostDeviceServiceGetResponse, nil
}

type HostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *HostDeviceServiceGetResponse) Device() *HostDevice {
	return p.device
}
func (p *HostDeviceService) Get() *HostDeviceServiceGetRequest {
	return &HostDeviceServiceGetRequest{hostDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostDeviceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostDeviceService) String() string {
	return fmt.Sprintf("HostDeviceService:%s", op.Path)
}

//
// This service manages image transfers, for performing Image I/O API in oVirt.
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
//
type ImageTransfersService struct {
	BaseService
}

func NewImageTransfersService(connection *Connection, path string) *ImageTransfersService {
	var result ImageTransfersService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImageTransfersServiceAddRequest struct {
	imageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *ImageTransfersServiceAddRequest) Header(key, value string) *ImageTransfersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceAddRequest) Query(key, value string) *ImageTransfersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceAddRequest) ImageTransfer(imageTransfer *ImageTransfer) *ImageTransfersServiceAddRequest {
	p.imageTransfer = imageTransfer
	return p
}
func (p *ImageTransfersServiceAddRequest) Send() (*ImageTransfersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.Connection.URL(), p.imageTransfersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.imageTransfer)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransfersService.Connection.username, p.imageTransfersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var imageTransfersServiceAddResponse ImageTransfersServiceAddResponse
	var imageTransferVar ImageTransfer
	xml.Unmarshal(respBodyBytes, &imageTransferVar)
	imageTransfersServiceAddResponse.imageTransfer = &imageTransferVar
	return &imageTransfersServiceAddResponse, nil
}

type ImageTransfersServiceAddResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransfersServiceAddResponse) ImageTransfer() *ImageTransfer {
	return p.imageTransfer
}
func (p *ImageTransfersService) Add() *ImageTransfersServiceAddRequest {
	return &ImageTransfersServiceAddRequest{imageTransfersService: p}
}

type ImageTransfersServiceListRequest struct {
	imageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
}

func (p *ImageTransfersServiceListRequest) Header(key, value string) *ImageTransfersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceListRequest) Query(key, value string) *ImageTransfersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceListRequest) Send() (*ImageTransfersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.Connection.URL(), p.imageTransfersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransfersService.Connection.username, p.imageTransfersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var imageTransfersServiceListResponse ImageTransfersServiceListResponse
	var imageTransferVar ImageTransfers
	xml.Unmarshal(respBodyBytes, &imageTransferVar)
	imageTransfersServiceListResponse.imageTransfer = imageTransferVar.ImageTransfers
	return &imageTransfersServiceListResponse, nil
}

type ImageTransfersServiceListResponse struct {
	imageTransfer []ImageTransfer
}

func (p *ImageTransfersServiceListResponse) ImageTransfer() []ImageTransfer {
	return p.imageTransfer
}
func (p *ImageTransfersService) List() *ImageTransfersServiceListRequest {
	return &ImageTransfersServiceListRequest{imageTransfersService: p}
}

//
// Returns a reference to the service that manages an
// specific image transfer.
//
func (op *ImageTransfersService) ImageTransferService(id string) *ImageTransferService {
	return NewImageTransferService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageTransfersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ImageTransferService(path)), nil
	}
	return op.ImageTransferService(path[:index]).Service(path[index+1:])
}

func (op *ImageTransfersService) String() string {
	return fmt.Sprintf("ImageTransfersService:%s", op.Path)
}

//
//
type ExternalProviderService struct {
	BaseService
}

func NewExternalProviderService(connection *Connection, path string) *ExternalProviderService {
	var result ExternalProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalProviderServiceImportCertificatesRequest struct {
	externalProviderService *ExternalProviderService
	header                  map[string]string
	query                   map[string]string
	certificates            []Certificate
}

func (p *ExternalProviderServiceImportCertificatesRequest) Header(key, value string) *ExternalProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) Query(key, value string) *ExternalProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *ExternalProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *ExternalProviderServiceImportCertificatesRequest) Send() (*ExternalProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.externalProviderService.Connection.URL(), p.externalProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalProviderService.Connection.username, p.externalProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalProviderServiceImportCertificatesResponse), nil
}

type ExternalProviderServiceImportCertificatesResponse struct {
}

func (p *ExternalProviderService) ImportCertificates() *ExternalProviderServiceImportCertificatesRequest {
	return &ExternalProviderServiceImportCertificatesRequest{externalProviderService: p}
}

type ExternalProviderServiceTestConnectivityRequest struct {
	externalProviderService *ExternalProviderService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *ExternalProviderServiceTestConnectivityRequest) Header(key, value string) *ExternalProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderServiceTestConnectivityRequest) Query(key, value string) *ExternalProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderServiceTestConnectivityRequest) Async(async bool) *ExternalProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *ExternalProviderServiceTestConnectivityRequest) Send() (*ExternalProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.externalProviderService.Connection.URL(), p.externalProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalProviderService.Connection.username, p.externalProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalProviderServiceTestConnectivityResponse), nil
}

type ExternalProviderServiceTestConnectivityResponse struct {
}

func (p *ExternalProviderService) TestConnectivity() *ExternalProviderServiceTestConnectivityRequest {
	return &ExternalProviderServiceTestConnectivityRequest{externalProviderService: p}
}

//
//
func (op *ExternalProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalProviderService) String() string {
	return fmt.Sprintf("ExternalProviderService:%s", op.Path)
}

//
// A service to manage an event in the system.
//
type EventService struct {
	BaseService
}

func NewEventService(connection *Connection, path string) *EventService {
	var result EventService
	result.Connection = connection
	result.Path = path
	return &result
}

type EventServiceGetRequest struct {
	eventService *EventService
	header       map[string]string
	query        map[string]string
}

func (p *EventServiceGetRequest) Header(key, value string) *EventServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventServiceGetRequest) Query(key, value string) *EventServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventServiceGetRequest) Send() (*EventServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventService.Connection.URL(), p.eventService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventService.Connection.username, p.eventService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var eventServiceGetResponse EventServiceGetResponse
	var eventVar Event
	xml.Unmarshal(respBodyBytes, &eventVar)
	eventServiceGetResponse.event = &eventVar
	return &eventServiceGetResponse, nil
}

type EventServiceGetResponse struct {
	event *Event
}

func (p *EventServiceGetResponse) Event() *Event {
	return p.event
}
func (p *EventService) Get() *EventServiceGetRequest {
	return &EventServiceGetRequest{eventService: p}
}

type EventServiceRemoveRequest struct {
	eventService *EventService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *EventServiceRemoveRequest) Header(key, value string) *EventServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventServiceRemoveRequest) Query(key, value string) *EventServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventServiceRemoveRequest) Async(async bool) *EventServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *EventServiceRemoveRequest) Send() (*EventServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventService.Connection.URL(), p.eventService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventService.Connection.username, p.eventService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(EventServiceRemoveResponse), nil
}

type EventServiceRemoveResponse struct {
}

func (p *EventService) Remove() *EventServiceRemoveRequest {
	return &EventServiceRemoveRequest{eventService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *EventService) String() string {
	return fmt.Sprintf("EventService:%s", op.Path)
}

//
// Represents a readonly network filters sub-collection.
// The network filter enables to filter packets send to/from the VM's nic according to defined rules.
// For more information please refer to <<services/network_filter,NetworkFilter>> service documentation
// Network filters are supported in different versions, starting from version 3.0.
// A network filter is defined for each vnic profile.
// A vnic profile is defined for a specific network.
// A network can be assigned to several different clusters. In the future, each network will be defined in
// cluster level.
// Currently, each network is being defined at data center level. Potential network filters for each network
// are determined by the network's data center compatibility version V.
// V must be >= the network filter version in order to configure this network filter for a specific network.
// Please note, that if a network is assigned to cluster with a version supporting a network filter, the filter
// may not be available due to the data center version being smaller then the network filter's version.
// Example of listing all of the supported network filters for a specific cluster:
// [source]
// ----
// GET http://localhost:8080/ovirt-engine/api/clusters/{cluster:id}/networkfilters
// ----
// Output:
// [source,xml]
// ----
// <network_filters>
//   <network_filter id="00000019-0019-0019-0019-00000000026c">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026b">
//     <name>example-network-filter-b</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026a">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>3</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
// </network_filters>
// ----
//
type NetworkFiltersService struct {
	BaseService
}

func NewNetworkFiltersService(connection *Connection, path string) *NetworkFiltersService {
	var result NetworkFiltersService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFiltersServiceListRequest struct {
	networkFiltersService *NetworkFiltersService
	header                map[string]string
	query                 map[string]string
}

func (p *NetworkFiltersServiceListRequest) Header(key, value string) *NetworkFiltersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFiltersServiceListRequest) Query(key, value string) *NetworkFiltersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFiltersServiceListRequest) Send() (*NetworkFiltersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFiltersService.Connection.URL(), p.networkFiltersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFiltersService.Connection.username, p.networkFiltersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFiltersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkFiltersServiceListResponse NetworkFiltersServiceListResponse
	var filtersVar NetworkFilters
	xml.Unmarshal(respBodyBytes, &filtersVar)
	networkFiltersServiceListResponse.filters = filtersVar.NetworkFilters
	return &networkFiltersServiceListResponse, nil
}

type NetworkFiltersServiceListResponse struct {
	filters []NetworkFilter
}

func (p *NetworkFiltersServiceListResponse) Filters() []NetworkFilter {
	return p.filters
}
func (p *NetworkFiltersService) List() *NetworkFiltersServiceListRequest {
	return &NetworkFiltersServiceListRequest{networkFiltersService: p}
}

//
//
func (op *NetworkFiltersService) NetworkFilterService(id string) *NetworkFilterService {
	return NewNetworkFilterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFiltersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkFilterService(path)), nil
	}
	return op.NetworkFilterService(path[:index]).Service(path[index+1:])
}

func (op *NetworkFiltersService) String() string {
	return fmt.Sprintf("NetworkFiltersService:%s", op.Path)
}

//
//
type StatisticService struct {
	BaseService
}

func NewStatisticService(connection *Connection, path string) *StatisticService {
	var result StatisticService
	result.Connection = connection
	result.Path = path
	return &result
}

type StatisticServiceGetRequest struct {
	statisticService *StatisticService
	header           map[string]string
	query            map[string]string
	statistic        *Statistic
}

func (p *StatisticServiceGetRequest) Header(key, value string) *StatisticServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StatisticServiceGetRequest) Query(key, value string) *StatisticServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StatisticServiceGetRequest) Statistic(statistic *Statistic) *StatisticServiceGetRequest {
	p.statistic = statistic
	return p
}
func (p *StatisticServiceGetRequest) Send() (*StatisticServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.statisticService.Connection.URL(), p.statisticService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.statisticService.Connection.username, p.statisticService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.statisticService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var statisticServiceGetResponse StatisticServiceGetResponse
	var statisticVar Statistic
	xml.Unmarshal(respBodyBytes, &statisticVar)
	statisticServiceGetResponse.statistic = &statisticVar
	return &statisticServiceGetResponse, nil
}

type StatisticServiceGetResponse struct {
	statistic *Statistic
}

func (p *StatisticServiceGetResponse) Statistic() *Statistic {
	return p.statistic
}
func (p *StatisticService) Get() *StatisticServiceGetRequest {
	return &StatisticServiceGetRequest{statisticService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StatisticService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StatisticService) String() string {
	return fmt.Sprintf("StatisticService:%s", op.Path)
}

//
// Provides capability to import external virtual machines.
//
type ExternalVmImportsService struct {
	BaseService
}

func NewExternalVmImportsService(connection *Connection, path string) *ExternalVmImportsService {
	var result ExternalVmImportsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalVmImportsServiceAddRequest struct {
	externalVmImportsService *ExternalVmImportsService
	header                   map[string]string
	query                    map[string]string
	import_                  *ExternalVmImport
}

func (p *ExternalVmImportsServiceAddRequest) Header(key, value string) *ExternalVmImportsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalVmImportsServiceAddRequest) Query(key, value string) *ExternalVmImportsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalVmImportsServiceAddRequest) Import(import_ *ExternalVmImport) *ExternalVmImportsServiceAddRequest {
	p.import_ = import_
	return p
}
func (p *ExternalVmImportsServiceAddRequest) Send() (*ExternalVmImportsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalVmImportsService.Connection.URL(), p.externalVmImportsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.import_)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalVmImportsService.Connection.username, p.externalVmImportsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalVmImportsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalVmImportsServiceAddResponse ExternalVmImportsServiceAddResponse
	var import_Var ExternalVmImport
	xml.Unmarshal(respBodyBytes, &import_Var)
	externalVmImportsServiceAddResponse.import_ = &import_Var
	return &externalVmImportsServiceAddResponse, nil
}

type ExternalVmImportsServiceAddResponse struct {
	import_ *ExternalVmImport
}

func (p *ExternalVmImportsServiceAddResponse) Import_() *ExternalVmImport {
	return p.import_
}
func (p *ExternalVmImportsService) Add() *ExternalVmImportsServiceAddRequest {
	return &ExternalVmImportsServiceAddRequest{externalVmImportsService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalVmImportsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalVmImportsService) String() string {
	return fmt.Sprintf("ExternalVmImportsService:%s", op.Path)
}

//
// Represents a roles sub-collection, for example scoped by user.
//
type AssignedRolesService struct {
	BaseService
}

func NewAssignedRolesService(connection *Connection, path string) *AssignedRolesService {
	var result AssignedRolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedRolesServiceListRequest struct {
	assignedRolesService *AssignedRolesService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *AssignedRolesServiceListRequest) Header(key, value string) *AssignedRolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedRolesServiceListRequest) Query(key, value string) *AssignedRolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedRolesServiceListRequest) Max(max int64) *AssignedRolesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedRolesServiceListRequest) Send() (*AssignedRolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedRolesService.Connection.URL(), p.assignedRolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedRolesService.Connection.username, p.assignedRolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedRolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedRolesServiceListResponse AssignedRolesServiceListResponse
	var rolesVar Roles
	xml.Unmarshal(respBodyBytes, &rolesVar)
	assignedRolesServiceListResponse.roles = rolesVar.Roles
	return &assignedRolesServiceListResponse, nil
}

type AssignedRolesServiceListResponse struct {
	roles []Role
}

func (p *AssignedRolesServiceListResponse) Roles() []Role {
	return p.roles
}
func (p *AssignedRolesService) List() *AssignedRolesServiceListRequest {
	return &AssignedRolesServiceListRequest{assignedRolesService: p}
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *AssignedRolesService) RoleService(id string) *RoleService {
	return NewRoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedRolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.RoleService(path)), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *AssignedRolesService) String() string {
	return fmt.Sprintf("AssignedRolesService:%s", op.Path)
}

//
// This service manages a parameter for a network filter.
//
type NetworkFilterParameterService struct {
	BaseService
}

func NewNetworkFilterParameterService(connection *Connection, path string) *NetworkFilterParameterService {
	var result NetworkFilterParameterService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFilterParameterServiceGetRequest struct {
	networkFilterParameterService *NetworkFilterParameterService
	header                        map[string]string
	query                         map[string]string
}

func (p *NetworkFilterParameterServiceGetRequest) Header(key, value string) *NetworkFilterParameterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParameterServiceGetRequest) Query(key, value string) *NetworkFilterParameterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParameterServiceGetRequest) Send() (*NetworkFilterParameterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParameterService.Connection.URL(), p.networkFilterParameterService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParameterService.Connection.username, p.networkFilterParameterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParameterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkFilterParameterServiceGetResponse NetworkFilterParameterServiceGetResponse
	var parameterVar NetworkFilterParameter
	xml.Unmarshal(respBodyBytes, &parameterVar)
	networkFilterParameterServiceGetResponse.parameter = &parameterVar
	return &networkFilterParameterServiceGetResponse, nil
}

type NetworkFilterParameterServiceGetResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NetworkFilterParameterServiceGetResponse) Parameter() *NetworkFilterParameter {
	return p.parameter
}
func (p *NetworkFilterParameterService) Get() *NetworkFilterParameterServiceGetRequest {
	return &NetworkFilterParameterServiceGetRequest{networkFilterParameterService: p}
}

type NetworkFilterParameterServiceRemoveRequest struct {
	networkFilterParameterService *NetworkFilterParameterService
	header                        map[string]string
	query                         map[string]string
}

func (p *NetworkFilterParameterServiceRemoveRequest) Header(key, value string) *NetworkFilterParameterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParameterServiceRemoveRequest) Query(key, value string) *NetworkFilterParameterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParameterServiceRemoveRequest) Send() (*NetworkFilterParameterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParameterService.Connection.URL(), p.networkFilterParameterService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParameterService.Connection.username, p.networkFilterParameterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParameterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NetworkFilterParameterServiceRemoveResponse), nil
}

type NetworkFilterParameterServiceRemoveResponse struct {
}

func (p *NetworkFilterParameterService) Remove() *NetworkFilterParameterServiceRemoveRequest {
	return &NetworkFilterParameterServiceRemoveRequest{networkFilterParameterService: p}
}

type NetworkFilterParameterServiceUpdateRequest struct {
	networkFilterParameterService *NetworkFilterParameterService
	header                        map[string]string
	query                         map[string]string
	parameter                     *NetworkFilterParameter
}

func (p *NetworkFilterParameterServiceUpdateRequest) Header(key, value string) *NetworkFilterParameterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParameterServiceUpdateRequest) Query(key, value string) *NetworkFilterParameterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParameterServiceUpdateRequest) Parameter(parameter *NetworkFilterParameter) *NetworkFilterParameterServiceUpdateRequest {
	p.parameter = parameter
	return p
}
func (p *NetworkFilterParameterServiceUpdateRequest) Send() (*NetworkFilterParameterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParameterService.Connection.URL(), p.networkFilterParameterService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.parameter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParameterService.Connection.username, p.networkFilterParameterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParameterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkFilterParameterServiceUpdateResponse NetworkFilterParameterServiceUpdateResponse
	var parameterVar NetworkFilterParameter
	xml.Unmarshal(respBodyBytes, &parameterVar)
	networkFilterParameterServiceUpdateResponse.parameter = &parameterVar
	return &networkFilterParameterServiceUpdateResponse, nil
}

type NetworkFilterParameterServiceUpdateResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NetworkFilterParameterServiceUpdateResponse) Parameter() *NetworkFilterParameter {
	return p.parameter
}
func (p *NetworkFilterParameterService) Update() *NetworkFilterParameterServiceUpdateRequest {
	return &NetworkFilterParameterServiceUpdateRequest{networkFilterParameterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFilterParameterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkFilterParameterService) String() string {
	return fmt.Sprintf("NetworkFilterParameterService:%s", op.Path)
}

//
//
type OpenstackImageProviderService struct {
	BaseService
}

func NewOpenstackImageProviderService(connection *Connection, path string) *OpenstackImageProviderService {
	var result OpenstackImageProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImageProviderServiceGetRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
}

func (p *OpenstackImageProviderServiceGetRequest) Header(key, value string) *OpenstackImageProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceGetRequest) Query(key, value string) *OpenstackImageProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceGetRequest) Send() (*OpenstackImageProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.Connection.URL(), p.openstackImageProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProviderService.Connection.username, p.openstackImageProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackImageProviderServiceGetResponse OpenstackImageProviderServiceGetResponse
	var providerVar OpenStackImageProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackImageProviderServiceGetResponse.provider = &providerVar
	return &openstackImageProviderServiceGetResponse, nil
}

type OpenstackImageProviderServiceGetResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceGetResponse) Provider() *OpenStackImageProvider {
	return p.provider
}
func (p *OpenstackImageProviderService) Get() *OpenstackImageProviderServiceGetRequest {
	return &OpenstackImageProviderServiceGetRequest{openstackImageProviderService: p}
}

type OpenstackImageProviderServiceImportCertificatesRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	certificates                  []Certificate
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackImageProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackImageProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *OpenstackImageProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *OpenstackImageProviderServiceImportCertificatesRequest) Send() (*OpenstackImageProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackImageProviderService.Connection.URL(), p.openstackImageProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProviderService.Connection.username, p.openstackImageProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackImageProviderServiceImportCertificatesResponse), nil
}

type OpenstackImageProviderServiceImportCertificatesResponse struct {
}

func (p *OpenstackImageProviderService) ImportCertificates() *OpenstackImageProviderServiceImportCertificatesRequest {
	return &OpenstackImageProviderServiceImportCertificatesRequest{openstackImageProviderService: p}
}

type OpenstackImageProviderServiceRemoveRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *OpenstackImageProviderServiceRemoveRequest) Header(key, value string) *OpenstackImageProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceRemoveRequest) Query(key, value string) *OpenstackImageProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceRemoveRequest) Async(async bool) *OpenstackImageProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageProviderServiceRemoveRequest) Send() (*OpenstackImageProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.Connection.URL(), p.openstackImageProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProviderService.Connection.username, p.openstackImageProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackImageProviderServiceRemoveResponse), nil
}

type OpenstackImageProviderServiceRemoveResponse struct {
}

func (p *OpenstackImageProviderService) Remove() *OpenstackImageProviderServiceRemoveRequest {
	return &OpenstackImageProviderServiceRemoveRequest{openstackImageProviderService: p}
}

type OpenstackImageProviderServiceTestConnectivityRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackImageProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackImageProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackImageProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageProviderServiceTestConnectivityRequest) Send() (*OpenstackImageProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackImageProviderService.Connection.URL(), p.openstackImageProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProviderService.Connection.username, p.openstackImageProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackImageProviderServiceTestConnectivityResponse), nil
}

type OpenstackImageProviderServiceTestConnectivityResponse struct {
}

func (p *OpenstackImageProviderService) TestConnectivity() *OpenstackImageProviderServiceTestConnectivityRequest {
	return &OpenstackImageProviderServiceTestConnectivityRequest{openstackImageProviderService: p}
}

type OpenstackImageProviderServiceUpdateRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	provider                      *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceUpdateRequest) Header(key, value string) *OpenstackImageProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Query(key, value string) *OpenstackImageProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Async(async bool) *OpenstackImageProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageProviderServiceUpdateRequest) Provider(provider *OpenStackImageProvider) *OpenstackImageProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *OpenstackImageProviderServiceUpdateRequest) Send() (*OpenstackImageProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.Connection.URL(), p.openstackImageProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProviderService.Connection.username, p.openstackImageProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackImageProviderServiceUpdateResponse OpenstackImageProviderServiceUpdateResponse
	var providerVar OpenStackImageProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackImageProviderServiceUpdateResponse.provider = &providerVar
	return &openstackImageProviderServiceUpdateResponse, nil
}

type OpenstackImageProviderServiceUpdateResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceUpdateResponse) Provider() *OpenStackImageProvider {
	return p.provider
}
func (p *OpenstackImageProviderService) Update() *OpenstackImageProviderServiceUpdateRequest {
	return &OpenstackImageProviderServiceUpdateRequest{openstackImageProviderService: p}
}

//
//
func (op *OpenstackImageProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
//
func (op *OpenstackImageProviderService) ImagesService() *OpenstackImagesService {
	return NewOpenstackImagesService(op.Connection, fmt.Sprintf("%s/images", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackImageProviderService) String() string {
	return fmt.Sprintf("OpenstackImageProviderService:%s", op.Path)
}

//
//
type OpenstackNetworkService struct {
	BaseService
}

func NewOpenstackNetworkService(connection *Connection, path string) *OpenstackNetworkService {
	var result OpenstackNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworkServiceGetRequest struct {
	openstackNetworkService *OpenstackNetworkService
	header                  map[string]string
	query                   map[string]string
}

func (p *OpenstackNetworkServiceGetRequest) Header(key, value string) *OpenstackNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkServiceGetRequest) Query(key, value string) *OpenstackNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkServiceGetRequest) Send() (*OpenstackNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkService.Connection.URL(), p.openstackNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkService.Connection.username, p.openstackNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackNetworkServiceGetResponse OpenstackNetworkServiceGetResponse
	var networkVar OpenStackNetwork
	xml.Unmarshal(respBodyBytes, &networkVar)
	openstackNetworkServiceGetResponse.network = &networkVar
	return &openstackNetworkServiceGetResponse, nil
}

type OpenstackNetworkServiceGetResponse struct {
	network *OpenStackNetwork
}

func (p *OpenstackNetworkServiceGetResponse) Network() *OpenStackNetwork {
	return p.network
}
func (p *OpenstackNetworkService) Get() *OpenstackNetworkServiceGetRequest {
	return &OpenstackNetworkServiceGetRequest{openstackNetworkService: p}
}

type OpenstackNetworkServiceImportRequest struct {
	openstackNetworkService *OpenstackNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	dataCenter              *DataCenter
}

func (p *OpenstackNetworkServiceImportRequest) Header(key, value string) *OpenstackNetworkServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkServiceImportRequest) Query(key, value string) *OpenstackNetworkServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkServiceImportRequest) Async(async bool) *OpenstackNetworkServiceImportRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkServiceImportRequest) DataCenter(dataCenter *DataCenter) *OpenstackNetworkServiceImportRequest {
	p.dataCenter = dataCenter
	return p
}
func (p *OpenstackNetworkServiceImportRequest) Send() (*OpenstackNetworkServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.openstackNetworkService.Connection.URL(), p.openstackNetworkService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.DataCenter(p.dataCenter)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkService.Connection.username, p.openstackNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackNetworkServiceImportResponse), nil
}

type OpenstackNetworkServiceImportResponse struct {
}

func (p *OpenstackNetworkService) Import() *OpenstackNetworkServiceImportRequest {
	return &OpenstackNetworkServiceImportRequest{openstackNetworkService: p}
}

//
//
func (op *OpenstackNetworkService) SubnetsService() *OpenstackSubnetsService {
	return NewOpenstackSubnetsService(op.Connection, fmt.Sprintf("%s/subnets", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "subnets" {
		return op.SubnetsService(), nil
	}
	if strings.HasPrefix(path, "subnets/") {
		return op.SubnetsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackNetworkService) String() string {
	return fmt.Sprintf("OpenstackNetworkService:%s", op.Path)
}

//
//
type OpenstackImageProvidersService struct {
	BaseService
}

func NewOpenstackImageProvidersService(connection *Connection, path string) *OpenstackImageProvidersService {
	var result OpenstackImageProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImageProvidersServiceAddRequest struct {
	openstackImageProvidersService *OpenstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	provider                       *OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceAddRequest) Header(key, value string) *OpenstackImageProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceAddRequest) Query(key, value string) *OpenstackImageProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceAddRequest) Provider(provider *OpenStackImageProvider) *OpenstackImageProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *OpenstackImageProvidersServiceAddRequest) Send() (*OpenstackImageProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.Connection.URL(), p.openstackImageProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProvidersService.Connection.username, p.openstackImageProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackImageProvidersServiceAddResponse OpenstackImageProvidersServiceAddResponse
	var providerVar OpenStackImageProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackImageProvidersServiceAddResponse.provider = &providerVar
	return &openstackImageProvidersServiceAddResponse, nil
}

type OpenstackImageProvidersServiceAddResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceAddResponse) Provider() *OpenStackImageProvider {
	return p.provider
}
func (p *OpenstackImageProvidersService) Add() *OpenstackImageProvidersServiceAddRequest {
	return &OpenstackImageProvidersServiceAddRequest{openstackImageProvidersService: p}
}

type OpenstackImageProvidersServiceListRequest struct {
	openstackImageProvidersService *OpenstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	max                            *int64
}

func (p *OpenstackImageProvidersServiceListRequest) Header(key, value string) *OpenstackImageProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Query(key, value string) *OpenstackImageProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Max(max int64) *OpenstackImageProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackImageProvidersServiceListRequest) Send() (*OpenstackImageProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.Connection.URL(), p.openstackImageProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProvidersService.Connection.username, p.openstackImageProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackImageProvidersServiceListResponse OpenstackImageProvidersServiceListResponse
	var providersVar OpenStackImageProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	openstackImageProvidersServiceListResponse.providers = providersVar.OpenStackImageProviders
	return &openstackImageProvidersServiceListResponse, nil
}

type OpenstackImageProvidersServiceListResponse struct {
	providers []OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceListResponse) Providers() []OpenStackImageProvider {
	return p.providers
}
func (p *OpenstackImageProvidersService) List() *OpenstackImageProvidersServiceListRequest {
	return &OpenstackImageProvidersServiceListRequest{openstackImageProvidersService: p}
}

//
//
func (op *OpenstackImageProvidersService) ProviderService(id string) *OpenstackImageProviderService {
	return NewOpenstackImageProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackImageProvidersService) String() string {
	return fmt.Sprintf("OpenstackImageProvidersService:%s", op.Path)
}

//
//
type OpenstackVolumeAuthenticationKeyService struct {
	BaseService
}

func NewOpenstackVolumeAuthenticationKeyService(connection *Connection, path string) *OpenstackVolumeAuthenticationKeyService {
	var result OpenstackVolumeAuthenticationKeyService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeAuthenticationKeyServiceGetRequest struct {
	openstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.Connection.URL(), p.openstackVolumeAuthenticationKeyService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeyService.Connection.username, p.openstackVolumeAuthenticationKeyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeAuthenticationKeyServiceGetResponse OpenstackVolumeAuthenticationKeyServiceGetResponse
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	openstackVolumeAuthenticationKeyServiceGetResponse.key = &keyVar
	return &openstackVolumeAuthenticationKeyServiceGetResponse, nil
}

type OpenstackVolumeAuthenticationKeyServiceGetResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetResponse) Key() *OpenstackVolumeAuthenticationKey {
	return p.key
}
func (p *OpenstackVolumeAuthenticationKeyService) Get() *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	return &OpenstackVolumeAuthenticationKeyServiceGetRequest{openstackVolumeAuthenticationKeyService: p}
}

type OpenstackVolumeAuthenticationKeyServiceRemoveRequest struct {
	openstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Async(async bool) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.Connection.URL(), p.openstackVolumeAuthenticationKeyService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeyService.Connection.username, p.openstackVolumeAuthenticationKeyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackVolumeAuthenticationKeyServiceRemoveResponse), nil
}

type OpenstackVolumeAuthenticationKeyServiceRemoveResponse struct {
}

func (p *OpenstackVolumeAuthenticationKeyService) Remove() *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	return &OpenstackVolumeAuthenticationKeyServiceRemoveRequest{openstackVolumeAuthenticationKeyService: p}
}

type OpenstackVolumeAuthenticationKeyServiceUpdateRequest struct {
	openstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	key                                     *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Key(key *OpenstackVolumeAuthenticationKey) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	p.key = key
	return p
}
func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.Connection.URL(), p.openstackVolumeAuthenticationKeyService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.key)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeyService.Connection.username, p.openstackVolumeAuthenticationKeyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeAuthenticationKeyServiceUpdateResponse OpenstackVolumeAuthenticationKeyServiceUpdateResponse
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	openstackVolumeAuthenticationKeyServiceUpdateResponse.key = &keyVar
	return &openstackVolumeAuthenticationKeyServiceUpdateResponse, nil
}

type OpenstackVolumeAuthenticationKeyServiceUpdateResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateResponse) Key() *OpenstackVolumeAuthenticationKey {
	return p.key
}
func (p *OpenstackVolumeAuthenticationKeyService) Update() *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	return &OpenstackVolumeAuthenticationKeyServiceUpdateRequest{openstackVolumeAuthenticationKeyService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeAuthenticationKeyService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeAuthenticationKeyService) String() string {
	return fmt.Sprintf("OpenstackVolumeAuthenticationKeyService:%s", op.Path)
}

//
//
type OpenstackImagesService struct {
	BaseService
}

func NewOpenstackImagesService(connection *Connection, path string) *OpenstackImagesService {
	var result OpenstackImagesService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImagesServiceListRequest struct {
	openstackImagesService *OpenstackImagesService
	header                 map[string]string
	query                  map[string]string
	max                    *int64
}

func (p *OpenstackImagesServiceListRequest) Header(key, value string) *OpenstackImagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImagesServiceListRequest) Query(key, value string) *OpenstackImagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImagesServiceListRequest) Max(max int64) *OpenstackImagesServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackImagesServiceListRequest) Send() (*OpenstackImagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImagesService.Connection.URL(), p.openstackImagesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImagesService.Connection.username, p.openstackImagesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImagesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackImagesServiceListResponse OpenstackImagesServiceListResponse
	var imagesVar OpenStackImages
	xml.Unmarshal(respBodyBytes, &imagesVar)
	openstackImagesServiceListResponse.images = imagesVar.OpenStackImages
	return &openstackImagesServiceListResponse, nil
}

type OpenstackImagesServiceListResponse struct {
	images []OpenStackImage
}

func (p *OpenstackImagesServiceListResponse) Images() []OpenStackImage {
	return p.images
}
func (p *OpenstackImagesService) List() *OpenstackImagesServiceListRequest {
	return &OpenstackImagesServiceListRequest{openstackImagesService: p}
}

//
// Returns a reference to the service that manages a specific image.
//
func (op *OpenstackImagesService) ImageService(id string) *OpenstackImageService {
	return NewOpenstackImageService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImagesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ImageService(path)), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackImagesService) String() string {
	return fmt.Sprintf("OpenstackImagesService:%s", op.Path)
}

//
// This service manages OpenStack network providers.
//
type OpenstackNetworkProvidersService struct {
	BaseService
}

func NewOpenstackNetworkProvidersService(connection *Connection, path string) *OpenstackNetworkProvidersService {
	var result OpenstackNetworkProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworkProvidersServiceAddRequest struct {
	openstackNetworkProvidersService *OpenstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	provider                         *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Header(key, value string) *OpenstackNetworkProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Query(key, value string) *OpenstackNetworkProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Provider(provider *OpenStackNetworkProvider) *OpenstackNetworkProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *OpenstackNetworkProvidersServiceAddRequest) Send() (*OpenstackNetworkProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.Connection.URL(), p.openstackNetworkProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProvidersService.Connection.username, p.openstackNetworkProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackNetworkProvidersServiceAddResponse OpenstackNetworkProvidersServiceAddResponse
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackNetworkProvidersServiceAddResponse.provider = &providerVar
	return &openstackNetworkProvidersServiceAddResponse, nil
}

type OpenstackNetworkProvidersServiceAddResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceAddResponse) Provider() *OpenStackNetworkProvider {
	return p.provider
}
func (p *OpenstackNetworkProvidersService) Add() *OpenstackNetworkProvidersServiceAddRequest {
	return &OpenstackNetworkProvidersServiceAddRequest{openstackNetworkProvidersService: p}
}

type OpenstackNetworkProvidersServiceListRequest struct {
	openstackNetworkProvidersService *OpenstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	max                              *int64
}

func (p *OpenstackNetworkProvidersServiceListRequest) Header(key, value string) *OpenstackNetworkProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Query(key, value string) *OpenstackNetworkProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Max(max int64) *OpenstackNetworkProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackNetworkProvidersServiceListRequest) Send() (*OpenstackNetworkProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.Connection.URL(), p.openstackNetworkProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProvidersService.Connection.username, p.openstackNetworkProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackNetworkProvidersServiceListResponse OpenstackNetworkProvidersServiceListResponse
	var providersVar OpenStackNetworkProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	openstackNetworkProvidersServiceListResponse.providers = providersVar.OpenStackNetworkProviders
	return &openstackNetworkProvidersServiceListResponse, nil
}

type OpenstackNetworkProvidersServiceListResponse struct {
	providers []OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceListResponse) Providers() []OpenStackNetworkProvider {
	return p.providers
}
func (p *OpenstackNetworkProvidersService) List() *OpenstackNetworkProvidersServiceListRequest {
	return &OpenstackNetworkProvidersServiceListRequest{openstackNetworkProvidersService: p}
}

//
// Reference to OpenStack network provider service.
//
func (op *OpenstackNetworkProvidersService) ProviderService(id string) *OpenstackNetworkProviderService {
	return NewOpenstackNetworkProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackNetworkProvidersService) String() string {
	return fmt.Sprintf("OpenstackNetworkProvidersService:%s", op.Path)
}

//
//
type OpenstackVolumeProvidersService struct {
	BaseService
}

func NewOpenstackVolumeProvidersService(connection *Connection, path string) *OpenstackVolumeProvidersService {
	var result OpenstackVolumeProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeProvidersServiceAddRequest struct {
	openstackVolumeProvidersService *OpenstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	provider                        *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Header(key, value string) *OpenstackVolumeProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Query(key, value string) *OpenstackVolumeProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Provider(provider *OpenStackVolumeProvider) *OpenstackVolumeProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *OpenstackVolumeProvidersServiceAddRequest) Send() (*OpenstackVolumeProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.Connection.URL(), p.openstackVolumeProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProvidersService.Connection.username, p.openstackVolumeProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeProvidersServiceAddResponse OpenstackVolumeProvidersServiceAddResponse
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackVolumeProvidersServiceAddResponse.provider = &providerVar
	return &openstackVolumeProvidersServiceAddResponse, nil
}

type OpenstackVolumeProvidersServiceAddResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceAddResponse) Provider() *OpenStackVolumeProvider {
	return p.provider
}
func (p *OpenstackVolumeProvidersService) Add() *OpenstackVolumeProvidersServiceAddRequest {
	return &OpenstackVolumeProvidersServiceAddRequest{openstackVolumeProvidersService: p}
}

type OpenstackVolumeProvidersServiceListRequest struct {
	openstackVolumeProvidersService *OpenstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *OpenstackVolumeProvidersServiceListRequest) Header(key, value string) *OpenstackVolumeProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Query(key, value string) *OpenstackVolumeProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Max(max int64) *OpenstackVolumeProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackVolumeProvidersServiceListRequest) Send() (*OpenstackVolumeProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.Connection.URL(), p.openstackVolumeProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProvidersService.Connection.username, p.openstackVolumeProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeProvidersServiceListResponse OpenstackVolumeProvidersServiceListResponse
	var providersVar OpenStackVolumeProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	openstackVolumeProvidersServiceListResponse.providers = providersVar.OpenStackVolumeProviders
	return &openstackVolumeProvidersServiceListResponse, nil
}

type OpenstackVolumeProvidersServiceListResponse struct {
	providers []OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceListResponse) Providers() []OpenStackVolumeProvider {
	return p.providers
}
func (p *OpenstackVolumeProvidersService) List() *OpenstackVolumeProvidersServiceListRequest {
	return &OpenstackVolumeProvidersServiceListRequest{openstackVolumeProvidersService: p}
}

//
//
func (op *OpenstackVolumeProvidersService) ProviderService(id string) *OpenstackVolumeProviderService {
	return NewOpenstackVolumeProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeProvidersService) String() string {
	return fmt.Sprintf("OpenstackVolumeProvidersService:%s", op.Path)
}

//
//
type OpenstackNetworksService struct {
	BaseService
}

func NewOpenstackNetworksService(connection *Connection, path string) *OpenstackNetworksService {
	var result OpenstackNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworksServiceListRequest struct {
	openstackNetworksService *OpenstackNetworksService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *OpenstackNetworksServiceListRequest) Header(key, value string) *OpenstackNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworksServiceListRequest) Query(key, value string) *OpenstackNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworksServiceListRequest) Max(max int64) *OpenstackNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackNetworksServiceListRequest) Send() (*OpenstackNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworksService.Connection.URL(), p.openstackNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworksService.Connection.username, p.openstackNetworksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackNetworksServiceListResponse OpenstackNetworksServiceListResponse
	var networksVar OpenStackNetworks
	xml.Unmarshal(respBodyBytes, &networksVar)
	openstackNetworksServiceListResponse.networks = networksVar.OpenStackNetworks
	return &openstackNetworksServiceListResponse, nil
}

type OpenstackNetworksServiceListResponse struct {
	networks []OpenStackNetwork
}

func (p *OpenstackNetworksServiceListResponse) Networks() []OpenStackNetwork {
	return p.networks
}
func (p *OpenstackNetworksService) List() *OpenstackNetworksServiceListRequest {
	return &OpenstackNetworksServiceListRequest{openstackNetworksService: p}
}

//
//
func (op *OpenstackNetworksService) NetworkService(id string) *OpenstackNetworkService {
	return NewOpenstackNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackNetworksService) String() string {
	return fmt.Sprintf("OpenstackNetworksService:%s", op.Path)
}

//
//
type OpenstackVolumeProviderService struct {
	BaseService
}

func NewOpenstackVolumeProviderService(connection *Connection, path string) *OpenstackVolumeProviderService {
	var result OpenstackVolumeProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeProviderServiceGetRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
}

func (p *OpenstackVolumeProviderServiceGetRequest) Header(key, value string) *OpenstackVolumeProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceGetRequest) Query(key, value string) *OpenstackVolumeProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceGetRequest) Send() (*OpenstackVolumeProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.Connection.URL(), p.openstackVolumeProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProviderService.Connection.username, p.openstackVolumeProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeProviderServiceGetResponse OpenstackVolumeProviderServiceGetResponse
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackVolumeProviderServiceGetResponse.provider = &providerVar
	return &openstackVolumeProviderServiceGetResponse, nil
}

type OpenstackVolumeProviderServiceGetResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceGetResponse) Provider() *OpenStackVolumeProvider {
	return p.provider
}
func (p *OpenstackVolumeProviderService) Get() *OpenstackVolumeProviderServiceGetRequest {
	return &OpenstackVolumeProviderServiceGetRequest{openstackVolumeProviderService: p}
}

type OpenstackVolumeProviderServiceImportCertificatesRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	certificates                   []Certificate
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Send() (*OpenstackVolumeProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackVolumeProviderService.Connection.URL(), p.openstackVolumeProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProviderService.Connection.username, p.openstackVolumeProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackVolumeProviderServiceImportCertificatesResponse), nil
}

type OpenstackVolumeProviderServiceImportCertificatesResponse struct {
}

func (p *OpenstackVolumeProviderService) ImportCertificates() *OpenstackVolumeProviderServiceImportCertificatesRequest {
	return &OpenstackVolumeProviderServiceImportCertificatesRequest{openstackVolumeProviderService: p}
}

type OpenstackVolumeProviderServiceRemoveRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Header(key, value string) *OpenstackVolumeProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Query(key, value string) *OpenstackVolumeProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Async(async bool) *OpenstackVolumeProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeProviderServiceRemoveRequest) Send() (*OpenstackVolumeProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.Connection.URL(), p.openstackVolumeProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProviderService.Connection.username, p.openstackVolumeProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackVolumeProviderServiceRemoveResponse), nil
}

type OpenstackVolumeProviderServiceRemoveResponse struct {
}

func (p *OpenstackVolumeProviderService) Remove() *OpenstackVolumeProviderServiceRemoveRequest {
	return &OpenstackVolumeProviderServiceRemoveRequest{openstackVolumeProviderService: p}
}

type OpenstackVolumeProviderServiceTestConnectivityRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Send() (*OpenstackVolumeProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackVolumeProviderService.Connection.URL(), p.openstackVolumeProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProviderService.Connection.username, p.openstackVolumeProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackVolumeProviderServiceTestConnectivityResponse), nil
}

type OpenstackVolumeProviderServiceTestConnectivityResponse struct {
}

func (p *OpenstackVolumeProviderService) TestConnectivity() *OpenstackVolumeProviderServiceTestConnectivityRequest {
	return &OpenstackVolumeProviderServiceTestConnectivityRequest{openstackVolumeProviderService: p}
}

type OpenstackVolumeProviderServiceUpdateRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	provider                       *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Header(key, value string) *OpenstackVolumeProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Query(key, value string) *OpenstackVolumeProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Async(async bool) *OpenstackVolumeProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeProviderServiceUpdateRequest) Provider(provider *OpenStackVolumeProvider) *OpenstackVolumeProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *OpenstackVolumeProviderServiceUpdateRequest) Send() (*OpenstackVolumeProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.Connection.URL(), p.openstackVolumeProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProviderService.Connection.username, p.openstackVolumeProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeProviderServiceUpdateResponse OpenstackVolumeProviderServiceUpdateResponse
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackVolumeProviderServiceUpdateResponse.provider = &providerVar
	return &openstackVolumeProviderServiceUpdateResponse, nil
}

type OpenstackVolumeProviderServiceUpdateResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceUpdateResponse) Provider() *OpenStackVolumeProvider {
	return p.provider
}
func (p *OpenstackVolumeProviderService) Update() *OpenstackVolumeProviderServiceUpdateRequest {
	return &OpenstackVolumeProviderServiceUpdateRequest{openstackVolumeProviderService: p}
}

//
//
func (op *OpenstackVolumeProviderService) AuthenticationKeysService() *OpenstackVolumeAuthenticationKeysService {
	return NewOpenstackVolumeAuthenticationKeysService(op.Connection, fmt.Sprintf("%s/authenticationkeys", op.Path))
}

//
//
func (op *OpenstackVolumeProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
//
func (op *OpenstackVolumeProviderService) VolumeTypesService() *OpenstackVolumeTypesService {
	return NewOpenstackVolumeTypesService(op.Connection, fmt.Sprintf("%s/volumetypes", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "authenticationkeys" {
		return op.AuthenticationKeysService(), nil
	}
	if strings.HasPrefix(path, "authenticationkeys/") {
		return op.AuthenticationKeysService().Service(path[19:])
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "volumetypes" {
		return op.VolumeTypesService(), nil
	}
	if strings.HasPrefix(path, "volumetypes/") {
		return op.VolumeTypesService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeProviderService) String() string {
	return fmt.Sprintf("OpenstackVolumeProviderService:%s", op.Path)
}

//
//
type OpenstackVolumeTypesService struct {
	BaseService
}

func NewOpenstackVolumeTypesService(connection *Connection, path string) *OpenstackVolumeTypesService {
	var result OpenstackVolumeTypesService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeTypesServiceListRequest struct {
	openstackVolumeTypesService *OpenstackVolumeTypesService
	header                      map[string]string
	query                       map[string]string
	max                         *int64
}

func (p *OpenstackVolumeTypesServiceListRequest) Header(key, value string) *OpenstackVolumeTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Query(key, value string) *OpenstackVolumeTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Max(max int64) *OpenstackVolumeTypesServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackVolumeTypesServiceListRequest) Send() (*OpenstackVolumeTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypesService.Connection.URL(), p.openstackVolumeTypesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeTypesService.Connection.username, p.openstackVolumeTypesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeTypesServiceListResponse OpenstackVolumeTypesServiceListResponse
	var typesVar OpenStackVolumeTypes
	xml.Unmarshal(respBodyBytes, &typesVar)
	openstackVolumeTypesServiceListResponse.types = typesVar.OpenStackVolumeTypes
	return &openstackVolumeTypesServiceListResponse, nil
}

type OpenstackVolumeTypesServiceListResponse struct {
	types []OpenStackVolumeType
}

func (p *OpenstackVolumeTypesServiceListResponse) Types() []OpenStackVolumeType {
	return p.types
}
func (p *OpenstackVolumeTypesService) List() *OpenstackVolumeTypesServiceListRequest {
	return &OpenstackVolumeTypesServiceListRequest{openstackVolumeTypesService: p}
}

//
//
func (op *OpenstackVolumeTypesService) TypeService(id string) *OpenstackVolumeTypeService {
	return NewOpenstackVolumeTypeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeTypesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TypeService(path)), nil
	}
	return op.TypeService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeTypesService) String() string {
	return fmt.Sprintf("OpenstackVolumeTypesService:%s", op.Path)
}

//
//
type OpenstackVolumeAuthenticationKeysService struct {
	BaseService
}

func NewOpenstackVolumeAuthenticationKeysService(connection *Connection, path string) *OpenstackVolumeAuthenticationKeysService {
	var result OpenstackVolumeAuthenticationKeysService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeAuthenticationKeysServiceAddRequest struct {
	openstackVolumeAuthenticationKeysService *OpenstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	key                                      *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Key(key *OpenstackVolumeAuthenticationKey) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	p.key = key
	return p
}
func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Send() (*OpenstackVolumeAuthenticationKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.Connection.URL(), p.openstackVolumeAuthenticationKeysService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.key)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeysService.Connection.username, p.openstackVolumeAuthenticationKeysService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeAuthenticationKeysServiceAddResponse OpenstackVolumeAuthenticationKeysServiceAddResponse
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	openstackVolumeAuthenticationKeysServiceAddResponse.key = &keyVar
	return &openstackVolumeAuthenticationKeysServiceAddResponse, nil
}

type OpenstackVolumeAuthenticationKeysServiceAddResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddResponse) Key() *OpenstackVolumeAuthenticationKey {
	return p.key
}
func (p *OpenstackVolumeAuthenticationKeysService) Add() *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	return &OpenstackVolumeAuthenticationKeysServiceAddRequest{openstackVolumeAuthenticationKeysService: p}
}

type OpenstackVolumeAuthenticationKeysServiceListRequest struct {
	openstackVolumeAuthenticationKeysService *OpenstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	max                                      *int64
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Max(max int64) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Send() (*OpenstackVolumeAuthenticationKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.Connection.URL(), p.openstackVolumeAuthenticationKeysService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeysService.Connection.username, p.openstackVolumeAuthenticationKeysService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeAuthenticationKeysServiceListResponse OpenstackVolumeAuthenticationKeysServiceListResponse
	var keysVar OpenstackVolumeAuthenticationKeys
	xml.Unmarshal(respBodyBytes, &keysVar)
	openstackVolumeAuthenticationKeysServiceListResponse.keys = keysVar.OpenstackVolumeAuthenticationKeys
	return &openstackVolumeAuthenticationKeysServiceListResponse, nil
}

type OpenstackVolumeAuthenticationKeysServiceListResponse struct {
	keys []OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceListResponse) Keys() []OpenstackVolumeAuthenticationKey {
	return p.keys
}
func (p *OpenstackVolumeAuthenticationKeysService) List() *OpenstackVolumeAuthenticationKeysServiceListRequest {
	return &OpenstackVolumeAuthenticationKeysServiceListRequest{openstackVolumeAuthenticationKeysService: p}
}

//
//
func (op *OpenstackVolumeAuthenticationKeysService) KeyService(id string) *OpenstackVolumeAuthenticationKeyService {
	return NewOpenstackVolumeAuthenticationKeyService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeAuthenticationKeysService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KeyService(path)), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeAuthenticationKeysService) String() string {
	return fmt.Sprintf("OpenstackVolumeAuthenticationKeysService:%s", op.Path)
}

//
//
type OpenstackImageService struct {
	BaseService
}

func NewOpenstackImageService(connection *Connection, path string) *OpenstackImageService {
	var result OpenstackImageService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImageServiceGetRequest struct {
	openstackImageService *OpenstackImageService
	header                map[string]string
	query                 map[string]string
}

func (p *OpenstackImageServiceGetRequest) Header(key, value string) *OpenstackImageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageServiceGetRequest) Query(key, value string) *OpenstackImageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageServiceGetRequest) Send() (*OpenstackImageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageService.Connection.URL(), p.openstackImageService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageService.Connection.username, p.openstackImageService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackImageServiceGetResponse OpenstackImageServiceGetResponse
	var imageVar OpenStackImage
	xml.Unmarshal(respBodyBytes, &imageVar)
	openstackImageServiceGetResponse.image = &imageVar
	return &openstackImageServiceGetResponse, nil
}

type OpenstackImageServiceGetResponse struct {
	image *OpenStackImage
}

func (p *OpenstackImageServiceGetResponse) Image() *OpenStackImage {
	return p.image
}
func (p *OpenstackImageService) Get() *OpenstackImageServiceGetRequest {
	return &OpenstackImageServiceGetRequest{openstackImageService: p}
}

type OpenstackImageServiceImportRequest struct {
	openstackImageService *OpenstackImageService
	header                map[string]string
	query                 map[string]string
	async                 *bool
	cluster               *Cluster
	disk                  *Disk
	importAsTemplate      *bool
	storageDomain         *StorageDomain
	template              *Template
}

func (p *OpenstackImageServiceImportRequest) Header(key, value string) *OpenstackImageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageServiceImportRequest) Query(key, value string) *OpenstackImageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageServiceImportRequest) Async(async bool) *OpenstackImageServiceImportRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageServiceImportRequest) Cluster(cluster *Cluster) *OpenstackImageServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *OpenstackImageServiceImportRequest) Disk(disk *Disk) *OpenstackImageServiceImportRequest {
	p.disk = disk
	return p
}
func (p *OpenstackImageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *OpenstackImageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}
func (p *OpenstackImageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *OpenstackImageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *OpenstackImageServiceImportRequest) Template(template *Template) *OpenstackImageServiceImportRequest {
	p.template = template
	return p
}
func (p *OpenstackImageServiceImportRequest) Send() (*OpenstackImageServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.openstackImageService.Connection.URL(), p.openstackImageService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageService.Connection.username, p.openstackImageService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackImageServiceImportResponse), nil
}

type OpenstackImageServiceImportResponse struct {
}

func (p *OpenstackImageService) Import() *OpenstackImageServiceImportRequest {
	return &OpenstackImageServiceImportRequest{openstackImageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackImageService) String() string {
	return fmt.Sprintf("OpenstackImageService:%s", op.Path)
}

//
//
type OpenstackVolumeTypeService struct {
	BaseService
}

func NewOpenstackVolumeTypeService(connection *Connection, path string) *OpenstackVolumeTypeService {
	var result OpenstackVolumeTypeService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeTypeServiceGetRequest struct {
	openstackVolumeTypeService *OpenstackVolumeTypeService
	header                     map[string]string
	query                      map[string]string
}

func (p *OpenstackVolumeTypeServiceGetRequest) Header(key, value string) *OpenstackVolumeTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeTypeServiceGetRequest) Query(key, value string) *OpenstackVolumeTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeTypeServiceGetRequest) Send() (*OpenstackVolumeTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypeService.Connection.URL(), p.openstackVolumeTypeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeTypeService.Connection.username, p.openstackVolumeTypeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackVolumeTypeServiceGetResponse OpenstackVolumeTypeServiceGetResponse
	var type_Var OpenStackVolumeType
	xml.Unmarshal(respBodyBytes, &type_Var)
	openstackVolumeTypeServiceGetResponse.type_ = &type_Var
	return &openstackVolumeTypeServiceGetResponse, nil
}

type OpenstackVolumeTypeServiceGetResponse struct {
	type_ *OpenStackVolumeType
}

func (p *OpenstackVolumeTypeServiceGetResponse) Type_() *OpenStackVolumeType {
	return p.type_
}
func (p *OpenstackVolumeTypeService) Get() *OpenstackVolumeTypeServiceGetRequest {
	return &OpenstackVolumeTypeServiceGetRequest{openstackVolumeTypeService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeTypeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeTypeService) String() string {
	return fmt.Sprintf("OpenstackVolumeTypeService:%s", op.Path)
}

//
//
type OpenstackSubnetService struct {
	BaseService
}

func NewOpenstackSubnetService(connection *Connection, path string) *OpenstackSubnetService {
	var result OpenstackSubnetService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackSubnetServiceGetRequest struct {
	openstackSubnetService *OpenstackSubnetService
	header                 map[string]string
	query                  map[string]string
}

func (p *OpenstackSubnetServiceGetRequest) Header(key, value string) *OpenstackSubnetServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetServiceGetRequest) Query(key, value string) *OpenstackSubnetServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetServiceGetRequest) Send() (*OpenstackSubnetServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetService.Connection.URL(), p.openstackSubnetService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackSubnetService.Connection.username, p.openstackSubnetService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackSubnetService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackSubnetServiceGetResponse OpenstackSubnetServiceGetResponse
	var subnetVar OpenStackSubnet
	xml.Unmarshal(respBodyBytes, &subnetVar)
	openstackSubnetServiceGetResponse.subnet = &subnetVar
	return &openstackSubnetServiceGetResponse, nil
}

type OpenstackSubnetServiceGetResponse struct {
	subnet *OpenStackSubnet
}

func (p *OpenstackSubnetServiceGetResponse) Subnet() *OpenStackSubnet {
	return p.subnet
}
func (p *OpenstackSubnetService) Get() *OpenstackSubnetServiceGetRequest {
	return &OpenstackSubnetServiceGetRequest{openstackSubnetService: p}
}

type OpenstackSubnetServiceRemoveRequest struct {
	openstackSubnetService *OpenstackSubnetService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *OpenstackSubnetServiceRemoveRequest) Header(key, value string) *OpenstackSubnetServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetServiceRemoveRequest) Query(key, value string) *OpenstackSubnetServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetServiceRemoveRequest) Async(async bool) *OpenstackSubnetServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackSubnetServiceRemoveRequest) Send() (*OpenstackSubnetServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetService.Connection.URL(), p.openstackSubnetService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackSubnetService.Connection.username, p.openstackSubnetService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackSubnetService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackSubnetServiceRemoveResponse), nil
}

type OpenstackSubnetServiceRemoveResponse struct {
}

func (p *OpenstackSubnetService) Remove() *OpenstackSubnetServiceRemoveRequest {
	return &OpenstackSubnetServiceRemoveRequest{openstackSubnetService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackSubnetService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackSubnetService) String() string {
	return fmt.Sprintf("OpenstackSubnetService:%s", op.Path)
}

//
//
type OpenstackSubnetsService struct {
	BaseService
}

func NewOpenstackSubnetsService(connection *Connection, path string) *OpenstackSubnetsService {
	var result OpenstackSubnetsService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackSubnetsServiceAddRequest struct {
	openstackSubnetsService *OpenstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	subnet                  *OpenStackSubnet
}

func (p *OpenstackSubnetsServiceAddRequest) Header(key, value string) *OpenstackSubnetsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetsServiceAddRequest) Query(key, value string) *OpenstackSubnetsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetsServiceAddRequest) Subnet(subnet *OpenStackSubnet) *OpenstackSubnetsServiceAddRequest {
	p.subnet = subnet
	return p
}
func (p *OpenstackSubnetsServiceAddRequest) Send() (*OpenstackSubnetsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.Connection.URL(), p.openstackSubnetsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.subnet)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackSubnetsService.Connection.username, p.openstackSubnetsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackSubnetsServiceAddResponse OpenstackSubnetsServiceAddResponse
	var subnetVar OpenStackSubnet
	xml.Unmarshal(respBodyBytes, &subnetVar)
	openstackSubnetsServiceAddResponse.subnet = &subnetVar
	return &openstackSubnetsServiceAddResponse, nil
}

type OpenstackSubnetsServiceAddResponse struct {
	subnet *OpenStackSubnet
}

func (p *OpenstackSubnetsServiceAddResponse) Subnet() *OpenStackSubnet {
	return p.subnet
}
func (p *OpenstackSubnetsService) Add() *OpenstackSubnetsServiceAddRequest {
	return &OpenstackSubnetsServiceAddRequest{openstackSubnetsService: p}
}

type OpenstackSubnetsServiceListRequest struct {
	openstackSubnetsService *OpenstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *OpenstackSubnetsServiceListRequest) Header(key, value string) *OpenstackSubnetsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Query(key, value string) *OpenstackSubnetsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Max(max int64) *OpenstackSubnetsServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackSubnetsServiceListRequest) Send() (*OpenstackSubnetsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.Connection.URL(), p.openstackSubnetsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackSubnetsService.Connection.username, p.openstackSubnetsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackSubnetsServiceListResponse OpenstackSubnetsServiceListResponse
	var subnetsVar OpenStackSubnets
	xml.Unmarshal(respBodyBytes, &subnetsVar)
	openstackSubnetsServiceListResponse.subnets = subnetsVar.OpenStackSubnets
	return &openstackSubnetsServiceListResponse, nil
}

type OpenstackSubnetsServiceListResponse struct {
	subnets []OpenStackSubnet
}

func (p *OpenstackSubnetsServiceListResponse) Subnets() []OpenStackSubnet {
	return p.subnets
}
func (p *OpenstackSubnetsService) List() *OpenstackSubnetsServiceListRequest {
	return &OpenstackSubnetsServiceListRequest{openstackSubnetsService: p}
}

//
//
func (op *OpenstackSubnetsService) SubnetService(id string) *OpenstackSubnetService {
	return NewOpenstackSubnetService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackSubnetsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SubnetService(path)), nil
	}
	return op.SubnetService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackSubnetsService) String() string {
	return fmt.Sprintf("OpenstackSubnetsService:%s", op.Path)
}

//
// This service manages OpenStack network provider.
//
type OpenstackNetworkProviderService struct {
	BaseService
}

func NewOpenstackNetworkProviderService(connection *Connection, path string) *OpenstackNetworkProviderService {
	var result OpenstackNetworkProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworkProviderServiceGetRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
}

func (p *OpenstackNetworkProviderServiceGetRequest) Header(key, value string) *OpenstackNetworkProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceGetRequest) Query(key, value string) *OpenstackNetworkProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceGetRequest) Send() (*OpenstackNetworkProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.Connection.URL(), p.openstackNetworkProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProviderService.Connection.username, p.openstackNetworkProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackNetworkProviderServiceGetResponse OpenstackNetworkProviderServiceGetResponse
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackNetworkProviderServiceGetResponse.provider = &providerVar
	return &openstackNetworkProviderServiceGetResponse, nil
}

type OpenstackNetworkProviderServiceGetResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceGetResponse) Provider() *OpenStackNetworkProvider {
	return p.provider
}
func (p *OpenstackNetworkProviderService) Get() *OpenstackNetworkProviderServiceGetRequest {
	return &OpenstackNetworkProviderServiceGetRequest{openstackNetworkProviderService: p}
}

type OpenstackNetworkProviderServiceImportCertificatesRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	certificates                    []Certificate
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Send() (*OpenstackNetworkProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackNetworkProviderService.Connection.URL(), p.openstackNetworkProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProviderService.Connection.username, p.openstackNetworkProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackNetworkProviderServiceImportCertificatesResponse), nil
}

type OpenstackNetworkProviderServiceImportCertificatesResponse struct {
}

func (p *OpenstackNetworkProviderService) ImportCertificates() *OpenstackNetworkProviderServiceImportCertificatesRequest {
	return &OpenstackNetworkProviderServiceImportCertificatesRequest{openstackNetworkProviderService: p}
}

type OpenstackNetworkProviderServiceRemoveRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Header(key, value string) *OpenstackNetworkProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Query(key, value string) *OpenstackNetworkProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Async(async bool) *OpenstackNetworkProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkProviderServiceRemoveRequest) Send() (*OpenstackNetworkProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.Connection.URL(), p.openstackNetworkProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProviderService.Connection.username, p.openstackNetworkProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackNetworkProviderServiceRemoveResponse), nil
}

type OpenstackNetworkProviderServiceRemoveResponse struct {
}

func (p *OpenstackNetworkProviderService) Remove() *OpenstackNetworkProviderServiceRemoveRequest {
	return &OpenstackNetworkProviderServiceRemoveRequest{openstackNetworkProviderService: p}
}

type OpenstackNetworkProviderServiceTestConnectivityRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Send() (*OpenstackNetworkProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackNetworkProviderService.Connection.URL(), p.openstackNetworkProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProviderService.Connection.username, p.openstackNetworkProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackNetworkProviderServiceTestConnectivityResponse), nil
}

type OpenstackNetworkProviderServiceTestConnectivityResponse struct {
}

func (p *OpenstackNetworkProviderService) TestConnectivity() *OpenstackNetworkProviderServiceTestConnectivityRequest {
	return &OpenstackNetworkProviderServiceTestConnectivityRequest{openstackNetworkProviderService: p}
}

type OpenstackNetworkProviderServiceUpdateRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
	provider                        *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Header(key, value string) *OpenstackNetworkProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Query(key, value string) *OpenstackNetworkProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Async(async bool) *OpenstackNetworkProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkProviderServiceUpdateRequest) Provider(provider *OpenStackNetworkProvider) *OpenstackNetworkProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *OpenstackNetworkProviderServiceUpdateRequest) Send() (*OpenstackNetworkProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.Connection.URL(), p.openstackNetworkProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProviderService.Connection.username, p.openstackNetworkProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var openstackNetworkProviderServiceUpdateResponse OpenstackNetworkProviderServiceUpdateResponse
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackNetworkProviderServiceUpdateResponse.provider = &providerVar
	return &openstackNetworkProviderServiceUpdateResponse, nil
}

type OpenstackNetworkProviderServiceUpdateResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceUpdateResponse) Provider() *OpenStackNetworkProvider {
	return p.provider
}
func (p *OpenstackNetworkProviderService) Update() *OpenstackNetworkProviderServiceUpdateRequest {
	return &OpenstackNetworkProviderServiceUpdateRequest{openstackNetworkProviderService: p}
}

//
//
func (op *OpenstackNetworkProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
// Reference to OpenStack networks service.
//
func (op *OpenstackNetworkProviderService) NetworksService() *OpenstackNetworksService {
	return NewOpenstackNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackNetworkProviderService) String() string {
	return fmt.Sprintf("OpenstackNetworkProviderService:%s", op.Path)
}

//
// Manages the virtual machine template and template versions.
//
type TemplateService struct {
	BaseService
}

func NewTemplateService(connection *Connection, path string) *TemplateService {
	var result TemplateService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateServiceExportRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	exclusive       *bool
	storageDomain   *StorageDomain
}

func (p *TemplateServiceExportRequest) Header(key, value string) *TemplateServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceExportRequest) Query(key, value string) *TemplateServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceExportRequest) Exclusive(exclusive bool) *TemplateServiceExportRequest {
	p.exclusive = &exclusive
	return p
}
func (p *TemplateServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *TemplateServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *TemplateServiceExportRequest) Send() (*TemplateServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.templateService.Connection.URL(), p.templateService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Exclusive(*p.exclusive)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateService.Connection.username, p.templateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateServiceExportResponse), nil
}

type TemplateServiceExportResponse struct {
}

func (p *TemplateService) Export() *TemplateServiceExportRequest {
	return &TemplateServiceExportRequest{templateService: p}
}

type TemplateServiceGetRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	filter          *bool
}

func (p *TemplateServiceGetRequest) Header(key, value string) *TemplateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceGetRequest) Query(key, value string) *TemplateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceGetRequest) Filter(filter bool) *TemplateServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *TemplateServiceGetRequest) Send() (*TemplateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateService.Connection.URL(), p.templateService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateService.Connection.username, p.templateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateServiceGetResponse TemplateServiceGetResponse
	var templateVar Template
	xml.Unmarshal(respBodyBytes, &templateVar)
	templateServiceGetResponse.template = &templateVar
	return &templateServiceGetResponse, nil
}

type TemplateServiceGetResponse struct {
	template *Template
}

func (p *TemplateServiceGetResponse) Template() *Template {
	return p.template
}
func (p *TemplateService) Get() *TemplateServiceGetRequest {
	return &TemplateServiceGetRequest{templateService: p}
}

type TemplateServiceRemoveRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *TemplateServiceRemoveRequest) Header(key, value string) *TemplateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceRemoveRequest) Query(key, value string) *TemplateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceRemoveRequest) Async(async bool) *TemplateServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateServiceRemoveRequest) Send() (*TemplateServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateService.Connection.URL(), p.templateService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateService.Connection.username, p.templateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateServiceRemoveResponse), nil
}

type TemplateServiceRemoveResponse struct {
}

func (p *TemplateService) Remove() *TemplateServiceRemoveRequest {
	return &TemplateServiceRemoveRequest{templateService: p}
}

type TemplateServiceSealRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
}

func (p *TemplateServiceSealRequest) Header(key, value string) *TemplateServiceSealRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceSealRequest) Query(key, value string) *TemplateServiceSealRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceSealRequest) Send() (*TemplateServiceSealResponse, error) {
	rawURL := fmt.Sprintf("%s%s/seal", p.templateService.Connection.URL(), p.templateService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateService.Connection.username, p.templateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateServiceSealResponse), nil
}

type TemplateServiceSealResponse struct {
}

func (p *TemplateService) Seal() *TemplateServiceSealRequest {
	return &TemplateServiceSealRequest{templateService: p}
}

type TemplateServiceUpdateRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	async           *bool
	template        *Template
}

func (p *TemplateServiceUpdateRequest) Header(key, value string) *TemplateServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceUpdateRequest) Query(key, value string) *TemplateServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceUpdateRequest) Async(async bool) *TemplateServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TemplateServiceUpdateRequest) Template(template *Template) *TemplateServiceUpdateRequest {
	p.template = template
	return p
}
func (p *TemplateServiceUpdateRequest) Send() (*TemplateServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateService.Connection.URL(), p.templateService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.template)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateService.Connection.username, p.templateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateServiceUpdateResponse TemplateServiceUpdateResponse
	var templateVar Template
	xml.Unmarshal(respBodyBytes, &templateVar)
	templateServiceUpdateResponse.template = &templateVar
	return &templateServiceUpdateResponse, nil
}

type TemplateServiceUpdateResponse struct {
	template *Template
}

func (p *TemplateServiceUpdateResponse) Template() *Template {
	return p.template
}
func (p *TemplateService) Update() *TemplateServiceUpdateRequest {
	return &TemplateServiceUpdateRequest{templateService: p}
}

//
// Returns a reference to the service that manages the CDROMs that are associated with the template.
//
func (op *TemplateService) CdromsService() *TemplateCdromsService {
	return NewTemplateCdromsService(op.Connection, fmt.Sprintf("%s/cdroms", op.Path))
}

//
// Reference to the service that manages a specific
// disk attachment of the template.
//
func (op *TemplateService) DiskAttachmentsService() *TemplateDiskAttachmentsService {
	return NewTemplateDiskAttachmentsService(op.Connection, fmt.Sprintf("%s/diskattachments", op.Path))
}

//
// Returns a reference to the service that manages the graphical consoles that are associated with the template.
//
func (op *TemplateService) GraphicsConsolesService() *TemplateGraphicsConsolesService {
	return NewTemplateGraphicsConsolesService(op.Connection, fmt.Sprintf("%s/graphicsconsoles", op.Path))
}

//
// Returns a reference to the service that manages the NICs that are associated with the template.
//
func (op *TemplateService) NicsService() *TemplateNicsService {
	return NewTemplateNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Returns a reference to the service that manages the permissions that are associated with the template.
//
func (op *TemplateService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Returns a reference to the service that manages the tags that are associated with the template.
//
func (op *TemplateService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Returns a reference to the service that manages the _watchdogs_ that are associated with the template.
//
func (op *TemplateService) WatchdogsService() *TemplateWatchdogsService {
	return NewTemplateWatchdogsService(op.Connection, fmt.Sprintf("%s/watchdogs", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateService) String() string {
	return fmt.Sprintf("TemplateService:%s", op.Path)
}

//
// Lists the watchdogs of a virtual machine.
//
type VmWatchdogsService struct {
	BaseService
}

func NewVmWatchdogsService(connection *Connection, path string) *VmWatchdogsService {
	var result VmWatchdogsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmWatchdogsServiceAddRequest struct {
	vmWatchdogsService *VmWatchdogsService
	header             map[string]string
	query              map[string]string
	watchdog           *Watchdog
}

func (p *VmWatchdogsServiceAddRequest) Header(key, value string) *VmWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogsServiceAddRequest) Query(key, value string) *VmWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *VmWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}
func (p *VmWatchdogsServiceAddRequest) Send() (*VmWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.Connection.URL(), p.vmWatchdogsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogsService.Connection.username, p.vmWatchdogsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmWatchdogsServiceAddResponse VmWatchdogsServiceAddResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	vmWatchdogsServiceAddResponse.watchdog = &watchdogVar
	return &vmWatchdogsServiceAddResponse, nil
}

type VmWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogsServiceAddResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *VmWatchdogsService) Add() *VmWatchdogsServiceAddRequest {
	return &VmWatchdogsServiceAddRequest{vmWatchdogsService: p}
}

type VmWatchdogsServiceListRequest struct {
	vmWatchdogsService *VmWatchdogsService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *VmWatchdogsServiceListRequest) Header(key, value string) *VmWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogsServiceListRequest) Query(key, value string) *VmWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogsServiceListRequest) Max(max int64) *VmWatchdogsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmWatchdogsServiceListRequest) Send() (*VmWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.Connection.URL(), p.vmWatchdogsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogsService.Connection.username, p.vmWatchdogsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmWatchdogsServiceListResponse VmWatchdogsServiceListResponse
	var watchdogsVar Watchdogs
	xml.Unmarshal(respBodyBytes, &watchdogsVar)
	vmWatchdogsServiceListResponse.watchdogs = watchdogsVar.Watchdogs
	return &vmWatchdogsServiceListResponse, nil
}

type VmWatchdogsServiceListResponse struct {
	watchdogs []Watchdog
}

func (p *VmWatchdogsServiceListResponse) Watchdogs() []Watchdog {
	return p.watchdogs
}
func (p *VmWatchdogsService) List() *VmWatchdogsServiceListRequest {
	return &VmWatchdogsServiceListRequest{vmWatchdogsService: p}
}

//
// Returns a reference to the service that manages a specific watchdog.
//
func (op *VmWatchdogsService) WatchdogService(id string) *VmWatchdogService {
	return NewVmWatchdogService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmWatchdogsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WatchdogService(path)), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *VmWatchdogsService) String() string {
	return fmt.Sprintf("VmWatchdogsService:%s", op.Path)
}

//
// This service represents a vm that has a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type AffinityLabelVmService struct {
	BaseService
}

func NewAffinityLabelVmService(connection *Connection, path string) *AffinityLabelVmService {
	var result AffinityLabelVmService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelVmServiceGetRequest struct {
	affinityLabelVmService *AffinityLabelVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *AffinityLabelVmServiceGetRequest) Header(key, value string) *AffinityLabelVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmServiceGetRequest) Query(key, value string) *AffinityLabelVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmServiceGetRequest) Send() (*AffinityLabelVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmService.Connection.URL(), p.affinityLabelVmService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelVmService.Connection.username, p.affinityLabelVmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelVmServiceGetResponse AffinityLabelVmServiceGetResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	affinityLabelVmServiceGetResponse.vm = &vmVar
	return &affinityLabelVmServiceGetResponse, nil
}

type AffinityLabelVmServiceGetResponse struct {
	vm *Vm
}

func (p *AffinityLabelVmServiceGetResponse) Vm() *Vm {
	return p.vm
}
func (p *AffinityLabelVmService) Get() *AffinityLabelVmServiceGetRequest {
	return &AffinityLabelVmServiceGetRequest{affinityLabelVmService: p}
}

type AffinityLabelVmServiceRemoveRequest struct {
	affinityLabelVmService *AffinityLabelVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *AffinityLabelVmServiceRemoveRequest) Header(key, value string) *AffinityLabelVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmServiceRemoveRequest) Query(key, value string) *AffinityLabelVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmServiceRemoveRequest) Send() (*AffinityLabelVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmService.Connection.URL(), p.affinityLabelVmService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelVmService.Connection.username, p.affinityLabelVmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityLabelVmServiceRemoveResponse), nil
}

type AffinityLabelVmServiceRemoveResponse struct {
}

func (p *AffinityLabelVmService) Remove() *AffinityLabelVmServiceRemoveRequest {
	return &AffinityLabelVmServiceRemoveRequest{affinityLabelVmService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelVmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelVmService) String() string {
	return fmt.Sprintf("AffinityLabelVmService:%s", op.Path)
}

//
//
type VmService struct {
	BaseService
}

func NewVmService(connection *Connection, path string) *VmService {
	var result VmService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmServiceCancelMigrationRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceCancelMigrationRequest) Header(key, value string) *VmServiceCancelMigrationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCancelMigrationRequest) Query(key, value string) *VmServiceCancelMigrationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCancelMigrationRequest) Async(async bool) *VmServiceCancelMigrationRequest {
	p.async = &async
	return p
}
func (p *VmServiceCancelMigrationRequest) Send() (*VmServiceCancelMigrationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/cancelmigration", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceCancelMigrationResponse), nil
}

type VmServiceCancelMigrationResponse struct {
}

func (p *VmService) CancelMigration() *VmServiceCancelMigrationRequest {
	return &VmServiceCancelMigrationRequest{vmService: p}
}

type VmServiceCloneRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	vm        *Vm
}

func (p *VmServiceCloneRequest) Header(key, value string) *VmServiceCloneRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCloneRequest) Query(key, value string) *VmServiceCloneRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCloneRequest) Async(async bool) *VmServiceCloneRequest {
	p.async = &async
	return p
}
func (p *VmServiceCloneRequest) Vm(vm *Vm) *VmServiceCloneRequest {
	p.vm = vm
	return p
}
func (p *VmServiceCloneRequest) Send() (*VmServiceCloneResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clone", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Vm(p.vm)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceCloneResponse), nil
}

type VmServiceCloneResponse struct {
}

func (p *VmService) Clone() *VmServiceCloneRequest {
	return &VmServiceCloneRequest{vmService: p}
}

type VmServiceCommitSnapshotRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceCommitSnapshotRequest) Header(key, value string) *VmServiceCommitSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCommitSnapshotRequest) Query(key, value string) *VmServiceCommitSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCommitSnapshotRequest) Async(async bool) *VmServiceCommitSnapshotRequest {
	p.async = &async
	return p
}
func (p *VmServiceCommitSnapshotRequest) Send() (*VmServiceCommitSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/commitsnapshot", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceCommitSnapshotResponse), nil
}

type VmServiceCommitSnapshotResponse struct {
}

func (p *VmService) CommitSnapshot() *VmServiceCommitSnapshotRequest {
	return &VmServiceCommitSnapshotRequest{vmService: p}
}

type VmServiceDetachRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceDetachRequest) Header(key, value string) *VmServiceDetachRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceDetachRequest) Query(key, value string) *VmServiceDetachRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceDetachRequest) Async(async bool) *VmServiceDetachRequest {
	p.async = &async
	return p
}
func (p *VmServiceDetachRequest) Send() (*VmServiceDetachResponse, error) {
	rawURL := fmt.Sprintf("%s%s/detach", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceDetachResponse), nil
}

type VmServiceDetachResponse struct {
}

func (p *VmService) Detach() *VmServiceDetachRequest {
	return &VmServiceDetachRequest{vmService: p}
}

type VmServiceExportRequest struct {
	vmService        *VmService
	header           map[string]string
	query            map[string]string
	async            *bool
	discardSnapshots *bool
	exclusive        *bool
	storageDomain    *StorageDomain
}

func (p *VmServiceExportRequest) Header(key, value string) *VmServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceExportRequest) Query(key, value string) *VmServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceExportRequest) Async(async bool) *VmServiceExportRequest {
	p.async = &async
	return p
}
func (p *VmServiceExportRequest) DiscardSnapshots(discardSnapshots bool) *VmServiceExportRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}
func (p *VmServiceExportRequest) Exclusive(exclusive bool) *VmServiceExportRequest {
	p.exclusive = &exclusive
	return p
}
func (p *VmServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *VmServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *VmServiceExportRequest) Send() (*VmServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	actionBuilder.Exclusive(*p.exclusive)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceExportResponse), nil
}

type VmServiceExportResponse struct {
}

func (p *VmService) Export() *VmServiceExportRequest {
	return &VmServiceExportRequest{vmService: p}
}

type VmServiceFreezeFilesystemsRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceFreezeFilesystemsRequest) Header(key, value string) *VmServiceFreezeFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceFreezeFilesystemsRequest) Query(key, value string) *VmServiceFreezeFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceFreezeFilesystemsRequest) Async(async bool) *VmServiceFreezeFilesystemsRequest {
	p.async = &async
	return p
}
func (p *VmServiceFreezeFilesystemsRequest) Send() (*VmServiceFreezeFilesystemsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/freezefilesystems", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceFreezeFilesystemsResponse), nil
}

type VmServiceFreezeFilesystemsResponse struct {
}

func (p *VmService) FreezeFilesystems() *VmServiceFreezeFilesystemsRequest {
	return &VmServiceFreezeFilesystemsRequest{vmService: p}
}

type VmServiceGetRequest struct {
	vmService  *VmService
	header     map[string]string
	query      map[string]string
	allContent *bool
	filter     *bool
	nextRun    *bool
}

func (p *VmServiceGetRequest) Header(key, value string) *VmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceGetRequest) Query(key, value string) *VmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceGetRequest) AllContent(allContent bool) *VmServiceGetRequest {
	p.allContent = &allContent
	return p
}
func (p *VmServiceGetRequest) Filter(filter bool) *VmServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *VmServiceGetRequest) NextRun(nextRun bool) *VmServiceGetRequest {
	p.nextRun = &nextRun
	return p
}
func (p *VmServiceGetRequest) Send() (*VmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmService.Connection.URL(), p.vmService.Path)
	values := make(url.Values)
	if p.allContent != nil {
		values["allContent"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.nextRun != nil {
		values["nextRun"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmServiceGetResponse VmServiceGetResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	vmServiceGetResponse.vm = &vmVar
	return &vmServiceGetResponse, nil
}

type VmServiceGetResponse struct {
	vm *Vm
}

func (p *VmServiceGetResponse) Vm() *Vm {
	return p.vm
}
func (p *VmService) Get() *VmServiceGetRequest {
	return &VmServiceGetRequest{vmService: p}
}

type VmServiceLogonRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceLogonRequest) Header(key, value string) *VmServiceLogonRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceLogonRequest) Query(key, value string) *VmServiceLogonRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceLogonRequest) Async(async bool) *VmServiceLogonRequest {
	p.async = &async
	return p
}
func (p *VmServiceLogonRequest) Send() (*VmServiceLogonResponse, error) {
	rawURL := fmt.Sprintf("%s%s/logon", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceLogonResponse), nil
}

type VmServiceLogonResponse struct {
}

func (p *VmService) Logon() *VmServiceLogonRequest {
	return &VmServiceLogonRequest{vmService: p}
}

type VmServiceMaintenanceRequest struct {
	vmService          *VmService
	header             map[string]string
	query              map[string]string
	async              *bool
	maintenanceEnabled *bool
}

func (p *VmServiceMaintenanceRequest) Header(key, value string) *VmServiceMaintenanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceMaintenanceRequest) Query(key, value string) *VmServiceMaintenanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceMaintenanceRequest) Async(async bool) *VmServiceMaintenanceRequest {
	p.async = &async
	return p
}
func (p *VmServiceMaintenanceRequest) MaintenanceEnabled(maintenanceEnabled bool) *VmServiceMaintenanceRequest {
	p.maintenanceEnabled = &maintenanceEnabled
	return p
}
func (p *VmServiceMaintenanceRequest) Send() (*VmServiceMaintenanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/maintenance", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.MaintenanceEnabled(*p.maintenanceEnabled)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceMaintenanceResponse), nil
}

type VmServiceMaintenanceResponse struct {
}

func (p *VmService) Maintenance() *VmServiceMaintenanceRequest {
	return &VmServiceMaintenanceRequest{vmService: p}
}

type VmServiceMigrateRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	cluster   *Cluster
	force     *bool
	host      *Host
}

func (p *VmServiceMigrateRequest) Header(key, value string) *VmServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceMigrateRequest) Query(key, value string) *VmServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceMigrateRequest) Async(async bool) *VmServiceMigrateRequest {
	p.async = &async
	return p
}
func (p *VmServiceMigrateRequest) Cluster(cluster *Cluster) *VmServiceMigrateRequest {
	p.cluster = cluster
	return p
}
func (p *VmServiceMigrateRequest) Force(force bool) *VmServiceMigrateRequest {
	p.force = &force
	return p
}
func (p *VmServiceMigrateRequest) Host(host *Host) *VmServiceMigrateRequest {
	p.host = host
	return p
}
func (p *VmServiceMigrateRequest) Send() (*VmServiceMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/migrate", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Force(*p.force)
	actionBuilder.Host(p.host)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceMigrateResponse), nil
}

type VmServiceMigrateResponse struct {
}

func (p *VmService) Migrate() *VmServiceMigrateRequest {
	return &VmServiceMigrateRequest{vmService: p}
}

type VmServicePreviewSnapshotRequest struct {
	vmService     *VmService
	header        map[string]string
	query         map[string]string
	async         *bool
	disks         []Disk
	restoreMemory *bool
	snapshot      *Snapshot
	vm            *Vm
}

func (p *VmServicePreviewSnapshotRequest) Header(key, value string) *VmServicePreviewSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServicePreviewSnapshotRequest) Query(key, value string) *VmServicePreviewSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServicePreviewSnapshotRequest) Async(async bool) *VmServicePreviewSnapshotRequest {
	p.async = &async
	return p
}
func (p *VmServicePreviewSnapshotRequest) Disks(disks []Disk) *VmServicePreviewSnapshotRequest {
	p.disks = disks
	return p
}
func (p *VmServicePreviewSnapshotRequest) RestoreMemory(restoreMemory bool) *VmServicePreviewSnapshotRequest {
	p.restoreMemory = &restoreMemory
	return p
}
func (p *VmServicePreviewSnapshotRequest) Snapshot(snapshot *Snapshot) *VmServicePreviewSnapshotRequest {
	p.snapshot = snapshot
	return p
}
func (p *VmServicePreviewSnapshotRequest) Vm(vm *Vm) *VmServicePreviewSnapshotRequest {
	p.vm = vm
	return p
}
func (p *VmServicePreviewSnapshotRequest) Send() (*VmServicePreviewSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/previewsnapshot", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Disks(p.disks)
	actionBuilder.RestoreMemory(*p.restoreMemory)
	actionBuilder.Snapshot(p.snapshot)
	actionBuilder.Vm(p.vm)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServicePreviewSnapshotResponse), nil
}

type VmServicePreviewSnapshotResponse struct {
}

func (p *VmService) PreviewSnapshot() *VmServicePreviewSnapshotRequest {
	return &VmServicePreviewSnapshotRequest{vmService: p}
}

type VmServiceRebootRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceRebootRequest) Header(key, value string) *VmServiceRebootRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceRebootRequest) Query(key, value string) *VmServiceRebootRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceRebootRequest) Async(async bool) *VmServiceRebootRequest {
	p.async = &async
	return p
}
func (p *VmServiceRebootRequest) Send() (*VmServiceRebootResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reboot", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceRebootResponse), nil
}

type VmServiceRebootResponse struct {
}

func (p *VmService) Reboot() *VmServiceRebootRequest {
	return &VmServiceRebootRequest{vmService: p}
}

type VmServiceRemoveRequest struct {
	vmService  *VmService
	header     map[string]string
	query      map[string]string
	async      *bool
	detachOnly *bool
	force      *bool
}

func (p *VmServiceRemoveRequest) Header(key, value string) *VmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceRemoveRequest) Query(key, value string) *VmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceRemoveRequest) Async(async bool) *VmServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmServiceRemoveRequest) DetachOnly(detachOnly bool) *VmServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}
func (p *VmServiceRemoveRequest) Force(force bool) *VmServiceRemoveRequest {
	p.force = &force
	return p
}
func (p *VmServiceRemoveRequest) Send() (*VmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmService.Connection.URL(), p.vmService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.detachOnly != nil {
		values["detachOnly"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}
	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmServiceRemoveResponse), nil
}

type VmServiceRemoveResponse struct {
}

func (p *VmService) Remove() *VmServiceRemoveRequest {
	return &VmServiceRemoveRequest{vmService: p}
}

type VmServiceReorderMacAddressesRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceReorderMacAddressesRequest) Header(key, value string) *VmServiceReorderMacAddressesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceReorderMacAddressesRequest) Query(key, value string) *VmServiceReorderMacAddressesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceReorderMacAddressesRequest) Async(async bool) *VmServiceReorderMacAddressesRequest {
	p.async = &async
	return p
}
func (p *VmServiceReorderMacAddressesRequest) Send() (*VmServiceReorderMacAddressesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reordermacaddresses", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceReorderMacAddressesResponse), nil
}

type VmServiceReorderMacAddressesResponse struct {
}

func (p *VmService) ReorderMacAddresses() *VmServiceReorderMacAddressesRequest {
	return &VmServiceReorderMacAddressesRequest{vmService: p}
}

type VmServiceShutdownRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceShutdownRequest) Header(key, value string) *VmServiceShutdownRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceShutdownRequest) Query(key, value string) *VmServiceShutdownRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceShutdownRequest) Async(async bool) *VmServiceShutdownRequest {
	p.async = &async
	return p
}
func (p *VmServiceShutdownRequest) Send() (*VmServiceShutdownResponse, error) {
	rawURL := fmt.Sprintf("%s%s/shutdown", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceShutdownResponse), nil
}

type VmServiceShutdownResponse struct {
}

func (p *VmService) Shutdown() *VmServiceShutdownRequest {
	return &VmServiceShutdownRequest{vmService: p}
}

type VmServiceStartRequest struct {
	vmService    *VmService
	header       map[string]string
	query        map[string]string
	async        *bool
	filter       *bool
	pause        *bool
	useCloudInit *bool
	useSysprep   *bool
	vm           *Vm
}

func (p *VmServiceStartRequest) Header(key, value string) *VmServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceStartRequest) Query(key, value string) *VmServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceStartRequest) Async(async bool) *VmServiceStartRequest {
	p.async = &async
	return p
}
func (p *VmServiceStartRequest) Filter(filter bool) *VmServiceStartRequest {
	p.filter = &filter
	return p
}
func (p *VmServiceStartRequest) Pause(pause bool) *VmServiceStartRequest {
	p.pause = &pause
	return p
}
func (p *VmServiceStartRequest) UseCloudInit(useCloudInit bool) *VmServiceStartRequest {
	p.useCloudInit = &useCloudInit
	return p
}
func (p *VmServiceStartRequest) UseSysprep(useSysprep bool) *VmServiceStartRequest {
	p.useSysprep = &useSysprep
	return p
}
func (p *VmServiceStartRequest) Vm(vm *Vm) *VmServiceStartRequest {
	p.vm = vm
	return p
}
func (p *VmServiceStartRequest) Send() (*VmServiceStartResponse, error) {
	rawURL := fmt.Sprintf("%s%s/start", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	actionBuilder.Pause(*p.pause)
	actionBuilder.UseCloudInit(*p.useCloudInit)
	actionBuilder.UseSysprep(*p.useSysprep)
	actionBuilder.Vm(p.vm)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceStartResponse), nil
}

type VmServiceStartResponse struct {
}

func (p *VmService) Start() *VmServiceStartRequest {
	return &VmServiceStartRequest{vmService: p}
}

type VmServiceStopRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceStopRequest) Header(key, value string) *VmServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceStopRequest) Query(key, value string) *VmServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceStopRequest) Async(async bool) *VmServiceStopRequest {
	p.async = &async
	return p
}
func (p *VmServiceStopRequest) Send() (*VmServiceStopResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stop", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceStopResponse), nil
}

type VmServiceStopResponse struct {
}

func (p *VmService) Stop() *VmServiceStopRequest {
	return &VmServiceStopRequest{vmService: p}
}

type VmServiceSuspendRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceSuspendRequest) Header(key, value string) *VmServiceSuspendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceSuspendRequest) Query(key, value string) *VmServiceSuspendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceSuspendRequest) Async(async bool) *VmServiceSuspendRequest {
	p.async = &async
	return p
}
func (p *VmServiceSuspendRequest) Send() (*VmServiceSuspendResponse, error) {
	rawURL := fmt.Sprintf("%s%s/suspend", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceSuspendResponse), nil
}

type VmServiceSuspendResponse struct {
}

func (p *VmService) Suspend() *VmServiceSuspendRequest {
	return &VmServiceSuspendRequest{vmService: p}
}

type VmServiceThawFilesystemsRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceThawFilesystemsRequest) Header(key, value string) *VmServiceThawFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceThawFilesystemsRequest) Query(key, value string) *VmServiceThawFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceThawFilesystemsRequest) Async(async bool) *VmServiceThawFilesystemsRequest {
	p.async = &async
	return p
}
func (p *VmServiceThawFilesystemsRequest) Send() (*VmServiceThawFilesystemsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/thawfilesystems", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceThawFilesystemsResponse), nil
}

type VmServiceThawFilesystemsResponse struct {
}

func (p *VmService) ThawFilesystems() *VmServiceThawFilesystemsRequest {
	return &VmServiceThawFilesystemsRequest{vmService: p}
}

type VmServiceTicketRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	ticket    *Ticket
}

func (p *VmServiceTicketRequest) Header(key, value string) *VmServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceTicketRequest) Query(key, value string) *VmServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceTicketRequest) Async(async bool) *VmServiceTicketRequest {
	p.async = &async
	return p
}
func (p *VmServiceTicketRequest) Ticket(ticket *Ticket) *VmServiceTicketRequest {
	p.ticket = ticket
	return p
}
func (p *VmServiceTicketRequest) Send() (*VmServiceTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/ticket", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Ticket(p.ticket)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &VmServiceTicketResponse{ticket: action.Ticket}, nil
}

type VmServiceTicketResponse struct {
	ticket *Ticket
}

func (p *VmServiceTicketResponse) Ticket() *Ticket {
	return p.ticket
}
func (p *VmService) Ticket() *VmServiceTicketRequest {
	return &VmServiceTicketRequest{vmService: p}
}

type VmServiceUndoSnapshotRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceUndoSnapshotRequest) Header(key, value string) *VmServiceUndoSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceUndoSnapshotRequest) Query(key, value string) *VmServiceUndoSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceUndoSnapshotRequest) Async(async bool) *VmServiceUndoSnapshotRequest {
	p.async = &async
	return p
}
func (p *VmServiceUndoSnapshotRequest) Send() (*VmServiceUndoSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/undosnapshot", p.vmService.Connection.URL(), p.vmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceUndoSnapshotResponse), nil
}

type VmServiceUndoSnapshotResponse struct {
}

func (p *VmService) UndoSnapshot() *VmServiceUndoSnapshotRequest {
	return &VmServiceUndoSnapshotRequest{vmService: p}
}

type VmServiceUpdateRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	nextRun   *bool
	vm        *Vm
}

func (p *VmServiceUpdateRequest) Header(key, value string) *VmServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceUpdateRequest) Query(key, value string) *VmServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceUpdateRequest) Async(async bool) *VmServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmServiceUpdateRequest) NextRun(nextRun bool) *VmServiceUpdateRequest {
	p.nextRun = &nextRun
	return p
}
func (p *VmServiceUpdateRequest) Vm(vm *Vm) *VmServiceUpdateRequest {
	p.vm = vm
	return p
}
func (p *VmServiceUpdateRequest) Send() (*VmServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmService.Connection.URL(), p.vmService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.nextRun != nil {
		values["nextRun"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.vm)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmServiceUpdateResponse VmServiceUpdateResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	vmServiceUpdateResponse.vm = &vmVar
	return &vmServiceUpdateResponse, nil
}

type VmServiceUpdateResponse struct {
	vm *Vm
}

func (p *VmServiceUpdateResponse) Vm() *Vm {
	return p.vm
}
func (p *VmService) Update() *VmServiceUpdateRequest {
	return &VmServiceUpdateRequest{vmService: p}
}

//
// List of scheduling labels assigned to this VM.
//
func (op *VmService) AffinityLabelsService() *AssignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.Connection, fmt.Sprintf("%s/affinitylabels", op.Path))
}

//
//
func (op *VmService) ApplicationsService() *VmApplicationsService {
	return NewVmApplicationsService(op.Connection, fmt.Sprintf("%s/applications", op.Path))
}

//
//
func (op *VmService) CdromsService() *VmCdromsService {
	return NewVmCdromsService(op.Connection, fmt.Sprintf("%s/cdroms", op.Path))
}

//
// List of disks attached to this virtual machine.
//
func (op *VmService) DiskAttachmentsService() *DiskAttachmentsService {
	return NewDiskAttachmentsService(op.Connection, fmt.Sprintf("%s/diskattachments", op.Path))
}

//
//
func (op *VmService) GraphicsConsolesService() *VmGraphicsConsolesService {
	return NewVmGraphicsConsolesService(op.Connection, fmt.Sprintf("%s/graphicsconsoles", op.Path))
}

//
//
func (op *VmService) HostDevicesService() *VmHostDevicesService {
	return NewVmHostDevicesService(op.Connection, fmt.Sprintf("%s/hostdevices", op.Path))
}

//
// Reference to the service that can show the applicable errata available on the virtual machine.
// This information is taken from Katello.
//
func (op *VmService) KatelloErrataService() *KatelloErrataService {
	return NewKatelloErrataService(op.Connection, fmt.Sprintf("%s/katelloerrata", op.Path))
}

//
//
func (op *VmService) NicsService() *VmNicsService {
	return NewVmNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
//
func (op *VmService) NumaNodesService() *VmNumaNodesService {
	return NewVmNumaNodesService(op.Connection, fmt.Sprintf("%s/numanodes", op.Path))
}

//
//
func (op *VmService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *VmService) ReportedDevicesService() *VmReportedDevicesService {
	return NewVmReportedDevicesService(op.Connection, fmt.Sprintf("%s/reporteddevices", op.Path))
}

//
// Reference to the service that provides information about virtual machine user sessions.
//
func (op *VmService) SessionsService() *VmSessionsService {
	return NewVmSessionsService(op.Connection, fmt.Sprintf("%s/sessions", op.Path))
}

//
//
func (op *VmService) SnapshotsService() *SnapshotsService {
	return NewSnapshotsService(op.Connection, fmt.Sprintf("%s/snapshots", op.Path))
}

//
//
func (op *VmService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
//
func (op *VmService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
//
func (op *VmService) WatchdogsService() *VmWatchdogsService {
	return NewVmWatchdogsService(op.Connection, fmt.Sprintf("%s/watchdogs", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "applications" {
		return op.ApplicationsService(), nil
	}
	if strings.HasPrefix(path, "applications/") {
		return op.ApplicationsService().Service(path[13:])
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "hostdevices" {
		return op.HostDevicesService(), nil
	}
	if strings.HasPrefix(path, "hostdevices/") {
		return op.HostDevicesService().Service(path[12:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "sessions" {
		return op.SessionsService(), nil
	}
	if strings.HasPrefix(path, "sessions/") {
		return op.SessionsService().Service(path[9:])
	}
	if path == "snapshots" {
		return op.SnapshotsService(), nil
	}
	if strings.HasPrefix(path, "snapshots/") {
		return op.SnapshotsService().Service(path[10:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmService) String() string {
	return fmt.Sprintf("VmService:%s", op.Path)
}

//
//
type InstanceTypeGraphicsConsolesService struct {
	BaseService
}

func NewInstanceTypeGraphicsConsolesService(connection *Connection, path string) *InstanceTypeGraphicsConsolesService {
	var result InstanceTypeGraphicsConsolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeGraphicsConsolesServiceAddRequest struct {
	instanceTypeGraphicsConsolesService *InstanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	console                             *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Header(key, value string) *InstanceTypeGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Query(key, value string) *InstanceTypeGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *InstanceTypeGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}
func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Send() (*InstanceTypeGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.Connection.URL(), p.instanceTypeGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.console)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeGraphicsConsolesService.Connection.username, p.instanceTypeGraphicsConsolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeGraphicsConsolesServiceAddResponse InstanceTypeGraphicsConsolesServiceAddResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	instanceTypeGraphicsConsolesServiceAddResponse.console = &consoleVar
	return &instanceTypeGraphicsConsolesServiceAddResponse, nil
}

type InstanceTypeGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceAddResponse) Console() *GraphicsConsole {
	return p.console
}
func (p *InstanceTypeGraphicsConsolesService) Add() *InstanceTypeGraphicsConsolesServiceAddRequest {
	return &InstanceTypeGraphicsConsolesServiceAddRequest{instanceTypeGraphicsConsolesService: p}
}

type InstanceTypeGraphicsConsolesServiceListRequest struct {
	instanceTypeGraphicsConsolesService *InstanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	max                                 *int64
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Header(key, value string) *InstanceTypeGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Query(key, value string) *InstanceTypeGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Max(max int64) *InstanceTypeGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypeGraphicsConsolesServiceListRequest) Send() (*InstanceTypeGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.Connection.URL(), p.instanceTypeGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeGraphicsConsolesService.Connection.username, p.instanceTypeGraphicsConsolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeGraphicsConsolesServiceListResponse InstanceTypeGraphicsConsolesServiceListResponse
	var consolesVar GraphicsConsoles
	xml.Unmarshal(respBodyBytes, &consolesVar)
	instanceTypeGraphicsConsolesServiceListResponse.consoles = consolesVar.GraphicsConsoles
	return &instanceTypeGraphicsConsolesServiceListResponse, nil
}

type InstanceTypeGraphicsConsolesServiceListResponse struct {
	consoles []GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceListResponse) Consoles() []GraphicsConsole {
	return p.consoles
}
func (p *InstanceTypeGraphicsConsolesService) List() *InstanceTypeGraphicsConsolesServiceListRequest {
	return &InstanceTypeGraphicsConsolesServiceListRequest{instanceTypeGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific instance type graphics console.
//
func (op *InstanceTypeGraphicsConsolesService) ConsoleService(id string) *InstanceTypeGraphicsConsoleService {
	return NewInstanceTypeGraphicsConsoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeGraphicsConsolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConsoleService(path)), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeGraphicsConsolesService) String() string {
	return fmt.Sprintf("InstanceTypeGraphicsConsolesService:%s", op.Path)
}

//
//
type StorageDomainVmService struct {
	BaseService
}

func NewStorageDomainVmService(connection *Connection, path string) *StorageDomainVmService {
	var result StorageDomainVmService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmServiceGetRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *StorageDomainVmServiceGetRequest) Header(key, value string) *StorageDomainVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceGetRequest) Query(key, value string) *StorageDomainVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceGetRequest) Send() (*StorageDomainVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmService.Connection.URL(), p.storageDomainVmService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmService.Connection.username, p.storageDomainVmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainVmServiceGetResponse StorageDomainVmServiceGetResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	storageDomainVmServiceGetResponse.vm = &vmVar
	return &storageDomainVmServiceGetResponse, nil
}

type StorageDomainVmServiceGetResponse struct {
	vm *Vm
}

func (p *StorageDomainVmServiceGetResponse) Vm() *Vm {
	return p.vm
}
func (p *StorageDomainVmService) Get() *StorageDomainVmServiceGetRequest {
	return &StorageDomainVmServiceGetRequest{storageDomainVmService: p}
}

type StorageDomainVmServiceImportRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	clone                  *bool
	cluster                *Cluster
	collapseSnapshots      *bool
	storageDomain          *StorageDomain
	vm                     *Vm
}

func (p *StorageDomainVmServiceImportRequest) Header(key, value string) *StorageDomainVmServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceImportRequest) Query(key, value string) *StorageDomainVmServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceImportRequest) Async(async bool) *StorageDomainVmServiceImportRequest {
	p.async = &async
	return p
}
func (p *StorageDomainVmServiceImportRequest) Clone(clone bool) *StorageDomainVmServiceImportRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainVmServiceImportRequest) Cluster(cluster *Cluster) *StorageDomainVmServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainVmServiceImportRequest) CollapseSnapshots(collapseSnapshots bool) *StorageDomainVmServiceImportRequest {
	p.collapseSnapshots = &collapseSnapshots
	return p
}
func (p *StorageDomainVmServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainVmServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainVmServiceImportRequest) Vm(vm *Vm) *StorageDomainVmServiceImportRequest {
	p.vm = vm
	return p
}
func (p *StorageDomainVmServiceImportRequest) Send() (*StorageDomainVmServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.storageDomainVmService.Connection.URL(), p.storageDomainVmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Clone(*p.clone)
	actionBuilder.Cluster(p.cluster)
	actionBuilder.CollapseSnapshots(*p.collapseSnapshots)
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Vm(p.vm)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmService.Connection.username, p.storageDomainVmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainVmServiceImportResponse), nil
}

type StorageDomainVmServiceImportResponse struct {
}

func (p *StorageDomainVmService) Import() *StorageDomainVmServiceImportRequest {
	return &StorageDomainVmServiceImportRequest{storageDomainVmService: p}
}

type StorageDomainVmServiceRegisterRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	allowPartialImport     *bool
	async                  *bool
	clone                  *bool
	cluster                *Cluster
	reassignBadMacs        *bool
	vm                     *Vm
	vnicProfileMappings    []VnicProfileMapping
}

func (p *StorageDomainVmServiceRegisterRequest) Header(key, value string) *StorageDomainVmServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Query(key, value string) *StorageDomainVmServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *StorageDomainVmServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Async(async bool) *StorageDomainVmServiceRegisterRequest {
	p.async = &async
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Clone(clone bool) *StorageDomainVmServiceRegisterRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Cluster(cluster *Cluster) *StorageDomainVmServiceRegisterRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) ReassignBadMacs(reassignBadMacs bool) *StorageDomainVmServiceRegisterRequest {
	p.reassignBadMacs = &reassignBadMacs
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Vm(vm *Vm) *StorageDomainVmServiceRegisterRequest {
	p.vm = vm
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) VnicProfileMappings(vnicProfileMappings []VnicProfileMapping) *StorageDomainVmServiceRegisterRequest {
	p.vnicProfileMappings = vnicProfileMappings
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Send() (*StorageDomainVmServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.storageDomainVmService.Connection.URL(), p.storageDomainVmService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.AllowPartialImport(*p.allowPartialImport)
	actionBuilder.Async(*p.async)
	actionBuilder.Clone(*p.clone)
	actionBuilder.Cluster(p.cluster)
	actionBuilder.ReassignBadMacs(*p.reassignBadMacs)
	actionBuilder.Vm(p.vm)
	actionBuilder.VnicProfileMappings(p.vnicProfileMappings)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmService.Connection.username, p.storageDomainVmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainVmServiceRegisterResponse), nil
}

type StorageDomainVmServiceRegisterResponse struct {
}

func (p *StorageDomainVmService) Register() *StorageDomainVmServiceRegisterRequest {
	return &StorageDomainVmServiceRegisterRequest{storageDomainVmService: p}
}

type StorageDomainVmServiceRemoveRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *StorageDomainVmServiceRemoveRequest) Header(key, value string) *StorageDomainVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceRemoveRequest) Query(key, value string) *StorageDomainVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceRemoveRequest) Async(async bool) *StorageDomainVmServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainVmServiceRemoveRequest) Send() (*StorageDomainVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmService.Connection.URL(), p.storageDomainVmService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmService.Connection.username, p.storageDomainVmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainVmServiceRemoveResponse), nil
}

type StorageDomainVmServiceRemoveResponse struct {
}

func (p *StorageDomainVmService) Remove() *StorageDomainVmServiceRemoveRequest {
	return &StorageDomainVmServiceRemoveRequest{storageDomainVmService: p}
}

//
// Returns a reference to the service that manages the disk attachments of the virtual machine.
//
func (op *StorageDomainVmService) DiskAttachmentsService() *StorageDomainVmDiskAttachmentsService {
	return NewStorageDomainVmDiskAttachmentsService(op.Connection, fmt.Sprintf("%s/diskattachments", op.Path))
}

//
//
func (op *StorageDomainVmService) DisksService() *StorageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainVmService) String() string {
	return fmt.Sprintf("StorageDomainVmService:%s", op.Path)
}

//
// A service to manage specific cluster.
//
type ClusterService struct {
	BaseService
}

func NewClusterService(connection *Connection, path string) *ClusterService {
	var result ClusterService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClusterServiceGetRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	filter         *bool
}

func (p *ClusterServiceGetRequest) Header(key, value string) *ClusterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceGetRequest) Query(key, value string) *ClusterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceGetRequest) Filter(filter bool) *ClusterServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *ClusterServiceGetRequest) Send() (*ClusterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.Connection.URL(), p.clusterService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterService.Connection.username, p.clusterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var clusterServiceGetResponse ClusterServiceGetResponse
	var clusterVar Cluster
	xml.Unmarshal(respBodyBytes, &clusterVar)
	clusterServiceGetResponse.cluster = &clusterVar
	return &clusterServiceGetResponse, nil
}

type ClusterServiceGetResponse struct {
	cluster *Cluster
}

func (p *ClusterServiceGetResponse) Cluster() *Cluster {
	return p.cluster
}
func (p *ClusterService) Get() *ClusterServiceGetRequest {
	return &ClusterServiceGetRequest{clusterService: p}
}

type ClusterServiceRemoveRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *ClusterServiceRemoveRequest) Header(key, value string) *ClusterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceRemoveRequest) Query(key, value string) *ClusterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceRemoveRequest) Async(async bool) *ClusterServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *ClusterServiceRemoveRequest) Send() (*ClusterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.Connection.URL(), p.clusterService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterService.Connection.username, p.clusterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(ClusterServiceRemoveResponse), nil
}

type ClusterServiceRemoveResponse struct {
}

func (p *ClusterService) Remove() *ClusterServiceRemoveRequest {
	return &ClusterServiceRemoveRequest{clusterService: p}
}

type ClusterServiceResetEmulatedMachineRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *ClusterServiceResetEmulatedMachineRequest) Header(key, value string) *ClusterServiceResetEmulatedMachineRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceResetEmulatedMachineRequest) Query(key, value string) *ClusterServiceResetEmulatedMachineRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceResetEmulatedMachineRequest) Async(async bool) *ClusterServiceResetEmulatedMachineRequest {
	p.async = &async
	return p
}
func (p *ClusterServiceResetEmulatedMachineRequest) Send() (*ClusterServiceResetEmulatedMachineResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetemulatedmachine", p.clusterService.Connection.URL(), p.clusterService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterService.Connection.username, p.clusterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ClusterServiceResetEmulatedMachineResponse), nil
}

type ClusterServiceResetEmulatedMachineResponse struct {
}

func (p *ClusterService) ResetEmulatedMachine() *ClusterServiceResetEmulatedMachineRequest {
	return &ClusterServiceResetEmulatedMachineRequest{clusterService: p}
}

type ClusterServiceUpdateRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
	cluster        *Cluster
}

func (p *ClusterServiceUpdateRequest) Header(key, value string) *ClusterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceUpdateRequest) Query(key, value string) *ClusterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceUpdateRequest) Async(async bool) *ClusterServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *ClusterServiceUpdateRequest) Cluster(cluster *Cluster) *ClusterServiceUpdateRequest {
	p.cluster = cluster
	return p
}
func (p *ClusterServiceUpdateRequest) Send() (*ClusterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.Connection.URL(), p.clusterService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.cluster)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterService.Connection.username, p.clusterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var clusterServiceUpdateResponse ClusterServiceUpdateResponse
	var clusterVar Cluster
	xml.Unmarshal(respBodyBytes, &clusterVar)
	clusterServiceUpdateResponse.cluster = &clusterVar
	return &clusterServiceUpdateResponse, nil
}

type ClusterServiceUpdateResponse struct {
	cluster *Cluster
}

func (p *ClusterServiceUpdateResponse) Cluster() *Cluster {
	return p.cluster
}
func (p *ClusterService) Update() *ClusterServiceUpdateRequest {
	return &ClusterServiceUpdateRequest{clusterService: p}
}

//
// Reference to the service that manages affinity groups.
//
func (op *ClusterService) AffinityGroupsService() *AffinityGroupsService {
	return NewAffinityGroupsService(op.Connection, fmt.Sprintf("%s/affinitygroups", op.Path))
}

//
// Reference to the service that manages assigned CPU profiles for cluster.
//
func (op *ClusterService) CpuProfilesService() *AssignedCpuProfilesService {
	return NewAssignedCpuProfilesService(op.Connection, fmt.Sprintf("%s/cpuprofiles", op.Path))
}

//
// Reference to the service that manages the Gluster hooks for cluster.
//
func (op *ClusterService) GlusterHooksService() *GlusterHooksService {
	return NewGlusterHooksService(op.Connection, fmt.Sprintf("%s/glusterhooks", op.Path))
}

//
// Reference to the service that manages Gluster volumes for cluster.
//
func (op *ClusterService) GlusterVolumesService() *GlusterVolumesService {
	return NewGlusterVolumesService(op.Connection, fmt.Sprintf("%s/glustervolumes", op.Path))
}

//
// A sub collection with all the supported network filters for this cluster.
//
func (op *ClusterService) NetworkFiltersService() *NetworkFiltersService {
	return NewNetworkFiltersService(op.Connection, fmt.Sprintf("%s/networkfilters", op.Path))
}

//
// Reference to the service that manages assigned networks for cluster.
//
func (op *ClusterService) NetworksService() *AssignedNetworksService {
	return NewAssignedNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
// Reference to permissions.
//
func (op *ClusterService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitygroups" {
		return op.AffinityGroupsService(), nil
	}
	if strings.HasPrefix(path, "affinitygroups/") {
		return op.AffinityGroupsService().Service(path[15:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "glusterhooks" {
		return op.GlusterHooksService(), nil
	}
	if strings.HasPrefix(path, "glusterhooks/") {
		return op.GlusterHooksService().Service(path[13:])
	}
	if path == "glustervolumes" {
		return op.GlusterVolumesService(), nil
	}
	if strings.HasPrefix(path, "glustervolumes/") {
		return op.GlusterVolumesService().Service(path[15:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterService) String() string {
	return fmt.Sprintf("ClusterService:%s", op.Path)
}

//
//
type SnapshotDisksService struct {
	BaseService
}

func NewSnapshotDisksService(connection *Connection, path string) *SnapshotDisksService {
	var result SnapshotDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotDisksServiceListRequest struct {
	snapshotDisksService *SnapshotDisksService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *SnapshotDisksServiceListRequest) Header(key, value string) *SnapshotDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotDisksServiceListRequest) Query(key, value string) *SnapshotDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotDisksServiceListRequest) Max(max int64) *SnapshotDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotDisksServiceListRequest) Send() (*SnapshotDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDisksService.Connection.URL(), p.snapshotDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotDisksService.Connection.username, p.snapshotDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotDisksServiceListResponse SnapshotDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	snapshotDisksServiceListResponse.disks = disksVar.Disks
	return &snapshotDisksServiceListResponse, nil
}

type SnapshotDisksServiceListResponse struct {
	disks []Disk
}

func (p *SnapshotDisksServiceListResponse) Disks() []Disk {
	return p.disks
}
func (p *SnapshotDisksService) List() *SnapshotDisksServiceListRequest {
	return &SnapshotDisksServiceListRequest{snapshotDisksService: p}
}

//
//
func (op *SnapshotDisksService) DiskService(id string) *SnapshotDiskService {
	return NewSnapshotDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotDisksService) String() string {
	return fmt.Sprintf("SnapshotDisksService:%s", op.Path)
}

//
//
type TemplateGraphicsConsolesService struct {
	BaseService
}

func NewTemplateGraphicsConsolesService(connection *Connection, path string) *TemplateGraphicsConsolesService {
	var result TemplateGraphicsConsolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateGraphicsConsolesServiceAddRequest struct {
	templateGraphicsConsolesService *TemplateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	console                         *GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Header(key, value string) *TemplateGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Query(key, value string) *TemplateGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *TemplateGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}
func (p *TemplateGraphicsConsolesServiceAddRequest) Send() (*TemplateGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.Connection.URL(), p.templateGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.console)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateGraphicsConsolesService.Connection.username, p.templateGraphicsConsolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateGraphicsConsolesServiceAddResponse TemplateGraphicsConsolesServiceAddResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	templateGraphicsConsolesServiceAddResponse.console = &consoleVar
	return &templateGraphicsConsolesServiceAddResponse, nil
}

type TemplateGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceAddResponse) Console() *GraphicsConsole {
	return p.console
}
func (p *TemplateGraphicsConsolesService) Add() *TemplateGraphicsConsolesServiceAddRequest {
	return &TemplateGraphicsConsolesServiceAddRequest{templateGraphicsConsolesService: p}
}

type TemplateGraphicsConsolesServiceListRequest struct {
	templateGraphicsConsolesService *TemplateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *TemplateGraphicsConsolesServiceListRequest) Header(key, value string) *TemplateGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Query(key, value string) *TemplateGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Max(max int64) *TemplateGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateGraphicsConsolesServiceListRequest) Send() (*TemplateGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.Connection.URL(), p.templateGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateGraphicsConsolesService.Connection.username, p.templateGraphicsConsolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateGraphicsConsolesServiceListResponse TemplateGraphicsConsolesServiceListResponse
	var consolesVar GraphicsConsoles
	xml.Unmarshal(respBodyBytes, &consolesVar)
	templateGraphicsConsolesServiceListResponse.consoles = consolesVar.GraphicsConsoles
	return &templateGraphicsConsolesServiceListResponse, nil
}

type TemplateGraphicsConsolesServiceListResponse struct {
	consoles []GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceListResponse) Consoles() []GraphicsConsole {
	return p.consoles
}
func (p *TemplateGraphicsConsolesService) List() *TemplateGraphicsConsolesServiceListRequest {
	return &TemplateGraphicsConsolesServiceListRequest{templateGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific template graphics console.
//
func (op *TemplateGraphicsConsolesService) ConsoleService(id string) *TemplateGraphicsConsoleService {
	return NewTemplateGraphicsConsoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateGraphicsConsolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConsoleService(path)), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *TemplateGraphicsConsolesService) String() string {
	return fmt.Sprintf("TemplateGraphicsConsolesService:%s", op.Path)
}

//
// A service to manage a virtual machines pool.
//
type VmPoolService struct {
	BaseService
}

func NewVmPoolService(connection *Connection, path string) *VmPoolService {
	var result VmPoolService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmPoolServiceAllocateVmRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmPoolServiceAllocateVmRequest) Header(key, value string) *VmPoolServiceAllocateVmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceAllocateVmRequest) Query(key, value string) *VmPoolServiceAllocateVmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceAllocateVmRequest) Async(async bool) *VmPoolServiceAllocateVmRequest {
	p.async = &async
	return p
}
func (p *VmPoolServiceAllocateVmRequest) Send() (*VmPoolServiceAllocateVmResponse, error) {
	rawURL := fmt.Sprintf("%s%s/allocatevm", p.vmPoolService.Connection.URL(), p.vmPoolService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolService.Connection.username, p.vmPoolService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmPoolServiceAllocateVmResponse), nil
}

type VmPoolServiceAllocateVmResponse struct {
}

func (p *VmPoolService) AllocateVm() *VmPoolServiceAllocateVmRequest {
	return &VmPoolServiceAllocateVmRequest{vmPoolService: p}
}

type VmPoolServiceGetRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	filter        *bool
}

func (p *VmPoolServiceGetRequest) Header(key, value string) *VmPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceGetRequest) Query(key, value string) *VmPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceGetRequest) Filter(filter bool) *VmPoolServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *VmPoolServiceGetRequest) Send() (*VmPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.Connection.URL(), p.vmPoolService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolService.Connection.username, p.vmPoolService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmPoolServiceGetResponse VmPoolServiceGetResponse
	var poolVar VmPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	vmPoolServiceGetResponse.pool = &poolVar
	return &vmPoolServiceGetResponse, nil
}

type VmPoolServiceGetResponse struct {
	pool *VmPool
}

func (p *VmPoolServiceGetResponse) Pool() *VmPool {
	return p.pool
}
func (p *VmPoolService) Get() *VmPoolServiceGetRequest {
	return &VmPoolServiceGetRequest{vmPoolService: p}
}

type VmPoolServiceRemoveRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmPoolServiceRemoveRequest) Header(key, value string) *VmPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceRemoveRequest) Query(key, value string) *VmPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceRemoveRequest) Async(async bool) *VmPoolServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmPoolServiceRemoveRequest) Send() (*VmPoolServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.Connection.URL(), p.vmPoolService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolService.Connection.username, p.vmPoolService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmPoolServiceRemoveResponse), nil
}

type VmPoolServiceRemoveResponse struct {
}

func (p *VmPoolService) Remove() *VmPoolServiceRemoveRequest {
	return &VmPoolServiceRemoveRequest{vmPoolService: p}
}

type VmPoolServiceUpdateRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
	pool          *VmPool
}

func (p *VmPoolServiceUpdateRequest) Header(key, value string) *VmPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceUpdateRequest) Query(key, value string) *VmPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceUpdateRequest) Async(async bool) *VmPoolServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmPoolServiceUpdateRequest) Pool(pool *VmPool) *VmPoolServiceUpdateRequest {
	p.pool = pool
	return p
}
func (p *VmPoolServiceUpdateRequest) Send() (*VmPoolServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.Connection.URL(), p.vmPoolService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.pool)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolService.Connection.username, p.vmPoolService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmPoolServiceUpdateResponse VmPoolServiceUpdateResponse
	var poolVar VmPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	vmPoolServiceUpdateResponse.pool = &poolVar
	return &vmPoolServiceUpdateResponse, nil
}

type VmPoolServiceUpdateResponse struct {
	pool *VmPool
}

func (p *VmPoolServiceUpdateResponse) Pool() *VmPool {
	return p.pool
}
func (p *VmPoolService) Update() *VmPoolServiceUpdateRequest {
	return &VmPoolServiceUpdateRequest{vmPoolService: p}
}

//
// Reference to a service managing the virtual machine pool assigned permissions.
//
func (op *VmPoolService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmPoolService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmPoolService) String() string {
	return fmt.Sprintf("VmPoolService:%s", op.Path)
}

//
//
type QuotasService struct {
	BaseService
}

func NewQuotasService(connection *Connection, path string) *QuotasService {
	var result QuotasService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotasServiceAddRequest struct {
	quotasService *QuotasService
	header        map[string]string
	query         map[string]string
	quota         *Quota
}

func (p *QuotasServiceAddRequest) Header(key, value string) *QuotasServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotasServiceAddRequest) Query(key, value string) *QuotasServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotasServiceAddRequest) Quota(quota *Quota) *QuotasServiceAddRequest {
	p.quota = quota
	return p
}
func (p *QuotasServiceAddRequest) Send() (*QuotasServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.Connection.URL(), p.quotasService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.quota)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotasService.Connection.username, p.quotasService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotasService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotasServiceAddResponse QuotasServiceAddResponse
	var quotaVar Quota
	xml.Unmarshal(respBodyBytes, &quotaVar)
	quotasServiceAddResponse.quota = &quotaVar
	return &quotasServiceAddResponse, nil
}

type QuotasServiceAddResponse struct {
	quota *Quota
}

func (p *QuotasServiceAddResponse) Quota() *Quota {
	return p.quota
}
func (p *QuotasService) Add() *QuotasServiceAddRequest {
	return &QuotasServiceAddRequest{quotasService: p}
}

type QuotasServiceListRequest struct {
	quotasService *QuotasService
	header        map[string]string
	query         map[string]string
	max           *int64
}

func (p *QuotasServiceListRequest) Header(key, value string) *QuotasServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotasServiceListRequest) Query(key, value string) *QuotasServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotasServiceListRequest) Max(max int64) *QuotasServiceListRequest {
	p.max = &max
	return p
}
func (p *QuotasServiceListRequest) Send() (*QuotasServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.Connection.URL(), p.quotasService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotasService.Connection.username, p.quotasService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotasService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotasServiceListResponse QuotasServiceListResponse
	var quotasVar Quotas
	xml.Unmarshal(respBodyBytes, &quotasVar)
	quotasServiceListResponse.quotas = quotasVar.Quotas
	return &quotasServiceListResponse, nil
}

type QuotasServiceListResponse struct {
	quotas []Quota
}

func (p *QuotasServiceListResponse) Quotas() []Quota {
	return p.quotas
}
func (p *QuotasService) List() *QuotasServiceListRequest {
	return &QuotasServiceListRequest{quotasService: p}
}

//
//
func (op *QuotasService) QuotaService(id string) *QuotaService {
	return NewQuotaService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotasService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.QuotaService(path)), nil
	}
	return op.QuotaService(path[:index]).Service(path[index+1:])
}

func (op *QuotasService) String() string {
	return fmt.Sprintf("QuotasService:%s", op.Path)
}

//
// Provides information about a specific cluster level. See the <<services/cluster_levels,ClusterLevels>> service for
// more information.
//
type ClusterLevelService struct {
	BaseService
}

func NewClusterLevelService(connection *Connection, path string) *ClusterLevelService {
	var result ClusterLevelService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClusterLevelServiceGetRequest struct {
	clusterLevelService *ClusterLevelService
	header              map[string]string
	query               map[string]string
}

func (p *ClusterLevelServiceGetRequest) Header(key, value string) *ClusterLevelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterLevelServiceGetRequest) Query(key, value string) *ClusterLevelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterLevelServiceGetRequest) Send() (*ClusterLevelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelService.Connection.URL(), p.clusterLevelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterLevelService.Connection.username, p.clusterLevelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterLevelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var clusterLevelServiceGetResponse ClusterLevelServiceGetResponse
	var levelVar ClusterLevel
	xml.Unmarshal(respBodyBytes, &levelVar)
	clusterLevelServiceGetResponse.level = &levelVar
	return &clusterLevelServiceGetResponse, nil
}

type ClusterLevelServiceGetResponse struct {
	level *ClusterLevel
}

func (p *ClusterLevelServiceGetResponse) Level() *ClusterLevel {
	return p.level
}
func (p *ClusterLevelService) Get() *ClusterLevelServiceGetRequest {
	return &ClusterLevelServiceGetRequest{clusterLevelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterLevelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterLevelService) String() string {
	return fmt.Sprintf("ClusterLevelService:%s", op.Path)
}

//
//
type StorageDomainContentDiskService struct {
	BaseService
}

func NewStorageDomainContentDiskService(connection *Connection, path string) *StorageDomainContentDiskService {
	var result StorageDomainContentDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainContentDiskServiceGetRequest struct {
	storageDomainContentDiskService *StorageDomainContentDiskService
	header                          map[string]string
	query                           map[string]string
	filter                          *bool
}

func (p *StorageDomainContentDiskServiceGetRequest) Header(key, value string) *StorageDomainContentDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Query(key, value string) *StorageDomainContentDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Filter(filter bool) *StorageDomainContentDiskServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainContentDiskServiceGetRequest) Send() (*StorageDomainContentDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDiskService.Connection.URL(), p.storageDomainContentDiskService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainContentDiskService.Connection.username, p.storageDomainContentDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainContentDiskServiceGetResponse StorageDomainContentDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	storageDomainContentDiskServiceGetResponse.disk = &diskVar
	return &storageDomainContentDiskServiceGetResponse, nil
}

type StorageDomainContentDiskServiceGetResponse struct {
	disk *Disk
}

func (p *StorageDomainContentDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}
func (p *StorageDomainContentDiskService) Get() *StorageDomainContentDiskServiceGetRequest {
	return &StorageDomainContentDiskServiceGetRequest{storageDomainContentDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainContentDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainContentDiskService) String() string {
	return fmt.Sprintf("StorageDomainContentDiskService:%s", op.Path)
}

//
// A service that provides information about applications installed in a virtual machine.
//
type VmApplicationsService struct {
	BaseService
}

func NewVmApplicationsService(connection *Connection, path string) *VmApplicationsService {
	var result VmApplicationsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmApplicationsServiceListRequest struct {
	vmApplicationsService *VmApplicationsService
	header                map[string]string
	query                 map[string]string
	filter                *bool
	max                   *int64
}

func (p *VmApplicationsServiceListRequest) Header(key, value string) *VmApplicationsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmApplicationsServiceListRequest) Query(key, value string) *VmApplicationsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmApplicationsServiceListRequest) Filter(filter bool) *VmApplicationsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *VmApplicationsServiceListRequest) Max(max int64) *VmApplicationsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmApplicationsServiceListRequest) Send() (*VmApplicationsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationsService.Connection.URL(), p.vmApplicationsService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmApplicationsService.Connection.username, p.vmApplicationsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmApplicationsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmApplicationsServiceListResponse VmApplicationsServiceListResponse
	var applicationsVar Applications
	xml.Unmarshal(respBodyBytes, &applicationsVar)
	vmApplicationsServiceListResponse.applications = applicationsVar.Applications
	return &vmApplicationsServiceListResponse, nil
}

type VmApplicationsServiceListResponse struct {
	applications []Application
}

func (p *VmApplicationsServiceListResponse) Applications() []Application {
	return p.applications
}
func (p *VmApplicationsService) List() *VmApplicationsServiceListRequest {
	return &VmApplicationsServiceListRequest{vmApplicationsService: p}
}

//
// Returns a reference to the service that provides information about a specific application.
//
func (op *VmApplicationsService) ApplicationService(id string) *VmApplicationService {
	return NewVmApplicationService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmApplicationsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ApplicationService(path)), nil
	}
	return op.ApplicationService(path[:index]).Service(path[index+1:])
}

func (op *VmApplicationsService) String() string {
	return fmt.Sprintf("VmApplicationsService:%s", op.Path)
}

//
// Provides a way for clients to list available files.
// This services is specifically targeted to ISO storage domains, which contain ISO images and virtual floppy disks
// (VFDs) that an administrator uploads.
// The addition of a CDROM device to a virtual machine requires an ISO image from the files of an ISO storage domain.
//
type FilesService struct {
	BaseService
}

func NewFilesService(connection *Connection, path string) *FilesService {
	var result FilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type FilesServiceListRequest struct {
	filesService  *FilesService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *FilesServiceListRequest) Header(key, value string) *FilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilesServiceListRequest) Query(key, value string) *FilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilesServiceListRequest) CaseSensitive(caseSensitive bool) *FilesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *FilesServiceListRequest) Max(max int64) *FilesServiceListRequest {
	p.max = &max
	return p
}
func (p *FilesServiceListRequest) Search(search string) *FilesServiceListRequest {
	p.search = &search
	return p
}
func (p *FilesServiceListRequest) Send() (*FilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filesService.Connection.URL(), p.filesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filesService.Connection.username, p.filesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var filesServiceListResponse FilesServiceListResponse
	var fileVar Files
	xml.Unmarshal(respBodyBytes, &fileVar)
	filesServiceListResponse.file = fileVar.Files
	return &filesServiceListResponse, nil
}

type FilesServiceListResponse struct {
	file []File
}

func (p *FilesServiceListResponse) File() []File {
	return p.file
}
func (p *FilesService) List() *FilesServiceListRequest {
	return &FilesServiceListRequest{filesService: p}
}

//
//
func (op *FilesService) FileService(id string) *FileService {
	return NewFileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.FileService(path)), nil
	}
	return op.FileService(path[:index]).Service(path[index+1:])
}

func (op *FilesService) String() string {
	return fmt.Sprintf("FilesService:%s", op.Path)
}

//
// This service manages a single virtual machine to affinity group assignment.
//
type AffinityGroupVmService struct {
	BaseService
}

func NewAffinityGroupVmService(connection *Connection, path string) *AffinityGroupVmService {
	var result AffinityGroupVmService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupVmServiceRemoveRequest struct {
	affinityGroupVmService *AffinityGroupVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *AffinityGroupVmServiceRemoveRequest) Header(key, value string) *AffinityGroupVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmServiceRemoveRequest) Query(key, value string) *AffinityGroupVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmServiceRemoveRequest) Async(async bool) *AffinityGroupVmServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AffinityGroupVmServiceRemoveRequest) Send() (*AffinityGroupVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmService.Connection.URL(), p.affinityGroupVmService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupVmService.Connection.username, p.affinityGroupVmService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityGroupVmServiceRemoveResponse), nil
}

type AffinityGroupVmServiceRemoveResponse struct {
}

func (p *AffinityGroupVmService) Remove() *AffinityGroupVmServiceRemoveRequest {
	return &AffinityGroupVmServiceRemoveRequest{affinityGroupVmService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupVmService) String() string {
	return fmt.Sprintf("AffinityGroupVmService:%s", op.Path)
}

//
// Manages a CDROM device of a virtual machine.
// Changing and ejecting the disk is done using always the `update` method, to change the value of the `file`
// attribute.
//
type VmCdromService struct {
	BaseService
}

func NewVmCdromService(connection *Connection, path string) *VmCdromService {
	var result VmCdromService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmCdromServiceGetRequest struct {
	vmCdromService *VmCdromService
	header         map[string]string
	query          map[string]string
	current        *bool
}

func (p *VmCdromServiceGetRequest) Header(key, value string) *VmCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromServiceGetRequest) Query(key, value string) *VmCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromServiceGetRequest) Current(current bool) *VmCdromServiceGetRequest {
	p.current = &current
	return p
}
func (p *VmCdromServiceGetRequest) Send() (*VmCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromService.Connection.URL(), p.vmCdromService.Path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmCdromService.Connection.username, p.vmCdromService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmCdromService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmCdromServiceGetResponse VmCdromServiceGetResponse
	var cdromVar Cdrom
	xml.Unmarshal(respBodyBytes, &cdromVar)
	vmCdromServiceGetResponse.cdrom = &cdromVar
	return &vmCdromServiceGetResponse, nil
}

type VmCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *VmCdromServiceGetResponse) Cdrom() *Cdrom {
	return p.cdrom
}
func (p *VmCdromService) Get() *VmCdromServiceGetRequest {
	return &VmCdromServiceGetRequest{vmCdromService: p}
}

type VmCdromServiceUpdateRequest struct {
	vmCdromService *VmCdromService
	header         map[string]string
	query          map[string]string
	cdrom          *Cdrom
	current        *bool
}

func (p *VmCdromServiceUpdateRequest) Header(key, value string) *VmCdromServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromServiceUpdateRequest) Query(key, value string) *VmCdromServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromServiceUpdateRequest) Cdrom(cdrom *Cdrom) *VmCdromServiceUpdateRequest {
	p.cdrom = cdrom
	return p
}
func (p *VmCdromServiceUpdateRequest) Current(current bool) *VmCdromServiceUpdateRequest {
	p.current = &current
	return p
}
func (p *VmCdromServiceUpdateRequest) Send() (*VmCdromServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromService.Connection.URL(), p.vmCdromService.Path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.cdrom)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmCdromService.Connection.username, p.vmCdromService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmCdromService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmCdromServiceUpdateResponse VmCdromServiceUpdateResponse
	var cdromVar Cdrom
	xml.Unmarshal(respBodyBytes, &cdromVar)
	vmCdromServiceUpdateResponse.cdrom = &cdromVar
	return &vmCdromServiceUpdateResponse, nil
}

type VmCdromServiceUpdateResponse struct {
	cdrom *Cdrom
}

func (p *VmCdromServiceUpdateResponse) Cdrom() *Cdrom {
	return p.cdrom
}
func (p *VmCdromService) Update() *VmCdromServiceUpdateRequest {
	return &VmCdromServiceUpdateRequest{vmCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmCdromService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmCdromService) String() string {
	return fmt.Sprintf("VmCdromService:%s", op.Path)
}

//
//
type QuotaClusterLimitService struct {
	BaseService
}

func NewQuotaClusterLimitService(connection *Connection, path string) *QuotaClusterLimitService {
	var result QuotaClusterLimitService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaClusterLimitServiceGetRequest struct {
	quotaClusterLimitService *QuotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
}

func (p *QuotaClusterLimitServiceGetRequest) Header(key, value string) *QuotaClusterLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitServiceGetRequest) Query(key, value string) *QuotaClusterLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitServiceGetRequest) Send() (*QuotaClusterLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitService.Connection.URL(), p.quotaClusterLimitService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaClusterLimitService.Connection.username, p.quotaClusterLimitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaClusterLimitServiceGetResponse QuotaClusterLimitServiceGetResponse
	var limitVar QuotaClusterLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaClusterLimitServiceGetResponse.limit = &limitVar
	return &quotaClusterLimitServiceGetResponse, nil
}

type QuotaClusterLimitServiceGetResponse struct {
	limit *QuotaClusterLimit
}

func (p *QuotaClusterLimitServiceGetResponse) Limit() *QuotaClusterLimit {
	return p.limit
}
func (p *QuotaClusterLimitService) Get() *QuotaClusterLimitServiceGetRequest {
	return &QuotaClusterLimitServiceGetRequest{quotaClusterLimitService: p}
}

type QuotaClusterLimitServiceRemoveRequest struct {
	quotaClusterLimitService *QuotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *QuotaClusterLimitServiceRemoveRequest) Header(key, value string) *QuotaClusterLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitServiceRemoveRequest) Query(key, value string) *QuotaClusterLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitServiceRemoveRequest) Async(async bool) *QuotaClusterLimitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QuotaClusterLimitServiceRemoveRequest) Send() (*QuotaClusterLimitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitService.Connection.URL(), p.quotaClusterLimitService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaClusterLimitService.Connection.username, p.quotaClusterLimitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QuotaClusterLimitServiceRemoveResponse), nil
}

type QuotaClusterLimitServiceRemoveResponse struct {
}

func (p *QuotaClusterLimitService) Remove() *QuotaClusterLimitServiceRemoveRequest {
	return &QuotaClusterLimitServiceRemoveRequest{quotaClusterLimitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaClusterLimitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaClusterLimitService) String() string {
	return fmt.Sprintf("QuotaClusterLimitService:%s", op.Path)
}

//
// This service manages the attachment of a disk to a virtual machine.
//
type DiskAttachmentService struct {
	BaseService
}

func NewDiskAttachmentService(connection *Connection, path string) *DiskAttachmentService {
	var result DiskAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskAttachmentServiceGetRequest struct {
	diskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
}

func (p *DiskAttachmentServiceGetRequest) Header(key, value string) *DiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceGetRequest) Query(key, value string) *DiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceGetRequest) Send() (*DiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.Connection.URL(), p.diskAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentService.Connection.username, p.diskAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskAttachmentServiceGetResponse DiskAttachmentServiceGetResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	diskAttachmentServiceGetResponse.attachment = &attachmentVar
	return &diskAttachmentServiceGetResponse, nil
}

type DiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentServiceGetResponse) Attachment() *DiskAttachment {
	return p.attachment
}
func (p *DiskAttachmentService) Get() *DiskAttachmentServiceGetRequest {
	return &DiskAttachmentServiceGetRequest{diskAttachmentService: p}
}

type DiskAttachmentServiceRemoveRequest struct {
	diskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
	detachOnly            *bool
}

func (p *DiskAttachmentServiceRemoveRequest) Header(key, value string) *DiskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceRemoveRequest) Query(key, value string) *DiskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceRemoveRequest) DetachOnly(detachOnly bool) *DiskAttachmentServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}
func (p *DiskAttachmentServiceRemoveRequest) Send() (*DiskAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.Connection.URL(), p.diskAttachmentService.Path)
	values := make(url.Values)
	if p.detachOnly != nil {
		values["detachOnly"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentService.Connection.username, p.diskAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskAttachmentServiceRemoveResponse), nil
}

type DiskAttachmentServiceRemoveResponse struct {
}

func (p *DiskAttachmentService) Remove() *DiskAttachmentServiceRemoveRequest {
	return &DiskAttachmentServiceRemoveRequest{diskAttachmentService: p}
}

type DiskAttachmentServiceUpdateRequest struct {
	diskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
	diskAttachment        *DiskAttachment
}

func (p *DiskAttachmentServiceUpdateRequest) Header(key, value string) *DiskAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceUpdateRequest) Query(key, value string) *DiskAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceUpdateRequest) DiskAttachment(diskAttachment *DiskAttachment) *DiskAttachmentServiceUpdateRequest {
	p.diskAttachment = diskAttachment
	return p
}
func (p *DiskAttachmentServiceUpdateRequest) Send() (*DiskAttachmentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.Connection.URL(), p.diskAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.diskAttachment)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentService.Connection.username, p.diskAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskAttachmentServiceUpdateResponse DiskAttachmentServiceUpdateResponse
	var diskAttachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &diskAttachmentVar)
	diskAttachmentServiceUpdateResponse.diskAttachment = &diskAttachmentVar
	return &diskAttachmentServiceUpdateResponse, nil
}

type DiskAttachmentServiceUpdateResponse struct {
	diskAttachment *DiskAttachment
}

func (p *DiskAttachmentServiceUpdateResponse) DiskAttachment() *DiskAttachment {
	return p.diskAttachment
}
func (p *DiskAttachmentService) Update() *DiskAttachmentServiceUpdateRequest {
	return &DiskAttachmentServiceUpdateRequest{diskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskAttachmentService) String() string {
	return fmt.Sprintf("DiskAttachmentService:%s", op.Path)
}

//
// A service to manage a bookmark.
//
type BookmarkService struct {
	BaseService
}

func NewBookmarkService(connection *Connection, path string) *BookmarkService {
	var result BookmarkService
	result.Connection = connection
	result.Path = path
	return &result
}

type BookmarkServiceGetRequest struct {
	bookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
}

func (p *BookmarkServiceGetRequest) Header(key, value string) *BookmarkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceGetRequest) Query(key, value string) *BookmarkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceGetRequest) Send() (*BookmarkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.Connection.URL(), p.bookmarkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarkService.Connection.username, p.bookmarkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var bookmarkServiceGetResponse BookmarkServiceGetResponse
	var bookmarkVar Bookmark
	xml.Unmarshal(respBodyBytes, &bookmarkVar)
	bookmarkServiceGetResponse.bookmark = &bookmarkVar
	return &bookmarkServiceGetResponse, nil
}

type BookmarkServiceGetResponse struct {
	bookmark *Bookmark
}

func (p *BookmarkServiceGetResponse) Bookmark() *Bookmark {
	return p.bookmark
}
func (p *BookmarkService) Get() *BookmarkServiceGetRequest {
	return &BookmarkServiceGetRequest{bookmarkService: p}
}

type BookmarkServiceRemoveRequest struct {
	bookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *BookmarkServiceRemoveRequest) Header(key, value string) *BookmarkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceRemoveRequest) Query(key, value string) *BookmarkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceRemoveRequest) Async(async bool) *BookmarkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *BookmarkServiceRemoveRequest) Send() (*BookmarkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.Connection.URL(), p.bookmarkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarkService.Connection.username, p.bookmarkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(BookmarkServiceRemoveResponse), nil
}

type BookmarkServiceRemoveResponse struct {
}

func (p *BookmarkService) Remove() *BookmarkServiceRemoveRequest {
	return &BookmarkServiceRemoveRequest{bookmarkService: p}
}

type BookmarkServiceUpdateRequest struct {
	bookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
	bookmark        *Bookmark
}

func (p *BookmarkServiceUpdateRequest) Header(key, value string) *BookmarkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceUpdateRequest) Query(key, value string) *BookmarkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceUpdateRequest) Async(async bool) *BookmarkServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *BookmarkServiceUpdateRequest) Bookmark(bookmark *Bookmark) *BookmarkServiceUpdateRequest {
	p.bookmark = bookmark
	return p
}
func (p *BookmarkServiceUpdateRequest) Send() (*BookmarkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.Connection.URL(), p.bookmarkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bookmark)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarkService.Connection.username, p.bookmarkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var bookmarkServiceUpdateResponse BookmarkServiceUpdateResponse
	var bookmarkVar Bookmark
	xml.Unmarshal(respBodyBytes, &bookmarkVar)
	bookmarkServiceUpdateResponse.bookmark = &bookmarkVar
	return &bookmarkServiceUpdateResponse, nil
}

type BookmarkServiceUpdateResponse struct {
	bookmark *Bookmark
}

func (p *BookmarkServiceUpdateResponse) Bookmark() *Bookmark {
	return p.bookmark
}
func (p *BookmarkService) Update() *BookmarkServiceUpdateRequest {
	return &BookmarkServiceUpdateRequest{bookmarkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BookmarkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *BookmarkService) String() string {
	return fmt.Sprintf("BookmarkService:%s", op.Path)
}

//
//
type InstanceTypeNicService struct {
	BaseService
}

func NewInstanceTypeNicService(connection *Connection, path string) *InstanceTypeNicService {
	var result InstanceTypeNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeNicServiceGetRequest struct {
	instanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
}

func (p *InstanceTypeNicServiceGetRequest) Header(key, value string) *InstanceTypeNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceGetRequest) Query(key, value string) *InstanceTypeNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceGetRequest) Send() (*InstanceTypeNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.Connection.URL(), p.instanceTypeNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicService.Connection.username, p.instanceTypeNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeNicServiceGetResponse InstanceTypeNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	instanceTypeNicServiceGetResponse.nic = &nicVar
	return &instanceTypeNicServiceGetResponse, nil
}

type InstanceTypeNicServiceGetResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicServiceGetResponse) Nic() *Nic {
	return p.nic
}
func (p *InstanceTypeNicService) Get() *InstanceTypeNicServiceGetRequest {
	return &InstanceTypeNicServiceGetRequest{instanceTypeNicService: p}
}

type InstanceTypeNicServiceRemoveRequest struct {
	instanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *InstanceTypeNicServiceRemoveRequest) Header(key, value string) *InstanceTypeNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceRemoveRequest) Query(key, value string) *InstanceTypeNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceRemoveRequest) Async(async bool) *InstanceTypeNicServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeNicServiceRemoveRequest) Send() (*InstanceTypeNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.Connection.URL(), p.instanceTypeNicService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicService.Connection.username, p.instanceTypeNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeNicServiceRemoveResponse), nil
}

type InstanceTypeNicServiceRemoveResponse struct {
}

func (p *InstanceTypeNicService) Remove() *InstanceTypeNicServiceRemoveRequest {
	return &InstanceTypeNicServiceRemoveRequest{instanceTypeNicService: p}
}

type InstanceTypeNicServiceUpdateRequest struct {
	instanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	nic                    *Nic
}

func (p *InstanceTypeNicServiceUpdateRequest) Header(key, value string) *InstanceTypeNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Query(key, value string) *InstanceTypeNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Async(async bool) *InstanceTypeNicServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeNicServiceUpdateRequest) Nic(nic *Nic) *InstanceTypeNicServiceUpdateRequest {
	p.nic = nic
	return p
}
func (p *InstanceTypeNicServiceUpdateRequest) Send() (*InstanceTypeNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.Connection.URL(), p.instanceTypeNicService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicService.Connection.username, p.instanceTypeNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeNicServiceUpdateResponse InstanceTypeNicServiceUpdateResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	instanceTypeNicServiceUpdateResponse.nic = &nicVar
	return &instanceTypeNicServiceUpdateResponse, nil
}

type InstanceTypeNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicServiceUpdateResponse) Nic() *Nic {
	return p.nic
}
func (p *InstanceTypeNicService) Update() *InstanceTypeNicServiceUpdateRequest {
	return &InstanceTypeNicServiceUpdateRequest{instanceTypeNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeNicService) String() string {
	return fmt.Sprintf("InstanceTypeNicService:%s", op.Path)
}

//
//
type AssignedDiskProfileService struct {
	BaseService
}

func NewAssignedDiskProfileService(connection *Connection, path string) *AssignedDiskProfileService {
	var result AssignedDiskProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedDiskProfileServiceGetRequest struct {
	assignedDiskProfileService *AssignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
}

func (p *AssignedDiskProfileServiceGetRequest) Header(key, value string) *AssignedDiskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfileServiceGetRequest) Query(key, value string) *AssignedDiskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfileServiceGetRequest) Send() (*AssignedDiskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfileService.Connection.URL(), p.assignedDiskProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedDiskProfileService.Connection.username, p.assignedDiskProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedDiskProfileServiceGetResponse AssignedDiskProfileServiceGetResponse
	var diskProfileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &diskProfileVar)
	assignedDiskProfileServiceGetResponse.diskProfile = &diskProfileVar
	return &assignedDiskProfileServiceGetResponse, nil
}

type AssignedDiskProfileServiceGetResponse struct {
	diskProfile *DiskProfile
}

func (p *AssignedDiskProfileServiceGetResponse) DiskProfile() *DiskProfile {
	return p.diskProfile
}
func (p *AssignedDiskProfileService) Get() *AssignedDiskProfileServiceGetRequest {
	return &AssignedDiskProfileServiceGetRequest{assignedDiskProfileService: p}
}

type AssignedDiskProfileServiceRemoveRequest struct {
	assignedDiskProfileService *AssignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *AssignedDiskProfileServiceRemoveRequest) Header(key, value string) *AssignedDiskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfileServiceRemoveRequest) Query(key, value string) *AssignedDiskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfileServiceRemoveRequest) Async(async bool) *AssignedDiskProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedDiskProfileServiceRemoveRequest) Send() (*AssignedDiskProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfileService.Connection.URL(), p.assignedDiskProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedDiskProfileService.Connection.username, p.assignedDiskProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedDiskProfileServiceRemoveResponse), nil
}

type AssignedDiskProfileServiceRemoveResponse struct {
}

func (p *AssignedDiskProfileService) Remove() *AssignedDiskProfileServiceRemoveRequest {
	return &AssignedDiskProfileServiceRemoveRequest{assignedDiskProfileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedDiskProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedDiskProfileService) String() string {
	return fmt.Sprintf("AssignedDiskProfileService:%s", op.Path)
}

//
//
type NetworkLabelsService struct {
	BaseService
}

func NewNetworkLabelsService(connection *Connection, path string) *NetworkLabelsService {
	var result NetworkLabelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkLabelsServiceAddRequest struct {
	networkLabelsService *NetworkLabelsService
	header               map[string]string
	query                map[string]string
	label                *NetworkLabel
}

func (p *NetworkLabelsServiceAddRequest) Header(key, value string) *NetworkLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelsServiceAddRequest) Query(key, value string) *NetworkLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelsServiceAddRequest) Label(label *NetworkLabel) *NetworkLabelsServiceAddRequest {
	p.label = label
	return p
}
func (p *NetworkLabelsServiceAddRequest) Send() (*NetworkLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.Connection.URL(), p.networkLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.label)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkLabelsService.Connection.username, p.networkLabelsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkLabelsServiceAddResponse NetworkLabelsServiceAddResponse
	var labelVar NetworkLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	networkLabelsServiceAddResponse.label = &labelVar
	return &networkLabelsServiceAddResponse, nil
}

type NetworkLabelsServiceAddResponse struct {
	label *NetworkLabel
}

func (p *NetworkLabelsServiceAddResponse) Label() *NetworkLabel {
	return p.label
}
func (p *NetworkLabelsService) Add() *NetworkLabelsServiceAddRequest {
	return &NetworkLabelsServiceAddRequest{networkLabelsService: p}
}

type NetworkLabelsServiceListRequest struct {
	networkLabelsService *NetworkLabelsService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *NetworkLabelsServiceListRequest) Header(key, value string) *NetworkLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelsServiceListRequest) Query(key, value string) *NetworkLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelsServiceListRequest) Max(max int64) *NetworkLabelsServiceListRequest {
	p.max = &max
	return p
}
func (p *NetworkLabelsServiceListRequest) Send() (*NetworkLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.Connection.URL(), p.networkLabelsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkLabelsService.Connection.username, p.networkLabelsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkLabelsServiceListResponse NetworkLabelsServiceListResponse
	var labelsVar NetworkLabels
	xml.Unmarshal(respBodyBytes, &labelsVar)
	networkLabelsServiceListResponse.labels = labelsVar.NetworkLabels
	return &networkLabelsServiceListResponse, nil
}

type NetworkLabelsServiceListResponse struct {
	labels []NetworkLabel
}

func (p *NetworkLabelsServiceListResponse) Labels() []NetworkLabel {
	return p.labels
}
func (p *NetworkLabelsService) List() *NetworkLabelsServiceListRequest {
	return &NetworkLabelsServiceListRequest{networkLabelsService: p}
}

//
//
func (op *NetworkLabelsService) LabelService(id string) *NetworkLabelService {
	return NewNetworkLabelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkLabelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LabelService(path)), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *NetworkLabelsService) String() string {
	return fmt.Sprintf("NetworkLabelsService:%s", op.Path)
}

//
//
type StorageDomainService struct {
	BaseService
}

func NewStorageDomainService(connection *Connection, path string) *StorageDomainService {
	var result StorageDomainService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainServiceGetRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	filter               *bool
}

func (p *StorageDomainServiceGetRequest) Header(key, value string) *StorageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceGetRequest) Query(key, value string) *StorageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceGetRequest) Filter(filter bool) *StorageDomainServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainServiceGetRequest) Send() (*StorageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainServiceGetResponse StorageDomainServiceGetResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	storageDomainServiceGetResponse.storageDomain = &storageDomainVar
	return &storageDomainServiceGetResponse, nil
}

type StorageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainServiceGetResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}
func (p *StorageDomainService) Get() *StorageDomainServiceGetRequest {
	return &StorageDomainServiceGetRequest{storageDomainService: p}
}

type StorageDomainServiceIsAttachedRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	host                 *Host
}

func (p *StorageDomainServiceIsAttachedRequest) Header(key, value string) *StorageDomainServiceIsAttachedRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Query(key, value string) *StorageDomainServiceIsAttachedRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Async(async bool) *StorageDomainServiceIsAttachedRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceIsAttachedRequest) Host(host *Host) *StorageDomainServiceIsAttachedRequest {
	p.host = host
	return p
}
func (p *StorageDomainServiceIsAttachedRequest) Send() (*StorageDomainServiceIsAttachedResponse, error) {
	rawURL := fmt.Sprintf("%s%s/isattached", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Host(p.host)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &StorageDomainServiceIsAttachedResponse{isAttached: *action.IsAttached}, nil
}

type StorageDomainServiceIsAttachedResponse struct {
	isAttached bool
}

func (p *StorageDomainServiceIsAttachedResponse) IsAttached() bool {
	return p.isAttached
}
func (p *StorageDomainService) IsAttached() *StorageDomainServiceIsAttachedRequest {
	return &StorageDomainServiceIsAttachedRequest{storageDomainService: p}
}

type StorageDomainServiceReduceLunsRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	logicalUnits         []LogicalUnit
}

func (p *StorageDomainServiceReduceLunsRequest) Header(key, value string) *StorageDomainServiceReduceLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) Query(key, value string) *StorageDomainServiceReduceLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) LogicalUnits(logicalUnits []LogicalUnit) *StorageDomainServiceReduceLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}
func (p *StorageDomainServiceReduceLunsRequest) Send() (*StorageDomainServiceReduceLunsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reduceluns", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainServiceReduceLunsResponse), nil
}

type StorageDomainServiceReduceLunsResponse struct {
}

func (p *StorageDomainService) ReduceLuns() *StorageDomainServiceReduceLunsRequest {
	return &StorageDomainServiceReduceLunsRequest{storageDomainService: p}
}

type StorageDomainServiceRefreshLunsRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	logicalUnits         []LogicalUnit
}

func (p *StorageDomainServiceRefreshLunsRequest) Header(key, value string) *StorageDomainServiceRefreshLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) Query(key, value string) *StorageDomainServiceRefreshLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) Async(async bool) *StorageDomainServiceRefreshLunsRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceRefreshLunsRequest) LogicalUnits(logicalUnits []LogicalUnit) *StorageDomainServiceRefreshLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}
func (p *StorageDomainServiceRefreshLunsRequest) Send() (*StorageDomainServiceRefreshLunsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refreshluns", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainServiceRefreshLunsResponse), nil
}

type StorageDomainServiceRefreshLunsResponse struct {
}

func (p *StorageDomainService) RefreshLuns() *StorageDomainServiceRefreshLunsRequest {
	return &StorageDomainServiceRefreshLunsRequest{storageDomainService: p}
}

type StorageDomainServiceRemoveRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	destroy              *bool
	format               *bool
	host                 *string
}

func (p *StorageDomainServiceRemoveRequest) Header(key, value string) *StorageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceRemoveRequest) Query(key, value string) *StorageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceRemoveRequest) Async(async bool) *StorageDomainServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceRemoveRequest) Destroy(destroy bool) *StorageDomainServiceRemoveRequest {
	p.destroy = &destroy
	return p
}
func (p *StorageDomainServiceRemoveRequest) Format(format bool) *StorageDomainServiceRemoveRequest {
	p.format = &format
	return p
}
func (p *StorageDomainServiceRemoveRequest) Host(host string) *StorageDomainServiceRemoveRequest {
	p.host = &host
	return p
}
func (p *StorageDomainServiceRemoveRequest) Send() (*StorageDomainServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.destroy != nil {
		values["destroy"] = []string{fmt.Sprintf("%v", *p.destroy)}
	}
	if p.format != nil {
		values["format"] = []string{fmt.Sprintf("%v", *p.format)}
	}
	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainServiceRemoveResponse), nil
}

type StorageDomainServiceRemoveResponse struct {
}

func (p *StorageDomainService) Remove() *StorageDomainServiceRemoveRequest {
	return &StorageDomainServiceRemoveRequest{storageDomainService: p}
}

type StorageDomainServiceUpdateRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	storageDomain        *StorageDomain
}

func (p *StorageDomainServiceUpdateRequest) Header(key, value string) *StorageDomainServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceUpdateRequest) Query(key, value string) *StorageDomainServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceUpdateRequest) Async(async bool) *StorageDomainServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceUpdateRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainServiceUpdateRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainServiceUpdateRequest) Send() (*StorageDomainServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.storageDomain)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainServiceUpdateResponse StorageDomainServiceUpdateResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	storageDomainServiceUpdateResponse.storageDomain = &storageDomainVar
	return &storageDomainServiceUpdateResponse, nil
}

type StorageDomainServiceUpdateResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainServiceUpdateResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}
func (p *StorageDomainService) Update() *StorageDomainServiceUpdateRequest {
	return &StorageDomainServiceUpdateRequest{storageDomainService: p}
}

type StorageDomainServiceUpdateOvfStoreRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Header(key, value string) *StorageDomainServiceUpdateOvfStoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Query(key, value string) *StorageDomainServiceUpdateOvfStoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Async(async bool) *StorageDomainServiceUpdateOvfStoreRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceUpdateOvfStoreRequest) Send() (*StorageDomainServiceUpdateOvfStoreResponse, error) {
	rawURL := fmt.Sprintf("%s%s/updateovfstore", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainServiceUpdateOvfStoreResponse), nil
}

type StorageDomainServiceUpdateOvfStoreResponse struct {
}

func (p *StorageDomainService) UpdateOvfStore() *StorageDomainServiceUpdateOvfStoreRequest {
	return &StorageDomainServiceUpdateOvfStoreRequest{storageDomainService: p}
}

//
//
func (op *StorageDomainService) DiskProfilesService() *AssignedDiskProfilesService {
	return NewAssignedDiskProfilesService(op.Connection, fmt.Sprintf("%s/diskprofiles", op.Path))
}

//
//
func (op *StorageDomainService) DiskSnapshotsService() *DiskSnapshotsService {
	return NewDiskSnapshotsService(op.Connection, fmt.Sprintf("%s/disksnapshots", op.Path))
}

//
// Reference to the service that manages the disks available in the storage domain.
//
func (op *StorageDomainService) DisksService() *StorageDomainDisksService {
	return NewStorageDomainDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Returns a reference to the service that manages the files available in the storage domain.
//
func (op *StorageDomainService) FilesService() *FilesService {
	return NewFilesService(op.Connection, fmt.Sprintf("%s/files", op.Path))
}

//
//
func (op *StorageDomainService) ImagesService() *ImagesService {
	return NewImagesService(op.Connection, fmt.Sprintf("%s/images", op.Path))
}

//
//
func (op *StorageDomainService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Returns a reference to the service that manages the storage connections.
//
func (op *StorageDomainService) StorageConnectionsService() *StorageDomainServerConnectionsService {
	return NewStorageDomainServerConnectionsService(op.Connection, fmt.Sprintf("%s/storageconnections", op.Path))
}

//
//
func (op *StorageDomainService) TemplatesService() *StorageDomainTemplatesService {
	return NewStorageDomainTemplatesService(op.Connection, fmt.Sprintf("%s/templates", op.Path))
}

//
//
func (op *StorageDomainService) VmsService() *StorageDomainVmsService {
	return NewStorageDomainVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disksnapshots" {
		return op.DiskSnapshotsService(), nil
	}
	if strings.HasPrefix(path, "disksnapshots/") {
		return op.DiskSnapshotsService().Service(path[14:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "files" {
		return op.FilesService(), nil
	}
	if strings.HasPrefix(path, "files/") {
		return op.FilesService().Service(path[6:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainService) String() string {
	return fmt.Sprintf("StorageDomainService:%s", op.Path)
}

//
// A service to manage data centers.
//
type DataCentersService struct {
	BaseService
}

func NewDataCentersService(connection *Connection, path string) *DataCentersService {
	var result DataCentersService
	result.Connection = connection
	result.Path = path
	return &result
}

type DataCentersServiceAddRequest struct {
	dataCentersService *DataCentersService
	header             map[string]string
	query              map[string]string
	dataCenter         *DataCenter
}

func (p *DataCentersServiceAddRequest) Header(key, value string) *DataCentersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCentersServiceAddRequest) Query(key, value string) *DataCentersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCentersServiceAddRequest) DataCenter(dataCenter *DataCenter) *DataCentersServiceAddRequest {
	p.dataCenter = dataCenter
	return p
}
func (p *DataCentersServiceAddRequest) Send() (*DataCentersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.Connection.URL(), p.dataCentersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.dataCenter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCentersService.Connection.username, p.dataCentersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCentersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var dataCentersServiceAddResponse DataCentersServiceAddResponse
	var dataCenterVar DataCenter
	xml.Unmarshal(respBodyBytes, &dataCenterVar)
	dataCentersServiceAddResponse.dataCenter = &dataCenterVar
	return &dataCentersServiceAddResponse, nil
}

type DataCentersServiceAddResponse struct {
	dataCenter *DataCenter
}

func (p *DataCentersServiceAddResponse) DataCenter() *DataCenter {
	return p.dataCenter
}
func (p *DataCentersService) Add() *DataCentersServiceAddRequest {
	return &DataCentersServiceAddRequest{dataCentersService: p}
}

type DataCentersServiceListRequest struct {
	dataCentersService *DataCentersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	filter             *bool
	max                *int64
	search             *string
}

func (p *DataCentersServiceListRequest) Header(key, value string) *DataCentersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCentersServiceListRequest) Query(key, value string) *DataCentersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCentersServiceListRequest) CaseSensitive(caseSensitive bool) *DataCentersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DataCentersServiceListRequest) Filter(filter bool) *DataCentersServiceListRequest {
	p.filter = &filter
	return p
}
func (p *DataCentersServiceListRequest) Max(max int64) *DataCentersServiceListRequest {
	p.max = &max
	return p
}
func (p *DataCentersServiceListRequest) Search(search string) *DataCentersServiceListRequest {
	p.search = &search
	return p
}
func (p *DataCentersServiceListRequest) Send() (*DataCentersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.Connection.URL(), p.dataCentersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCentersService.Connection.username, p.dataCentersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCentersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var dataCentersServiceListResponse DataCentersServiceListResponse
	var dataCentersVar DataCenters
	xml.Unmarshal(respBodyBytes, &dataCentersVar)
	dataCentersServiceListResponse.dataCenters = dataCentersVar.DataCenters
	return &dataCentersServiceListResponse, nil
}

type DataCentersServiceListResponse struct {
	dataCenters []DataCenter
}

func (p *DataCentersServiceListResponse) DataCenters() []DataCenter {
	return p.dataCenters
}
func (p *DataCentersService) List() *DataCentersServiceListRequest {
	return &DataCentersServiceListRequest{dataCentersService: p}
}

//
// Reference to the service that manages a specific data center.
//
func (op *DataCentersService) DataCenterService(id string) *DataCenterService {
	return NewDataCenterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCentersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DataCenterService(path)), nil
	}
	return op.DataCenterService(path[:index]).Service(path[index+1:])
}

func (op *DataCentersService) String() string {
	return fmt.Sprintf("DataCentersService:%s", op.Path)
}

//
// A service that provides information about an application installed in a virtual machine.
//
type VmApplicationService struct {
	BaseService
}

func NewVmApplicationService(connection *Connection, path string) *VmApplicationService {
	var result VmApplicationService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmApplicationServiceGetRequest struct {
	vmApplicationService *VmApplicationService
	header               map[string]string
	query                map[string]string
	filter               *bool
}

func (p *VmApplicationServiceGetRequest) Header(key, value string) *VmApplicationServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmApplicationServiceGetRequest) Query(key, value string) *VmApplicationServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmApplicationServiceGetRequest) Filter(filter bool) *VmApplicationServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *VmApplicationServiceGetRequest) Send() (*VmApplicationServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationService.Connection.URL(), p.vmApplicationService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmApplicationService.Connection.username, p.vmApplicationService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmApplicationService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmApplicationServiceGetResponse VmApplicationServiceGetResponse
	var applicationVar Application
	xml.Unmarshal(respBodyBytes, &applicationVar)
	vmApplicationServiceGetResponse.application = &applicationVar
	return &vmApplicationServiceGetResponse, nil
}

type VmApplicationServiceGetResponse struct {
	application *Application
}

func (p *VmApplicationServiceGetResponse) Application() *Application {
	return p.application
}
func (p *VmApplicationService) Get() *VmApplicationServiceGetRequest {
	return &VmApplicationServiceGetRequest{vmApplicationService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmApplicationService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmApplicationService) String() string {
	return fmt.Sprintf("VmApplicationService:%s", op.Path)
}

//
//
type QuotaStorageLimitsService struct {
	BaseService
}

func NewQuotaStorageLimitsService(connection *Connection, path string) *QuotaStorageLimitsService {
	var result QuotaStorageLimitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaStorageLimitsServiceAddRequest struct {
	quotaStorageLimitsService *QuotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceAddRequest) Header(key, value string) *QuotaStorageLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceAddRequest) Query(key, value string) *QuotaStorageLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceAddRequest) Limit(limit *QuotaStorageLimit) *QuotaStorageLimitsServiceAddRequest {
	p.limit = limit
	return p
}
func (p *QuotaStorageLimitsServiceAddRequest) Send() (*QuotaStorageLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.Connection.URL(), p.quotaStorageLimitsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.limit)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaStorageLimitsService.Connection.username, p.quotaStorageLimitsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaStorageLimitsServiceAddResponse QuotaStorageLimitsServiceAddResponse
	var limitVar QuotaStorageLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaStorageLimitsServiceAddResponse.limit = &limitVar
	return &quotaStorageLimitsServiceAddResponse, nil
}

type QuotaStorageLimitsServiceAddResponse struct {
	limit *QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceAddResponse) Limit() *QuotaStorageLimit {
	return p.limit
}
func (p *QuotaStorageLimitsService) Add() *QuotaStorageLimitsServiceAddRequest {
	return &QuotaStorageLimitsServiceAddRequest{quotaStorageLimitsService: p}
}

type QuotaStorageLimitsServiceListRequest struct {
	quotaStorageLimitsService *QuotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *QuotaStorageLimitsServiceListRequest) Header(key, value string) *QuotaStorageLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Query(key, value string) *QuotaStorageLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Max(max int64) *QuotaStorageLimitsServiceListRequest {
	p.max = &max
	return p
}
func (p *QuotaStorageLimitsServiceListRequest) Send() (*QuotaStorageLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.Connection.URL(), p.quotaStorageLimitsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaStorageLimitsService.Connection.username, p.quotaStorageLimitsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaStorageLimitsServiceListResponse QuotaStorageLimitsServiceListResponse
	var limitsVar QuotaStorageLimits
	xml.Unmarshal(respBodyBytes, &limitsVar)
	quotaStorageLimitsServiceListResponse.limits = limitsVar.QuotaStorageLimits
	return &quotaStorageLimitsServiceListResponse, nil
}

type QuotaStorageLimitsServiceListResponse struct {
	limits []QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceListResponse) Limits() []QuotaStorageLimit {
	return p.limits
}
func (p *QuotaStorageLimitsService) List() *QuotaStorageLimitsServiceListRequest {
	return &QuotaStorageLimitsServiceListRequest{quotaStorageLimitsService: p}
}

//
//
func (op *QuotaStorageLimitsService) LimitService(id string) *QuotaStorageLimitService {
	return NewQuotaStorageLimitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaStorageLimitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LimitService(path)), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *QuotaStorageLimitsService) String() string {
	return fmt.Sprintf("QuotaStorageLimitsService:%s", op.Path)
}

//
//
type TemplateNicService struct {
	BaseService
}

func NewTemplateNicService(connection *Connection, path string) *TemplateNicService {
	var result TemplateNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateNicServiceGetRequest struct {
	templateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
}

func (p *TemplateNicServiceGetRequest) Header(key, value string) *TemplateNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceGetRequest) Query(key, value string) *TemplateNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceGetRequest) Send() (*TemplateNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.Connection.URL(), p.templateNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicService.Connection.username, p.templateNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateNicServiceGetResponse TemplateNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	templateNicServiceGetResponse.nic = &nicVar
	return &templateNicServiceGetResponse, nil
}

type TemplateNicServiceGetResponse struct {
	nic *Nic
}

func (p *TemplateNicServiceGetResponse) Nic() *Nic {
	return p.nic
}
func (p *TemplateNicService) Get() *TemplateNicServiceGetRequest {
	return &TemplateNicServiceGetRequest{templateNicService: p}
}

type TemplateNicServiceRemoveRequest struct {
	templateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *TemplateNicServiceRemoveRequest) Header(key, value string) *TemplateNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceRemoveRequest) Query(key, value string) *TemplateNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceRemoveRequest) Async(async bool) *TemplateNicServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateNicServiceRemoveRequest) Send() (*TemplateNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.Connection.URL(), p.templateNicService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicService.Connection.username, p.templateNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateNicServiceRemoveResponse), nil
}

type TemplateNicServiceRemoveResponse struct {
}

func (p *TemplateNicService) Remove() *TemplateNicServiceRemoveRequest {
	return &TemplateNicServiceRemoveRequest{templateNicService: p}
}

type TemplateNicServiceUpdateRequest struct {
	templateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
	nic                *Nic
}

func (p *TemplateNicServiceUpdateRequest) Header(key, value string) *TemplateNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceUpdateRequest) Query(key, value string) *TemplateNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceUpdateRequest) Async(async bool) *TemplateNicServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TemplateNicServiceUpdateRequest) Nic(nic *Nic) *TemplateNicServiceUpdateRequest {
	p.nic = nic
	return p
}
func (p *TemplateNicServiceUpdateRequest) Send() (*TemplateNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.Connection.URL(), p.templateNicService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicService.Connection.username, p.templateNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateNicServiceUpdateResponse TemplateNicServiceUpdateResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	templateNicServiceUpdateResponse.nic = &nicVar
	return &templateNicServiceUpdateResponse, nil
}

type TemplateNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *TemplateNicServiceUpdateResponse) Nic() *Nic {
	return p.nic
}
func (p *TemplateNicService) Update() *TemplateNicServiceUpdateRequest {
	return &TemplateNicServiceUpdateRequest{templateNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateNicService) String() string {
	return fmt.Sprintf("TemplateNicService:%s", op.Path)
}

//
// Manages the CDROM devices of a virtual machine.
// Currently virtual machines have exactly one CDROM device. No new devices can be added, and the existing one can't
// be removed, thus there are no `add` or `remove` methods. Changing and ejecting CDROM disks is done with the
// <<services/vm_cdrom/methods/update, update>> method of the <<services/vm_cdrom, service>> that manages the
// CDROM device.
//
type VmCdromsService struct {
	BaseService
}

func NewVmCdromsService(connection *Connection, path string) *VmCdromsService {
	var result VmCdromsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmCdromsServiceListRequest struct {
	vmCdromsService *VmCdromsService
	header          map[string]string
	query           map[string]string
	max             *int64
}

func (p *VmCdromsServiceListRequest) Header(key, value string) *VmCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromsServiceListRequest) Query(key, value string) *VmCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromsServiceListRequest) Max(max int64) *VmCdromsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmCdromsServiceListRequest) Send() (*VmCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromsService.Connection.URL(), p.vmCdromsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmCdromsService.Connection.username, p.vmCdromsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmCdromsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmCdromsServiceListResponse VmCdromsServiceListResponse
	var cdromsVar Cdroms
	xml.Unmarshal(respBodyBytes, &cdromsVar)
	vmCdromsServiceListResponse.cdroms = cdromsVar.Cdroms
	return &vmCdromsServiceListResponse, nil
}

type VmCdromsServiceListResponse struct {
	cdroms []Cdrom
}

func (p *VmCdromsServiceListResponse) Cdroms() []Cdrom {
	return p.cdroms
}
func (p *VmCdromsService) List() *VmCdromsServiceListRequest {
	return &VmCdromsServiceListRequest{vmCdromsService: p}
}

//
// Returns a reference to the service that manages a specific CDROM device.
//
func (op *VmCdromsService) CdromService(id string) *VmCdromService {
	return NewVmCdromService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmCdromsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CdromService(path)), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *VmCdromsService) String() string {
	return fmt.Sprintf("VmCdromsService:%s", op.Path)
}

//
// Provides information about virtual machine user sessions.
//
type VmSessionsService struct {
	BaseService
}

func NewVmSessionsService(connection *Connection, path string) *VmSessionsService {
	var result VmSessionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmSessionsServiceListRequest struct {
	vmSessionsService *VmSessionsService
	header            map[string]string
	query             map[string]string
	max               *int64
}

func (p *VmSessionsServiceListRequest) Header(key, value string) *VmSessionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmSessionsServiceListRequest) Query(key, value string) *VmSessionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmSessionsServiceListRequest) Max(max int64) *VmSessionsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmSessionsServiceListRequest) Send() (*VmSessionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionsService.Connection.URL(), p.vmSessionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmSessionsService.Connection.username, p.vmSessionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmSessionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmSessionsServiceListResponse VmSessionsServiceListResponse
	var sessionsVar Sessions
	xml.Unmarshal(respBodyBytes, &sessionsVar)
	vmSessionsServiceListResponse.sessions = sessionsVar.Sessions
	return &vmSessionsServiceListResponse, nil
}

type VmSessionsServiceListResponse struct {
	sessions []Session
}

func (p *VmSessionsServiceListResponse) Sessions() []Session {
	return p.sessions
}
func (p *VmSessionsService) List() *VmSessionsServiceListRequest {
	return &VmSessionsServiceListRequest{vmSessionsService: p}
}

//
// Reference to the service that manages a specific session.
//
func (op *VmSessionsService) SessionService(id string) *VmSessionService {
	return NewVmSessionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmSessionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SessionService(path)), nil
	}
	return op.SessionService(path[:index]).Service(path[index+1:])
}

func (op *VmSessionsService) String() string {
	return fmt.Sprintf("VmSessionsService:%s", op.Path)
}

//
//
type VmDiskService struct {
	BaseService
}

func NewVmDiskService(connection *Connection, path string) *VmDiskService {
	var result VmDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmDiskServiceActivateRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceActivateRequest) Header(key, value string) *VmDiskServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceActivateRequest) Query(key, value string) *VmDiskServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceActivateRequest) Async(async bool) *VmDiskServiceActivateRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceActivateRequest) Send() (*VmDiskServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceActivateResponse), nil
}

type VmDiskServiceActivateResponse struct {
}

func (p *VmDiskService) Activate() *VmDiskServiceActivateRequest {
	return &VmDiskServiceActivateRequest{vmDiskService: p}
}

type VmDiskServiceDeactivateRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceDeactivateRequest) Header(key, value string) *VmDiskServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceDeactivateRequest) Query(key, value string) *VmDiskServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceDeactivateRequest) Async(async bool) *VmDiskServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceDeactivateRequest) Send() (*VmDiskServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceDeactivateResponse), nil
}

type VmDiskServiceDeactivateResponse struct {
}

func (p *VmDiskService) Deactivate() *VmDiskServiceDeactivateRequest {
	return &VmDiskServiceDeactivateRequest{vmDiskService: p}
}

type VmDiskServiceExportRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *VmDiskServiceExportRequest) Header(key, value string) *VmDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceExportRequest) Query(key, value string) *VmDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceExportRequest) Async(async bool) *VmDiskServiceExportRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceExportRequest) Filter(filter bool) *VmDiskServiceExportRequest {
	p.filter = &filter
	return p
}
func (p *VmDiskServiceExportRequest) Send() (*VmDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceExportResponse), nil
}

type VmDiskServiceExportResponse struct {
}

func (p *VmDiskService) Export() *VmDiskServiceExportRequest {
	return &VmDiskServiceExportRequest{vmDiskService: p}
}

type VmDiskServiceGetRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
}

func (p *VmDiskServiceGetRequest) Header(key, value string) *VmDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceGetRequest) Query(key, value string) *VmDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceGetRequest) Send() (*VmDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmDiskServiceGetResponse VmDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	vmDiskServiceGetResponse.disk = &diskVar
	return &vmDiskServiceGetResponse, nil
}

type VmDiskServiceGetResponse struct {
	disk *Disk
}

func (p *VmDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}
func (p *VmDiskService) Get() *VmDiskServiceGetRequest {
	return &VmDiskServiceGetRequest{vmDiskService: p}
}

type VmDiskServiceMoveRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *VmDiskServiceMoveRequest) Header(key, value string) *VmDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceMoveRequest) Query(key, value string) *VmDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceMoveRequest) Async(async bool) *VmDiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceMoveRequest) Filter(filter bool) *VmDiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *VmDiskServiceMoveRequest) Send() (*VmDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceMoveResponse), nil
}

type VmDiskServiceMoveResponse struct {
}

func (p *VmDiskService) Move() *VmDiskServiceMoveRequest {
	return &VmDiskServiceMoveRequest{vmDiskService: p}
}

type VmDiskServiceRemoveRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceRemoveRequest) Header(key, value string) *VmDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceRemoveRequest) Query(key, value string) *VmDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceRemoveRequest) Async(async bool) *VmDiskServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceRemoveRequest) Send() (*VmDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmDiskServiceRemoveResponse), nil
}

type VmDiskServiceRemoveResponse struct {
}

func (p *VmDiskService) Remove() *VmDiskServiceRemoveRequest {
	return &VmDiskServiceRemoveRequest{vmDiskService: p}
}

type VmDiskServiceUpdateRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
}

func (p *VmDiskServiceUpdateRequest) Header(key, value string) *VmDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceUpdateRequest) Query(key, value string) *VmDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceUpdateRequest) Async(async bool) *VmDiskServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceUpdateRequest) Disk(disk *Disk) *VmDiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *VmDiskServiceUpdateRequest) Send() (*VmDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmDiskServiceUpdateResponse VmDiskServiceUpdateResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	vmDiskServiceUpdateResponse.disk = &diskVar
	return &vmDiskServiceUpdateResponse, nil
}

type VmDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *VmDiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}
func (p *VmDiskService) Update() *VmDiskServiceUpdateRequest {
	return &VmDiskServiceUpdateRequest{vmDiskService: p}
}

//
//
func (op *VmDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *VmDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmDiskService) String() string {
	return fmt.Sprintf("VmDiskService:%s", op.Path)
}

//
//
type StorageServerConnectionService struct {
	BaseService
}

func NewStorageServerConnectionService(connection *Connection, path string) *StorageServerConnectionService {
	var result StorageServerConnectionService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionServiceGetRequest struct {
	storageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
}

func (p *StorageServerConnectionServiceGetRequest) Header(key, value string) *StorageServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceGetRequest) Query(key, value string) *StorageServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceGetRequest) Send() (*StorageServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.Connection.URL(), p.storageServerConnectionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionService.Connection.username, p.storageServerConnectionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionServiceGetResponse StorageServerConnectionServiceGetResponse
	var conectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &conectionVar)
	storageServerConnectionServiceGetResponse.conection = &conectionVar
	return &storageServerConnectionServiceGetResponse, nil
}

type StorageServerConnectionServiceGetResponse struct {
	conection *StorageConnection
}

func (p *StorageServerConnectionServiceGetResponse) Conection() *StorageConnection {
	return p.conection
}
func (p *StorageServerConnectionService) Get() *StorageServerConnectionServiceGetRequest {
	return &StorageServerConnectionServiceGetRequest{storageServerConnectionService: p}
}

type StorageServerConnectionServiceRemoveRequest struct {
	storageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	host                           *string
}

func (p *StorageServerConnectionServiceRemoveRequest) Header(key, value string) *StorageServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Query(key, value string) *StorageServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Async(async bool) *StorageServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionServiceRemoveRequest) Host(host string) *StorageServerConnectionServiceRemoveRequest {
	p.host = &host
	return p
}
func (p *StorageServerConnectionServiceRemoveRequest) Send() (*StorageServerConnectionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.Connection.URL(), p.storageServerConnectionService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionService.Connection.username, p.storageServerConnectionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageServerConnectionServiceRemoveResponse), nil
}

type StorageServerConnectionServiceRemoveResponse struct {
}

func (p *StorageServerConnectionService) Remove() *StorageServerConnectionServiceRemoveRequest {
	return &StorageServerConnectionServiceRemoveRequest{storageServerConnectionService: p}
}

type StorageServerConnectionServiceUpdateRequest struct {
	storageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateRequest) Header(key, value string) *StorageServerConnectionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Query(key, value string) *StorageServerConnectionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Async(async bool) *StorageServerConnectionServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionServiceUpdateRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateRequest {
	p.connection = connection
	return p
}
func (p *StorageServerConnectionServiceUpdateRequest) Force(force bool) *StorageServerConnectionServiceUpdateRequest {
	p.force = &force
	return p
}
func (p *StorageServerConnectionServiceUpdateRequest) Send() (*StorageServerConnectionServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.Connection.URL(), p.storageServerConnectionService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.connection)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionService.Connection.username, p.storageServerConnectionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionServiceUpdateResponse StorageServerConnectionServiceUpdateResponse
	var connectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &connectionVar)
	storageServerConnectionServiceUpdateResponse.connection = &connectionVar
	return &storageServerConnectionServiceUpdateResponse, nil
}

type StorageServerConnectionServiceUpdateResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateResponse) Connection() *StorageConnection {
	return p.connection
}
func (p *StorageServerConnectionService) Update() *StorageServerConnectionServiceUpdateRequest {
	return &StorageServerConnectionServiceUpdateRequest{storageServerConnectionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageServerConnectionService) String() string {
	return fmt.Sprintf("StorageServerConnectionService:%s", op.Path)
}

//
// A service to manage a host.
//
type HostService struct {
	BaseService
}

func NewHostService(connection *Connection, path string) *HostService {
	var result HostService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostServiceActivateRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceActivateRequest) Header(key, value string) *HostServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceActivateRequest) Query(key, value string) *HostServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceActivateRequest) Async(async bool) *HostServiceActivateRequest {
	p.async = &async
	return p
}
func (p *HostServiceActivateRequest) Send() (*HostServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceActivateResponse), nil
}

type HostServiceActivateResponse struct {
}

func (p *HostService) Activate() *HostServiceActivateRequest {
	return &HostServiceActivateRequest{hostService: p}
}

type HostServiceApproveRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	cluster     *Cluster
}

func (p *HostServiceApproveRequest) Header(key, value string) *HostServiceApproveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceApproveRequest) Query(key, value string) *HostServiceApproveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceApproveRequest) Async(async bool) *HostServiceApproveRequest {
	p.async = &async
	return p
}
func (p *HostServiceApproveRequest) Cluster(cluster *Cluster) *HostServiceApproveRequest {
	p.cluster = cluster
	return p
}
func (p *HostServiceApproveRequest) Send() (*HostServiceApproveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/approve", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Cluster(p.cluster)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceApproveResponse), nil
}

type HostServiceApproveResponse struct {
}

func (p *HostService) Approve() *HostServiceApproveRequest {
	return &HostServiceApproveRequest{hostService: p}
}

type HostServiceCommitNetConfigRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceCommitNetConfigRequest) Header(key, value string) *HostServiceCommitNetConfigRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceCommitNetConfigRequest) Query(key, value string) *HostServiceCommitNetConfigRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceCommitNetConfigRequest) Async(async bool) *HostServiceCommitNetConfigRequest {
	p.async = &async
	return p
}
func (p *HostServiceCommitNetConfigRequest) Send() (*HostServiceCommitNetConfigResponse, error) {
	rawURL := fmt.Sprintf("%s%s/commitnetconfig", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceCommitNetConfigResponse), nil
}

type HostServiceCommitNetConfigResponse struct {
}

func (p *HostService) CommitNetConfig() *HostServiceCommitNetConfigRequest {
	return &HostServiceCommitNetConfigRequest{hostService: p}
}

type HostServiceDeactivateRequest struct {
	hostService        *HostService
	header             map[string]string
	query              map[string]string
	async              *bool
	reason             *string
	stopGlusterService *bool
}

func (p *HostServiceDeactivateRequest) Header(key, value string) *HostServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceDeactivateRequest) Query(key, value string) *HostServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceDeactivateRequest) Async(async bool) *HostServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *HostServiceDeactivateRequest) Reason(reason string) *HostServiceDeactivateRequest {
	p.reason = &reason
	return p
}
func (p *HostServiceDeactivateRequest) StopGlusterService(stopGlusterService bool) *HostServiceDeactivateRequest {
	p.stopGlusterService = &stopGlusterService
	return p
}
func (p *HostServiceDeactivateRequest) Send() (*HostServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Reason(*p.reason)
	actionBuilder.StopGlusterService(*p.stopGlusterService)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceDeactivateResponse), nil
}

type HostServiceDeactivateResponse struct {
}

func (p *HostService) Deactivate() *HostServiceDeactivateRequest {
	return &HostServiceDeactivateRequest{hostService: p}
}

type HostServiceEnrollCertificateRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceEnrollCertificateRequest) Header(key, value string) *HostServiceEnrollCertificateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceEnrollCertificateRequest) Query(key, value string) *HostServiceEnrollCertificateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceEnrollCertificateRequest) Async(async bool) *HostServiceEnrollCertificateRequest {
	p.async = &async
	return p
}
func (p *HostServiceEnrollCertificateRequest) Send() (*HostServiceEnrollCertificateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/enrollcertificate", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceEnrollCertificateResponse), nil
}

type HostServiceEnrollCertificateResponse struct {
}

func (p *HostService) EnrollCertificate() *HostServiceEnrollCertificateRequest {
	return &HostServiceEnrollCertificateRequest{hostService: p}
}

type HostServiceFenceRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	fenceType   *string
}

func (p *HostServiceFenceRequest) Header(key, value string) *HostServiceFenceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceFenceRequest) Query(key, value string) *HostServiceFenceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceFenceRequest) Async(async bool) *HostServiceFenceRequest {
	p.async = &async
	return p
}
func (p *HostServiceFenceRequest) FenceType(fenceType string) *HostServiceFenceRequest {
	p.fenceType = &fenceType
	return p
}
func (p *HostServiceFenceRequest) Send() (*HostServiceFenceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fence", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.FenceType(*p.fenceType)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &HostServiceFenceResponse{powerManagement: action.PowerManagement}, nil
}

type HostServiceFenceResponse struct {
	powerManagement *PowerManagement
}

func (p *HostServiceFenceResponse) PowerManagement() *PowerManagement {
	return p.powerManagement
}
func (p *HostService) Fence() *HostServiceFenceRequest {
	return &HostServiceFenceRequest{hostService: p}
}

type HostServiceForceSelectSpmRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceForceSelectSpmRequest) Header(key, value string) *HostServiceForceSelectSpmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceForceSelectSpmRequest) Query(key, value string) *HostServiceForceSelectSpmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceForceSelectSpmRequest) Async(async bool) *HostServiceForceSelectSpmRequest {
	p.async = &async
	return p
}
func (p *HostServiceForceSelectSpmRequest) Send() (*HostServiceForceSelectSpmResponse, error) {
	rawURL := fmt.Sprintf("%s%s/forceselectspm", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceForceSelectSpmResponse), nil
}

type HostServiceForceSelectSpmResponse struct {
}

func (p *HostService) ForceSelectSpm() *HostServiceForceSelectSpmRequest {
	return &HostServiceForceSelectSpmRequest{hostService: p}
}

type HostServiceGetRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	filter      *bool
}

func (p *HostServiceGetRequest) Header(key, value string) *HostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceGetRequest) Query(key, value string) *HostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceGetRequest) Filter(filter bool) *HostServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *HostServiceGetRequest) Send() (*HostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostService.Connection.URL(), p.hostService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostServiceGetResponse HostServiceGetResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	hostServiceGetResponse.host = &hostVar
	return &hostServiceGetResponse, nil
}

type HostServiceGetResponse struct {
	host *Host
}

func (p *HostServiceGetResponse) Host() *Host {
	return p.host
}
func (p *HostService) Get() *HostServiceGetRequest {
	return &HostServiceGetRequest{hostService: p}
}

type HostServiceInstallRequest struct {
	hostService          *HostService
	header               map[string]string
	query                map[string]string
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *HostServiceInstallRequest) Header(key, value string) *HostServiceInstallRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceInstallRequest) Query(key, value string) *HostServiceInstallRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceInstallRequest) Async(async bool) *HostServiceInstallRequest {
	p.async = &async
	return p
}
func (p *HostServiceInstallRequest) DeployHostedEngine(deployHostedEngine bool) *HostServiceInstallRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}
func (p *HostServiceInstallRequest) Host(host *Host) *HostServiceInstallRequest {
	p.host = host
	return p
}
func (p *HostServiceInstallRequest) Image(image string) *HostServiceInstallRequest {
	p.image = &image
	return p
}
func (p *HostServiceInstallRequest) RootPassword(rootPassword string) *HostServiceInstallRequest {
	p.rootPassword = &rootPassword
	return p
}
func (p *HostServiceInstallRequest) Ssh(ssh *Ssh) *HostServiceInstallRequest {
	p.ssh = ssh
	return p
}
func (p *HostServiceInstallRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostServiceInstallRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}
func (p *HostServiceInstallRequest) Send() (*HostServiceInstallResponse, error) {
	rawURL := fmt.Sprintf("%s%s/install", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	actionBuilder.Host(p.host)
	actionBuilder.Image(*p.image)
	actionBuilder.RootPassword(*p.rootPassword)
	actionBuilder.Ssh(p.ssh)
	actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceInstallResponse), nil
}

type HostServiceInstallResponse struct {
}

func (p *HostService) Install() *HostServiceInstallRequest {
	return &HostServiceInstallRequest{hostService: p}
}

type HostServiceIscsiDiscoverRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceIscsiDiscoverRequest) Header(key, value string) *HostServiceIscsiDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Query(key, value string) *HostServiceIscsiDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Async(async bool) *HostServiceIscsiDiscoverRequest {
	p.async = &async
	return p
}
func (p *HostServiceIscsiDiscoverRequest) Iscsi(iscsi *IscsiDetails) *HostServiceIscsiDiscoverRequest {
	p.iscsi = iscsi
	return p
}
func (p *HostServiceIscsiDiscoverRequest) Send() (*HostServiceIscsiDiscoverResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsidiscover", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Iscsi(p.iscsi)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &HostServiceIscsiDiscoverResponse{iscsiTargets: action.IscsiTargets}, nil
}

type HostServiceIscsiDiscoverResponse struct {
	iscsiTargets []string
}

func (p *HostServiceIscsiDiscoverResponse) IscsiTargets() []string {
	return p.iscsiTargets
}
func (p *HostService) IscsiDiscover() *HostServiceIscsiDiscoverRequest {
	return &HostServiceIscsiDiscoverRequest{hostService: p}
}

type HostServiceIscsiLoginRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceIscsiLoginRequest) Header(key, value string) *HostServiceIscsiLoginRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceIscsiLoginRequest) Query(key, value string) *HostServiceIscsiLoginRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceIscsiLoginRequest) Async(async bool) *HostServiceIscsiLoginRequest {
	p.async = &async
	return p
}
func (p *HostServiceIscsiLoginRequest) Iscsi(iscsi *IscsiDetails) *HostServiceIscsiLoginRequest {
	p.iscsi = iscsi
	return p
}
func (p *HostServiceIscsiLoginRequest) Send() (*HostServiceIscsiLoginResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsilogin", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Iscsi(p.iscsi)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceIscsiLoginResponse), nil
}

type HostServiceIscsiLoginResponse struct {
}

func (p *HostService) IscsiLogin() *HostServiceIscsiLoginRequest {
	return &HostServiceIscsiLoginRequest{hostService: p}
}

type HostServiceRefreshRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceRefreshRequest) Header(key, value string) *HostServiceRefreshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceRefreshRequest) Query(key, value string) *HostServiceRefreshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceRefreshRequest) Async(async bool) *HostServiceRefreshRequest {
	p.async = &async
	return p
}
func (p *HostServiceRefreshRequest) Send() (*HostServiceRefreshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refresh", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceRefreshResponse), nil
}

type HostServiceRefreshResponse struct {
}

func (p *HostService) Refresh() *HostServiceRefreshRequest {
	return &HostServiceRefreshRequest{hostService: p}
}

type HostServiceRemoveRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceRemoveRequest) Header(key, value string) *HostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceRemoveRequest) Query(key, value string) *HostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceRemoveRequest) Async(async bool) *HostServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *HostServiceRemoveRequest) Send() (*HostServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostService.Connection.URL(), p.hostService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(HostServiceRemoveResponse), nil
}

type HostServiceRemoveResponse struct {
}

func (p *HostService) Remove() *HostServiceRemoveRequest {
	return &HostServiceRemoveRequest{hostService: p}
}

type HostServiceSetupNetworksRequest struct {
	hostService                    *HostService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	checkConnectivity              *bool
	connectivityTimeout            *int64
	modifiedBonds                  []HostNic
	modifiedLabels                 []NetworkLabel
	modifiedNetworkAttachments     []NetworkAttachment
	removedBonds                   []HostNic
	removedLabels                  []NetworkLabel
	removedNetworkAttachments      []NetworkAttachment
	synchronizedNetworkAttachments []NetworkAttachment
}

func (p *HostServiceSetupNetworksRequest) Header(key, value string) *HostServiceSetupNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceSetupNetworksRequest) Query(key, value string) *HostServiceSetupNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceSetupNetworksRequest) Async(async bool) *HostServiceSetupNetworksRequest {
	p.async = &async
	return p
}
func (p *HostServiceSetupNetworksRequest) CheckConnectivity(checkConnectivity bool) *HostServiceSetupNetworksRequest {
	p.checkConnectivity = &checkConnectivity
	return p
}
func (p *HostServiceSetupNetworksRequest) ConnectivityTimeout(connectivityTimeout int64) *HostServiceSetupNetworksRequest {
	p.connectivityTimeout = &connectivityTimeout
	return p
}
func (p *HostServiceSetupNetworksRequest) ModifiedBonds(modifiedBonds []HostNic) *HostServiceSetupNetworksRequest {
	p.modifiedBonds = modifiedBonds
	return p
}
func (p *HostServiceSetupNetworksRequest) ModifiedLabels(modifiedLabels []NetworkLabel) *HostServiceSetupNetworksRequest {
	p.modifiedLabels = modifiedLabels
	return p
}
func (p *HostServiceSetupNetworksRequest) ModifiedNetworkAttachments(modifiedNetworkAttachments []NetworkAttachment) *HostServiceSetupNetworksRequest {
	p.modifiedNetworkAttachments = modifiedNetworkAttachments
	return p
}
func (p *HostServiceSetupNetworksRequest) RemovedBonds(removedBonds []HostNic) *HostServiceSetupNetworksRequest {
	p.removedBonds = removedBonds
	return p
}
func (p *HostServiceSetupNetworksRequest) RemovedLabels(removedLabels []NetworkLabel) *HostServiceSetupNetworksRequest {
	p.removedLabels = removedLabels
	return p
}
func (p *HostServiceSetupNetworksRequest) RemovedNetworkAttachments(removedNetworkAttachments []NetworkAttachment) *HostServiceSetupNetworksRequest {
	p.removedNetworkAttachments = removedNetworkAttachments
	return p
}
func (p *HostServiceSetupNetworksRequest) SynchronizedNetworkAttachments(synchronizedNetworkAttachments []NetworkAttachment) *HostServiceSetupNetworksRequest {
	p.synchronizedNetworkAttachments = synchronizedNetworkAttachments
	return p
}
func (p *HostServiceSetupNetworksRequest) Send() (*HostServiceSetupNetworksResponse, error) {
	rawURL := fmt.Sprintf("%s%s/setupnetworks", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.CheckConnectivity(*p.checkConnectivity)
	actionBuilder.ConnectivityTimeout(*p.connectivityTimeout)
	actionBuilder.ModifiedBonds(p.modifiedBonds)
	actionBuilder.ModifiedLabels(p.modifiedLabels)
	actionBuilder.ModifiedNetworkAttachments(p.modifiedNetworkAttachments)
	actionBuilder.RemovedBonds(p.removedBonds)
	actionBuilder.RemovedLabels(p.removedLabels)
	actionBuilder.RemovedNetworkAttachments(p.removedNetworkAttachments)
	actionBuilder.SynchronizedNetworkAttachments(p.synchronizedNetworkAttachments)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceSetupNetworksResponse), nil
}

type HostServiceSetupNetworksResponse struct {
}

func (p *HostService) SetupNetworks() *HostServiceSetupNetworksRequest {
	return &HostServiceSetupNetworksRequest{hostService: p}
}

type HostServiceUnregisteredStorageDomainsDiscoverRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Header(key, value string) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Query(key, value string) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Async(async bool) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.async = &async
	return p
}
func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Iscsi(iscsi *IscsiDetails) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.iscsi = iscsi
	return p
}
func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Send() (*HostServiceUnregisteredStorageDomainsDiscoverResponse, error) {
	rawURL := fmt.Sprintf("%s%s/unregisteredstoragedomainsdiscover", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Iscsi(p.iscsi)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &HostServiceUnregisteredStorageDomainsDiscoverResponse{storageDomains: action.StorageDomains}, nil
}

type HostServiceUnregisteredStorageDomainsDiscoverResponse struct {
	storageDomains []StorageDomain
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverResponse) StorageDomains() []StorageDomain {
	return p.storageDomains
}
func (p *HostService) UnregisteredStorageDomainsDiscover() *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	return &HostServiceUnregisteredStorageDomainsDiscoverRequest{hostService: p}
}

type HostServiceUpdateRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *HostServiceUpdateRequest) Header(key, value string) *HostServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpdateRequest) Query(key, value string) *HostServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpdateRequest) Async(async bool) *HostServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *HostServiceUpdateRequest) Host(host *Host) *HostServiceUpdateRequest {
	p.host = host
	return p
}
func (p *HostServiceUpdateRequest) Send() (*HostServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostService.Connection.URL(), p.hostService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.host)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostServiceUpdateResponse HostServiceUpdateResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	hostServiceUpdateResponse.host = &hostVar
	return &hostServiceUpdateResponse, nil
}

type HostServiceUpdateResponse struct {
	host *Host
}

func (p *HostServiceUpdateResponse) Host() *Host {
	return p.host
}
func (p *HostService) Update() *HostServiceUpdateRequest {
	return &HostServiceUpdateRequest{hostService: p}
}

type HostServiceUpgradeRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceUpgradeRequest) Header(key, value string) *HostServiceUpgradeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpgradeRequest) Query(key, value string) *HostServiceUpgradeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpgradeRequest) Async(async bool) *HostServiceUpgradeRequest {
	p.async = &async
	return p
}
func (p *HostServiceUpgradeRequest) Send() (*HostServiceUpgradeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/upgrade", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceUpgradeResponse), nil
}

type HostServiceUpgradeResponse struct {
}

func (p *HostService) Upgrade() *HostServiceUpgradeRequest {
	return &HostServiceUpgradeRequest{hostService: p}
}

type HostServiceUpgradeCheckRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
}

func (p *HostServiceUpgradeCheckRequest) Header(key, value string) *HostServiceUpgradeCheckRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpgradeCheckRequest) Query(key, value string) *HostServiceUpgradeCheckRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpgradeCheckRequest) Send() (*HostServiceUpgradeCheckResponse, error) {
	rawURL := fmt.Sprintf("%s%s/upgradecheck", p.hostService.Connection.URL(), p.hostService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceUpgradeCheckResponse), nil
}

type HostServiceUpgradeCheckResponse struct {
}

func (p *HostService) UpgradeCheck() *HostServiceUpgradeCheckRequest {
	return &HostServiceUpgradeCheckRequest{hostService: p}
}

//
// List of scheduling labels assigned to this host.
//
func (op *HostService) AffinityLabelsService() *AssignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.Connection, fmt.Sprintf("%s/affinitylabels", op.Path))
}

//
// Reference to the host devices service.
// Use this service to view the devices of the host object.
//
func (op *HostService) DevicesService() *HostDevicesService {
	return NewHostDevicesService(op.Connection, fmt.Sprintf("%s/devices", op.Path))
}

//
// Reference to the fence agents service.
// Use this service to manage fence and power management agents on the host object.
//
func (op *HostService) FenceAgentsService() *FenceAgentsService {
	return NewFenceAgentsService(op.Connection, fmt.Sprintf("%s/fenceagents", op.Path))
}

//
// Reference to the host hooks service.
// Use this service to view the hooks available in the host object.
//
func (op *HostService) HooksService() *HostHooksService {
	return NewHostHooksService(op.Connection, fmt.Sprintf("%s/hooks", op.Path))
}

//
// Reference to the service that can show the applicable errata available on the host.
// This information is taken from Katello.
//
func (op *HostService) KatelloErrataService() *KatelloErrataService {
	return NewKatelloErrataService(op.Connection, fmt.Sprintf("%s/katelloerrata", op.Path))
}

//
// Reference to the network attachments service. You can use this service to attach
// Logical networks to host interfaces.
//
func (op *HostService) NetworkAttachmentsService() *NetworkAttachmentsService {
	return NewNetworkAttachmentsService(op.Connection, fmt.Sprintf("%s/networkattachments", op.Path))
}

//
// Reference to the service that manages the network interface devices on the host.
//
func (op *HostService) NicsService() *HostNicsService {
	return NewHostNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Reference to the service that manage NUMA nodes for the host.
//
func (op *HostService) NumaNodesService() *HostNumaNodesService {
	return NewHostNumaNodesService(op.Connection, fmt.Sprintf("%s/numanodes", op.Path))
}

//
// Reference to the host permission service.
// Use this service to manage permissions on the host object.
//
func (op *HostService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *HostService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Reference to the service that manage hosts storage.
//
func (op *HostService) StorageService() *HostStorageService {
	return NewHostStorageService(op.Connection, fmt.Sprintf("%s/storage", op.Path))
}

//
// Reference to storage connection extensions.
//
func (op *HostService) StorageConnectionExtensionsService() *StorageServerConnectionExtensionsService {
	return NewStorageServerConnectionExtensionsService(op.Connection, fmt.Sprintf("%s/storageconnectionextensions", op.Path))
}

//
// Reference to the host tags service.
// Use this service to manage tags on the host object.
//
func (op *HostService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Reference to unmanaged networks.
//
func (op *HostService) UnmanagedNetworksService() *UnmanagedNetworksService {
	return NewUnmanagedNetworksService(op.Connection, fmt.Sprintf("%s/unmanagednetworks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "devices" {
		return op.DevicesService(), nil
	}
	if strings.HasPrefix(path, "devices/") {
		return op.DevicesService().Service(path[8:])
	}
	if path == "fenceagents" {
		return op.FenceAgentsService(), nil
	}
	if strings.HasPrefix(path, "fenceagents/") {
		return op.FenceAgentsService().Service(path[12:])
	}
	if path == "hooks" {
		return op.HooksService(), nil
	}
	if strings.HasPrefix(path, "hooks/") {
		return op.HooksService().Service(path[6:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "storage" {
		return op.StorageService(), nil
	}
	if strings.HasPrefix(path, "storage/") {
		return op.StorageService().Service(path[8:])
	}
	if path == "storageconnectionextensions" {
		return op.StorageConnectionExtensionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnectionextensions/") {
		return op.StorageConnectionExtensionsService().Service(path[28:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "unmanagednetworks" {
		return op.UnmanagedNetworksService(), nil
	}
	if strings.HasPrefix(path, "unmanagednetworks/") {
		return op.UnmanagedNetworksService().Service(path[18:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostService) String() string {
	return fmt.Sprintf("HostService:%s", op.Path)
}

//
//
type ExternalProviderCertificatesService struct {
	BaseService
}

func NewExternalProviderCertificatesService(connection *Connection, path string) *ExternalProviderCertificatesService {
	var result ExternalProviderCertificatesService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalProviderCertificatesServiceListRequest struct {
	externalProviderCertificatesService *ExternalProviderCertificatesService
	header                              map[string]string
	query                               map[string]string
	max                                 *int64
}

func (p *ExternalProviderCertificatesServiceListRequest) Header(key, value string) *ExternalProviderCertificatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Query(key, value string) *ExternalProviderCertificatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Max(max int64) *ExternalProviderCertificatesServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalProviderCertificatesServiceListRequest) Send() (*ExternalProviderCertificatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificatesService.Connection.URL(), p.externalProviderCertificatesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalProviderCertificatesService.Connection.username, p.externalProviderCertificatesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalProviderCertificatesServiceListResponse ExternalProviderCertificatesServiceListResponse
	var certificatesVar Certificates
	xml.Unmarshal(respBodyBytes, &certificatesVar)
	externalProviderCertificatesServiceListResponse.certificates = certificatesVar.Certificates
	return &externalProviderCertificatesServiceListResponse, nil
}

type ExternalProviderCertificatesServiceListResponse struct {
	certificates []Certificate
}

func (p *ExternalProviderCertificatesServiceListResponse) Certificates() []Certificate {
	return p.certificates
}
func (p *ExternalProviderCertificatesService) List() *ExternalProviderCertificatesServiceListRequest {
	return &ExternalProviderCertificatesServiceListRequest{externalProviderCertificatesService: p}
}

//
//
func (op *ExternalProviderCertificatesService) CertificateService(id string) *ExternalProviderCertificateService {
	return NewExternalProviderCertificateService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderCertificatesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CertificateService(path)), nil
	}
	return op.CertificateService(path[:index]).Service(path[index+1:])
}

func (op *ExternalProviderCertificatesService) String() string {
	return fmt.Sprintf("ExternalProviderCertificatesService:%s", op.Path)
}

//
// A service to manage individual host device attached to a virtual machine.
//
type VmHostDeviceService struct {
	BaseService
}

func NewVmHostDeviceService(connection *Connection, path string) *VmHostDeviceService {
	var result VmHostDeviceService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmHostDeviceServiceGetRequest struct {
	vmHostDeviceService *VmHostDeviceService
	header              map[string]string
	query               map[string]string
}

func (p *VmHostDeviceServiceGetRequest) Header(key, value string) *VmHostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDeviceServiceGetRequest) Query(key, value string) *VmHostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDeviceServiceGetRequest) Send() (*VmHostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDeviceService.Connection.URL(), p.vmHostDeviceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmHostDeviceService.Connection.username, p.vmHostDeviceService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmHostDeviceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmHostDeviceServiceGetResponse VmHostDeviceServiceGetResponse
	var deviceVar HostDevice
	xml.Unmarshal(respBodyBytes, &deviceVar)
	vmHostDeviceServiceGetResponse.device = &deviceVar
	return &vmHostDeviceServiceGetResponse, nil
}

type VmHostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *VmHostDeviceServiceGetResponse) Device() *HostDevice {
	return p.device
}
func (p *VmHostDeviceService) Get() *VmHostDeviceServiceGetRequest {
	return &VmHostDeviceServiceGetRequest{vmHostDeviceService: p}
}

type VmHostDeviceServiceRemoveRequest struct {
	vmHostDeviceService *VmHostDeviceService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *VmHostDeviceServiceRemoveRequest) Header(key, value string) *VmHostDeviceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDeviceServiceRemoveRequest) Query(key, value string) *VmHostDeviceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDeviceServiceRemoveRequest) Async(async bool) *VmHostDeviceServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmHostDeviceServiceRemoveRequest) Send() (*VmHostDeviceServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDeviceService.Connection.URL(), p.vmHostDeviceService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmHostDeviceService.Connection.username, p.vmHostDeviceService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmHostDeviceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmHostDeviceServiceRemoveResponse), nil
}

type VmHostDeviceServiceRemoveResponse struct {
}

func (p *VmHostDeviceService) Remove() *VmHostDeviceServiceRemoveRequest {
	return &VmHostDeviceServiceRemoveRequest{vmHostDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmHostDeviceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmHostDeviceService) String() string {
	return fmt.Sprintf("VmHostDeviceService:%s", op.Path)
}

//
// A service to manage a specific tag in the system.
//
type TagService struct {
	BaseService
}

func NewTagService(connection *Connection, path string) *TagService {
	var result TagService
	result.Connection = connection
	result.Path = path
	return &result
}

type TagServiceGetRequest struct {
	tagService *TagService
	header     map[string]string
	query      map[string]string
}

func (p *TagServiceGetRequest) Header(key, value string) *TagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceGetRequest) Query(key, value string) *TagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceGetRequest) Send() (*TagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagService.Connection.URL(), p.tagService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagService.Connection.username, p.tagService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var tagServiceGetResponse TagServiceGetResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	tagServiceGetResponse.tag = &tagVar
	return &tagServiceGetResponse, nil
}

type TagServiceGetResponse struct {
	tag *Tag
}

func (p *TagServiceGetResponse) Tag() *Tag {
	return p.tag
}
func (p *TagService) Get() *TagServiceGetRequest {
	return &TagServiceGetRequest{tagService: p}
}

type TagServiceRemoveRequest struct {
	tagService *TagService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *TagServiceRemoveRequest) Header(key, value string) *TagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceRemoveRequest) Query(key, value string) *TagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceRemoveRequest) Async(async bool) *TagServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TagServiceRemoveRequest) Send() (*TagServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagService.Connection.URL(), p.tagService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagService.Connection.username, p.tagService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TagServiceRemoveResponse), nil
}

type TagServiceRemoveResponse struct {
}

func (p *TagService) Remove() *TagServiceRemoveRequest {
	return &TagServiceRemoveRequest{tagService: p}
}

type TagServiceUpdateRequest struct {
	tagService *TagService
	header     map[string]string
	query      map[string]string
	async      *bool
	tag        *Tag
}

func (p *TagServiceUpdateRequest) Header(key, value string) *TagServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceUpdateRequest) Query(key, value string) *TagServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceUpdateRequest) Async(async bool) *TagServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TagServiceUpdateRequest) Tag(tag *Tag) *TagServiceUpdateRequest {
	p.tag = tag
	return p
}
func (p *TagServiceUpdateRequest) Send() (*TagServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagService.Connection.URL(), p.tagService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.tag)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagService.Connection.username, p.tagService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var tagServiceUpdateResponse TagServiceUpdateResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	tagServiceUpdateResponse.tag = &tagVar
	return &tagServiceUpdateResponse, nil
}

type TagServiceUpdateResponse struct {
	tag *Tag
}

func (p *TagServiceUpdateResponse) Tag() *Tag {
	return p.tag
}
func (p *TagService) Update() *TagServiceUpdateRequest {
	return &TagServiceUpdateRequest{tagService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TagService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TagService) String() string {
	return fmt.Sprintf("TagService:%s", op.Path)
}

//
//
type HostNumaNodesService struct {
	BaseService
}

func NewHostNumaNodesService(connection *Connection, path string) *HostNumaNodesService {
	var result HostNumaNodesService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNumaNodesServiceListRequest struct {
	hostNumaNodesService *HostNumaNodesService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *HostNumaNodesServiceListRequest) Header(key, value string) *HostNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNumaNodesServiceListRequest) Query(key, value string) *HostNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNumaNodesServiceListRequest) Max(max int64) *HostNumaNodesServiceListRequest {
	p.max = &max
	return p
}
func (p *HostNumaNodesServiceListRequest) Send() (*HostNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodesService.Connection.URL(), p.hostNumaNodesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNumaNodesService.Connection.username, p.hostNumaNodesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNumaNodesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostNumaNodesServiceListResponse HostNumaNodesServiceListResponse
	var nodesVar NumaNodes
	xml.Unmarshal(respBodyBytes, &nodesVar)
	hostNumaNodesServiceListResponse.nodes = nodesVar.NumaNodes
	return &hostNumaNodesServiceListResponse, nil
}

type HostNumaNodesServiceListResponse struct {
	nodes []NumaNode
}

func (p *HostNumaNodesServiceListResponse) Nodes() []NumaNode {
	return p.nodes
}
func (p *HostNumaNodesService) List() *HostNumaNodesServiceListRequest {
	return &HostNumaNodesServiceListRequest{hostNumaNodesService: p}
}

//
//
func (op *HostNumaNodesService) NodeService(id string) *HostNumaNodeService {
	return NewHostNumaNodeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNumaNodesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NodeService(path)), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *HostNumaNodesService) String() string {
	return fmt.Sprintf("HostNumaNodesService:%s", op.Path)
}

//
// A service to manage collection of assignment of tags to specific entities in system.
//
type AssignedTagsService struct {
	BaseService
}

func NewAssignedTagsService(connection *Connection, path string) *AssignedTagsService {
	var result AssignedTagsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedTagsServiceAddRequest struct {
	assignedTagsService *AssignedTagsService
	header              map[string]string
	query               map[string]string
	tag                 *Tag
}

func (p *AssignedTagsServiceAddRequest) Header(key, value string) *AssignedTagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagsServiceAddRequest) Query(key, value string) *AssignedTagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagsServiceAddRequest) Tag(tag *Tag) *AssignedTagsServiceAddRequest {
	p.tag = tag
	return p
}
func (p *AssignedTagsServiceAddRequest) Send() (*AssignedTagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.Connection.URL(), p.assignedTagsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.tag)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedTagsService.Connection.username, p.assignedTagsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedTagsServiceAddResponse AssignedTagsServiceAddResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	assignedTagsServiceAddResponse.tag = &tagVar
	return &assignedTagsServiceAddResponse, nil
}

type AssignedTagsServiceAddResponse struct {
	tag *Tag
}

func (p *AssignedTagsServiceAddResponse) Tag() *Tag {
	return p.tag
}
func (p *AssignedTagsService) Add() *AssignedTagsServiceAddRequest {
	return &AssignedTagsServiceAddRequest{assignedTagsService: p}
}

type AssignedTagsServiceListRequest struct {
	assignedTagsService *AssignedTagsService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *AssignedTagsServiceListRequest) Header(key, value string) *AssignedTagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagsServiceListRequest) Query(key, value string) *AssignedTagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagsServiceListRequest) Max(max int64) *AssignedTagsServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedTagsServiceListRequest) Send() (*AssignedTagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.Connection.URL(), p.assignedTagsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedTagsService.Connection.username, p.assignedTagsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedTagsServiceListResponse AssignedTagsServiceListResponse
	var tagsVar Tags
	xml.Unmarshal(respBodyBytes, &tagsVar)
	assignedTagsServiceListResponse.tags = tagsVar.Tags
	return &assignedTagsServiceListResponse, nil
}

type AssignedTagsServiceListResponse struct {
	tags []Tag
}

func (p *AssignedTagsServiceListResponse) Tags() []Tag {
	return p.tags
}
func (p *AssignedTagsService) List() *AssignedTagsServiceListRequest {
	return &AssignedTagsServiceListRequest{assignedTagsService: p}
}

//
// Reference to the service that manages assignment of specific tag.
//
func (op *AssignedTagsService) TagService(id string) *AssignedTagService {
	return NewAssignedTagService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedTagsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TagService(path)), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *AssignedTagsService) String() string {
	return fmt.Sprintf("AssignedTagsService:%s", op.Path)
}

//
// A service to manage a job.
//
type JobService struct {
	BaseService
}

func NewJobService(connection *Connection, path string) *JobService {
	var result JobService
	result.Connection = connection
	result.Path = path
	return &result
}

type JobServiceClearRequest struct {
	jobService *JobService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *JobServiceClearRequest) Header(key, value string) *JobServiceClearRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceClearRequest) Query(key, value string) *JobServiceClearRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceClearRequest) Async(async bool) *JobServiceClearRequest {
	p.async = &async
	return p
}
func (p *JobServiceClearRequest) Send() (*JobServiceClearResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clear", p.jobService.Connection.URL(), p.jobService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobService.Connection.username, p.jobService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(JobServiceClearResponse), nil
}

type JobServiceClearResponse struct {
}

func (p *JobService) Clear() *JobServiceClearRequest {
	return &JobServiceClearRequest{jobService: p}
}

type JobServiceEndRequest struct {
	jobService *JobService
	header     map[string]string
	query      map[string]string
	async      *bool
	force      *bool
	succeeded  *bool
}

func (p *JobServiceEndRequest) Header(key, value string) *JobServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceEndRequest) Query(key, value string) *JobServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceEndRequest) Async(async bool) *JobServiceEndRequest {
	p.async = &async
	return p
}
func (p *JobServiceEndRequest) Force(force bool) *JobServiceEndRequest {
	p.force = &force
	return p
}
func (p *JobServiceEndRequest) Succeeded(succeeded bool) *JobServiceEndRequest {
	p.succeeded = &succeeded
	return p
}
func (p *JobServiceEndRequest) Send() (*JobServiceEndResponse, error) {
	rawURL := fmt.Sprintf("%s%s/end", p.jobService.Connection.URL(), p.jobService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Force(*p.force)
	actionBuilder.Succeeded(*p.succeeded)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobService.Connection.username, p.jobService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(JobServiceEndResponse), nil
}

type JobServiceEndResponse struct {
}

func (p *JobService) End() *JobServiceEndRequest {
	return &JobServiceEndRequest{jobService: p}
}

type JobServiceGetRequest struct {
	jobService *JobService
	header     map[string]string
	query      map[string]string
}

func (p *JobServiceGetRequest) Header(key, value string) *JobServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceGetRequest) Query(key, value string) *JobServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceGetRequest) Send() (*JobServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobService.Connection.URL(), p.jobService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobService.Connection.username, p.jobService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var jobServiceGetResponse JobServiceGetResponse
	var jobVar Job
	xml.Unmarshal(respBodyBytes, &jobVar)
	jobServiceGetResponse.job = &jobVar
	return &jobServiceGetResponse, nil
}

type JobServiceGetResponse struct {
	job *Job
}

func (p *JobServiceGetResponse) Job() *Job {
	return p.job
}
func (p *JobService) Get() *JobServiceGetRequest {
	return &JobServiceGetRequest{jobService: p}
}

//
// List all the steps of the job.
//
func (op *JobService) StepsService() *StepsService {
	return NewStepsService(op.Connection, fmt.Sprintf("%s/steps", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *JobService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "steps" {
		return op.StepsService(), nil
	}
	if strings.HasPrefix(path, "steps/") {
		return op.StepsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *JobService) String() string {
	return fmt.Sprintf("JobService:%s", op.Path)
}

//
//
type FileService struct {
	BaseService
}

func NewFileService(connection *Connection, path string) *FileService {
	var result FileService
	result.Connection = connection
	result.Path = path
	return &result
}

type FileServiceGetRequest struct {
	fileService *FileService
	header      map[string]string
	query       map[string]string
}

func (p *FileServiceGetRequest) Header(key, value string) *FileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FileServiceGetRequest) Query(key, value string) *FileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FileServiceGetRequest) Send() (*FileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fileService.Connection.URL(), p.fileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fileService.Connection.username, p.fileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var fileServiceGetResponse FileServiceGetResponse
	var fileVar File
	xml.Unmarshal(respBodyBytes, &fileVar)
	fileServiceGetResponse.file = &fileVar
	return &fileServiceGetResponse, nil
}

type FileServiceGetResponse struct {
	file *File
}

func (p *FileServiceGetResponse) File() *File {
	return p.file
}
func (p *FileService) Get() *FileServiceGetRequest {
	return &FileServiceGetRequest{fileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FileService) String() string {
	return fmt.Sprintf("FileService:%s", op.Path)
}

//
// A service to manage steps.
//
type StepsService struct {
	BaseService
}

func NewStepsService(connection *Connection, path string) *StepsService {
	var result StepsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StepsServiceAddRequest struct {
	stepsService *StepsService
	header       map[string]string
	query        map[string]string
	step         *Step
}

func (p *StepsServiceAddRequest) Header(key, value string) *StepsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepsServiceAddRequest) Query(key, value string) *StepsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepsServiceAddRequest) Step(step *Step) *StepsServiceAddRequest {
	p.step = step
	return p
}
func (p *StepsServiceAddRequest) Send() (*StepsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.Connection.URL(), p.stepsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.step)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.stepsService.Connection.username, p.stepsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.stepsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var stepsServiceAddResponse StepsServiceAddResponse
	var stepVar Step
	xml.Unmarshal(respBodyBytes, &stepVar)
	stepsServiceAddResponse.step = &stepVar
	return &stepsServiceAddResponse, nil
}

type StepsServiceAddResponse struct {
	step *Step
}

func (p *StepsServiceAddResponse) Step() *Step {
	return p.step
}
func (p *StepsService) Add() *StepsServiceAddRequest {
	return &StepsServiceAddRequest{stepsService: p}
}

type StepsServiceListRequest struct {
	stepsService *StepsService
	header       map[string]string
	query        map[string]string
	max          *int64
}

func (p *StepsServiceListRequest) Header(key, value string) *StepsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepsServiceListRequest) Query(key, value string) *StepsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepsServiceListRequest) Max(max int64) *StepsServiceListRequest {
	p.max = &max
	return p
}
func (p *StepsServiceListRequest) Send() (*StepsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.Connection.URL(), p.stepsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.stepsService.Connection.username, p.stepsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.stepsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var stepsServiceListResponse StepsServiceListResponse
	var stepsVar Steps
	xml.Unmarshal(respBodyBytes, &stepsVar)
	stepsServiceListResponse.steps = stepsVar.Steps
	return &stepsServiceListResponse, nil
}

type StepsServiceListResponse struct {
	steps []Step
}

func (p *StepsServiceListResponse) Steps() []Step {
	return p.steps
}
func (p *StepsService) List() *StepsServiceListRequest {
	return &StepsServiceListRequest{stepsService: p}
}

//
// Reference to the step service.
//
func (op *StepsService) StepService(id string) *StepService {
	return NewStepService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StepsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StepService(path)), nil
	}
	return op.StepService(path[:index]).Service(path[index+1:])
}

func (op *StepsService) String() string {
	return fmt.Sprintf("StepsService:%s", op.Path)
}

//
//
type StorageDomainServerConnectionService struct {
	BaseService
}

func NewStorageDomainServerConnectionService(connection *Connection, path string) *StorageDomainServerConnectionService {
	var result StorageDomainServerConnectionService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainServerConnectionServiceGetRequest struct {
	storageDomainServerConnectionService *StorageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
}

func (p *StorageDomainServerConnectionServiceGetRequest) Header(key, value string) *StorageDomainServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceGetRequest) Query(key, value string) *StorageDomainServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceGetRequest) Send() (*StorageDomainServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionService.Connection.URL(), p.storageDomainServerConnectionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainServerConnectionService.Connection.username, p.storageDomainServerConnectionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainServerConnectionServiceGetResponse StorageDomainServerConnectionServiceGetResponse
	var connectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &connectionVar)
	storageDomainServerConnectionServiceGetResponse.connection = &connectionVar
	return &storageDomainServerConnectionServiceGetResponse, nil
}

type StorageDomainServerConnectionServiceGetResponse struct {
	connection *StorageConnection
}

func (p *StorageDomainServerConnectionServiceGetResponse) Connection() *StorageConnection {
	return p.connection
}
func (p *StorageDomainServerConnectionService) Get() *StorageDomainServerConnectionServiceGetRequest {
	return &StorageDomainServerConnectionServiceGetRequest{storageDomainServerConnectionService: p}
}

type StorageDomainServerConnectionServiceRemoveRequest struct {
	storageDomainServerConnectionService *StorageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Header(key, value string) *StorageDomainServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Query(key, value string) *StorageDomainServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Async(async bool) *StorageDomainServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServerConnectionServiceRemoveRequest) Send() (*StorageDomainServerConnectionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionService.Connection.URL(), p.storageDomainServerConnectionService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainServerConnectionService.Connection.username, p.storageDomainServerConnectionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainServerConnectionServiceRemoveResponse), nil
}

type StorageDomainServerConnectionServiceRemoveResponse struct {
}

func (p *StorageDomainServerConnectionService) Remove() *StorageDomainServerConnectionServiceRemoveRequest {
	return &StorageDomainServerConnectionServiceRemoveRequest{storageDomainServerConnectionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainServerConnectionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainServerConnectionService) String() string {
	return fmt.Sprintf("StorageDomainServerConnectionService:%s", op.Path)
}

//
// Provides read-only access to the global set of roles
//
type RolesService struct {
	BaseService
}

func NewRolesService(connection *Connection, path string) *RolesService {
	var result RolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type RolesServiceAddRequest struct {
	rolesService *RolesService
	header       map[string]string
	query        map[string]string
	role         *Role
}

func (p *RolesServiceAddRequest) Header(key, value string) *RolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RolesServiceAddRequest) Query(key, value string) *RolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RolesServiceAddRequest) Role(role *Role) *RolesServiceAddRequest {
	p.role = role
	return p
}
func (p *RolesServiceAddRequest) Send() (*RolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.Connection.URL(), p.rolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.role)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.rolesService.Connection.username, p.rolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.rolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var rolesServiceAddResponse RolesServiceAddResponse
	var roleVar Role
	xml.Unmarshal(respBodyBytes, &roleVar)
	rolesServiceAddResponse.role = &roleVar
	return &rolesServiceAddResponse, nil
}

type RolesServiceAddResponse struct {
	role *Role
}

func (p *RolesServiceAddResponse) Role() *Role {
	return p.role
}
func (p *RolesService) Add() *RolesServiceAddRequest {
	return &RolesServiceAddRequest{rolesService: p}
}

type RolesServiceListRequest struct {
	rolesService *RolesService
	header       map[string]string
	query        map[string]string
	max          *int64
}

func (p *RolesServiceListRequest) Header(key, value string) *RolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RolesServiceListRequest) Query(key, value string) *RolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RolesServiceListRequest) Max(max int64) *RolesServiceListRequest {
	p.max = &max
	return p
}
func (p *RolesServiceListRequest) Send() (*RolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.Connection.URL(), p.rolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.rolesService.Connection.username, p.rolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.rolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var rolesServiceListResponse RolesServiceListResponse
	var rolesVar Roles
	xml.Unmarshal(respBodyBytes, &rolesVar)
	rolesServiceListResponse.roles = rolesVar.Roles
	return &rolesServiceListResponse, nil
}

type RolesServiceListResponse struct {
	roles []Role
}

func (p *RolesServiceListResponse) Roles() []Role {
	return p.roles
}
func (p *RolesService) List() *RolesServiceListRequest {
	return &RolesServiceListRequest{rolesService: p}
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *RolesService) RoleService(id string) *RoleService {
	return NewRoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *RolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.RoleService(path)), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *RolesService) String() string {
	return fmt.Sprintf("RolesService:%s", op.Path)
}

//
// This service provides a mechanism to control an image transfer. The client will have
// to create a transfer by using <<services/image_transfers/methods/add, add>>
// of the <<services/image_transfers>> service, stating the image to transfer
// data to/from.
// After doing that, the transfer is managed by this service.
// E.g., for uploading to the disk image with id `52cb593f-837c-4633-a444-35a0a0383706`,
// the client can use oVirt's Python's SDK as follows:
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       image=types.Image(
//          id='52cb593f-837c-4633-a444-35a0a0383706'
//       )
//    )
// )
// ----
// If the user wishes to download a disk rather than upload, he/she should specify
// `download` as the <<types/image_transfer_direction, direction>> attribute of the transfer.
// This will grant a read permission from the image, instead of a write permission.
// E.g:
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       image=types.Image(
//          id='52cb593f-837c-4633-a444-35a0a0383706'
//       ),
//       direction=types.ImageTransferDirection.DOWNLOAD
//    )
// )
// ----
// Transfers have phases, which govern the flow of the upload/download.
// A client implementing such a flow should poll/check the transfer's phase and
// act accordingly. All the possible phases can be found in
// <<types/image_transfer_phase, ImageTransferPhase>>.
// After adding a new transfer, its phase will be <<types/image_transfer_phase, initializing>>.
// The client will have to poll on the transfer's phase until it changes.
// When the phase becomes <<types/image_transfer_phase, transferring>>,
// the session is ready to start the transfer.
// For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// while transfer.phase == types.ImageTransferPhase.INITIALIZING:
//    time.sleep(3)
//    transfer = transfer_service.get()
// ----
// At that stage, if the transfer's phase is <<types/image_transfer_phase, paused_system>>, then the session was
// not successfully established. One possible reason for that is that the ovirt-imageio-daemon is not running
// in the host that was selected for transfer.
// The transfer can be resumed by calling <<services/image_transfer/methods/resume, resume>>
// of the service that manages it.
// If the session was successfully established - the returned transfer entity will
// contain the <<types/image_transfer, proxy_url>> and <<types/image_transfer, signed_ticket>> attributes,
// which the client needs to use in order to transfer the required data. The client can choose whatever
// technique and tool for sending the HTTPS request with the image's data.
// - `proxy_url` is the address of a proxy server to the image, to do I/O to.
// - `signed_ticket` is the content that needs to be added to the `Authentication`
//    header in the HTTPS request, in order to perform a trusted communication.
// For example, Python's HTTPSConnection can be used in order to perform a transfer,
// so an `transfer_headers` dict is set for the upcoming transfer:
// [source,python]
// ----
// transfer_headers = {
//    'Authorization' :  transfer.signed_ticket,
// }
// ----
// Using Python's `HTTPSConnection`, a new connection is established:
// [source,python]
// ----
// # Extract the URI, port, and path from the transfer's proxy_url.
// url = urlparse.urlparse(transfer.proxy_url)
// # Create a new instance of the connection.
// proxy_connection = HTTPSConnection(
//    url.hostname,
//    url.port,
//    context=ssl.SSLContext(ssl.PROTOCOL_SSLv23)
// )
// ----
// For upload, the specific content range being sent must be noted in the `Content-Range` HTTPS
// header. This can be used in order to split the transfer into several requests for
// a more flexible process.
// For doing that, the client will have to repeatedly extend the transfer session
// to keep the channel open. Otherwise, the session will terminate and the transfer will
// get into `paused_system` phase, and HTTPS requests to the server will be rejected.
// E.g., the client can iterate on chunks of the file, and send them to the
// proxy server while asking the service to extend the session:
// [source,python]
// ----
// path = "/path/to/image"
// MB_per_request = 32
// with open(path, "rb") as disk:
//    size = os.path.getsize(path)
//    chunk_size = 1024*1024*MB_per_request
//    pos = 0
//    while (pos < size):
//       transfer_service.extend()
//       transfer_headers['Content-Range'] = "bytes %d-%d/%d" % (pos, min(pos + chunk_size, size)-1, size)
//       proxy_connection.request(
//          'PUT',
//          url.path,
//          disk.read(chunk_size),
//          headers=transfer_headers
//       )
//       r = proxy_connection.getresponse()
//       print r.status, r.reason, "Completed", "{:.0%}".format(pos/ float(size))
//       pos += chunk_size
// ----
// Similarly, for a download transfer, a `Range` header must be sent, making the download process
// more easily managed by downloading the disk in chunks.
// E.g., the client will again iterate on chunks of the disk image, but this time he/she will download
// it to a local file, rather than uploading its own file to the image:
// [source,python]
// ----
// output_file = "/home/user/downloaded_image"
// MiB_per_request = 32
// chunk_size = 1024*1024*MiB_per_request
// total = disk_size
// with open(output_file, "wb") as disk:
//    pos = 0
//    while pos < total:
//       transfer_service.extend()
//       transfer_headers['Range'] = "bytes=%d-%d" %  (pos, min(total, pos + chunk_size) - 1)
//       proxy_connection.request('GET', proxy_url.path, headers=transfer_headers)
//       r = proxy_connection.getresponse()
//       disk.write(r.read())
//       print "Completed", "{:.0%}".format(pos/ float(total))
//       pos += chunk_size
// ----
// When finishing the transfer, the user should call
// <<services/image_transfer/methods/finalize, finalize>>. This will make the
// final adjustments and verifications for finishing the transfer process.
// For example:
// [source,python]
// ----
// transfer_service.finalize()
// ----
// In case of an error, the transfer's phase will be changed to
// <<types/image_transfer_phase, finished_failure>>, and
// the disk's status will be changed to `Illegal`. Otherwise it will be changed to
// <<types/image_transfer_phase, finished_success>>, and the disk will be ready
// to be used. In both cases, the transfer entity will be removed shortly after.
//
type ImageTransferService struct {
	BaseService
}

func NewImageTransferService(connection *Connection, path string) *ImageTransferService {
	var result ImageTransferService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImageTransferServiceExtendRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceExtendRequest) Header(key, value string) *ImageTransferServiceExtendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceExtendRequest) Query(key, value string) *ImageTransferServiceExtendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceExtendRequest) Send() (*ImageTransferServiceExtendResponse, error) {
	rawURL := fmt.Sprintf("%s%s/extend", p.imageTransferService.Connection.URL(), p.imageTransferService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransferService.Connection.username, p.imageTransferService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransferService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServiceExtendResponse), nil
}

type ImageTransferServiceExtendResponse struct {
}

func (p *ImageTransferService) Extend() *ImageTransferServiceExtendRequest {
	return &ImageTransferServiceExtendRequest{imageTransferService: p}
}

type ImageTransferServiceFinalizeRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceFinalizeRequest) Header(key, value string) *ImageTransferServiceFinalizeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceFinalizeRequest) Query(key, value string) *ImageTransferServiceFinalizeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceFinalizeRequest) Send() (*ImageTransferServiceFinalizeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/finalize", p.imageTransferService.Connection.URL(), p.imageTransferService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransferService.Connection.username, p.imageTransferService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransferService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServiceFinalizeResponse), nil
}

type ImageTransferServiceFinalizeResponse struct {
}

func (p *ImageTransferService) Finalize() *ImageTransferServiceFinalizeRequest {
	return &ImageTransferServiceFinalizeRequest{imageTransferService: p}
}

type ImageTransferServiceGetRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceGetRequest) Header(key, value string) *ImageTransferServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceGetRequest) Query(key, value string) *ImageTransferServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceGetRequest) Send() (*ImageTransferServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransferService.Connection.URL(), p.imageTransferService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransferService.Connection.username, p.imageTransferService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransferService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var imageTransferServiceGetResponse ImageTransferServiceGetResponse
	var imageTransferVar ImageTransfer
	xml.Unmarshal(respBodyBytes, &imageTransferVar)
	imageTransferServiceGetResponse.imageTransfer = &imageTransferVar
	return &imageTransferServiceGetResponse, nil
}

type ImageTransferServiceGetResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransferServiceGetResponse) ImageTransfer() *ImageTransfer {
	return p.imageTransfer
}
func (p *ImageTransferService) Get() *ImageTransferServiceGetRequest {
	return &ImageTransferServiceGetRequest{imageTransferService: p}
}

type ImageTransferServicePauseRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServicePauseRequest) Header(key, value string) *ImageTransferServicePauseRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServicePauseRequest) Query(key, value string) *ImageTransferServicePauseRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServicePauseRequest) Send() (*ImageTransferServicePauseResponse, error) {
	rawURL := fmt.Sprintf("%s%s/pause", p.imageTransferService.Connection.URL(), p.imageTransferService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransferService.Connection.username, p.imageTransferService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransferService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServicePauseResponse), nil
}

type ImageTransferServicePauseResponse struct {
}

func (p *ImageTransferService) Pause() *ImageTransferServicePauseRequest {
	return &ImageTransferServicePauseRequest{imageTransferService: p}
}

type ImageTransferServiceResumeRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceResumeRequest) Header(key, value string) *ImageTransferServiceResumeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceResumeRequest) Query(key, value string) *ImageTransferServiceResumeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceResumeRequest) Send() (*ImageTransferServiceResumeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resume", p.imageTransferService.Connection.URL(), p.imageTransferService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransferService.Connection.username, p.imageTransferService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransferService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServiceResumeResponse), nil
}

type ImageTransferServiceResumeResponse struct {
}

func (p *ImageTransferService) Resume() *ImageTransferServiceResumeRequest {
	return &ImageTransferServiceResumeRequest{imageTransferService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageTransferService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ImageTransferService) String() string {
	return fmt.Sprintf("ImageTransferService:%s", op.Path)
}

//
//
type AssignedVnicProfileService struct {
	BaseService
}

func NewAssignedVnicProfileService(connection *Connection, path string) *AssignedVnicProfileService {
	var result AssignedVnicProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedVnicProfileServiceGetRequest struct {
	assignedVnicProfileService *AssignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
}

func (p *AssignedVnicProfileServiceGetRequest) Header(key, value string) *AssignedVnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfileServiceGetRequest) Query(key, value string) *AssignedVnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfileServiceGetRequest) Send() (*AssignedVnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfileService.Connection.URL(), p.assignedVnicProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedVnicProfileService.Connection.username, p.assignedVnicProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedVnicProfileServiceGetResponse AssignedVnicProfileServiceGetResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedVnicProfileServiceGetResponse.profile = &profileVar
	return &assignedVnicProfileServiceGetResponse, nil
}

type AssignedVnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *AssignedVnicProfileServiceGetResponse) Profile() *VnicProfile {
	return p.profile
}
func (p *AssignedVnicProfileService) Get() *AssignedVnicProfileServiceGetRequest {
	return &AssignedVnicProfileServiceGetRequest{assignedVnicProfileService: p}
}

type AssignedVnicProfileServiceRemoveRequest struct {
	assignedVnicProfileService *AssignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *AssignedVnicProfileServiceRemoveRequest) Header(key, value string) *AssignedVnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfileServiceRemoveRequest) Query(key, value string) *AssignedVnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfileServiceRemoveRequest) Async(async bool) *AssignedVnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedVnicProfileServiceRemoveRequest) Send() (*AssignedVnicProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfileService.Connection.URL(), p.assignedVnicProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedVnicProfileService.Connection.username, p.assignedVnicProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedVnicProfileServiceRemoveResponse), nil
}

type AssignedVnicProfileServiceRemoveResponse struct {
}

func (p *AssignedVnicProfileService) Remove() *AssignedVnicProfileServiceRemoveRequest {
	return &AssignedVnicProfileServiceRemoveRequest{assignedVnicProfileService: p}
}

//
//
func (op *AssignedVnicProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedVnicProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedVnicProfileService) String() string {
	return fmt.Sprintf("AssignedVnicProfileService:%s", op.Path)
}

//
//
type TemplateWatchdogService struct {
	BaseService
}

func NewTemplateWatchdogService(connection *Connection, path string) *TemplateWatchdogService {
	var result TemplateWatchdogService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateWatchdogServiceGetRequest struct {
	templateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
}

func (p *TemplateWatchdogServiceGetRequest) Header(key, value string) *TemplateWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceGetRequest) Query(key, value string) *TemplateWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceGetRequest) Send() (*TemplateWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.Connection.URL(), p.templateWatchdogService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogService.Connection.username, p.templateWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateWatchdogServiceGetResponse TemplateWatchdogServiceGetResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	templateWatchdogServiceGetResponse.watchdog = &watchdogVar
	return &templateWatchdogServiceGetResponse, nil
}

type TemplateWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogServiceGetResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *TemplateWatchdogService) Get() *TemplateWatchdogServiceGetRequest {
	return &TemplateWatchdogServiceGetRequest{templateWatchdogService: p}
}

type TemplateWatchdogServiceRemoveRequest struct {
	templateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *TemplateWatchdogServiceRemoveRequest) Header(key, value string) *TemplateWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceRemoveRequest) Query(key, value string) *TemplateWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceRemoveRequest) Async(async bool) *TemplateWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateWatchdogServiceRemoveRequest) Send() (*TemplateWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.Connection.URL(), p.templateWatchdogService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogService.Connection.username, p.templateWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateWatchdogServiceRemoveResponse), nil
}

type TemplateWatchdogServiceRemoveResponse struct {
}

func (p *TemplateWatchdogService) Remove() *TemplateWatchdogServiceRemoveRequest {
	return &TemplateWatchdogServiceRemoveRequest{templateWatchdogService: p}
}

type TemplateWatchdogServiceUpdateRequest struct {
	templateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	watchdog                *Watchdog
}

func (p *TemplateWatchdogServiceUpdateRequest) Header(key, value string) *TemplateWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Query(key, value string) *TemplateWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Async(async bool) *TemplateWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TemplateWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *TemplateWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}
func (p *TemplateWatchdogServiceUpdateRequest) Send() (*TemplateWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.Connection.URL(), p.templateWatchdogService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogService.Connection.username, p.templateWatchdogService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateWatchdogServiceUpdateResponse TemplateWatchdogServiceUpdateResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	templateWatchdogServiceUpdateResponse.watchdog = &watchdogVar
	return &templateWatchdogServiceUpdateResponse, nil
}

type TemplateWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogServiceUpdateResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *TemplateWatchdogService) Update() *TemplateWatchdogServiceUpdateRequest {
	return &TemplateWatchdogServiceUpdateRequest{templateWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateWatchdogService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateWatchdogService) String() string {
	return fmt.Sprintf("TemplateWatchdogService:%s", op.Path)
}

//
//
type VmSessionService struct {
	BaseService
}

func NewVmSessionService(connection *Connection, path string) *VmSessionService {
	var result VmSessionService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmSessionServiceGetRequest struct {
	vmSessionService *VmSessionService
	header           map[string]string
	query            map[string]string
}

func (p *VmSessionServiceGetRequest) Header(key, value string) *VmSessionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmSessionServiceGetRequest) Query(key, value string) *VmSessionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmSessionServiceGetRequest) Send() (*VmSessionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionService.Connection.URL(), p.vmSessionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmSessionService.Connection.username, p.vmSessionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmSessionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmSessionServiceGetResponse VmSessionServiceGetResponse
	var sessionVar Session
	xml.Unmarshal(respBodyBytes, &sessionVar)
	vmSessionServiceGetResponse.session = &sessionVar
	return &vmSessionServiceGetResponse, nil
}

type VmSessionServiceGetResponse struct {
	session *Session
}

func (p *VmSessionServiceGetResponse) Session() *Session {
	return p.session
}
func (p *VmSessionService) Get() *VmSessionServiceGetRequest {
	return &VmSessionServiceGetRequest{vmSessionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmSessionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmSessionService) String() string {
	return fmt.Sprintf("VmSessionService:%s", op.Path)
}

//
//
type VmNicService struct {
	BaseService
}

func NewVmNicService(connection *Connection, path string) *VmNicService {
	var result VmNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNicServiceActivateRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceActivateRequest) Header(key, value string) *VmNicServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceActivateRequest) Query(key, value string) *VmNicServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceActivateRequest) Async(async bool) *VmNicServiceActivateRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceActivateRequest) Send() (*VmNicServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.vmNicService.Connection.URL(), p.vmNicService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicService.Connection.username, p.vmNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmNicServiceActivateResponse), nil
}

type VmNicServiceActivateResponse struct {
}

func (p *VmNicService) Activate() *VmNicServiceActivateRequest {
	return &VmNicServiceActivateRequest{vmNicService: p}
}

type VmNicServiceDeactivateRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceDeactivateRequest) Header(key, value string) *VmNicServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceDeactivateRequest) Query(key, value string) *VmNicServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceDeactivateRequest) Async(async bool) *VmNicServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceDeactivateRequest) Send() (*VmNicServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.vmNicService.Connection.URL(), p.vmNicService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicService.Connection.username, p.vmNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmNicServiceDeactivateResponse), nil
}

type VmNicServiceDeactivateResponse struct {
}

func (p *VmNicService) Deactivate() *VmNicServiceDeactivateRequest {
	return &VmNicServiceDeactivateRequest{vmNicService: p}
}

type VmNicServiceGetRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
}

func (p *VmNicServiceGetRequest) Header(key, value string) *VmNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceGetRequest) Query(key, value string) *VmNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceGetRequest) Send() (*VmNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.Connection.URL(), p.vmNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicService.Connection.username, p.vmNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNicServiceGetResponse VmNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	vmNicServiceGetResponse.nic = &nicVar
	return &vmNicServiceGetResponse, nil
}

type VmNicServiceGetResponse struct {
	nic *Nic
}

func (p *VmNicServiceGetResponse) Nic() *Nic {
	return p.nic
}
func (p *VmNicService) Get() *VmNicServiceGetRequest {
	return &VmNicServiceGetRequest{vmNicService: p}
}

type VmNicServiceRemoveRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceRemoveRequest) Header(key, value string) *VmNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceRemoveRequest) Query(key, value string) *VmNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceRemoveRequest) Async(async bool) *VmNicServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceRemoveRequest) Send() (*VmNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.Connection.URL(), p.vmNicService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicService.Connection.username, p.vmNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmNicServiceRemoveResponse), nil
}

type VmNicServiceRemoveResponse struct {
}

func (p *VmNicService) Remove() *VmNicServiceRemoveRequest {
	return &VmNicServiceRemoveRequest{vmNicService: p}
}

type VmNicServiceUpdateRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
	nic          *Nic
}

func (p *VmNicServiceUpdateRequest) Header(key, value string) *VmNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceUpdateRequest) Query(key, value string) *VmNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceUpdateRequest) Async(async bool) *VmNicServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceUpdateRequest) Nic(nic *Nic) *VmNicServiceUpdateRequest {
	p.nic = nic
	return p
}
func (p *VmNicServiceUpdateRequest) Send() (*VmNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.Connection.URL(), p.vmNicService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicService.Connection.username, p.vmNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNicServiceUpdateResponse VmNicServiceUpdateResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	vmNicServiceUpdateResponse.nic = &nicVar
	return &vmNicServiceUpdateResponse, nil
}

type VmNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *VmNicServiceUpdateResponse) Nic() *Nic {
	return p.nic
}
func (p *VmNicService) Update() *VmNicServiceUpdateRequest {
	return &VmNicServiceUpdateRequest{vmNicService: p}
}

//
// Reference to the service that manages the network filter parameters of the NIC.
// A single top-level network filter may assigned to the NIC by the NIC's <<types/vnic_profile,vNIC Profile>>.
//
func (op *VmNicService) NetworkFilterParametersService() *NetworkFilterParametersService {
	return NewNetworkFilterParametersService(op.Connection, fmt.Sprintf("%s/networkfilterparameters", op.Path))
}

//
//
func (op *VmNicService) ReportedDevicesService() *VmReportedDevicesService {
	return NewVmReportedDevicesService(op.Connection, fmt.Sprintf("%s/reporteddevices", op.Path))
}

//
//
func (op *VmNicService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networkfilterparameters" {
		return op.NetworkFilterParametersService(), nil
	}
	if strings.HasPrefix(path, "networkfilterparameters/") {
		return op.NetworkFilterParametersService().Service(path[24:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmNicService) String() string {
	return fmt.Sprintf("VmNicService:%s", op.Path)
}

//
//
type SnapshotsService struct {
	BaseService
}

func NewSnapshotsService(connection *Connection, path string) *SnapshotsService {
	var result SnapshotsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotsServiceAddRequest struct {
	snapshotsService *SnapshotsService
	header           map[string]string
	query            map[string]string
	snapshot         *Snapshot
}

func (p *SnapshotsServiceAddRequest) Header(key, value string) *SnapshotsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotsServiceAddRequest) Query(key, value string) *SnapshotsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotsServiceAddRequest) Snapshot(snapshot *Snapshot) *SnapshotsServiceAddRequest {
	p.snapshot = snapshot
	return p
}
func (p *SnapshotsServiceAddRequest) Send() (*SnapshotsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.Connection.URL(), p.snapshotsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.snapshot)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotsService.Connection.username, p.snapshotsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotsServiceAddResponse SnapshotsServiceAddResponse
	var snapshotVar Snapshot
	xml.Unmarshal(respBodyBytes, &snapshotVar)
	snapshotsServiceAddResponse.snapshot = &snapshotVar
	return &snapshotsServiceAddResponse, nil
}

type SnapshotsServiceAddResponse struct {
	snapshot *Snapshot
}

func (p *SnapshotsServiceAddResponse) Snapshot() *Snapshot {
	return p.snapshot
}
func (p *SnapshotsService) Add() *SnapshotsServiceAddRequest {
	return &SnapshotsServiceAddRequest{snapshotsService: p}
}

type SnapshotsServiceListRequest struct {
	snapshotsService *SnapshotsService
	header           map[string]string
	query            map[string]string
	allContent       *bool
	max              *int64
}

func (p *SnapshotsServiceListRequest) Header(key, value string) *SnapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotsServiceListRequest) Query(key, value string) *SnapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotsServiceListRequest) AllContent(allContent bool) *SnapshotsServiceListRequest {
	p.allContent = &allContent
	return p
}
func (p *SnapshotsServiceListRequest) Max(max int64) *SnapshotsServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotsServiceListRequest) Send() (*SnapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.Connection.URL(), p.snapshotsService.Path)
	values := make(url.Values)
	if p.allContent != nil {
		values["allContent"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotsService.Connection.username, p.snapshotsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotsServiceListResponse SnapshotsServiceListResponse
	var snapshotsVar Snapshots
	xml.Unmarshal(respBodyBytes, &snapshotsVar)
	snapshotsServiceListResponse.snapshots = snapshotsVar.Snapshots
	return &snapshotsServiceListResponse, nil
}

type SnapshotsServiceListResponse struct {
	snapshots []Snapshot
}

func (p *SnapshotsServiceListResponse) Snapshots() []Snapshot {
	return p.snapshots
}
func (p *SnapshotsService) List() *SnapshotsServiceListRequest {
	return &SnapshotsServiceListRequest{snapshotsService: p}
}

//
//
func (op *SnapshotsService) SnapshotService(id string) *SnapshotService {
	return NewSnapshotService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SnapshotService(path)), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotsService) String() string {
	return fmt.Sprintf("SnapshotsService:%s", op.Path)
}

//
// Returns the details of a disk attached to a virtual machine in the export domain.
//
type StorageDomainVmDiskAttachmentsService struct {
	BaseService
}

func NewStorageDomainVmDiskAttachmentsService(connection *Connection, path string) *StorageDomainVmDiskAttachmentsService {
	var result StorageDomainVmDiskAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmDiskAttachmentsServiceListRequest struct {
	storageDomainVmDiskAttachmentsService *StorageDomainVmDiskAttachmentsService
	header                                map[string]string
	query                                 map[string]string
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Header(key, value string) *StorageDomainVmDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Query(key, value string) *StorageDomainVmDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Send() (*StorageDomainVmDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentsService.Connection.URL(), p.storageDomainVmDiskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmDiskAttachmentsService.Connection.username, p.storageDomainVmDiskAttachmentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainVmDiskAttachmentsServiceListResponse StorageDomainVmDiskAttachmentsServiceListResponse
	var attachmentsVar DiskAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	storageDomainVmDiskAttachmentsServiceListResponse.attachments = attachmentsVar.DiskAttachments
	return &storageDomainVmDiskAttachmentsServiceListResponse, nil
}

type StorageDomainVmDiskAttachmentsServiceListResponse struct {
	attachments []DiskAttachment
}

func (p *StorageDomainVmDiskAttachmentsServiceListResponse) Attachments() []DiskAttachment {
	return p.attachments
}
func (p *StorageDomainVmDiskAttachmentsService) List() *StorageDomainVmDiskAttachmentsServiceListRequest {
	return &StorageDomainVmDiskAttachmentsServiceListRequest{storageDomainVmDiskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *StorageDomainVmDiskAttachmentsService) AttachmentService(id string) *StorageDomainVmDiskAttachmentService {
	return NewStorageDomainVmDiskAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmDiskAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainVmDiskAttachmentsService) String() string {
	return fmt.Sprintf("StorageDomainVmDiskAttachmentsService:%s", op.Path)
}

//
//
type ImageService struct {
	BaseService
}

func NewImageService(connection *Connection, path string) *ImageService {
	var result ImageService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImageServiceGetRequest struct {
	imageService *ImageService
	header       map[string]string
	query        map[string]string
}

func (p *ImageServiceGetRequest) Header(key, value string) *ImageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageServiceGetRequest) Query(key, value string) *ImageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageServiceGetRequest) Send() (*ImageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageService.Connection.URL(), p.imageService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageService.Connection.username, p.imageService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var imageServiceGetResponse ImageServiceGetResponse
	var imageVar Image
	xml.Unmarshal(respBodyBytes, &imageVar)
	imageServiceGetResponse.image = &imageVar
	return &imageServiceGetResponse, nil
}

type ImageServiceGetResponse struct {
	image *Image
}

func (p *ImageServiceGetResponse) Image() *Image {
	return p.image
}
func (p *ImageService) Get() *ImageServiceGetRequest {
	return &ImageServiceGetRequest{imageService: p}
}

type ImageServiceImportRequest struct {
	imageService     *ImageService
	header           map[string]string
	query            map[string]string
	async            *bool
	cluster          *Cluster
	disk             *Disk
	importAsTemplate *bool
	storageDomain    *StorageDomain
	template         *Template
}

func (p *ImageServiceImportRequest) Header(key, value string) *ImageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageServiceImportRequest) Query(key, value string) *ImageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageServiceImportRequest) Async(async bool) *ImageServiceImportRequest {
	p.async = &async
	return p
}
func (p *ImageServiceImportRequest) Cluster(cluster *Cluster) *ImageServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *ImageServiceImportRequest) Disk(disk *Disk) *ImageServiceImportRequest {
	p.disk = disk
	return p
}
func (p *ImageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *ImageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}
func (p *ImageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *ImageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *ImageServiceImportRequest) Template(template *Template) *ImageServiceImportRequest {
	p.template = template
	return p
}
func (p *ImageServiceImportRequest) Send() (*ImageServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.imageService.Connection.URL(), p.imageService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageService.Connection.username, p.imageService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageServiceImportResponse), nil
}

type ImageServiceImportResponse struct {
}

func (p *ImageService) Import() *ImageServiceImportRequest {
	return &ImageServiceImportRequest{imageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ImageService) String() string {
	return fmt.Sprintf("ImageService:%s", op.Path)
}

//
//
type InstanceTypeNicsService struct {
	BaseService
}

func NewInstanceTypeNicsService(connection *Connection, path string) *InstanceTypeNicsService {
	var result InstanceTypeNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeNicsServiceAddRequest struct {
	instanceTypeNicsService *InstanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	nic                     *Nic
}

func (p *InstanceTypeNicsServiceAddRequest) Header(key, value string) *InstanceTypeNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicsServiceAddRequest) Query(key, value string) *InstanceTypeNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicsServiceAddRequest) Nic(nic *Nic) *InstanceTypeNicsServiceAddRequest {
	p.nic = nic
	return p
}
func (p *InstanceTypeNicsServiceAddRequest) Send() (*InstanceTypeNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.Connection.URL(), p.instanceTypeNicsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicsService.Connection.username, p.instanceTypeNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeNicsServiceAddResponse InstanceTypeNicsServiceAddResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	instanceTypeNicsServiceAddResponse.nic = &nicVar
	return &instanceTypeNicsServiceAddResponse, nil
}

type InstanceTypeNicsServiceAddResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicsServiceAddResponse) Nic() *Nic {
	return p.nic
}
func (p *InstanceTypeNicsService) Add() *InstanceTypeNicsServiceAddRequest {
	return &InstanceTypeNicsServiceAddRequest{instanceTypeNicsService: p}
}

type InstanceTypeNicsServiceListRequest struct {
	instanceTypeNicsService *InstanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
	search                  *string
}

func (p *InstanceTypeNicsServiceListRequest) Header(key, value string) *InstanceTypeNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Query(key, value string) *InstanceTypeNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Max(max int64) *InstanceTypeNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypeNicsServiceListRequest) Search(search string) *InstanceTypeNicsServiceListRequest {
	p.search = &search
	return p
}
func (p *InstanceTypeNicsServiceListRequest) Send() (*InstanceTypeNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.Connection.URL(), p.instanceTypeNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicsService.Connection.username, p.instanceTypeNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeNicsServiceListResponse InstanceTypeNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	instanceTypeNicsServiceListResponse.nics = nicsVar.Nics
	return &instanceTypeNicsServiceListResponse, nil
}

type InstanceTypeNicsServiceListResponse struct {
	nics []Nic
}

func (p *InstanceTypeNicsServiceListResponse) Nics() []Nic {
	return p.nics
}
func (p *InstanceTypeNicsService) List() *InstanceTypeNicsServiceListRequest {
	return &InstanceTypeNicsServiceListRequest{instanceTypeNicsService: p}
}

//
//
func (op *InstanceTypeNicsService) NicService(id string) *InstanceTypeNicService {
	return NewInstanceTypeNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeNicsService) String() string {
	return fmt.Sprintf("InstanceTypeNicsService:%s", op.Path)
}

//
//
type OperatingSystemsService struct {
	BaseService
}

func NewOperatingSystemsService(connection *Connection, path string) *OperatingSystemsService {
	var result OperatingSystemsService
	result.Connection = connection
	result.Path = path
	return &result
}

type OperatingSystemsServiceListRequest struct {
	operatingSystemsService *OperatingSystemsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *OperatingSystemsServiceListRequest) Header(key, value string) *OperatingSystemsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OperatingSystemsServiceListRequest) Query(key, value string) *OperatingSystemsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OperatingSystemsServiceListRequest) Max(max int64) *OperatingSystemsServiceListRequest {
	p.max = &max
	return p
}
func (p *OperatingSystemsServiceListRequest) Send() (*OperatingSystemsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemsService.Connection.URL(), p.operatingSystemsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.operatingSystemsService.Connection.username, p.operatingSystemsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.operatingSystemsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var operatingSystemsServiceListResponse OperatingSystemsServiceListResponse
	var operatingSystemVar OperatingSystemInfos
	xml.Unmarshal(respBodyBytes, &operatingSystemVar)
	operatingSystemsServiceListResponse.operatingSystem = operatingSystemVar.OperatingSystemInfos
	return &operatingSystemsServiceListResponse, nil
}

type OperatingSystemsServiceListResponse struct {
	operatingSystem []OperatingSystemInfo
}

func (p *OperatingSystemsServiceListResponse) OperatingSystem() []OperatingSystemInfo {
	return p.operatingSystem
}
func (p *OperatingSystemsService) List() *OperatingSystemsServiceListRequest {
	return &OperatingSystemsServiceListRequest{operatingSystemsService: p}
}

//
//
func (op *OperatingSystemsService) OperatingSystemService(id string) *OperatingSystemService {
	return NewOperatingSystemService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OperatingSystemsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.OperatingSystemService(path)), nil
	}
	return op.OperatingSystemService(path[:index]).Service(path[index+1:])
}

func (op *OperatingSystemsService) String() string {
	return fmt.Sprintf("OperatingSystemsService:%s", op.Path)
}

//
// A service to manage a network interface of a host.
//
type HostNicService struct {
	BaseService
}

func NewHostNicService(connection *Connection, path string) *HostNicService {
	var result HostNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNicServiceGetRequest struct {
	hostNicService *HostNicService
	header         map[string]string
	query          map[string]string
}

func (p *HostNicServiceGetRequest) Header(key, value string) *HostNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicServiceGetRequest) Query(key, value string) *HostNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicServiceGetRequest) Send() (*HostNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNicService.Connection.URL(), p.hostNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNicService.Connection.username, p.hostNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostNicServiceGetResponse HostNicServiceGetResponse
	var nicVar HostNic
	xml.Unmarshal(respBodyBytes, &nicVar)
	hostNicServiceGetResponse.nic = &nicVar
	return &hostNicServiceGetResponse, nil
}

type HostNicServiceGetResponse struct {
	nic *HostNic
}

func (p *HostNicServiceGetResponse) Nic() *HostNic {
	return p.nic
}
func (p *HostNicService) Get() *HostNicServiceGetRequest {
	return &HostNicServiceGetRequest{hostNicService: p}
}

type HostNicServiceUpdateVirtualFunctionsConfigurationRequest struct {
	hostNicService                *HostNicService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Header(key, value string) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Query(key, value string) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Async(async bool) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.async = &async
	return p
}
func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) VirtualFunctionsConfiguration(virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.virtualFunctionsConfiguration = virtualFunctionsConfiguration
	return p
}
func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Send() (*HostNicServiceUpdateVirtualFunctionsConfigurationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/updatevirtualfunctionsconfiguration", p.hostNicService.Connection.URL(), p.hostNicService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.VirtualFunctionsConfiguration(p.virtualFunctionsConfiguration)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNicService.Connection.username, p.hostNicService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostNicServiceUpdateVirtualFunctionsConfigurationResponse), nil
}

type HostNicServiceUpdateVirtualFunctionsConfigurationResponse struct {
}

func (p *HostNicService) UpdateVirtualFunctionsConfiguration() *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	return &HostNicServiceUpdateVirtualFunctionsConfigurationRequest{hostNicService: p}
}

//
// Reference to the service that manages the network attachments assigned to this network interface.
//
func (op *HostNicService) NetworkAttachmentsService() *NetworkAttachmentsService {
	return NewNetworkAttachmentsService(op.Connection, fmt.Sprintf("%s/networkattachments", op.Path))
}

//
// Reference to the service that manages the network labels assigned to this network interface.
//
func (op *HostNicService) NetworkLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.Connection, fmt.Sprintf("%s/networklabels", op.Path))
}

//
//
func (op *HostNicService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Retrieves sub-collection resource of network labels that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *HostNicService) VirtualFunctionAllowedLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.Connection, fmt.Sprintf("%s/virtualfunctionallowedlabels", op.Path))
}

//
// Retrieves sub-collection resource of networks that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *HostNicService) VirtualFunctionAllowedNetworksService() *VirtualFunctionAllowedNetworksService {
	return NewVirtualFunctionAllowedNetworksService(op.Connection, fmt.Sprintf("%s/virtualfunctionallowednetworks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "virtualfunctionallowedlabels" {
		return op.VirtualFunctionAllowedLabelsService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowedlabels/") {
		return op.VirtualFunctionAllowedLabelsService().Service(path[29:])
	}
	if path == "virtualfunctionallowednetworks" {
		return op.VirtualFunctionAllowedNetworksService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowednetworks/") {
		return op.VirtualFunctionAllowedNetworksService().Service(path[31:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostNicService) String() string {
	return fmt.Sprintf("HostNicService:%s", op.Path)
}

//
//
type IscsiBondsService struct {
	BaseService
}

func NewIscsiBondsService(connection *Connection, path string) *IscsiBondsService {
	var result IscsiBondsService
	result.Connection = connection
	result.Path = path
	return &result
}

type IscsiBondsServiceAddRequest struct {
	iscsiBondsService *IscsiBondsService
	header            map[string]string
	query             map[string]string
	bond              *IscsiBond
}

func (p *IscsiBondsServiceAddRequest) Header(key, value string) *IscsiBondsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondsServiceAddRequest) Query(key, value string) *IscsiBondsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondsServiceAddRequest) Bond(bond *IscsiBond) *IscsiBondsServiceAddRequest {
	p.bond = bond
	return p
}
func (p *IscsiBondsServiceAddRequest) Send() (*IscsiBondsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.Connection.URL(), p.iscsiBondsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bond)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondsService.Connection.username, p.iscsiBondsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var iscsiBondsServiceAddResponse IscsiBondsServiceAddResponse
	var bondVar IscsiBond
	xml.Unmarshal(respBodyBytes, &bondVar)
	iscsiBondsServiceAddResponse.bond = &bondVar
	return &iscsiBondsServiceAddResponse, nil
}

type IscsiBondsServiceAddResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondsServiceAddResponse) Bond() *IscsiBond {
	return p.bond
}
func (p *IscsiBondsService) Add() *IscsiBondsServiceAddRequest {
	return &IscsiBondsServiceAddRequest{iscsiBondsService: p}
}

type IscsiBondsServiceListRequest struct {
	iscsiBondsService *IscsiBondsService
	header            map[string]string
	query             map[string]string
	max               *int64
}

func (p *IscsiBondsServiceListRequest) Header(key, value string) *IscsiBondsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondsServiceListRequest) Query(key, value string) *IscsiBondsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondsServiceListRequest) Max(max int64) *IscsiBondsServiceListRequest {
	p.max = &max
	return p
}
func (p *IscsiBondsServiceListRequest) Send() (*IscsiBondsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.Connection.URL(), p.iscsiBondsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondsService.Connection.username, p.iscsiBondsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var iscsiBondsServiceListResponse IscsiBondsServiceListResponse
	var bondsVar IscsiBonds
	xml.Unmarshal(respBodyBytes, &bondsVar)
	iscsiBondsServiceListResponse.bonds = bondsVar.IscsiBonds
	return &iscsiBondsServiceListResponse, nil
}

type IscsiBondsServiceListResponse struct {
	bonds []IscsiBond
}

func (p *IscsiBondsServiceListResponse) Bonds() []IscsiBond {
	return p.bonds
}
func (p *IscsiBondsService) List() *IscsiBondsServiceListRequest {
	return &IscsiBondsServiceListRequest{iscsiBondsService: p}
}

//
//
func (op *IscsiBondsService) IscsiBondService(id string) *IscsiBondService {
	return NewIscsiBondService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IscsiBondsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.IscsiBondService(path)), nil
	}
	return op.IscsiBondService(path[:index]).Service(path[index+1:])
}

func (op *IscsiBondsService) String() string {
	return fmt.Sprintf("IscsiBondsService:%s", op.Path)
}

//
// A service to manage the users in the system.
//
type UsersService struct {
	BaseService
}

func NewUsersService(connection *Connection, path string) *UsersService {
	var result UsersService
	result.Connection = connection
	result.Path = path
	return &result
}

type UsersServiceAddRequest struct {
	usersService *UsersService
	header       map[string]string
	query        map[string]string
	user         *User
}

func (p *UsersServiceAddRequest) Header(key, value string) *UsersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UsersServiceAddRequest) Query(key, value string) *UsersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UsersServiceAddRequest) User(user *User) *UsersServiceAddRequest {
	p.user = user
	return p
}
func (p *UsersServiceAddRequest) Send() (*UsersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.usersService.Connection.URL(), p.usersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.user)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.usersService.Connection.username, p.usersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.usersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var usersServiceAddResponse UsersServiceAddResponse
	var userVar User
	xml.Unmarshal(respBodyBytes, &userVar)
	usersServiceAddResponse.user = &userVar
	return &usersServiceAddResponse, nil
}

type UsersServiceAddResponse struct {
	user *User
}

func (p *UsersServiceAddResponse) User() *User {
	return p.user
}
func (p *UsersService) Add() *UsersServiceAddRequest {
	return &UsersServiceAddRequest{usersService: p}
}

type UsersServiceListRequest struct {
	usersService  *UsersService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *UsersServiceListRequest) Header(key, value string) *UsersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UsersServiceListRequest) Query(key, value string) *UsersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UsersServiceListRequest) CaseSensitive(caseSensitive bool) *UsersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *UsersServiceListRequest) Max(max int64) *UsersServiceListRequest {
	p.max = &max
	return p
}
func (p *UsersServiceListRequest) Search(search string) *UsersServiceListRequest {
	p.search = &search
	return p
}
func (p *UsersServiceListRequest) Send() (*UsersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.usersService.Connection.URL(), p.usersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.usersService.Connection.username, p.usersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.usersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var usersServiceListResponse UsersServiceListResponse
	var usersVar Users
	xml.Unmarshal(respBodyBytes, &usersVar)
	usersServiceListResponse.users = usersVar.Users
	return &usersServiceListResponse, nil
}

type UsersServiceListResponse struct {
	users []User
}

func (p *UsersServiceListResponse) Users() []User {
	return p.users
}
func (p *UsersService) List() *UsersServiceListRequest {
	return &UsersServiceListRequest{usersService: p}
}

//
//
func (op *UsersService) UserService(id string) *UserService {
	return NewUserService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UsersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UserService(path)), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *UsersService) String() string {
	return fmt.Sprintf("UsersService:%s", op.Path)
}

//
//
type GroupsService struct {
	BaseService
}

func NewGroupsService(connection *Connection, path string) *GroupsService {
	var result GroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type GroupsServiceAddRequest struct {
	groupsService *GroupsService
	header        map[string]string
	query         map[string]string
	group         *Group
}

func (p *GroupsServiceAddRequest) Header(key, value string) *GroupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupsServiceAddRequest) Query(key, value string) *GroupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupsServiceAddRequest) Group(group *Group) *GroupsServiceAddRequest {
	p.group = group
	return p
}
func (p *GroupsServiceAddRequest) Send() (*GroupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.Connection.URL(), p.groupsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.group)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.groupsService.Connection.username, p.groupsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.groupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var groupsServiceAddResponse GroupsServiceAddResponse
	var groupVar Group
	xml.Unmarshal(respBodyBytes, &groupVar)
	groupsServiceAddResponse.group = &groupVar
	return &groupsServiceAddResponse, nil
}

type GroupsServiceAddResponse struct {
	group *Group
}

func (p *GroupsServiceAddResponse) Group() *Group {
	return p.group
}
func (p *GroupsService) Add() *GroupsServiceAddRequest {
	return &GroupsServiceAddRequest{groupsService: p}
}

type GroupsServiceListRequest struct {
	groupsService *GroupsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *GroupsServiceListRequest) Header(key, value string) *GroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupsServiceListRequest) Query(key, value string) *GroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupsServiceListRequest) CaseSensitive(caseSensitive bool) *GroupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *GroupsServiceListRequest) Max(max int64) *GroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *GroupsServiceListRequest) Search(search string) *GroupsServiceListRequest {
	p.search = &search
	return p
}
func (p *GroupsServiceListRequest) Send() (*GroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.Connection.URL(), p.groupsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.groupsService.Connection.username, p.groupsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.groupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var groupsServiceListResponse GroupsServiceListResponse
	var groupsVar Groups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	groupsServiceListResponse.groups = groupsVar.Groups
	return &groupsServiceListResponse, nil
}

type GroupsServiceListResponse struct {
	groups []Group
}

func (p *GroupsServiceListResponse) Groups() []Group {
	return p.groups
}
func (p *GroupsService) List() *GroupsServiceListRequest {
	return &GroupsServiceListRequest{groupsService: p}
}

//
//
func (op *GroupsService) GroupService(id string) *GroupService {
	return NewGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *GroupsService) String() string {
	return fmt.Sprintf("GroupsService:%s", op.Path)
}

//
// A service to view details of an authentication domain in the system.
//
type DomainService struct {
	BaseService
}

func NewDomainService(connection *Connection, path string) *DomainService {
	var result DomainService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainServiceGetRequest struct {
	domainService *DomainService
	header        map[string]string
	query         map[string]string
}

func (p *DomainServiceGetRequest) Header(key, value string) *DomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainServiceGetRequest) Query(key, value string) *DomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainServiceGetRequest) Send() (*DomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainService.Connection.URL(), p.domainService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainService.Connection.username, p.domainService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var domainServiceGetResponse DomainServiceGetResponse
	var domainVar Domain
	xml.Unmarshal(respBodyBytes, &domainVar)
	domainServiceGetResponse.domain = &domainVar
	return &domainServiceGetResponse, nil
}

type DomainServiceGetResponse struct {
	domain *Domain
}

func (p *DomainServiceGetResponse) Domain() *Domain {
	return p.domain
}
func (p *DomainService) Get() *DomainServiceGetRequest {
	return &DomainServiceGetRequest{domainService: p}
}

//
// Reference to a service to manage domain groups.
//
func (op *DomainService) GroupsService() *DomainGroupsService {
	return NewDomainGroupsService(op.Connection, fmt.Sprintf("%s/groups", op.Path))
}

//
// Reference to a service to manage domain users.
//
func (op *DomainService) UsersService() *DomainUsersService {
	return NewDomainUsersService(op.Connection, fmt.Sprintf("%s/users", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainService) String() string {
	return fmt.Sprintf("DomainService:%s", op.Path)
}

//
//
type SshPublicKeysService struct {
	BaseService
}

func NewSshPublicKeysService(connection *Connection, path string) *SshPublicKeysService {
	var result SshPublicKeysService
	result.Connection = connection
	result.Path = path
	return &result
}

type SshPublicKeysServiceAddRequest struct {
	sshPublicKeysService *SshPublicKeysService
	header               map[string]string
	query                map[string]string
	key                  *SshPublicKey
}

func (p *SshPublicKeysServiceAddRequest) Header(key, value string) *SshPublicKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeysServiceAddRequest) Query(key, value string) *SshPublicKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeysServiceAddRequest) Key(key *SshPublicKey) *SshPublicKeysServiceAddRequest {
	p.key = key
	return p
}
func (p *SshPublicKeysServiceAddRequest) Send() (*SshPublicKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.Connection.URL(), p.sshPublicKeysService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.key)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeysService.Connection.username, p.sshPublicKeysService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var sshPublicKeysServiceAddResponse SshPublicKeysServiceAddResponse
	var keyVar SshPublicKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	sshPublicKeysServiceAddResponse.key = &keyVar
	return &sshPublicKeysServiceAddResponse, nil
}

type SshPublicKeysServiceAddResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeysServiceAddResponse) Key() *SshPublicKey {
	return p.key
}
func (p *SshPublicKeysService) Add() *SshPublicKeysServiceAddRequest {
	return &SshPublicKeysServiceAddRequest{sshPublicKeysService: p}
}

type SshPublicKeysServiceListRequest struct {
	sshPublicKeysService *SshPublicKeysService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *SshPublicKeysServiceListRequest) Header(key, value string) *SshPublicKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeysServiceListRequest) Query(key, value string) *SshPublicKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeysServiceListRequest) Max(max int64) *SshPublicKeysServiceListRequest {
	p.max = &max
	return p
}
func (p *SshPublicKeysServiceListRequest) Send() (*SshPublicKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.Connection.URL(), p.sshPublicKeysService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeysService.Connection.username, p.sshPublicKeysService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var sshPublicKeysServiceListResponse SshPublicKeysServiceListResponse
	var keysVar SshPublicKeys
	xml.Unmarshal(respBodyBytes, &keysVar)
	sshPublicKeysServiceListResponse.keys = keysVar.SshPublicKeys
	return &sshPublicKeysServiceListResponse, nil
}

type SshPublicKeysServiceListResponse struct {
	keys []SshPublicKey
}

func (p *SshPublicKeysServiceListResponse) Keys() []SshPublicKey {
	return p.keys
}
func (p *SshPublicKeysService) List() *SshPublicKeysServiceListRequest {
	return &SshPublicKeysServiceListRequest{sshPublicKeysService: p}
}

//
//
func (op *SshPublicKeysService) KeyService(id string) *SshPublicKeyService {
	return NewSshPublicKeyService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SshPublicKeysService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KeyService(path)), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *SshPublicKeysService) String() string {
	return fmt.Sprintf("SshPublicKeysService:%s", op.Path)
}

//
// A service to view a domain user in the system.
//
type DomainUserService struct {
	BaseService
}

func NewDomainUserService(connection *Connection, path string) *DomainUserService {
	var result DomainUserService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainUserServiceGetRequest struct {
	domainUserService *DomainUserService
	header            map[string]string
	query             map[string]string
}

func (p *DomainUserServiceGetRequest) Header(key, value string) *DomainUserServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainUserServiceGetRequest) Query(key, value string) *DomainUserServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainUserServiceGetRequest) Send() (*DomainUserServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainUserService.Connection.URL(), p.domainUserService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainUserService.Connection.username, p.domainUserService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainUserService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var domainUserServiceGetResponse DomainUserServiceGetResponse
	var userVar User
	xml.Unmarshal(respBodyBytes, &userVar)
	domainUserServiceGetResponse.user = &userVar
	return &domainUserServiceGetResponse, nil
}

type DomainUserServiceGetResponse struct {
	user *User
}

func (p *DomainUserServiceGetResponse) User() *User {
	return p.user
}
func (p *DomainUserService) Get() *DomainUserServiceGetRequest {
	return &DomainUserServiceGetRequest{domainUserService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainUserService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainUserService) String() string {
	return fmt.Sprintf("DomainUserService:%s", op.Path)
}

//
// A service to manage a user in the system.
// Use this service to either get users details or remove users.
// In order to add new users please use
// <<services/users>>.
//
type UserService struct {
	BaseService
}

func NewUserService(connection *Connection, path string) *UserService {
	var result UserService
	result.Connection = connection
	result.Path = path
	return &result
}

type UserServiceGetRequest struct {
	userService *UserService
	header      map[string]string
	query       map[string]string
}

func (p *UserServiceGetRequest) Header(key, value string) *UserServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UserServiceGetRequest) Query(key, value string) *UserServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UserServiceGetRequest) Send() (*UserServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.userService.Connection.URL(), p.userService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.userService.Connection.username, p.userService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.userService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var userServiceGetResponse UserServiceGetResponse
	var userVar User
	xml.Unmarshal(respBodyBytes, &userVar)
	userServiceGetResponse.user = &userVar
	return &userServiceGetResponse, nil
}

type UserServiceGetResponse struct {
	user *User
}

func (p *UserServiceGetResponse) User() *User {
	return p.user
}
func (p *UserService) Get() *UserServiceGetRequest {
	return &UserServiceGetRequest{userService: p}
}

type UserServiceRemoveRequest struct {
	userService *UserService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *UserServiceRemoveRequest) Header(key, value string) *UserServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UserServiceRemoveRequest) Query(key, value string) *UserServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UserServiceRemoveRequest) Async(async bool) *UserServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *UserServiceRemoveRequest) Send() (*UserServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.userService.Connection.URL(), p.userService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.userService.Connection.username, p.userService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.userService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(UserServiceRemoveResponse), nil
}

type UserServiceRemoveResponse struct {
}

func (p *UserService) Remove() *UserServiceRemoveRequest {
	return &UserServiceRemoveRequest{userService: p}
}

//
//
func (op *UserService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *UserService) RolesService() *AssignedRolesService {
	return NewAssignedRolesService(op.Connection, fmt.Sprintf("%s/roles", op.Path))
}

//
//
func (op *UserService) SshPublicKeysService() *SshPublicKeysService {
	return NewSshPublicKeysService(op.Connection, fmt.Sprintf("%s/sshpublickeys", op.Path))
}

//
//
func (op *UserService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UserService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "sshpublickeys" {
		return op.SshPublicKeysService(), nil
	}
	if strings.HasPrefix(path, "sshpublickeys/") {
		return op.SshPublicKeysService().Service(path[14:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *UserService) String() string {
	return fmt.Sprintf("UserService:%s", op.Path)
}

//
// A service to list all authentication domains in the system.
//
type DomainsService struct {
	BaseService
}

func NewDomainsService(connection *Connection, path string) *DomainsService {
	var result DomainsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainsServiceListRequest struct {
	domainsService *DomainsService
	header         map[string]string
	query          map[string]string
	max            *int64
}

func (p *DomainsServiceListRequest) Header(key, value string) *DomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainsServiceListRequest) Query(key, value string) *DomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainsServiceListRequest) Max(max int64) *DomainsServiceListRequest {
	p.max = &max
	return p
}
func (p *DomainsServiceListRequest) Send() (*DomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainsService.Connection.URL(), p.domainsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainsService.Connection.username, p.domainsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var domainsServiceListResponse DomainsServiceListResponse
	var domainsVar Domains
	xml.Unmarshal(respBodyBytes, &domainsVar)
	domainsServiceListResponse.domains = domainsVar.Domains
	return &domainsServiceListResponse, nil
}

type DomainsServiceListResponse struct {
	domains []Domain
}

func (p *DomainsServiceListResponse) Domains() []Domain {
	return p.domains
}
func (p *DomainsService) List() *DomainsServiceListRequest {
	return &DomainsServiceListRequest{domainsService: p}
}

//
// Reference to a service to view details of a domain.
//
func (op *DomainsService) DomainService(id string) *DomainService {
	return NewDomainService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DomainService(path)), nil
	}
	return op.DomainService(path[:index]).Service(path[index+1:])
}

func (op *DomainsService) String() string {
	return fmt.Sprintf("DomainsService:%s", op.Path)
}

//
// A service to list all domain users in the system.
//
type DomainUsersService struct {
	BaseService
}

func NewDomainUsersService(connection *Connection, path string) *DomainUsersService {
	var result DomainUsersService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainUsersServiceListRequest struct {
	domainUsersService *DomainUsersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	max                *int64
	search             *string
}

func (p *DomainUsersServiceListRequest) Header(key, value string) *DomainUsersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainUsersServiceListRequest) Query(key, value string) *DomainUsersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainUsersServiceListRequest) CaseSensitive(caseSensitive bool) *DomainUsersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DomainUsersServiceListRequest) Max(max int64) *DomainUsersServiceListRequest {
	p.max = &max
	return p
}
func (p *DomainUsersServiceListRequest) Search(search string) *DomainUsersServiceListRequest {
	p.search = &search
	return p
}
func (p *DomainUsersServiceListRequest) Send() (*DomainUsersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainUsersService.Connection.URL(), p.domainUsersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainUsersService.Connection.username, p.domainUsersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainUsersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var domainUsersServiceListResponse DomainUsersServiceListResponse
	var usersVar Users
	xml.Unmarshal(respBodyBytes, &usersVar)
	domainUsersServiceListResponse.users = usersVar.Users
	return &domainUsersServiceListResponse, nil
}

type DomainUsersServiceListResponse struct {
	users []User
}

func (p *DomainUsersServiceListResponse) Users() []User {
	return p.users
}
func (p *DomainUsersService) List() *DomainUsersServiceListRequest {
	return &DomainUsersServiceListRequest{domainUsersService: p}
}

//
// Reference to a service to view details of a domain user.
//
func (op *DomainUsersService) UserService(id string) *DomainUserService {
	return NewDomainUserService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainUsersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UserService(path)), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *DomainUsersService) String() string {
	return fmt.Sprintf("DomainUsersService:%s", op.Path)
}

//
//
type DomainGroupsService struct {
	BaseService
}

func NewDomainGroupsService(connection *Connection, path string) *DomainGroupsService {
	var result DomainGroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainGroupsServiceListRequest struct {
	domainGroupsService *DomainGroupsService
	header              map[string]string
	query               map[string]string
	caseSensitive       *bool
	max                 *int64
	search              *string
}

func (p *DomainGroupsServiceListRequest) Header(key, value string) *DomainGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainGroupsServiceListRequest) Query(key, value string) *DomainGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainGroupsServiceListRequest) CaseSensitive(caseSensitive bool) *DomainGroupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DomainGroupsServiceListRequest) Max(max int64) *DomainGroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *DomainGroupsServiceListRequest) Search(search string) *DomainGroupsServiceListRequest {
	p.search = &search
	return p
}
func (p *DomainGroupsServiceListRequest) Send() (*DomainGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupsService.Connection.URL(), p.domainGroupsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainGroupsService.Connection.username, p.domainGroupsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var domainGroupsServiceListResponse DomainGroupsServiceListResponse
	var groupsVar Groups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	domainGroupsServiceListResponse.groups = groupsVar.Groups
	return &domainGroupsServiceListResponse, nil
}

type DomainGroupsServiceListResponse struct {
	groups []Group
}

func (p *DomainGroupsServiceListResponse) Groups() []Group {
	return p.groups
}
func (p *DomainGroupsService) List() *DomainGroupsServiceListRequest {
	return &DomainGroupsServiceListRequest{domainGroupsService: p}
}

//
//
func (op *DomainGroupsService) GroupService(id string) *DomainGroupService {
	return NewDomainGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainGroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *DomainGroupsService) String() string {
	return fmt.Sprintf("DomainGroupsService:%s", op.Path)
}

//
//
type GroupService struct {
	BaseService
}

func NewGroupService(connection *Connection, path string) *GroupService {
	var result GroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type GroupServiceGetRequest struct {
	groupService *GroupService
	header       map[string]string
	query        map[string]string
}

func (p *GroupServiceGetRequest) Header(key, value string) *GroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupServiceGetRequest) Query(key, value string) *GroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupServiceGetRequest) Send() (*GroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupService.Connection.URL(), p.groupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.groupService.Connection.username, p.groupService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.groupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var groupServiceGetResponse GroupServiceGetResponse
	var getVar Group
	xml.Unmarshal(respBodyBytes, &getVar)
	groupServiceGetResponse.get = &getVar
	return &groupServiceGetResponse, nil
}

type GroupServiceGetResponse struct {
	get *Group
}

func (p *GroupServiceGetResponse) Get() *Group {
	return p.get
}
func (p *GroupService) Get() *GroupServiceGetRequest {
	return &GroupServiceGetRequest{groupService: p}
}

type GroupServiceRemoveRequest struct {
	groupService *GroupService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *GroupServiceRemoveRequest) Header(key, value string) *GroupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupServiceRemoveRequest) Query(key, value string) *GroupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupServiceRemoveRequest) Async(async bool) *GroupServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GroupServiceRemoveRequest) Send() (*GroupServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupService.Connection.URL(), p.groupService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.groupService.Connection.username, p.groupService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.groupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GroupServiceRemoveResponse), nil
}

type GroupServiceRemoveResponse struct {
}

func (p *GroupService) Remove() *GroupServiceRemoveRequest {
	return &GroupServiceRemoveRequest{groupService: p}
}

//
//
func (op *GroupService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *GroupService) RolesService() *AssignedRolesService {
	return NewAssignedRolesService(op.Connection, fmt.Sprintf("%s/roles", op.Path))
}

//
//
func (op *GroupService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GroupService) String() string {
	return fmt.Sprintf("GroupService:%s", op.Path)
}

//
//
type DomainGroupService struct {
	BaseService
}

func NewDomainGroupService(connection *Connection, path string) *DomainGroupService {
	var result DomainGroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainGroupServiceGetRequest struct {
	domainGroupService *DomainGroupService
	header             map[string]string
	query              map[string]string
}

func (p *DomainGroupServiceGetRequest) Header(key, value string) *DomainGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainGroupServiceGetRequest) Query(key, value string) *DomainGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainGroupServiceGetRequest) Send() (*DomainGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupService.Connection.URL(), p.domainGroupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainGroupService.Connection.username, p.domainGroupService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var domainGroupServiceGetResponse DomainGroupServiceGetResponse
	var getVar Group
	xml.Unmarshal(respBodyBytes, &getVar)
	domainGroupServiceGetResponse.get = &getVar
	return &domainGroupServiceGetResponse, nil
}

type DomainGroupServiceGetResponse struct {
	get *Group
}

func (p *DomainGroupServiceGetResponse) Get() *Group {
	return p.get
}
func (p *DomainGroupService) Get() *DomainGroupServiceGetRequest {
	return &DomainGroupServiceGetRequest{domainGroupService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainGroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainGroupService) String() string {
	return fmt.Sprintf("DomainGroupService:%s", op.Path)
}

//
//
type SshPublicKeyService struct {
	BaseService
}

func NewSshPublicKeyService(connection *Connection, path string) *SshPublicKeyService {
	var result SshPublicKeyService
	result.Connection = connection
	result.Path = path
	return &result
}

type SshPublicKeyServiceGetRequest struct {
	sshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
}

func (p *SshPublicKeyServiceGetRequest) Header(key, value string) *SshPublicKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceGetRequest) Query(key, value string) *SshPublicKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceGetRequest) Send() (*SshPublicKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.Connection.URL(), p.sshPublicKeyService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeyService.Connection.username, p.sshPublicKeyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var sshPublicKeyServiceGetResponse SshPublicKeyServiceGetResponse
	var keyVar SshPublicKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	sshPublicKeyServiceGetResponse.key = &keyVar
	return &sshPublicKeyServiceGetResponse, nil
}

type SshPublicKeyServiceGetResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeyServiceGetResponse) Key() *SshPublicKey {
	return p.key
}
func (p *SshPublicKeyService) Get() *SshPublicKeyServiceGetRequest {
	return &SshPublicKeyServiceGetRequest{sshPublicKeyService: p}
}

type SshPublicKeyServiceRemoveRequest struct {
	sshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *SshPublicKeyServiceRemoveRequest) Header(key, value string) *SshPublicKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceRemoveRequest) Query(key, value string) *SshPublicKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceRemoveRequest) Async(async bool) *SshPublicKeyServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SshPublicKeyServiceRemoveRequest) Send() (*SshPublicKeyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.Connection.URL(), p.sshPublicKeyService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeyService.Connection.username, p.sshPublicKeyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SshPublicKeyServiceRemoveResponse), nil
}

type SshPublicKeyServiceRemoveResponse struct {
}

func (p *SshPublicKeyService) Remove() *SshPublicKeyServiceRemoveRequest {
	return &SshPublicKeyServiceRemoveRequest{sshPublicKeyService: p}
}

type SshPublicKeyServiceUpdateRequest struct {
	sshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
	key                 *SshPublicKey
}

func (p *SshPublicKeyServiceUpdateRequest) Header(key, value string) *SshPublicKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Query(key, value string) *SshPublicKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Async(async bool) *SshPublicKeyServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *SshPublicKeyServiceUpdateRequest) Key(key *SshPublicKey) *SshPublicKeyServiceUpdateRequest {
	p.key = key
	return p
}
func (p *SshPublicKeyServiceUpdateRequest) Send() (*SshPublicKeyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.Connection.URL(), p.sshPublicKeyService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.key)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeyService.Connection.username, p.sshPublicKeyService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var sshPublicKeyServiceUpdateResponse SshPublicKeyServiceUpdateResponse
	var keyVar SshPublicKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	sshPublicKeyServiceUpdateResponse.key = &keyVar
	return &sshPublicKeyServiceUpdateResponse, nil
}

type SshPublicKeyServiceUpdateResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeyServiceUpdateResponse) Key() *SshPublicKey {
	return p.key
}
func (p *SshPublicKeyService) Update() *SshPublicKeyServiceUpdateRequest {
	return &SshPublicKeyServiceUpdateRequest{sshPublicKeyService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SshPublicKeyService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SshPublicKeyService) String() string {
	return fmt.Sprintf("SshPublicKeyService:%s", op.Path)
}

//
//
type FenceAgentService struct {
	BaseService
}

func NewFenceAgentService(connection *Connection, path string) *FenceAgentService {
	var result FenceAgentService
	result.Connection = connection
	result.Path = path
	return &result
}

type FenceAgentServiceGetRequest struct {
	fenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
}

func (p *FenceAgentServiceGetRequest) Header(key, value string) *FenceAgentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceGetRequest) Query(key, value string) *FenceAgentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceGetRequest) Send() (*FenceAgentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.Connection.URL(), p.fenceAgentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentService.Connection.username, p.fenceAgentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var fenceAgentServiceGetResponse FenceAgentServiceGetResponse
	var agentVar Agent
	xml.Unmarshal(respBodyBytes, &agentVar)
	fenceAgentServiceGetResponse.agent = &agentVar
	return &fenceAgentServiceGetResponse, nil
}

type FenceAgentServiceGetResponse struct {
	agent *Agent
}

func (p *FenceAgentServiceGetResponse) Agent() *Agent {
	return p.agent
}
func (p *FenceAgentService) Get() *FenceAgentServiceGetRequest {
	return &FenceAgentServiceGetRequest{fenceAgentService: p}
}

type FenceAgentServiceRemoveRequest struct {
	fenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *FenceAgentServiceRemoveRequest) Header(key, value string) *FenceAgentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceRemoveRequest) Query(key, value string) *FenceAgentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceRemoveRequest) Async(async bool) *FenceAgentServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *FenceAgentServiceRemoveRequest) Send() (*FenceAgentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.Connection.URL(), p.fenceAgentService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentService.Connection.username, p.fenceAgentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(FenceAgentServiceRemoveResponse), nil
}

type FenceAgentServiceRemoveResponse struct {
}

func (p *FenceAgentService) Remove() *FenceAgentServiceRemoveRequest {
	return &FenceAgentServiceRemoveRequest{fenceAgentService: p}
}

type FenceAgentServiceUpdateRequest struct {
	fenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
	agent             *Agent
	async             *bool
}

func (p *FenceAgentServiceUpdateRequest) Header(key, value string) *FenceAgentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceUpdateRequest) Query(key, value string) *FenceAgentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceUpdateRequest) Agent(agent *Agent) *FenceAgentServiceUpdateRequest {
	p.agent = agent
	return p
}
func (p *FenceAgentServiceUpdateRequest) Async(async bool) *FenceAgentServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *FenceAgentServiceUpdateRequest) Send() (*FenceAgentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.Connection.URL(), p.fenceAgentService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.agent)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentService.Connection.username, p.fenceAgentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var fenceAgentServiceUpdateResponse FenceAgentServiceUpdateResponse
	var agentVar Agent
	xml.Unmarshal(respBodyBytes, &agentVar)
	fenceAgentServiceUpdateResponse.agent = &agentVar
	return &fenceAgentServiceUpdateResponse, nil
}

type FenceAgentServiceUpdateResponse struct {
	agent *Agent
}

func (p *FenceAgentServiceUpdateResponse) Agent() *Agent {
	return p.agent
}
func (p *FenceAgentService) Update() *FenceAgentServiceUpdateRequest {
	return &FenceAgentServiceUpdateRequest{fenceAgentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FenceAgentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FenceAgentService) String() string {
	return fmt.Sprintf("FenceAgentService:%s", op.Path)
}

//
//
type MacPoolService struct {
	BaseService
}

func NewMacPoolService(connection *Connection, path string) *MacPoolService {
	var result MacPoolService
	result.Connection = connection
	result.Path = path
	return &result
}

type MacPoolServiceGetRequest struct {
	macPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
}

func (p *MacPoolServiceGetRequest) Header(key, value string) *MacPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceGetRequest) Query(key, value string) *MacPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceGetRequest) Send() (*MacPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.Connection.URL(), p.macPoolService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolService.Connection.username, p.macPoolService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var macPoolServiceGetResponse MacPoolServiceGetResponse
	var poolVar MacPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	macPoolServiceGetResponse.pool = &poolVar
	return &macPoolServiceGetResponse, nil
}

type MacPoolServiceGetResponse struct {
	pool *MacPool
}

func (p *MacPoolServiceGetResponse) Pool() *MacPool {
	return p.pool
}
func (p *MacPoolService) Get() *MacPoolServiceGetRequest {
	return &MacPoolServiceGetRequest{macPoolService: p}
}

type MacPoolServiceRemoveRequest struct {
	macPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *MacPoolServiceRemoveRequest) Header(key, value string) *MacPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceRemoveRequest) Query(key, value string) *MacPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceRemoveRequest) Async(async bool) *MacPoolServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *MacPoolServiceRemoveRequest) Send() (*MacPoolServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.Connection.URL(), p.macPoolService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolService.Connection.username, p.macPoolService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(MacPoolServiceRemoveResponse), nil
}

type MacPoolServiceRemoveResponse struct {
}

func (p *MacPoolService) Remove() *MacPoolServiceRemoveRequest {
	return &MacPoolServiceRemoveRequest{macPoolService: p}
}

type MacPoolServiceUpdateRequest struct {
	macPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
	pool           *MacPool
}

func (p *MacPoolServiceUpdateRequest) Header(key, value string) *MacPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceUpdateRequest) Query(key, value string) *MacPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceUpdateRequest) Async(async bool) *MacPoolServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *MacPoolServiceUpdateRequest) Pool(pool *MacPool) *MacPoolServiceUpdateRequest {
	p.pool = pool
	return p
}
func (p *MacPoolServiceUpdateRequest) Send() (*MacPoolServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.Connection.URL(), p.macPoolService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.pool)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolService.Connection.username, p.macPoolService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var macPoolServiceUpdateResponse MacPoolServiceUpdateResponse
	var poolVar MacPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	macPoolServiceUpdateResponse.pool = &poolVar
	return &macPoolServiceUpdateResponse, nil
}

type MacPoolServiceUpdateResponse struct {
	pool *MacPool
}

func (p *MacPoolServiceUpdateResponse) Pool() *MacPool {
	return p.pool
}
func (p *MacPoolService) Update() *MacPoolServiceUpdateRequest {
	return &MacPoolServiceUpdateRequest{macPoolService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MacPoolService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MacPoolService) String() string {
	return fmt.Sprintf("MacPoolService:%s", op.Path)
}

//
//
type AssignedCpuProfilesService struct {
	BaseService
}

func NewAssignedCpuProfilesService(connection *Connection, path string) *AssignedCpuProfilesService {
	var result AssignedCpuProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedCpuProfilesServiceAddRequest struct {
	assignedCpuProfilesService *AssignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	profile                    *CpuProfile
}

func (p *AssignedCpuProfilesServiceAddRequest) Header(key, value string) *AssignedCpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceAddRequest) Query(key, value string) *AssignedCpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *AssignedCpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *AssignedCpuProfilesServiceAddRequest) Send() (*AssignedCpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.Connection.URL(), p.assignedCpuProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedCpuProfilesService.Connection.username, p.assignedCpuProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedCpuProfilesServiceAddResponse AssignedCpuProfilesServiceAddResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedCpuProfilesServiceAddResponse.profile = &profileVar
	return &assignedCpuProfilesServiceAddResponse, nil
}

type AssignedCpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *AssignedCpuProfilesServiceAddResponse) Profile() *CpuProfile {
	return p.profile
}
func (p *AssignedCpuProfilesService) Add() *AssignedCpuProfilesServiceAddRequest {
	return &AssignedCpuProfilesServiceAddRequest{assignedCpuProfilesService: p}
}

type AssignedCpuProfilesServiceListRequest struct {
	assignedCpuProfilesService *AssignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	max                        *int64
}

func (p *AssignedCpuProfilesServiceListRequest) Header(key, value string) *AssignedCpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Query(key, value string) *AssignedCpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Max(max int64) *AssignedCpuProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedCpuProfilesServiceListRequest) Send() (*AssignedCpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.Connection.URL(), p.assignedCpuProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedCpuProfilesService.Connection.username, p.assignedCpuProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedCpuProfilesServiceListResponse AssignedCpuProfilesServiceListResponse
	var profilesVar CpuProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	assignedCpuProfilesServiceListResponse.profiles = profilesVar.CpuProfiles
	return &assignedCpuProfilesServiceListResponse, nil
}

type AssignedCpuProfilesServiceListResponse struct {
	profiles []CpuProfile
}

func (p *AssignedCpuProfilesServiceListResponse) Profiles() []CpuProfile {
	return p.profiles
}
func (p *AssignedCpuProfilesService) List() *AssignedCpuProfilesServiceListRequest {
	return &AssignedCpuProfilesServiceListRequest{assignedCpuProfilesService: p}
}

//
//
func (op *AssignedCpuProfilesService) ProfileService(id string) *AssignedCpuProfileService {
	return NewAssignedCpuProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedCpuProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedCpuProfilesService) String() string {
	return fmt.Sprintf("AssignedCpuProfilesService:%s", op.Path)
}

//
//
type StorageServerConnectionExtensionsService struct {
	BaseService
}

func NewStorageServerConnectionExtensionsService(connection *Connection, path string) *StorageServerConnectionExtensionsService {
	var result StorageServerConnectionExtensionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionExtensionsServiceAddRequest struct {
	storageServerConnectionExtensionsService *StorageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	extension                                *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Header(key, value string) *StorageServerConnectionExtensionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Query(key, value string) *StorageServerConnectionExtensionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Extension(extension *StorageConnectionExtension) *StorageServerConnectionExtensionsServiceAddRequest {
	p.extension = extension
	return p
}
func (p *StorageServerConnectionExtensionsServiceAddRequest) Send() (*StorageServerConnectionExtensionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.Connection.URL(), p.storageServerConnectionExtensionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.extension)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionsService.Connection.username, p.storageServerConnectionExtensionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionExtensionsServiceAddResponse StorageServerConnectionExtensionsServiceAddResponse
	var extensionVar StorageConnectionExtension
	xml.Unmarshal(respBodyBytes, &extensionVar)
	storageServerConnectionExtensionsServiceAddResponse.extension = &extensionVar
	return &storageServerConnectionExtensionsServiceAddResponse, nil
}

type StorageServerConnectionExtensionsServiceAddResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceAddResponse) Extension() *StorageConnectionExtension {
	return p.extension
}
func (p *StorageServerConnectionExtensionsService) Add() *StorageServerConnectionExtensionsServiceAddRequest {
	return &StorageServerConnectionExtensionsServiceAddRequest{storageServerConnectionExtensionsService: p}
}

type StorageServerConnectionExtensionsServiceListRequest struct {
	storageServerConnectionExtensionsService *StorageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	max                                      *int64
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Header(key, value string) *StorageServerConnectionExtensionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Query(key, value string) *StorageServerConnectionExtensionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Max(max int64) *StorageServerConnectionExtensionsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageServerConnectionExtensionsServiceListRequest) Send() (*StorageServerConnectionExtensionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.Connection.URL(), p.storageServerConnectionExtensionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionsService.Connection.username, p.storageServerConnectionExtensionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionExtensionsServiceListResponse StorageServerConnectionExtensionsServiceListResponse
	var extensionsVar StorageConnectionExtensions
	xml.Unmarshal(respBodyBytes, &extensionsVar)
	storageServerConnectionExtensionsServiceListResponse.extensions = extensionsVar.StorageConnectionExtensions
	return &storageServerConnectionExtensionsServiceListResponse, nil
}

type StorageServerConnectionExtensionsServiceListResponse struct {
	extensions []StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceListResponse) Extensions() []StorageConnectionExtension {
	return p.extensions
}
func (p *StorageServerConnectionExtensionsService) List() *StorageServerConnectionExtensionsServiceListRequest {
	return &StorageServerConnectionExtensionsServiceListRequest{storageServerConnectionExtensionsService: p}
}

//
//
func (op *StorageServerConnectionExtensionsService) StorageConnectionExtensionService(id string) *StorageServerConnectionExtensionService {
	return NewStorageServerConnectionExtensionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionExtensionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageConnectionExtensionService(path)), nil
	}
	return op.StorageConnectionExtensionService(path[:index]).Service(path[index+1:])
}

func (op *StorageServerConnectionExtensionsService) String() string {
	return fmt.Sprintf("StorageServerConnectionExtensionsService:%s", op.Path)
}

//
//
type PermissionService struct {
	BaseService
}

func NewPermissionService(connection *Connection, path string) *PermissionService {
	var result PermissionService
	result.Connection = connection
	result.Path = path
	return &result
}

type PermissionServiceGetRequest struct {
	permissionService *PermissionService
	header            map[string]string
	query             map[string]string
}

func (p *PermissionServiceGetRequest) Header(key, value string) *PermissionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermissionServiceGetRequest) Query(key, value string) *PermissionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermissionServiceGetRequest) Send() (*PermissionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permissionService.Connection.URL(), p.permissionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permissionService.Connection.username, p.permissionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permissionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var permissionServiceGetResponse PermissionServiceGetResponse
	var permissionVar Permission
	xml.Unmarshal(respBodyBytes, &permissionVar)
	permissionServiceGetResponse.permission = &permissionVar
	return &permissionServiceGetResponse, nil
}

type PermissionServiceGetResponse struct {
	permission *Permission
}

func (p *PermissionServiceGetResponse) Permission() *Permission {
	return p.permission
}
func (p *PermissionService) Get() *PermissionServiceGetRequest {
	return &PermissionServiceGetRequest{permissionService: p}
}

type PermissionServiceRemoveRequest struct {
	permissionService *PermissionService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *PermissionServiceRemoveRequest) Header(key, value string) *PermissionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermissionServiceRemoveRequest) Query(key, value string) *PermissionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermissionServiceRemoveRequest) Async(async bool) *PermissionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *PermissionServiceRemoveRequest) Send() (*PermissionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permissionService.Connection.URL(), p.permissionService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permissionService.Connection.username, p.permissionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permissionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(PermissionServiceRemoveResponse), nil
}

type PermissionServiceRemoveResponse struct {
}

func (p *PermissionService) Remove() *PermissionServiceRemoveRequest {
	return &PermissionServiceRemoveRequest{permissionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermissionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *PermissionService) String() string {
	return fmt.Sprintf("PermissionService:%s", op.Path)
}

//
//
type DiskProfileService struct {
	BaseService
}

func NewDiskProfileService(connection *Connection, path string) *DiskProfileService {
	var result DiskProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskProfileServiceGetRequest struct {
	diskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
}

func (p *DiskProfileServiceGetRequest) Header(key, value string) *DiskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceGetRequest) Query(key, value string) *DiskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceGetRequest) Send() (*DiskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.Connection.URL(), p.diskProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfileService.Connection.username, p.diskProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskProfileServiceGetResponse DiskProfileServiceGetResponse
	var profileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	diskProfileServiceGetResponse.profile = &profileVar
	return &diskProfileServiceGetResponse, nil
}

type DiskProfileServiceGetResponse struct {
	profile *DiskProfile
}

func (p *DiskProfileServiceGetResponse) Profile() *DiskProfile {
	return p.profile
}
func (p *DiskProfileService) Get() *DiskProfileServiceGetRequest {
	return &DiskProfileServiceGetRequest{diskProfileService: p}
}

type DiskProfileServiceRemoveRequest struct {
	diskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *DiskProfileServiceRemoveRequest) Header(key, value string) *DiskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceRemoveRequest) Query(key, value string) *DiskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceRemoveRequest) Async(async bool) *DiskProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DiskProfileServiceRemoveRequest) Send() (*DiskProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.Connection.URL(), p.diskProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfileService.Connection.username, p.diskProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskProfileServiceRemoveResponse), nil
}

type DiskProfileServiceRemoveResponse struct {
}

func (p *DiskProfileService) Remove() *DiskProfileServiceRemoveRequest {
	return &DiskProfileServiceRemoveRequest{diskProfileService: p}
}

type DiskProfileServiceUpdateRequest struct {
	diskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *DiskProfile
}

func (p *DiskProfileServiceUpdateRequest) Header(key, value string) *DiskProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceUpdateRequest) Query(key, value string) *DiskProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceUpdateRequest) Async(async bool) *DiskProfileServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *DiskProfileServiceUpdateRequest) Profile(profile *DiskProfile) *DiskProfileServiceUpdateRequest {
	p.profile = profile
	return p
}
func (p *DiskProfileServiceUpdateRequest) Send() (*DiskProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.Connection.URL(), p.diskProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfileService.Connection.username, p.diskProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskProfileServiceUpdateResponse DiskProfileServiceUpdateResponse
	var profileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	diskProfileServiceUpdateResponse.profile = &profileVar
	return &diskProfileServiceUpdateResponse, nil
}

type DiskProfileServiceUpdateResponse struct {
	profile *DiskProfile
}

func (p *DiskProfileServiceUpdateResponse) Profile() *DiskProfile {
	return p.profile
}
func (p *DiskProfileService) Update() *DiskProfileServiceUpdateRequest {
	return &DiskProfileServiceUpdateRequest{diskProfileService: p}
}

//
//
func (op *DiskProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskProfileService) String() string {
	return fmt.Sprintf("DiskProfileService:%s", op.Path)
}

//
// This service manages a single affinity group.
//
type AffinityGroupService struct {
	BaseService
}

func NewAffinityGroupService(connection *Connection, path string) *AffinityGroupService {
	var result AffinityGroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupServiceGetRequest struct {
	affinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
}

func (p *AffinityGroupServiceGetRequest) Header(key, value string) *AffinityGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceGetRequest) Query(key, value string) *AffinityGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceGetRequest) Send() (*AffinityGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.Connection.URL(), p.affinityGroupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupService.Connection.username, p.affinityGroupService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityGroupServiceGetResponse AffinityGroupServiceGetResponse
	var groupVar AffinityGroup
	xml.Unmarshal(respBodyBytes, &groupVar)
	affinityGroupServiceGetResponse.group = &groupVar
	return &affinityGroupServiceGetResponse, nil
}

type AffinityGroupServiceGetResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupServiceGetResponse) Group() *AffinityGroup {
	return p.group
}
func (p *AffinityGroupService) Get() *AffinityGroupServiceGetRequest {
	return &AffinityGroupServiceGetRequest{affinityGroupService: p}
}

type AffinityGroupServiceRemoveRequest struct {
	affinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *AffinityGroupServiceRemoveRequest) Header(key, value string) *AffinityGroupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceRemoveRequest) Query(key, value string) *AffinityGroupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceRemoveRequest) Async(async bool) *AffinityGroupServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AffinityGroupServiceRemoveRequest) Send() (*AffinityGroupServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.Connection.URL(), p.affinityGroupService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupService.Connection.username, p.affinityGroupService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityGroupServiceRemoveResponse), nil
}

type AffinityGroupServiceRemoveResponse struct {
}

func (p *AffinityGroupService) Remove() *AffinityGroupServiceRemoveRequest {
	return &AffinityGroupServiceRemoveRequest{affinityGroupService: p}
}

type AffinityGroupServiceUpdateRequest struct {
	affinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
	group                *AffinityGroup
}

func (p *AffinityGroupServiceUpdateRequest) Header(key, value string) *AffinityGroupServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Query(key, value string) *AffinityGroupServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Async(async bool) *AffinityGroupServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *AffinityGroupServiceUpdateRequest) Group(group *AffinityGroup) *AffinityGroupServiceUpdateRequest {
	p.group = group
	return p
}
func (p *AffinityGroupServiceUpdateRequest) Send() (*AffinityGroupServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.Connection.URL(), p.affinityGroupService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.group)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupService.Connection.username, p.affinityGroupService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityGroupServiceUpdateResponse AffinityGroupServiceUpdateResponse
	var groupVar AffinityGroup
	xml.Unmarshal(respBodyBytes, &groupVar)
	affinityGroupServiceUpdateResponse.group = &groupVar
	return &affinityGroupServiceUpdateResponse, nil
}

type AffinityGroupServiceUpdateResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupServiceUpdateResponse) Group() *AffinityGroup {
	return p.group
}
func (p *AffinityGroupService) Update() *AffinityGroupServiceUpdateRequest {
	return &AffinityGroupServiceUpdateRequest{affinityGroupService: p}
}

//
// Returns a reference to the service that manages the
// list of all virtual machines attached to this affinity
// group.
//
func (op *AffinityGroupService) VmsService() *AffinityGroupVmsService {
	return NewAffinityGroupVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupService) String() string {
	return fmt.Sprintf("AffinityGroupService:%s", op.Path)
}

//
//
type UnmanagedNetworksService struct {
	BaseService
}

func NewUnmanagedNetworksService(connection *Connection, path string) *UnmanagedNetworksService {
	var result UnmanagedNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type UnmanagedNetworksServiceListRequest struct {
	unmanagedNetworksService *UnmanagedNetworksService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *UnmanagedNetworksServiceListRequest) Header(key, value string) *UnmanagedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Query(key, value string) *UnmanagedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Max(max int64) *UnmanagedNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *UnmanagedNetworksServiceListRequest) Send() (*UnmanagedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworksService.Connection.URL(), p.unmanagedNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.unmanagedNetworksService.Connection.username, p.unmanagedNetworksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var unmanagedNetworksServiceListResponse UnmanagedNetworksServiceListResponse
	var networksVar UnmanagedNetworks
	xml.Unmarshal(respBodyBytes, &networksVar)
	unmanagedNetworksServiceListResponse.networks = networksVar.UnmanagedNetworks
	return &unmanagedNetworksServiceListResponse, nil
}

type UnmanagedNetworksServiceListResponse struct {
	networks []UnmanagedNetwork
}

func (p *UnmanagedNetworksServiceListResponse) Networks() []UnmanagedNetwork {
	return p.networks
}
func (p *UnmanagedNetworksService) List() *UnmanagedNetworksServiceListRequest {
	return &UnmanagedNetworksServiceListRequest{unmanagedNetworksService: p}
}

//
//
func (op *UnmanagedNetworksService) UnmanagedNetworkService(id string) *UnmanagedNetworkService {
	return NewUnmanagedNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UnmanagedNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UnmanagedNetworkService(path)), nil
	}
	return op.UnmanagedNetworkService(path[:index]).Service(path[index+1:])
}

func (op *UnmanagedNetworksService) String() string {
	return fmt.Sprintf("UnmanagedNetworksService:%s", op.Path)
}

//
//
type VmsService struct {
	BaseService
}

func NewVmsService(connection *Connection, path string) *VmsService {
	var result VmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmsServiceAddRequest struct {
	vmsService       *VmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	vm               *Vm
}

func (p *VmsServiceAddRequest) Header(key, value string) *VmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceAddRequest) Query(key, value string) *VmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceAddRequest) Clone(clone bool) *VmsServiceAddRequest {
	p.clone = &clone
	return p
}
func (p *VmsServiceAddRequest) ClonePermissions(clonePermissions bool) *VmsServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}
func (p *VmsServiceAddRequest) Vm(vm *Vm) *VmsServiceAddRequest {
	p.vm = vm
	return p
}
func (p *VmsServiceAddRequest) Send() (*VmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.Connection.URL(), p.vmsService.Path)
	values := make(url.Values)
	if p.clone != nil {
		values["clone"] = []string{fmt.Sprintf("%v", *p.clone)}
	}
	if p.clonePermissions != nil {
		values["clonePermissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.vm)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmsService.Connection.username, p.vmsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmsServiceAddResponse VmsServiceAddResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	vmsServiceAddResponse.vm = &vmVar
	return &vmsServiceAddResponse, nil
}

type VmsServiceAddResponse struct {
	vm *Vm
}

func (p *VmsServiceAddResponse) Vm() *Vm {
	return p.vm
}
func (p *VmsService) Add() *VmsServiceAddRequest {
	return &VmsServiceAddRequest{vmsService: p}
}

type VmsServiceListRequest struct {
	vmsService    *VmsService
	header        map[string]string
	query         map[string]string
	allContent    *bool
	caseSensitive *bool
	filter        *bool
	max           *int64
	search        *string
}

func (p *VmsServiceListRequest) Header(key, value string) *VmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceListRequest) Query(key, value string) *VmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceListRequest) AllContent(allContent bool) *VmsServiceListRequest {
	p.allContent = &allContent
	return p
}
func (p *VmsServiceListRequest) CaseSensitive(caseSensitive bool) *VmsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *VmsServiceListRequest) Filter(filter bool) *VmsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *VmsServiceListRequest) Max(max int64) *VmsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmsServiceListRequest) Search(search string) *VmsServiceListRequest {
	p.search = &search
	return p
}
func (p *VmsServiceListRequest) Send() (*VmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.Connection.URL(), p.vmsService.Path)
	values := make(url.Values)
	if p.allContent != nil {
		values["allContent"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmsService.Connection.username, p.vmsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmsServiceListResponse VmsServiceListResponse
	var vmsVar Vms
	xml.Unmarshal(respBodyBytes, &vmsVar)
	vmsServiceListResponse.vms = vmsVar.Vms
	return &vmsServiceListResponse, nil
}

type VmsServiceListResponse struct {
	vms []Vm
}

func (p *VmsServiceListResponse) Vms() []Vm {
	return p.vms
}
func (p *VmsService) List() *VmsServiceListRequest {
	return &VmsServiceListRequest{vmsService: p}
}

//
//
func (op *VmsService) VmService(id string) *VmService {
	return NewVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *VmsService) String() string {
	return fmt.Sprintf("VmsService:%s", op.Path)
}

//
//
type StorageDomainTemplateService struct {
	BaseService
}

func NewStorageDomainTemplateService(connection *Connection, path string) *StorageDomainTemplateService {
	var result StorageDomainTemplateService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainTemplateServiceGetRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
}

func (p *StorageDomainTemplateServiceGetRequest) Header(key, value string) *StorageDomainTemplateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceGetRequest) Query(key, value string) *StorageDomainTemplateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceGetRequest) Send() (*StorageDomainTemplateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplateService.Connection.URL(), p.storageDomainTemplateService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainTemplateService.Connection.username, p.storageDomainTemplateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainTemplateServiceGetResponse StorageDomainTemplateServiceGetResponse
	var templateVar Template
	xml.Unmarshal(respBodyBytes, &templateVar)
	storageDomainTemplateServiceGetResponse.template = &templateVar
	return &storageDomainTemplateServiceGetResponse, nil
}

type StorageDomainTemplateServiceGetResponse struct {
	template *Template
}

func (p *StorageDomainTemplateServiceGetResponse) Template() *Template {
	return p.template
}
func (p *StorageDomainTemplateService) Get() *StorageDomainTemplateServiceGetRequest {
	return &StorageDomainTemplateServiceGetRequest{storageDomainTemplateService: p}
}

type StorageDomainTemplateServiceImportRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	storageDomain                *StorageDomain
	template                     *Template
	vm                           *Vm
}

func (p *StorageDomainTemplateServiceImportRequest) Header(key, value string) *StorageDomainTemplateServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Query(key, value string) *StorageDomainTemplateServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Async(async bool) *StorageDomainTemplateServiceImportRequest {
	p.async = &async
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Clone(clone bool) *StorageDomainTemplateServiceImportRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Cluster(cluster *Cluster) *StorageDomainTemplateServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Exclusive(exclusive bool) *StorageDomainTemplateServiceImportRequest {
	p.exclusive = &exclusive
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainTemplateServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Template(template *Template) *StorageDomainTemplateServiceImportRequest {
	p.template = template
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Vm(vm *Vm) *StorageDomainTemplateServiceImportRequest {
	p.vm = vm
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Send() (*StorageDomainTemplateServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.storageDomainTemplateService.Connection.URL(), p.storageDomainTemplateService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Clone(*p.clone)
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Exclusive(*p.exclusive)
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	actionBuilder.Vm(p.vm)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainTemplateService.Connection.username, p.storageDomainTemplateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainTemplateServiceImportResponse), nil
}

type StorageDomainTemplateServiceImportResponse struct {
}

func (p *StorageDomainTemplateService) Import() *StorageDomainTemplateServiceImportRequest {
	return &StorageDomainTemplateServiceImportRequest{storageDomainTemplateService: p}
}

type StorageDomainTemplateServiceRegisterRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	allowPartialImport           *bool
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	template                     *Template
}

func (p *StorageDomainTemplateServiceRegisterRequest) Header(key, value string) *StorageDomainTemplateServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Query(key, value string) *StorageDomainTemplateServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *StorageDomainTemplateServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Async(async bool) *StorageDomainTemplateServiceRegisterRequest {
	p.async = &async
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Clone(clone bool) *StorageDomainTemplateServiceRegisterRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Cluster(cluster *Cluster) *StorageDomainTemplateServiceRegisterRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Exclusive(exclusive bool) *StorageDomainTemplateServiceRegisterRequest {
	p.exclusive = &exclusive
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Template(template *Template) *StorageDomainTemplateServiceRegisterRequest {
	p.template = template
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Send() (*StorageDomainTemplateServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.storageDomainTemplateService.Connection.URL(), p.storageDomainTemplateService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.AllowPartialImport(*p.allowPartialImport)
	actionBuilder.Async(*p.async)
	actionBuilder.Clone(*p.clone)
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Exclusive(*p.exclusive)
	actionBuilder.Template(p.template)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainTemplateService.Connection.username, p.storageDomainTemplateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainTemplateServiceRegisterResponse), nil
}

type StorageDomainTemplateServiceRegisterResponse struct {
}

func (p *StorageDomainTemplateService) Register() *StorageDomainTemplateServiceRegisterRequest {
	return &StorageDomainTemplateServiceRegisterRequest{storageDomainTemplateService: p}
}

type StorageDomainTemplateServiceRemoveRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *StorageDomainTemplateServiceRemoveRequest) Header(key, value string) *StorageDomainTemplateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRemoveRequest) Query(key, value string) *StorageDomainTemplateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRemoveRequest) Async(async bool) *StorageDomainTemplateServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainTemplateServiceRemoveRequest) Send() (*StorageDomainTemplateServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplateService.Connection.URL(), p.storageDomainTemplateService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainTemplateService.Connection.username, p.storageDomainTemplateService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainTemplateServiceRemoveResponse), nil
}

type StorageDomainTemplateServiceRemoveResponse struct {
}

func (p *StorageDomainTemplateService) Remove() *StorageDomainTemplateServiceRemoveRequest {
	return &StorageDomainTemplateServiceRemoveRequest{storageDomainTemplateService: p}
}

//
//
func (op *StorageDomainTemplateService) DisksService() *StorageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainTemplateService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainTemplateService) String() string {
	return fmt.Sprintf("StorageDomainTemplateService:%s", op.Path)
}

//
// Provides read-write access to virtual machines pools.
//
type VmPoolsService struct {
	BaseService
}

func NewVmPoolsService(connection *Connection, path string) *VmPoolsService {
	var result VmPoolsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmPoolsServiceAddRequest struct {
	vmPoolsService *VmPoolsService
	header         map[string]string
	query          map[string]string
	pool           *VmPool
}

func (p *VmPoolsServiceAddRequest) Header(key, value string) *VmPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolsServiceAddRequest) Query(key, value string) *VmPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolsServiceAddRequest) Pool(pool *VmPool) *VmPoolsServiceAddRequest {
	p.pool = pool
	return p
}
func (p *VmPoolsServiceAddRequest) Send() (*VmPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.Connection.URL(), p.vmPoolsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.pool)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolsService.Connection.username, p.vmPoolsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmPoolsServiceAddResponse VmPoolsServiceAddResponse
	var poolVar VmPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	vmPoolsServiceAddResponse.pool = &poolVar
	return &vmPoolsServiceAddResponse, nil
}

type VmPoolsServiceAddResponse struct {
	pool *VmPool
}

func (p *VmPoolsServiceAddResponse) Pool() *VmPool {
	return p.pool
}
func (p *VmPoolsService) Add() *VmPoolsServiceAddRequest {
	return &VmPoolsServiceAddRequest{vmPoolsService: p}
}

type VmPoolsServiceListRequest struct {
	vmPoolsService *VmPoolsService
	header         map[string]string
	query          map[string]string
	caseSensitive  *bool
	filter         *bool
	max            *int64
	search         *string
}

func (p *VmPoolsServiceListRequest) Header(key, value string) *VmPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolsServiceListRequest) Query(key, value string) *VmPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolsServiceListRequest) CaseSensitive(caseSensitive bool) *VmPoolsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *VmPoolsServiceListRequest) Filter(filter bool) *VmPoolsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *VmPoolsServiceListRequest) Max(max int64) *VmPoolsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmPoolsServiceListRequest) Search(search string) *VmPoolsServiceListRequest {
	p.search = &search
	return p
}
func (p *VmPoolsServiceListRequest) Send() (*VmPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.Connection.URL(), p.vmPoolsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolsService.Connection.username, p.vmPoolsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmPoolsServiceListResponse VmPoolsServiceListResponse
	var poolsVar VmPools
	xml.Unmarshal(respBodyBytes, &poolsVar)
	vmPoolsServiceListResponse.pools = poolsVar.VmPools
	return &vmPoolsServiceListResponse, nil
}

type VmPoolsServiceListResponse struct {
	pools []VmPool
}

func (p *VmPoolsServiceListResponse) Pools() []VmPool {
	return p.pools
}
func (p *VmPoolsService) List() *VmPoolsServiceListRequest {
	return &VmPoolsServiceListRequest{vmPoolsService: p}
}

//
// Reference to the service that manages a specific virtual machine pool.
//
func (op *VmPoolsService) PoolService(id string) *VmPoolService {
	return NewVmPoolService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmPoolsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PoolService(path)), nil
	}
	return op.PoolService(path[:index]).Service(path[index+1:])
}

func (op *VmPoolsService) String() string {
	return fmt.Sprintf("VmPoolsService:%s", op.Path)
}

//
//
type AssignedDiskProfilesService struct {
	BaseService
}

func NewAssignedDiskProfilesService(connection *Connection, path string) *AssignedDiskProfilesService {
	var result AssignedDiskProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedDiskProfilesServiceAddRequest struct {
	assignedDiskProfilesService *AssignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *DiskProfile
}

func (p *AssignedDiskProfilesServiceAddRequest) Header(key, value string) *AssignedDiskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceAddRequest) Query(key, value string) *AssignedDiskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceAddRequest) Profile(profile *DiskProfile) *AssignedDiskProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *AssignedDiskProfilesServiceAddRequest) Send() (*AssignedDiskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.Connection.URL(), p.assignedDiskProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedDiskProfilesService.Connection.username, p.assignedDiskProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedDiskProfilesServiceAddResponse AssignedDiskProfilesServiceAddResponse
	var profileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedDiskProfilesServiceAddResponse.profile = &profileVar
	return &assignedDiskProfilesServiceAddResponse, nil
}

type AssignedDiskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *AssignedDiskProfilesServiceAddResponse) Profile() *DiskProfile {
	return p.profile
}
func (p *AssignedDiskProfilesService) Add() *AssignedDiskProfilesServiceAddRequest {
	return &AssignedDiskProfilesServiceAddRequest{assignedDiskProfilesService: p}
}

type AssignedDiskProfilesServiceListRequest struct {
	assignedDiskProfilesService *AssignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	max                         *int64
}

func (p *AssignedDiskProfilesServiceListRequest) Header(key, value string) *AssignedDiskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Query(key, value string) *AssignedDiskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Max(max int64) *AssignedDiskProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedDiskProfilesServiceListRequest) Send() (*AssignedDiskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.Connection.URL(), p.assignedDiskProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedDiskProfilesService.Connection.username, p.assignedDiskProfilesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedDiskProfilesServiceListResponse AssignedDiskProfilesServiceListResponse
	var profilesVar DiskProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	assignedDiskProfilesServiceListResponse.profiles = profilesVar.DiskProfiles
	return &assignedDiskProfilesServiceListResponse, nil
}

type AssignedDiskProfilesServiceListResponse struct {
	profiles []DiskProfile
}

func (p *AssignedDiskProfilesServiceListResponse) Profiles() []DiskProfile {
	return p.profiles
}
func (p *AssignedDiskProfilesService) List() *AssignedDiskProfilesServiceListRequest {
	return &AssignedDiskProfilesServiceListRequest{assignedDiskProfilesService: p}
}

//
//
func (op *AssignedDiskProfilesService) ProfileService(id string) *AssignedDiskProfileService {
	return NewAssignedDiskProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedDiskProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedDiskProfilesService) String() string {
	return fmt.Sprintf("AssignedDiskProfilesService:%s", op.Path)
}

//
// A service to manage a step.
//
type StepService struct {
	BaseService
}

func NewStepService(connection *Connection, path string) *StepService {
	var result StepService
	result.Connection = connection
	result.Path = path
	return &result
}

type StepServiceEndRequest struct {
	stepService *StepService
	header      map[string]string
	query       map[string]string
	async       *bool
	force       *bool
	succeeded   *bool
}

func (p *StepServiceEndRequest) Header(key, value string) *StepServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepServiceEndRequest) Query(key, value string) *StepServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepServiceEndRequest) Async(async bool) *StepServiceEndRequest {
	p.async = &async
	return p
}
func (p *StepServiceEndRequest) Force(force bool) *StepServiceEndRequest {
	p.force = &force
	return p
}
func (p *StepServiceEndRequest) Succeeded(succeeded bool) *StepServiceEndRequest {
	p.succeeded = &succeeded
	return p
}
func (p *StepServiceEndRequest) Send() (*StepServiceEndResponse, error) {
	rawURL := fmt.Sprintf("%s%s/end", p.stepService.Connection.URL(), p.stepService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Force(*p.force)
	actionBuilder.Succeeded(*p.succeeded)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.stepService.Connection.username, p.stepService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.stepService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StepServiceEndResponse), nil
}

type StepServiceEndResponse struct {
}

func (p *StepService) End() *StepServiceEndRequest {
	return &StepServiceEndRequest{stepService: p}
}

type StepServiceGetRequest struct {
	stepService *StepService
	header      map[string]string
	query       map[string]string
}

func (p *StepServiceGetRequest) Header(key, value string) *StepServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepServiceGetRequest) Query(key, value string) *StepServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepServiceGetRequest) Send() (*StepServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepService.Connection.URL(), p.stepService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.stepService.Connection.username, p.stepService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.stepService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var stepServiceGetResponse StepServiceGetResponse
	var stepVar Step
	xml.Unmarshal(respBodyBytes, &stepVar)
	stepServiceGetResponse.step = &stepVar
	return &stepServiceGetResponse, nil
}

type StepServiceGetResponse struct {
	step *Step
}

func (p *StepServiceGetResponse) Step() *Step {
	return p.step
}
func (p *StepService) Get() *StepServiceGetRequest {
	return &StepServiceGetRequest{stepService: p}
}

//
//
func (op *StepService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StepService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StepService) String() string {
	return fmt.Sprintf("StepService:%s", op.Path)
}

//
// Manages the collection of disks available inside an storage domain that is attached to a data center.
//
type AttachedStorageDomainDisksService struct {
	BaseService
}

func NewAttachedStorageDomainDisksService(connection *Connection, path string) *AttachedStorageDomainDisksService {
	var result AttachedStorageDomainDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainDisksServiceAddRequest struct {
	attachedStorageDomainDisksService *AttachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	disk                              *Disk
	unregistered                      *bool
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Header(key, value string) *AttachedStorageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Query(key, value string) *AttachedStorageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Disk(disk *Disk) *AttachedStorageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *AttachedStorageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *AttachedStorageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}
func (p *AttachedStorageDomainDisksServiceAddRequest) Send() (*AttachedStorageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.Connection.URL(), p.attachedStorageDomainDisksService.Path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDisksService.Connection.username, p.attachedStorageDomainDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var attachedStorageDomainDisksServiceAddResponse AttachedStorageDomainDisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	attachedStorageDomainDisksServiceAddResponse.disk = &diskVar
	return &attachedStorageDomainDisksServiceAddResponse, nil
}

type AttachedStorageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDisksServiceAddResponse) Disk() *Disk {
	return p.disk
}
func (p *AttachedStorageDomainDisksService) Add() *AttachedStorageDomainDisksServiceAddRequest {
	return &AttachedStorageDomainDisksServiceAddRequest{attachedStorageDomainDisksService: p}
}

type AttachedStorageDomainDisksServiceListRequest struct {
	attachedStorageDomainDisksService *AttachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	max                               *int64
}

func (p *AttachedStorageDomainDisksServiceListRequest) Header(key, value string) *AttachedStorageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Query(key, value string) *AttachedStorageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Max(max int64) *AttachedStorageDomainDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *AttachedStorageDomainDisksServiceListRequest) Send() (*AttachedStorageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.Connection.URL(), p.attachedStorageDomainDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDisksService.Connection.username, p.attachedStorageDomainDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var attachedStorageDomainDisksServiceListResponse AttachedStorageDomainDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	attachedStorageDomainDisksServiceListResponse.disks = disksVar.Disks
	return &attachedStorageDomainDisksServiceListResponse, nil
}

type AttachedStorageDomainDisksServiceListResponse struct {
	disks []Disk
}

func (p *AttachedStorageDomainDisksServiceListResponse) Disks() []Disk {
	return p.disks
}
func (p *AttachedStorageDomainDisksService) List() *AttachedStorageDomainDisksServiceListRequest {
	return &AttachedStorageDomainDisksServiceListRequest{attachedStorageDomainDisksService: p}
}

//
// Reference to the service that manages a specific disk.
//
func (op *AttachedStorageDomainDisksService) DiskService(id string) *AttachedStorageDomainDiskService {
	return NewAttachedStorageDomainDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *AttachedStorageDomainDisksService) String() string {
	return fmt.Sprintf("AttachedStorageDomainDisksService:%s", op.Path)
}

//
// Manages a network filter.
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026b">
//   <name>example-network-filter-b</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
// Please note that version is referring to the minimal support version for the specific filter.
//
type NetworkFilterService struct {
	BaseService
}

func NewNetworkFilterService(connection *Connection, path string) *NetworkFilterService {
	var result NetworkFilterService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFilterServiceGetRequest struct {
	networkFilterService *NetworkFilterService
	header               map[string]string
	query                map[string]string
}

func (p *NetworkFilterServiceGetRequest) Header(key, value string) *NetworkFilterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterServiceGetRequest) Query(key, value string) *NetworkFilterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterServiceGetRequest) Send() (*NetworkFilterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterService.Connection.URL(), p.networkFilterService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterService.Connection.username, p.networkFilterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkFilterServiceGetResponse NetworkFilterServiceGetResponse
	var networkFilterVar NetworkFilter
	xml.Unmarshal(respBodyBytes, &networkFilterVar)
	networkFilterServiceGetResponse.networkFilter = &networkFilterVar
	return &networkFilterServiceGetResponse, nil
}

type NetworkFilterServiceGetResponse struct {
	networkFilter *NetworkFilter
}

func (p *NetworkFilterServiceGetResponse) NetworkFilter() *NetworkFilter {
	return p.networkFilter
}
func (p *NetworkFilterService) Get() *NetworkFilterServiceGetRequest {
	return &NetworkFilterServiceGetRequest{networkFilterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFilterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkFilterService) String() string {
	return fmt.Sprintf("NetworkFilterService:%s", op.Path)
}

//
//
type VmDisksService struct {
	BaseService
}

func NewVmDisksService(connection *Connection, path string) *VmDisksService {
	var result VmDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmDisksServiceAddRequest struct {
	vmDisksService *VmDisksService
	header         map[string]string
	query          map[string]string
	disk           *Disk
}

func (p *VmDisksServiceAddRequest) Header(key, value string) *VmDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDisksServiceAddRequest) Query(key, value string) *VmDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDisksServiceAddRequest) Disk(disk *Disk) *VmDisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *VmDisksServiceAddRequest) Send() (*VmDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.Connection.URL(), p.vmDisksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDisksService.Connection.username, p.vmDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmDisksServiceAddResponse VmDisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	vmDisksServiceAddResponse.disk = &diskVar
	return &vmDisksServiceAddResponse, nil
}

type VmDisksServiceAddResponse struct {
	disk *Disk
}

func (p *VmDisksServiceAddResponse) Disk() *Disk {
	return p.disk
}
func (p *VmDisksService) Add() *VmDisksServiceAddRequest {
	return &VmDisksServiceAddRequest{vmDisksService: p}
}

type VmDisksServiceListRequest struct {
	vmDisksService *VmDisksService
	header         map[string]string
	query          map[string]string
	max            *int64
}

func (p *VmDisksServiceListRequest) Header(key, value string) *VmDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDisksServiceListRequest) Query(key, value string) *VmDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDisksServiceListRequest) Max(max int64) *VmDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *VmDisksServiceListRequest) Send() (*VmDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.Connection.URL(), p.vmDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDisksService.Connection.username, p.vmDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmDisksServiceListResponse VmDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	vmDisksServiceListResponse.disks = disksVar.Disks
	return &vmDisksServiceListResponse, nil
}

type VmDisksServiceListResponse struct {
	disks []Disk
}

func (p *VmDisksServiceListResponse) Disks() []Disk {
	return p.disks
}
func (p *VmDisksService) List() *VmDisksServiceListRequest {
	return &VmDisksServiceListRequest{vmDisksService: p}
}

//
//
func (op *VmDisksService) DiskService(id string) *VmDiskService {
	return NewVmDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *VmDisksService) String() string {
	return fmt.Sprintf("VmDisksService:%s", op.Path)
}

//
// This service manages the set of disks attached to a virtual machine. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>, containing the bootable flag, the disk interface and the reference to
// the disk.
//
type DiskAttachmentsService struct {
	BaseService
}

func NewDiskAttachmentsService(connection *Connection, path string) *DiskAttachmentsService {
	var result DiskAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskAttachmentsServiceAddRequest struct {
	diskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *DiskAttachmentsServiceAddRequest) Header(key, value string) *DiskAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddRequest) Query(key, value string) *DiskAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddRequest) Attachment(attachment *DiskAttachment) *DiskAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}
func (p *DiskAttachmentsServiceAddRequest) Send() (*DiskAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.Connection.URL(), p.diskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.attachment)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentsService.Connection.username, p.diskAttachmentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskAttachmentsServiceAddResponse DiskAttachmentsServiceAddResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	diskAttachmentsServiceAddResponse.attachment = &attachmentVar
	return &diskAttachmentsServiceAddResponse, nil
}

type DiskAttachmentsServiceAddResponse struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentsServiceAddResponse) Attachment() *DiskAttachment {
	return p.attachment
}
func (p *DiskAttachmentsService) Add() *DiskAttachmentsServiceAddRequest {
	return &DiskAttachmentsServiceAddRequest{diskAttachmentsService: p}
}

type DiskAttachmentsServiceListRequest struct {
	diskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
}

func (p *DiskAttachmentsServiceListRequest) Header(key, value string) *DiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceListRequest) Query(key, value string) *DiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceListRequest) Send() (*DiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.Connection.URL(), p.diskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentsService.Connection.username, p.diskAttachmentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskAttachmentsServiceListResponse DiskAttachmentsServiceListResponse
	var attachmentsVar DiskAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	diskAttachmentsServiceListResponse.attachments = attachmentsVar.DiskAttachments
	return &diskAttachmentsServiceListResponse, nil
}

type DiskAttachmentsServiceListResponse struct {
	attachments []DiskAttachment
}

func (p *DiskAttachmentsServiceListResponse) Attachments() []DiskAttachment {
	return p.attachments
}
func (p *DiskAttachmentsService) List() *DiskAttachmentsServiceListRequest {
	return &DiskAttachmentsServiceListRequest{diskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *DiskAttachmentsService) AttachmentService(id string) *DiskAttachmentService {
	return NewDiskAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *DiskAttachmentsService) String() string {
	return fmt.Sprintf("DiskAttachmentsService:%s", op.Path)
}

//
// Manages a single disk available in a storage domain.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type StorageDomainDiskService struct {
	BaseService
}

func NewStorageDomainDiskService(connection *Connection, path string) *StorageDomainDiskService {
	var result StorageDomainDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainDiskServiceCopyRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceCopyRequest) Header(key, value string) *StorageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) Query(key, value string) *StorageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) Disk(disk *Disk) *StorageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}
func (p *StorageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainDiskServiceCopyRequest) Send() (*StorageDomainDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceCopyResponse), nil
}

type StorageDomainDiskServiceCopyResponse struct {
}

func (p *StorageDomainDiskService) Copy() *StorageDomainDiskServiceCopyRequest {
	return &StorageDomainDiskServiceCopyRequest{storageDomainDiskService: p}
}

type StorageDomainDiskServiceExportRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceExportRequest) Header(key, value string) *StorageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceExportRequest) Query(key, value string) *StorageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainDiskServiceExportRequest) Send() (*StorageDomainDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceExportResponse), nil
}

type StorageDomainDiskServiceExportResponse struct {
}

func (p *StorageDomainDiskService) Export() *StorageDomainDiskServiceExportRequest {
	return &StorageDomainDiskServiceExportRequest{storageDomainDiskService: p}
}

type StorageDomainDiskServiceGetRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceGetRequest) Header(key, value string) *StorageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceGetRequest) Query(key, value string) *StorageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceGetRequest) Send() (*StorageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainDiskServiceGetResponse StorageDomainDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	storageDomainDiskServiceGetResponse.disk = &diskVar
	return &storageDomainDiskServiceGetResponse, nil
}

type StorageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *StorageDomainDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}
func (p *StorageDomainDiskService) Get() *StorageDomainDiskServiceGetRequest {
	return &StorageDomainDiskServiceGetRequest{storageDomainDiskService: p}
}

type StorageDomainDiskServiceMoveRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	filter                   *bool
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceMoveRequest) Header(key, value string) *StorageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Query(key, value string) *StorageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Async(async bool) *StorageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainDiskServiceMoveRequest) Filter(filter bool) *StorageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainDiskServiceMoveRequest) Send() (*StorageDomainDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceMoveResponse), nil
}

type StorageDomainDiskServiceMoveResponse struct {
}

func (p *StorageDomainDiskService) Move() *StorageDomainDiskServiceMoveRequest {
	return &StorageDomainDiskServiceMoveRequest{storageDomainDiskService: p}
}

type StorageDomainDiskServiceRemoveRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceRemoveRequest) Header(key, value string) *StorageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceRemoveRequest) Query(key, value string) *StorageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceRemoveRequest) Send() (*StorageDomainDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainDiskServiceRemoveResponse), nil
}

type StorageDomainDiskServiceRemoveResponse struct {
}

func (p *StorageDomainDiskService) Remove() *StorageDomainDiskServiceRemoveRequest {
	return &StorageDomainDiskServiceRemoveRequest{storageDomainDiskService: p}
}

type StorageDomainDiskServiceSparsifyRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceSparsifyRequest) Header(key, value string) *StorageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceSparsifyRequest) Query(key, value string) *StorageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceSparsifyRequest) Send() (*StorageDomainDiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceSparsifyResponse), nil
}

type StorageDomainDiskServiceSparsifyResponse struct {
}

func (p *StorageDomainDiskService) Sparsify() *StorageDomainDiskServiceSparsifyRequest {
	return &StorageDomainDiskServiceSparsifyRequest{storageDomainDiskService: p}
}

type StorageDomainDiskServiceUpdateRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
}

func (p *StorageDomainDiskServiceUpdateRequest) Header(key, value string) *StorageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceUpdateRequest) Query(key, value string) *StorageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *StorageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *StorageDomainDiskServiceUpdateRequest) Send() (*StorageDomainDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainDiskServiceUpdateResponse StorageDomainDiskServiceUpdateResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	storageDomainDiskServiceUpdateResponse.disk = &diskVar
	return &storageDomainDiskServiceUpdateResponse, nil
}

type StorageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *StorageDomainDiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}
func (p *StorageDomainDiskService) Update() *StorageDomainDiskServiceUpdateRequest {
	return &StorageDomainDiskServiceUpdateRequest{storageDomainDiskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *StorageDomainDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *StorageDomainDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainDiskService) String() string {
	return fmt.Sprintf("StorageDomainDiskService:%s", op.Path)
}

//
//
type HostHooksService struct {
	BaseService
}

func NewHostHooksService(connection *Connection, path string) *HostHooksService {
	var result HostHooksService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostHooksServiceListRequest struct {
	hostHooksService *HostHooksService
	header           map[string]string
	query            map[string]string
	max              *int64
}

func (p *HostHooksServiceListRequest) Header(key, value string) *HostHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostHooksServiceListRequest) Query(key, value string) *HostHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostHooksServiceListRequest) Max(max int64) *HostHooksServiceListRequest {
	p.max = &max
	return p
}
func (p *HostHooksServiceListRequest) Send() (*HostHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostHooksService.Connection.URL(), p.hostHooksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostHooksService.Connection.username, p.hostHooksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostHooksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostHooksServiceListResponse HostHooksServiceListResponse
	var hooksVar Hooks
	xml.Unmarshal(respBodyBytes, &hooksVar)
	hostHooksServiceListResponse.hooks = hooksVar.Hooks
	return &hostHooksServiceListResponse, nil
}

type HostHooksServiceListResponse struct {
	hooks []Hook
}

func (p *HostHooksServiceListResponse) Hooks() []Hook {
	return p.hooks
}
func (p *HostHooksService) List() *HostHooksServiceListRequest {
	return &HostHooksServiceListRequest{hostHooksService: p}
}

//
//
func (op *HostHooksService) HookService(id string) *HostHookService {
	return NewHostHookService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostHooksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HookService(path)), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *HostHooksService) String() string {
	return fmt.Sprintf("HostHooksService:%s", op.Path)
}

//
//
type StorageDomainsService struct {
	BaseService
}

func NewStorageDomainsService(connection *Connection, path string) *StorageDomainsService {
	var result StorageDomainsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainsServiceAddRequest struct {
	storageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddRequest) Header(key, value string) *StorageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddRequest) Query(key, value string) *StorageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainsServiceAddRequest) Send() (*StorageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.Connection.URL(), p.storageDomainsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.storageDomain)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainsService.Connection.username, p.storageDomainsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainsServiceAddResponse StorageDomainsServiceAddResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	storageDomainsServiceAddResponse.storageDomain = &storageDomainVar
	return &storageDomainsServiceAddResponse, nil
}

type StorageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}
func (p *StorageDomainsService) Add() *StorageDomainsServiceAddRequest {
	return &StorageDomainsServiceAddRequest{storageDomainsService: p}
}

type StorageDomainsServiceListRequest struct {
	storageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	filter                *bool
	max                   *int64
	search                *string
}

func (p *StorageDomainsServiceListRequest) Header(key, value string) *StorageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceListRequest) Query(key, value string) *StorageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceListRequest) CaseSensitive(caseSensitive bool) *StorageDomainsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *StorageDomainsServiceListRequest) Filter(filter bool) *StorageDomainsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainsServiceListRequest) Max(max int64) *StorageDomainsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainsServiceListRequest) Search(search string) *StorageDomainsServiceListRequest {
	p.search = &search
	return p
}
func (p *StorageDomainsServiceListRequest) Send() (*StorageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.Connection.URL(), p.storageDomainsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainsService.Connection.username, p.storageDomainsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainsServiceListResponse StorageDomainsServiceListResponse
	var storageDomainsVar StorageDomains
	xml.Unmarshal(respBodyBytes, &storageDomainsVar)
	storageDomainsServiceListResponse.storageDomains = storageDomainsVar.StorageDomains
	return &storageDomainsServiceListResponse, nil
}

type StorageDomainsServiceListResponse struct {
	storageDomains []StorageDomain
}

func (p *StorageDomainsServiceListResponse) StorageDomains() []StorageDomain {
	return p.storageDomains
}
func (p *StorageDomainsService) List() *StorageDomainsServiceListRequest {
	return &StorageDomainsServiceListRequest{storageDomainsService: p}
}

//
//
func (op *StorageDomainsService) StorageDomainService(id string) *StorageDomainService {
	return NewStorageDomainService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageDomainService(path)), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainsService) String() string {
	return fmt.Sprintf("StorageDomainsService:%s", op.Path)
}

//
//
type NetworkLabelService struct {
	BaseService
}

func NewNetworkLabelService(connection *Connection, path string) *NetworkLabelService {
	var result NetworkLabelService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkLabelServiceGetRequest struct {
	networkLabelService *NetworkLabelService
	header              map[string]string
	query               map[string]string
}

func (p *NetworkLabelServiceGetRequest) Header(key, value string) *NetworkLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelServiceGetRequest) Query(key, value string) *NetworkLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelServiceGetRequest) Send() (*NetworkLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelService.Connection.URL(), p.networkLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkLabelService.Connection.username, p.networkLabelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkLabelServiceGetResponse NetworkLabelServiceGetResponse
	var labelVar NetworkLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	networkLabelServiceGetResponse.label = &labelVar
	return &networkLabelServiceGetResponse, nil
}

type NetworkLabelServiceGetResponse struct {
	label *NetworkLabel
}

func (p *NetworkLabelServiceGetResponse) Label() *NetworkLabel {
	return p.label
}
func (p *NetworkLabelService) Get() *NetworkLabelServiceGetRequest {
	return &NetworkLabelServiceGetRequest{networkLabelService: p}
}

type NetworkLabelServiceRemoveRequest struct {
	networkLabelService *NetworkLabelService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *NetworkLabelServiceRemoveRequest) Header(key, value string) *NetworkLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelServiceRemoveRequest) Query(key, value string) *NetworkLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelServiceRemoveRequest) Async(async bool) *NetworkLabelServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *NetworkLabelServiceRemoveRequest) Send() (*NetworkLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelService.Connection.URL(), p.networkLabelService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkLabelService.Connection.username, p.networkLabelService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NetworkLabelServiceRemoveResponse), nil
}

type NetworkLabelServiceRemoveResponse struct {
}

func (p *NetworkLabelService) Remove() *NetworkLabelServiceRemoveRequest {
	return &NetworkLabelServiceRemoveRequest{networkLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkLabelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkLabelService) String() string {
	return fmt.Sprintf("NetworkLabelService:%s", op.Path)
}

//
//
type InstanceTypesService struct {
	BaseService
}

func NewInstanceTypesService(connection *Connection, path string) *InstanceTypesService {
	var result InstanceTypesService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypesServiceAddRequest struct {
	instanceTypesService *InstanceTypesService
	header               map[string]string
	query                map[string]string
	instanceType         *InstanceType
}

func (p *InstanceTypesServiceAddRequest) Header(key, value string) *InstanceTypesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypesServiceAddRequest) Query(key, value string) *InstanceTypesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypesServiceAddRequest) InstanceType(instanceType *InstanceType) *InstanceTypesServiceAddRequest {
	p.instanceType = instanceType
	return p
}
func (p *InstanceTypesServiceAddRequest) Send() (*InstanceTypesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.Connection.URL(), p.instanceTypesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.instanceType)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypesService.Connection.username, p.instanceTypesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypesServiceAddResponse InstanceTypesServiceAddResponse
	var instanceTypeVar InstanceType
	xml.Unmarshal(respBodyBytes, &instanceTypeVar)
	instanceTypesServiceAddResponse.instanceType = &instanceTypeVar
	return &instanceTypesServiceAddResponse, nil
}

type InstanceTypesServiceAddResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypesServiceAddResponse) InstanceType() *InstanceType {
	return p.instanceType
}
func (p *InstanceTypesService) Add() *InstanceTypesServiceAddRequest {
	return &InstanceTypesServiceAddRequest{instanceTypesService: p}
}

type InstanceTypesServiceListRequest struct {
	instanceTypesService *InstanceTypesService
	header               map[string]string
	query                map[string]string
	caseSensitive        *bool
	max                  *int64
	search               *string
}

func (p *InstanceTypesServiceListRequest) Header(key, value string) *InstanceTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypesServiceListRequest) Query(key, value string) *InstanceTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypesServiceListRequest) CaseSensitive(caseSensitive bool) *InstanceTypesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *InstanceTypesServiceListRequest) Max(max int64) *InstanceTypesServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypesServiceListRequest) Search(search string) *InstanceTypesServiceListRequest {
	p.search = &search
	return p
}
func (p *InstanceTypesServiceListRequest) Send() (*InstanceTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.Connection.URL(), p.instanceTypesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypesService.Connection.username, p.instanceTypesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypesServiceListResponse InstanceTypesServiceListResponse
	var instanceTypeVar InstanceTypes
	xml.Unmarshal(respBodyBytes, &instanceTypeVar)
	instanceTypesServiceListResponse.instanceType = instanceTypeVar.InstanceTypes
	return &instanceTypesServiceListResponse, nil
}

type InstanceTypesServiceListResponse struct {
	instanceType []InstanceType
}

func (p *InstanceTypesServiceListResponse) InstanceType() []InstanceType {
	return p.instanceType
}
func (p *InstanceTypesService) List() *InstanceTypesServiceListRequest {
	return &InstanceTypesServiceListRequest{instanceTypesService: p}
}

//
//
func (op *InstanceTypesService) InstanceTypeService(id string) *InstanceTypeService {
	return NewInstanceTypeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.InstanceTypeService(path)), nil
	}
	return op.InstanceTypeService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypesService) String() string {
	return fmt.Sprintf("InstanceTypesService:%s", op.Path)
}

//
//
type StorageDomainServerConnectionsService struct {
	BaseService
}

func NewStorageDomainServerConnectionsService(connection *Connection, path string) *StorageDomainServerConnectionsService {
	var result StorageDomainServerConnectionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainServerConnectionsServiceAddRequest struct {
	storageDomainServerConnectionsService *StorageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	connection                            *StorageConnection
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Header(key, value string) *StorageDomainServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Query(key, value string) *StorageDomainServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *StorageDomainServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}
func (p *StorageDomainServerConnectionsServiceAddRequest) Send() (*StorageDomainServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.Connection.URL(), p.storageDomainServerConnectionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.connection)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainServerConnectionsService.Connection.username, p.storageDomainServerConnectionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainServerConnectionsServiceAddResponse StorageDomainServerConnectionsServiceAddResponse
	var connectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &connectionVar)
	storageDomainServerConnectionsServiceAddResponse.connection = &connectionVar
	return &storageDomainServerConnectionsServiceAddResponse, nil
}

type StorageDomainServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *StorageDomainServerConnectionsServiceAddResponse) Connection() *StorageConnection {
	return p.connection
}
func (p *StorageDomainServerConnectionsService) Add() *StorageDomainServerConnectionsServiceAddRequest {
	return &StorageDomainServerConnectionsServiceAddRequest{storageDomainServerConnectionsService: p}
}

type StorageDomainServerConnectionsServiceListRequest struct {
	storageDomainServerConnectionsService *StorageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	max                                   *int64
}

func (p *StorageDomainServerConnectionsServiceListRequest) Header(key, value string) *StorageDomainServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Query(key, value string) *StorageDomainServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Max(max int64) *StorageDomainServerConnectionsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainServerConnectionsServiceListRequest) Send() (*StorageDomainServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.Connection.URL(), p.storageDomainServerConnectionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainServerConnectionsService.Connection.username, p.storageDomainServerConnectionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainServerConnectionsServiceListResponse StorageDomainServerConnectionsServiceListResponse
	var connectionsVar StorageConnections
	xml.Unmarshal(respBodyBytes, &connectionsVar)
	storageDomainServerConnectionsServiceListResponse.connections = connectionsVar.StorageConnections
	return &storageDomainServerConnectionsServiceListResponse, nil
}

type StorageDomainServerConnectionsServiceListResponse struct {
	connections []StorageConnection
}

func (p *StorageDomainServerConnectionsServiceListResponse) Connections() []StorageConnection {
	return p.connections
}
func (p *StorageDomainServerConnectionsService) List() *StorageDomainServerConnectionsServiceListRequest {
	return &StorageDomainServerConnectionsServiceListRequest{storageDomainServerConnectionsService: p}
}

//
//
func (op *StorageDomainServerConnectionsService) ConnectionService(id string) *StorageDomainServerConnectionService {
	return NewStorageDomainServerConnectionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainServerConnectionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConnectionService(path)), nil
	}
	return op.ConnectionService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainServerConnectionsService) String() string {
	return fmt.Sprintf("StorageDomainServerConnectionsService:%s", op.Path)
}

//
//
type InstanceTypeGraphicsConsoleService struct {
	BaseService
}

func NewInstanceTypeGraphicsConsoleService(connection *Connection, path string) *InstanceTypeGraphicsConsoleService {
	var result InstanceTypeGraphicsConsoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeGraphicsConsoleServiceGetRequest struct {
	instanceTypeGraphicsConsoleService *InstanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Header(key, value string) *InstanceTypeGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Query(key, value string) *InstanceTypeGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Send() (*InstanceTypeGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsoleService.Connection.URL(), p.instanceTypeGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeGraphicsConsoleService.Connection.username, p.instanceTypeGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeGraphicsConsoleServiceGetResponse InstanceTypeGraphicsConsoleServiceGetResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	instanceTypeGraphicsConsoleServiceGetResponse.console = &consoleVar
	return &instanceTypeGraphicsConsoleServiceGetResponse, nil
}

type InstanceTypeGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsoleServiceGetResponse) Console() *GraphicsConsole {
	return p.console
}
func (p *InstanceTypeGraphicsConsoleService) Get() *InstanceTypeGraphicsConsoleServiceGetRequest {
	return &InstanceTypeGraphicsConsoleServiceGetRequest{instanceTypeGraphicsConsoleService: p}
}

type InstanceTypeGraphicsConsoleServiceRemoveRequest struct {
	instanceTypeGraphicsConsoleService *InstanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
	async                              *bool
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Header(key, value string) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Query(key, value string) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Async(async bool) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Send() (*InstanceTypeGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsoleService.Connection.URL(), p.instanceTypeGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeGraphicsConsoleService.Connection.username, p.instanceTypeGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeGraphicsConsoleServiceRemoveResponse), nil
}

type InstanceTypeGraphicsConsoleServiceRemoveResponse struct {
}

func (p *InstanceTypeGraphicsConsoleService) Remove() *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	return &InstanceTypeGraphicsConsoleServiceRemoveRequest{instanceTypeGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeGraphicsConsoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeGraphicsConsoleService) String() string {
	return fmt.Sprintf("InstanceTypeGraphicsConsoleService:%s", op.Path)
}

//
//
type IscsiBondService struct {
	BaseService
}

func NewIscsiBondService(connection *Connection, path string) *IscsiBondService {
	var result IscsiBondService
	result.Connection = connection
	result.Path = path
	return &result
}

type IscsiBondServiceGetRequest struct {
	iscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
}

func (p *IscsiBondServiceGetRequest) Header(key, value string) *IscsiBondServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceGetRequest) Query(key, value string) *IscsiBondServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceGetRequest) Send() (*IscsiBondServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.Connection.URL(), p.iscsiBondService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondService.Connection.username, p.iscsiBondService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var iscsiBondServiceGetResponse IscsiBondServiceGetResponse
	var bondVar IscsiBond
	xml.Unmarshal(respBodyBytes, &bondVar)
	iscsiBondServiceGetResponse.bond = &bondVar
	return &iscsiBondServiceGetResponse, nil
}

type IscsiBondServiceGetResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondServiceGetResponse) Bond() *IscsiBond {
	return p.bond
}
func (p *IscsiBondService) Get() *IscsiBondServiceGetRequest {
	return &IscsiBondServiceGetRequest{iscsiBondService: p}
}

type IscsiBondServiceRemoveRequest struct {
	iscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
}

func (p *IscsiBondServiceRemoveRequest) Header(key, value string) *IscsiBondServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceRemoveRequest) Query(key, value string) *IscsiBondServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceRemoveRequest) Async(async bool) *IscsiBondServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *IscsiBondServiceRemoveRequest) Send() (*IscsiBondServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.Connection.URL(), p.iscsiBondService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondService.Connection.username, p.iscsiBondService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(IscsiBondServiceRemoveResponse), nil
}

type IscsiBondServiceRemoveResponse struct {
}

func (p *IscsiBondService) Remove() *IscsiBondServiceRemoveRequest {
	return &IscsiBondServiceRemoveRequest{iscsiBondService: p}
}

type IscsiBondServiceUpdateRequest struct {
	iscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
	bond             *IscsiBond
}

func (p *IscsiBondServiceUpdateRequest) Header(key, value string) *IscsiBondServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceUpdateRequest) Query(key, value string) *IscsiBondServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceUpdateRequest) Async(async bool) *IscsiBondServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *IscsiBondServiceUpdateRequest) Bond(bond *IscsiBond) *IscsiBondServiceUpdateRequest {
	p.bond = bond
	return p
}
func (p *IscsiBondServiceUpdateRequest) Send() (*IscsiBondServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.Connection.URL(), p.iscsiBondService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bond)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondService.Connection.username, p.iscsiBondService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var iscsiBondServiceUpdateResponse IscsiBondServiceUpdateResponse
	var bondVar IscsiBond
	xml.Unmarshal(respBodyBytes, &bondVar)
	iscsiBondServiceUpdateResponse.bond = &bondVar
	return &iscsiBondServiceUpdateResponse, nil
}

type IscsiBondServiceUpdateResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondServiceUpdateResponse) Bond() *IscsiBond {
	return p.bond
}
func (p *IscsiBondService) Update() *IscsiBondServiceUpdateRequest {
	return &IscsiBondServiceUpdateRequest{iscsiBondService: p}
}

//
//
func (op *IscsiBondService) NetworksService() *NetworksService {
	return NewNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
//
func (op *IscsiBondService) StorageServerConnectionsService() *StorageServerConnectionsService {
	return NewStorageServerConnectionsService(op.Connection, fmt.Sprintf("%s/storageserverconnections", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IscsiBondService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "storageserverconnections" {
		return op.StorageServerConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageserverconnections/") {
		return op.StorageServerConnectionsService().Service(path[25:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *IscsiBondService) String() string {
	return fmt.Sprintf("IscsiBondService:%s", op.Path)
}

//
// This service manages the attachment of a disk to a template.
//
type TemplateDiskAttachmentService struct {
	BaseService
}

func NewTemplateDiskAttachmentService(connection *Connection, path string) *TemplateDiskAttachmentService {
	var result TemplateDiskAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDiskAttachmentServiceGetRequest struct {
	templateDiskAttachmentService *TemplateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
}

func (p *TemplateDiskAttachmentServiceGetRequest) Header(key, value string) *TemplateDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceGetRequest) Query(key, value string) *TemplateDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceGetRequest) Send() (*TemplateDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentService.Connection.URL(), p.templateDiskAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskAttachmentService.Connection.username, p.templateDiskAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateDiskAttachmentServiceGetResponse TemplateDiskAttachmentServiceGetResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	templateDiskAttachmentServiceGetResponse.attachment = &attachmentVar
	return &templateDiskAttachmentServiceGetResponse, nil
}

type TemplateDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *TemplateDiskAttachmentServiceGetResponse) Attachment() *DiskAttachment {
	return p.attachment
}
func (p *TemplateDiskAttachmentService) Get() *TemplateDiskAttachmentServiceGetRequest {
	return &TemplateDiskAttachmentServiceGetRequest{templateDiskAttachmentService: p}
}

type TemplateDiskAttachmentServiceRemoveRequest struct {
	templateDiskAttachmentService *TemplateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
	force                         *bool
	storageDomain                 *string
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Header(key, value string) *TemplateDiskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Query(key, value string) *TemplateDiskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Force(force bool) *TemplateDiskAttachmentServiceRemoveRequest {
	p.force = &force
	return p
}
func (p *TemplateDiskAttachmentServiceRemoveRequest) StorageDomain(storageDomain string) *TemplateDiskAttachmentServiceRemoveRequest {
	p.storageDomain = &storageDomain
	return p
}
func (p *TemplateDiskAttachmentServiceRemoveRequest) Send() (*TemplateDiskAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentService.Connection.URL(), p.templateDiskAttachmentService.Path)
	values := make(url.Values)
	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}
	if p.storageDomain != nil {
		values["storageDomain"] = []string{fmt.Sprintf("%v", *p.storageDomain)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskAttachmentService.Connection.username, p.templateDiskAttachmentService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateDiskAttachmentServiceRemoveResponse), nil
}

type TemplateDiskAttachmentServiceRemoveResponse struct {
}

func (p *TemplateDiskAttachmentService) Remove() *TemplateDiskAttachmentServiceRemoveRequest {
	return &TemplateDiskAttachmentServiceRemoveRequest{templateDiskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateDiskAttachmentService) String() string {
	return fmt.Sprintf("TemplateDiskAttachmentService:%s", op.Path)
}

//
// A service to manage host storages.
//
type HostStorageService struct {
	BaseService
}

func NewHostStorageService(connection *Connection, path string) *HostStorageService {
	var result HostStorageService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostStorageServiceListRequest struct {
	hostStorageService *HostStorageService
	header             map[string]string
	query              map[string]string
	reportStatus       *bool
}

func (p *HostStorageServiceListRequest) Header(key, value string) *HostStorageServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostStorageServiceListRequest) Query(key, value string) *HostStorageServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostStorageServiceListRequest) ReportStatus(reportStatus bool) *HostStorageServiceListRequest {
	p.reportStatus = &reportStatus
	return p
}
func (p *HostStorageServiceListRequest) Send() (*HostStorageServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostStorageService.Connection.URL(), p.hostStorageService.Path)
	values := make(url.Values)
	if p.reportStatus != nil {
		values["reportStatus"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostStorageService.Connection.username, p.hostStorageService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostStorageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostStorageServiceListResponse HostStorageServiceListResponse
	var storagesVar HostStorages
	xml.Unmarshal(respBodyBytes, &storagesVar)
	hostStorageServiceListResponse.storages = storagesVar.HostStorages
	return &hostStorageServiceListResponse, nil
}

type HostStorageServiceListResponse struct {
	storages []HostStorage
}

func (p *HostStorageServiceListResponse) Storages() []HostStorage {
	return p.storages
}
func (p *HostStorageService) List() *HostStorageServiceListRequest {
	return &HostStorageServiceListRequest{hostStorageService: p}
}

//
// Reference to a service managing the storage.
//
func (op *HostStorageService) StorageService(id string) *StorageService {
	return NewStorageService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostStorageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageService(path)), nil
	}
	return op.StorageService(path[:index]).Service(path[index+1:])
}

func (op *HostStorageService) String() string {
	return fmt.Sprintf("HostStorageService:%s", op.Path)
}

//
//
type WeightService struct {
	BaseService
}

func NewWeightService(connection *Connection, path string) *WeightService {
	var result WeightService
	result.Connection = connection
	result.Path = path
	return &result
}

type WeightServiceGetRequest struct {
	weightService *WeightService
	header        map[string]string
	query         map[string]string
	filter        *bool
}

func (p *WeightServiceGetRequest) Header(key, value string) *WeightServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightServiceGetRequest) Query(key, value string) *WeightServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightServiceGetRequest) Filter(filter bool) *WeightServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *WeightServiceGetRequest) Send() (*WeightServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightService.Connection.URL(), p.weightService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.weightService.Connection.username, p.weightService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.weightService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var weightServiceGetResponse WeightServiceGetResponse
	var weightVar Weight
	xml.Unmarshal(respBodyBytes, &weightVar)
	weightServiceGetResponse.weight = &weightVar
	return &weightServiceGetResponse, nil
}

type WeightServiceGetResponse struct {
	weight *Weight
}

func (p *WeightServiceGetResponse) Weight() *Weight {
	return p.weight
}
func (p *WeightService) Get() *WeightServiceGetRequest {
	return &WeightServiceGetRequest{weightService: p}
}

type WeightServiceRemoveRequest struct {
	weightService *WeightService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *WeightServiceRemoveRequest) Header(key, value string) *WeightServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightServiceRemoveRequest) Query(key, value string) *WeightServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightServiceRemoveRequest) Async(async bool) *WeightServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *WeightServiceRemoveRequest) Send() (*WeightServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightService.Connection.URL(), p.weightService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.weightService.Connection.username, p.weightService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.weightService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(WeightServiceRemoveResponse), nil
}

type WeightServiceRemoveResponse struct {
}

func (p *WeightService) Remove() *WeightServiceRemoveRequest {
	return &WeightServiceRemoveRequest{weightService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *WeightService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *WeightService) String() string {
	return fmt.Sprintf("WeightService:%s", op.Path)
}

//
//
type VmNumaNodesService struct {
	BaseService
}

func NewVmNumaNodesService(connection *Connection, path string) *VmNumaNodesService {
	var result VmNumaNodesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNumaNodesServiceAddRequest struct {
	vmNumaNodesService *VmNumaNodesService
	header             map[string]string
	query              map[string]string
	node               *VirtualNumaNode
}

func (p *VmNumaNodesServiceAddRequest) Header(key, value string) *VmNumaNodesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodesServiceAddRequest) Query(key, value string) *VmNumaNodesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodesServiceAddRequest) Node(node *VirtualNumaNode) *VmNumaNodesServiceAddRequest {
	p.node = node
	return p
}
func (p *VmNumaNodesServiceAddRequest) Send() (*VmNumaNodesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.Connection.URL(), p.vmNumaNodesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.node)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodesService.Connection.username, p.vmNumaNodesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNumaNodesServiceAddResponse VmNumaNodesServiceAddResponse
	var nodeVar VirtualNumaNode
	xml.Unmarshal(respBodyBytes, &nodeVar)
	vmNumaNodesServiceAddResponse.node = &nodeVar
	return &vmNumaNodesServiceAddResponse, nil
}

type VmNumaNodesServiceAddResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodesServiceAddResponse) Node() *VirtualNumaNode {
	return p.node
}
func (p *VmNumaNodesService) Add() *VmNumaNodesServiceAddRequest {
	return &VmNumaNodesServiceAddRequest{vmNumaNodesService: p}
}

type VmNumaNodesServiceListRequest struct {
	vmNumaNodesService *VmNumaNodesService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *VmNumaNodesServiceListRequest) Header(key, value string) *VmNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodesServiceListRequest) Query(key, value string) *VmNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodesServiceListRequest) Max(max int64) *VmNumaNodesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmNumaNodesServiceListRequest) Send() (*VmNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.Connection.URL(), p.vmNumaNodesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodesService.Connection.username, p.vmNumaNodesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNumaNodesServiceListResponse VmNumaNodesServiceListResponse
	var nodesVar VirtualNumaNodes
	xml.Unmarshal(respBodyBytes, &nodesVar)
	vmNumaNodesServiceListResponse.nodes = nodesVar.VirtualNumaNodes
	return &vmNumaNodesServiceListResponse, nil
}

type VmNumaNodesServiceListResponse struct {
	nodes []VirtualNumaNode
}

func (p *VmNumaNodesServiceListResponse) Nodes() []VirtualNumaNode {
	return p.nodes
}
func (p *VmNumaNodesService) List() *VmNumaNodesServiceListRequest {
	return &VmNumaNodesServiceListRequest{vmNumaNodesService: p}
}

//
//
func (op *VmNumaNodesService) NodeService(id string) *VmNumaNodeService {
	return NewVmNumaNodeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNumaNodesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NodeService(path)), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *VmNumaNodesService) String() string {
	return fmt.Sprintf("VmNumaNodesService:%s", op.Path)
}

//
//
type TemplateWatchdogsService struct {
	BaseService
}

func NewTemplateWatchdogsService(connection *Connection, path string) *TemplateWatchdogsService {
	var result TemplateWatchdogsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateWatchdogsServiceAddRequest struct {
	templateWatchdogsService *TemplateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	watchdog                 *Watchdog
}

func (p *TemplateWatchdogsServiceAddRequest) Header(key, value string) *TemplateWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogsServiceAddRequest) Query(key, value string) *TemplateWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *TemplateWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}
func (p *TemplateWatchdogsServiceAddRequest) Send() (*TemplateWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.Connection.URL(), p.templateWatchdogsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogsService.Connection.username, p.templateWatchdogsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateWatchdogsServiceAddResponse TemplateWatchdogsServiceAddResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	templateWatchdogsServiceAddResponse.watchdog = &watchdogVar
	return &templateWatchdogsServiceAddResponse, nil
}

type TemplateWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogsServiceAddResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *TemplateWatchdogsService) Add() *TemplateWatchdogsServiceAddRequest {
	return &TemplateWatchdogsServiceAddRequest{templateWatchdogsService: p}
}

type TemplateWatchdogsServiceListRequest struct {
	templateWatchdogsService *TemplateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *TemplateWatchdogsServiceListRequest) Header(key, value string) *TemplateWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Query(key, value string) *TemplateWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Max(max int64) *TemplateWatchdogsServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateWatchdogsServiceListRequest) Send() (*TemplateWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.Connection.URL(), p.templateWatchdogsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogsService.Connection.username, p.templateWatchdogsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateWatchdogsServiceListResponse TemplateWatchdogsServiceListResponse
	var watchdogsVar Watchdogs
	xml.Unmarshal(respBodyBytes, &watchdogsVar)
	templateWatchdogsServiceListResponse.watchdogs = watchdogsVar.Watchdogs
	return &templateWatchdogsServiceListResponse, nil
}

type TemplateWatchdogsServiceListResponse struct {
	watchdogs []Watchdog
}

func (p *TemplateWatchdogsServiceListResponse) Watchdogs() []Watchdog {
	return p.watchdogs
}
func (p *TemplateWatchdogsService) List() *TemplateWatchdogsServiceListRequest {
	return &TemplateWatchdogsServiceListRequest{templateWatchdogsService: p}
}

//
//
func (op *TemplateWatchdogsService) WatchdogService(id string) *TemplateWatchdogService {
	return NewTemplateWatchdogService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateWatchdogsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WatchdogService(path)), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *TemplateWatchdogsService) String() string {
	return fmt.Sprintf("TemplateWatchdogsService:%s", op.Path)
}

//
// Manages a single disk available in a storage domain attached to a data center.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type AttachedStorageDomainDiskService struct {
	BaseService
}

func NewAttachedStorageDomainDiskService(connection *Connection, path string) *AttachedStorageDomainDiskService {
	var result AttachedStorageDomainDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainDiskServiceCopyRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Header(key, value string) *AttachedStorageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Query(key, value string) *AttachedStorageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Disk(disk *Disk) *AttachedStorageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}
func (p *AttachedStorageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainDiskServiceCopyRequest) Send() (*AttachedStorageDomainDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceCopyResponse), nil
}

type AttachedStorageDomainDiskServiceCopyResponse struct {
}

func (p *AttachedStorageDomainDiskService) Copy() *AttachedStorageDomainDiskServiceCopyRequest {
	return &AttachedStorageDomainDiskServiceCopyRequest{attachedStorageDomainDiskService: p}
}

type AttachedStorageDomainDiskServiceExportRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceExportRequest) Header(key, value string) *AttachedStorageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceExportRequest) Query(key, value string) *AttachedStorageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainDiskServiceExportRequest) Send() (*AttachedStorageDomainDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceExportResponse), nil
}

type AttachedStorageDomainDiskServiceExportResponse struct {
}

func (p *AttachedStorageDomainDiskService) Export() *AttachedStorageDomainDiskServiceExportRequest {
	return &AttachedStorageDomainDiskServiceExportRequest{attachedStorageDomainDiskService: p}
}

type AttachedStorageDomainDiskServiceGetRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Header(key, value string) *AttachedStorageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Query(key, value string) *AttachedStorageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Send() (*AttachedStorageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var attachedStorageDomainDiskServiceGetResponse AttachedStorageDomainDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	attachedStorageDomainDiskServiceGetResponse.disk = &diskVar
	return &attachedStorageDomainDiskServiceGetResponse, nil
}

type AttachedStorageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}
func (p *AttachedStorageDomainDiskService) Get() *AttachedStorageDomainDiskServiceGetRequest {
	return &AttachedStorageDomainDiskServiceGetRequest{attachedStorageDomainDiskService: p}
}

type AttachedStorageDomainDiskServiceMoveRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	async                            *bool
	filter                           *bool
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Header(key, value string) *AttachedStorageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Query(key, value string) *AttachedStorageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Async(async bool) *AttachedStorageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainDiskServiceMoveRequest) Filter(filter bool) *AttachedStorageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *AttachedStorageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainDiskServiceMoveRequest) Send() (*AttachedStorageDomainDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceMoveResponse), nil
}

type AttachedStorageDomainDiskServiceMoveResponse struct {
}

func (p *AttachedStorageDomainDiskService) Move() *AttachedStorageDomainDiskServiceMoveRequest {
	return &AttachedStorageDomainDiskServiceMoveRequest{attachedStorageDomainDiskService: p}
}

type AttachedStorageDomainDiskServiceRegisterRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Header(key, value string) *AttachedStorageDomainDiskServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Query(key, value string) *AttachedStorageDomainDiskServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Send() (*AttachedStorageDomainDiskServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceRegisterResponse), nil
}

type AttachedStorageDomainDiskServiceRegisterResponse struct {
}

func (p *AttachedStorageDomainDiskService) Register() *AttachedStorageDomainDiskServiceRegisterRequest {
	return &AttachedStorageDomainDiskServiceRegisterRequest{attachedStorageDomainDiskService: p}
}

type AttachedStorageDomainDiskServiceRemoveRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Header(key, value string) *AttachedStorageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Query(key, value string) *AttachedStorageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Send() (*AttachedStorageDomainDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AttachedStorageDomainDiskServiceRemoveResponse), nil
}

type AttachedStorageDomainDiskServiceRemoveResponse struct {
}

func (p *AttachedStorageDomainDiskService) Remove() *AttachedStorageDomainDiskServiceRemoveRequest {
	return &AttachedStorageDomainDiskServiceRemoveRequest{attachedStorageDomainDiskService: p}
}

type AttachedStorageDomainDiskServiceSparsifyRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Header(key, value string) *AttachedStorageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Query(key, value string) *AttachedStorageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Send() (*AttachedStorageDomainDiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceSparsifyResponse), nil
}

type AttachedStorageDomainDiskServiceSparsifyResponse struct {
}

func (p *AttachedStorageDomainDiskService) Sparsify() *AttachedStorageDomainDiskServiceSparsifyRequest {
	return &AttachedStorageDomainDiskServiceSparsifyRequest{attachedStorageDomainDiskService: p}
}

type AttachedStorageDomainDiskServiceUpdateRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Header(key, value string) *AttachedStorageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Query(key, value string) *AttachedStorageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *AttachedStorageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *AttachedStorageDomainDiskServiceUpdateRequest) Send() (*AttachedStorageDomainDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var attachedStorageDomainDiskServiceUpdateResponse AttachedStorageDomainDiskServiceUpdateResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	attachedStorageDomainDiskServiceUpdateResponse.disk = &diskVar
	return &attachedStorageDomainDiskServiceUpdateResponse, nil
}

type AttachedStorageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}
func (p *AttachedStorageDomainDiskService) Update() *AttachedStorageDomainDiskServiceUpdateRequest {
	return &AttachedStorageDomainDiskServiceUpdateRequest{attachedStorageDomainDiskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *AttachedStorageDomainDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *AttachedStorageDomainDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AttachedStorageDomainDiskService) String() string {
	return fmt.Sprintf("AttachedStorageDomainDiskService:%s", op.Path)
}

//
// This service manages a vNIC profile.
//
type VnicProfileService struct {
	BaseService
}

func NewVnicProfileService(connection *Connection, path string) *VnicProfileService {
	var result VnicProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type VnicProfileServiceGetRequest struct {
	vnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
}

func (p *VnicProfileServiceGetRequest) Header(key, value string) *VnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceGetRequest) Query(key, value string) *VnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceGetRequest) Send() (*VnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.Connection.URL(), p.vnicProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfileService.Connection.username, p.vnicProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vnicProfileServiceGetResponse VnicProfileServiceGetResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	vnicProfileServiceGetResponse.profile = &profileVar
	return &vnicProfileServiceGetResponse, nil
}

type VnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *VnicProfileServiceGetResponse) Profile() *VnicProfile {
	return p.profile
}
func (p *VnicProfileService) Get() *VnicProfileServiceGetRequest {
	return &VnicProfileServiceGetRequest{vnicProfileService: p}
}

type VnicProfileServiceRemoveRequest struct {
	vnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *VnicProfileServiceRemoveRequest) Header(key, value string) *VnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceRemoveRequest) Query(key, value string) *VnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceRemoveRequest) Async(async bool) *VnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VnicProfileServiceRemoveRequest) Send() (*VnicProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.Connection.URL(), p.vnicProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfileService.Connection.username, p.vnicProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VnicProfileServiceRemoveResponse), nil
}

type VnicProfileServiceRemoveResponse struct {
}

func (p *VnicProfileService) Remove() *VnicProfileServiceRemoveRequest {
	return &VnicProfileServiceRemoveRequest{vnicProfileService: p}
}

type VnicProfileServiceUpdateRequest struct {
	vnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *VnicProfile
}

func (p *VnicProfileServiceUpdateRequest) Header(key, value string) *VnicProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceUpdateRequest) Query(key, value string) *VnicProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceUpdateRequest) Async(async bool) *VnicProfileServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VnicProfileServiceUpdateRequest) Profile(profile *VnicProfile) *VnicProfileServiceUpdateRequest {
	p.profile = profile
	return p
}
func (p *VnicProfileServiceUpdateRequest) Send() (*VnicProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.Connection.URL(), p.vnicProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfileService.Connection.username, p.vnicProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vnicProfileServiceUpdateResponse VnicProfileServiceUpdateResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	vnicProfileServiceUpdateResponse.profile = &profileVar
	return &vnicProfileServiceUpdateResponse, nil
}

type VnicProfileServiceUpdateResponse struct {
	profile *VnicProfile
}

func (p *VnicProfileServiceUpdateResponse) Profile() *VnicProfile {
	return p.profile
}
func (p *VnicProfileService) Update() *VnicProfileServiceUpdateRequest {
	return &VnicProfileServiceUpdateRequest{vnicProfileService: p}
}

//
//
func (op *VnicProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VnicProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VnicProfileService) String() string {
	return fmt.Sprintf("VnicProfileService:%s", op.Path)
}

//
//
type VmGraphicsConsolesService struct {
	BaseService
}

func NewVmGraphicsConsolesService(connection *Connection, path string) *VmGraphicsConsolesService {
	var result VmGraphicsConsolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmGraphicsConsolesServiceAddRequest struct {
	vmGraphicsConsolesService *VmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	console                   *GraphicsConsole
}

func (p *VmGraphicsConsolesServiceAddRequest) Header(key, value string) *VmGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceAddRequest) Query(key, value string) *VmGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *VmGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}
func (p *VmGraphicsConsolesServiceAddRequest) Send() (*VmGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.Connection.URL(), p.vmGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.console)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsolesService.Connection.username, p.vmGraphicsConsolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmGraphicsConsolesServiceAddResponse VmGraphicsConsolesServiceAddResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	vmGraphicsConsolesServiceAddResponse.console = &consoleVar
	return &vmGraphicsConsolesServiceAddResponse, nil
}

type VmGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *VmGraphicsConsolesServiceAddResponse) Console() *GraphicsConsole {
	return p.console
}
func (p *VmGraphicsConsolesService) Add() *VmGraphicsConsolesServiceAddRequest {
	return &VmGraphicsConsolesServiceAddRequest{vmGraphicsConsolesService: p}
}

type VmGraphicsConsolesServiceListRequest struct {
	vmGraphicsConsolesService *VmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	current                   *bool
	max                       *int64
}

func (p *VmGraphicsConsolesServiceListRequest) Header(key, value string) *VmGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Query(key, value string) *VmGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Current(current bool) *VmGraphicsConsolesServiceListRequest {
	p.current = &current
	return p
}
func (p *VmGraphicsConsolesServiceListRequest) Max(max int64) *VmGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmGraphicsConsolesServiceListRequest) Send() (*VmGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.Connection.URL(), p.vmGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsolesService.Connection.username, p.vmGraphicsConsolesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmGraphicsConsolesServiceListResponse VmGraphicsConsolesServiceListResponse
	var consolesVar GraphicsConsoles
	xml.Unmarshal(respBodyBytes, &consolesVar)
	vmGraphicsConsolesServiceListResponse.consoles = consolesVar.GraphicsConsoles
	return &vmGraphicsConsolesServiceListResponse, nil
}

type VmGraphicsConsolesServiceListResponse struct {
	consoles []GraphicsConsole
}

func (p *VmGraphicsConsolesServiceListResponse) Consoles() []GraphicsConsole {
	return p.consoles
}
func (p *VmGraphicsConsolesService) List() *VmGraphicsConsolesServiceListRequest {
	return &VmGraphicsConsolesServiceListRequest{vmGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific virtual machine graphics console.
//
func (op *VmGraphicsConsolesService) ConsoleService(id string) *VmGraphicsConsoleService {
	return NewVmGraphicsConsoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmGraphicsConsolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConsoleService(path)), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *VmGraphicsConsolesService) String() string {
	return fmt.Sprintf("VmGraphicsConsolesService:%s", op.Path)
}

//
// A service to manage a specific permit of the role.
//
type PermitService struct {
	BaseService
}

func NewPermitService(connection *Connection, path string) *PermitService {
	var result PermitService
	result.Connection = connection
	result.Path = path
	return &result
}

type PermitServiceGetRequest struct {
	permitService *PermitService
	header        map[string]string
	query         map[string]string
}

func (p *PermitServiceGetRequest) Header(key, value string) *PermitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitServiceGetRequest) Query(key, value string) *PermitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitServiceGetRequest) Send() (*PermitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitService.Connection.URL(), p.permitService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permitService.Connection.username, p.permitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var permitServiceGetResponse PermitServiceGetResponse
	var permitVar Permit
	xml.Unmarshal(respBodyBytes, &permitVar)
	permitServiceGetResponse.permit = &permitVar
	return &permitServiceGetResponse, nil
}

type PermitServiceGetResponse struct {
	permit *Permit
}

func (p *PermitServiceGetResponse) Permit() *Permit {
	return p.permit
}
func (p *PermitService) Get() *PermitServiceGetRequest {
	return &PermitServiceGetRequest{permitService: p}
}

type PermitServiceRemoveRequest struct {
	permitService *PermitService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *PermitServiceRemoveRequest) Header(key, value string) *PermitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitServiceRemoveRequest) Query(key, value string) *PermitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitServiceRemoveRequest) Async(async bool) *PermitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *PermitServiceRemoveRequest) Send() (*PermitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitService.Connection.URL(), p.permitService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permitService.Connection.username, p.permitService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(PermitServiceRemoveResponse), nil
}

type PermitServiceRemoveResponse struct {
}

func (p *PermitService) Remove() *PermitServiceRemoveRequest {
	return &PermitServiceRemoveRequest{permitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *PermitService) String() string {
	return fmt.Sprintf("PermitService:%s", op.Path)
}

//
// A service to manage a data center.
//
type DataCenterService struct {
	BaseService
}

func NewDataCenterService(connection *Connection, path string) *DataCenterService {
	var result DataCenterService
	result.Connection = connection
	result.Path = path
	return &result
}

type DataCenterServiceGetRequest struct {
	dataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	filter            *bool
}

func (p *DataCenterServiceGetRequest) Header(key, value string) *DataCenterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceGetRequest) Query(key, value string) *DataCenterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceGetRequest) Filter(filter bool) *DataCenterServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *DataCenterServiceGetRequest) Send() (*DataCenterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.Connection.URL(), p.dataCenterService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCenterService.Connection.username, p.dataCenterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCenterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var dataCenterServiceGetResponse DataCenterServiceGetResponse
	var dataCenterVar DataCenter
	xml.Unmarshal(respBodyBytes, &dataCenterVar)
	dataCenterServiceGetResponse.dataCenter = &dataCenterVar
	return &dataCenterServiceGetResponse, nil
}

type DataCenterServiceGetResponse struct {
	dataCenter *DataCenter
}

func (p *DataCenterServiceGetResponse) DataCenter() *DataCenter {
	return p.dataCenter
}
func (p *DataCenterService) Get() *DataCenterServiceGetRequest {
	return &DataCenterServiceGetRequest{dataCenterService: p}
}

type DataCenterServiceRemoveRequest struct {
	dataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	force             *bool
}

func (p *DataCenterServiceRemoveRequest) Header(key, value string) *DataCenterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceRemoveRequest) Query(key, value string) *DataCenterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceRemoveRequest) Async(async bool) *DataCenterServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DataCenterServiceRemoveRequest) Force(force bool) *DataCenterServiceRemoveRequest {
	p.force = &force
	return p
}
func (p *DataCenterServiceRemoveRequest) Send() (*DataCenterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.Connection.URL(), p.dataCenterService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCenterService.Connection.username, p.dataCenterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCenterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DataCenterServiceRemoveResponse), nil
}

type DataCenterServiceRemoveResponse struct {
}

func (p *DataCenterService) Remove() *DataCenterServiceRemoveRequest {
	return &DataCenterServiceRemoveRequest{dataCenterService: p}
}

type DataCenterServiceUpdateRequest struct {
	dataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	dataCenter        *DataCenter
}

func (p *DataCenterServiceUpdateRequest) Header(key, value string) *DataCenterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceUpdateRequest) Query(key, value string) *DataCenterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceUpdateRequest) Async(async bool) *DataCenterServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *DataCenterServiceUpdateRequest) DataCenter(dataCenter *DataCenter) *DataCenterServiceUpdateRequest {
	p.dataCenter = dataCenter
	return p
}
func (p *DataCenterServiceUpdateRequest) Send() (*DataCenterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.Connection.URL(), p.dataCenterService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.dataCenter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCenterService.Connection.username, p.dataCenterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCenterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var dataCenterServiceUpdateResponse DataCenterServiceUpdateResponse
	var dataCenterVar DataCenter
	xml.Unmarshal(respBodyBytes, &dataCenterVar)
	dataCenterServiceUpdateResponse.dataCenter = &dataCenterVar
	return &dataCenterServiceUpdateResponse, nil
}

type DataCenterServiceUpdateResponse struct {
	dataCenter *DataCenter
}

func (p *DataCenterServiceUpdateResponse) DataCenter() *DataCenter {
	return p.dataCenter
}
func (p *DataCenterService) Update() *DataCenterServiceUpdateRequest {
	return &DataCenterServiceUpdateRequest{dataCenterService: p}
}

//
//
func (op *DataCenterService) ClustersService() *ClustersService {
	return NewClustersService(op.Connection, fmt.Sprintf("%s/clusters", op.Path))
}

//
// Reference to the iSCSI bonds service.
//
func (op *DataCenterService) IscsiBondsService() *IscsiBondsService {
	return NewIscsiBondsService(op.Connection, fmt.Sprintf("%s/iscsibonds", op.Path))
}

//
// Returns a reference to the service, that manages the networks, that are associated with the data center.
//
func (op *DataCenterService) NetworksService() *NetworksService {
	return NewNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
// Reference to the permissions service.
//
func (op *DataCenterService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Reference to the QOSs service.
//
func (op *DataCenterService) QossService() *QossService {
	return NewQossService(op.Connection, fmt.Sprintf("%s/qoss", op.Path))
}

//
// Reference to the quotas service.
//
func (op *DataCenterService) QuotasService() *QuotasService {
	return NewQuotasService(op.Connection, fmt.Sprintf("%s/quotas", op.Path))
}

//
// Attach and detach storage domains to and from a data center.
// For attaching a single storage domain we should use the following POST request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>data1</name>
// </storage_domain>
// ----
// For detaching a single storage domain we should use the following DELETE request:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/storagedomains/123
// ----
//
func (op *DataCenterService) StorageDomainsService() *AttachedStorageDomainsService {
	return NewAttachedStorageDomainsService(op.Connection, fmt.Sprintf("%s/storagedomains", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCenterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "iscsibonds" {
		return op.IscsiBondsService(), nil
	}
	if strings.HasPrefix(path, "iscsibonds/") {
		return op.IscsiBondsService().Service(path[11:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "qoss" {
		return op.QossService(), nil
	}
	if strings.HasPrefix(path, "qoss/") {
		return op.QossService().Service(path[5:])
	}
	if path == "quotas" {
		return op.QuotasService(), nil
	}
	if strings.HasPrefix(path, "quotas/") {
		return op.QuotasService().Service(path[7:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DataCenterService) String() string {
	return fmt.Sprintf("DataCenterService:%s", op.Path)
}

//
//
type StatisticsService struct {
	BaseService
}

func NewStatisticsService(connection *Connection, path string) *StatisticsService {
	var result StatisticsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StatisticsServiceListRequest struct {
	statisticsService *StatisticsService
	header            map[string]string
	query             map[string]string
	max               *int64
}

func (p *StatisticsServiceListRequest) Header(key, value string) *StatisticsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StatisticsServiceListRequest) Query(key, value string) *StatisticsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StatisticsServiceListRequest) Max(max int64) *StatisticsServiceListRequest {
	p.max = &max
	return p
}
func (p *StatisticsServiceListRequest) Send() (*StatisticsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.statisticsService.Connection.URL(), p.statisticsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.statisticsService.Connection.username, p.statisticsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.statisticsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var statisticsServiceListResponse StatisticsServiceListResponse
	var statisticsVar Statistics
	xml.Unmarshal(respBodyBytes, &statisticsVar)
	statisticsServiceListResponse.statistics = statisticsVar.Statistics
	return &statisticsServiceListResponse, nil
}

type StatisticsServiceListResponse struct {
	statistics []Statistic
}

func (p *StatisticsServiceListResponse) Statistics() []Statistic {
	return p.statistics
}
func (p *StatisticsService) List() *StatisticsServiceListRequest {
	return &StatisticsServiceListRequest{statisticsService: p}
}

//
//
func (op *StatisticsService) StatisticService(id string) *StatisticService {
	return NewStatisticService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StatisticsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StatisticService(path)), nil
	}
	return op.StatisticService(path[:index]).Service(path[index+1:])
}

func (op *StatisticsService) String() string {
	return fmt.Sprintf("StatisticsService:%s", op.Path)
}

//
//
type SchedulingPolicyUnitsService struct {
	BaseService
}

func NewSchedulingPolicyUnitsService(connection *Connection, path string) *SchedulingPolicyUnitsService {
	var result SchedulingPolicyUnitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPolicyUnitsServiceListRequest struct {
	schedulingPolicyUnitsService *SchedulingPolicyUnitsService
	header                       map[string]string
	query                        map[string]string
	filter                       *bool
	max                          *int64
}

func (p *SchedulingPolicyUnitsServiceListRequest) Header(key, value string) *SchedulingPolicyUnitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Query(key, value string) *SchedulingPolicyUnitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Filter(filter bool) *SchedulingPolicyUnitsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPolicyUnitsServiceListRequest) Max(max int64) *SchedulingPolicyUnitsServiceListRequest {
	p.max = &max
	return p
}
func (p *SchedulingPolicyUnitsServiceListRequest) Send() (*SchedulingPolicyUnitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitsService.Connection.URL(), p.schedulingPolicyUnitsService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyUnitsService.Connection.username, p.schedulingPolicyUnitsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var schedulingPolicyUnitsServiceListResponse SchedulingPolicyUnitsServiceListResponse
	var unitsVar SchedulingPolicyUnits
	xml.Unmarshal(respBodyBytes, &unitsVar)
	schedulingPolicyUnitsServiceListResponse.units = unitsVar.SchedulingPolicyUnits
	return &schedulingPolicyUnitsServiceListResponse, nil
}

type SchedulingPolicyUnitsServiceListResponse struct {
	units []SchedulingPolicyUnit
}

func (p *SchedulingPolicyUnitsServiceListResponse) Units() []SchedulingPolicyUnit {
	return p.units
}
func (p *SchedulingPolicyUnitsService) List() *SchedulingPolicyUnitsServiceListRequest {
	return &SchedulingPolicyUnitsServiceListRequest{schedulingPolicyUnitsService: p}
}

//
//
func (op *SchedulingPolicyUnitsService) UnitService(id string) *SchedulingPolicyUnitService {
	return NewSchedulingPolicyUnitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyUnitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UnitService(path)), nil
	}
	return op.UnitService(path[:index]).Service(path[index+1:])
}

func (op *SchedulingPolicyUnitsService) String() string {
	return fmt.Sprintf("SchedulingPolicyUnitsService:%s", op.Path)
}

//
//
type TemplateDiskService struct {
	BaseService
}

func NewTemplateDiskService(connection *Connection, path string) *TemplateDiskService {
	var result TemplateDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDiskServiceCopyRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
}

func (p *TemplateDiskServiceCopyRequest) Header(key, value string) *TemplateDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceCopyRequest) Query(key, value string) *TemplateDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceCopyRequest) Async(async bool) *TemplateDiskServiceCopyRequest {
	p.async = &async
	return p
}
func (p *TemplateDiskServiceCopyRequest) Filter(filter bool) *TemplateDiskServiceCopyRequest {
	p.filter = &filter
	return p
}
func (p *TemplateDiskServiceCopyRequest) Send() (*TemplateDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.templateDiskService.Connection.URL(), p.templateDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskService.Connection.username, p.templateDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateDiskServiceCopyResponse), nil
}

type TemplateDiskServiceCopyResponse struct {
}

func (p *TemplateDiskService) Copy() *TemplateDiskServiceCopyRequest {
	return &TemplateDiskServiceCopyRequest{templateDiskService: p}
}

type TemplateDiskServiceExportRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
}

func (p *TemplateDiskServiceExportRequest) Header(key, value string) *TemplateDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceExportRequest) Query(key, value string) *TemplateDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceExportRequest) Async(async bool) *TemplateDiskServiceExportRequest {
	p.async = &async
	return p
}
func (p *TemplateDiskServiceExportRequest) Filter(filter bool) *TemplateDiskServiceExportRequest {
	p.filter = &filter
	return p
}
func (p *TemplateDiskServiceExportRequest) Send() (*TemplateDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.templateDiskService.Connection.URL(), p.templateDiskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskService.Connection.username, p.templateDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateDiskServiceExportResponse), nil
}

type TemplateDiskServiceExportResponse struct {
}

func (p *TemplateDiskService) Export() *TemplateDiskServiceExportRequest {
	return &TemplateDiskServiceExportRequest{templateDiskService: p}
}

type TemplateDiskServiceGetRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
}

func (p *TemplateDiskServiceGetRequest) Header(key, value string) *TemplateDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceGetRequest) Query(key, value string) *TemplateDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceGetRequest) Send() (*TemplateDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskService.Connection.URL(), p.templateDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskService.Connection.username, p.templateDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateDiskServiceGetResponse TemplateDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	templateDiskServiceGetResponse.disk = &diskVar
	return &templateDiskServiceGetResponse, nil
}

type TemplateDiskServiceGetResponse struct {
	disk *Disk
}

func (p *TemplateDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}
func (p *TemplateDiskService) Get() *TemplateDiskServiceGetRequest {
	return &TemplateDiskServiceGetRequest{templateDiskService: p}
}

type TemplateDiskServiceRemoveRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *TemplateDiskServiceRemoveRequest) Header(key, value string) *TemplateDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceRemoveRequest) Query(key, value string) *TemplateDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceRemoveRequest) Async(async bool) *TemplateDiskServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateDiskServiceRemoveRequest) Send() (*TemplateDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskService.Connection.URL(), p.templateDiskService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskService.Connection.username, p.templateDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateDiskServiceRemoveResponse), nil
}

type TemplateDiskServiceRemoveResponse struct {
}

func (p *TemplateDiskService) Remove() *TemplateDiskServiceRemoveRequest {
	return &TemplateDiskServiceRemoveRequest{templateDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateDiskService) String() string {
	return fmt.Sprintf("TemplateDiskService:%s", op.Path)
}

//
// This service represents list of vms that have a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type AffinityLabelVmsService struct {
	BaseService
}

func NewAffinityLabelVmsService(connection *Connection, path string) *AffinityLabelVmsService {
	var result AffinityLabelVmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelVmsServiceAddRequest struct {
	affinityLabelVmsService *AffinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *AffinityLabelVmsServiceAddRequest) Header(key, value string) *AffinityLabelVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmsServiceAddRequest) Query(key, value string) *AffinityLabelVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmsServiceAddRequest) Vm(vm *Vm) *AffinityLabelVmsServiceAddRequest {
	p.vm = vm
	return p
}
func (p *AffinityLabelVmsServiceAddRequest) Send() (*AffinityLabelVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.Connection.URL(), p.affinityLabelVmsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.vm)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelVmsService.Connection.username, p.affinityLabelVmsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelVmsServiceAddResponse AffinityLabelVmsServiceAddResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	affinityLabelVmsServiceAddResponse.vm = &vmVar
	return &affinityLabelVmsServiceAddResponse, nil
}

type AffinityLabelVmsServiceAddResponse struct {
	vm *Vm
}

func (p *AffinityLabelVmsServiceAddResponse) Vm() *Vm {
	return p.vm
}
func (p *AffinityLabelVmsService) Add() *AffinityLabelVmsServiceAddRequest {
	return &AffinityLabelVmsServiceAddRequest{affinityLabelVmsService: p}
}

type AffinityLabelVmsServiceListRequest struct {
	affinityLabelVmsService *AffinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
}

func (p *AffinityLabelVmsServiceListRequest) Header(key, value string) *AffinityLabelVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmsServiceListRequest) Query(key, value string) *AffinityLabelVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmsServiceListRequest) Send() (*AffinityLabelVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.Connection.URL(), p.affinityLabelVmsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelVmsService.Connection.username, p.affinityLabelVmsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelVmsServiceListResponse AffinityLabelVmsServiceListResponse
	var vmsVar Vms
	xml.Unmarshal(respBodyBytes, &vmsVar)
	affinityLabelVmsServiceListResponse.vms = vmsVar.Vms
	return &affinityLabelVmsServiceListResponse, nil
}

type AffinityLabelVmsServiceListResponse struct {
	vms []Vm
}

func (p *AffinityLabelVmsServiceListResponse) Vms() []Vm {
	return p.vms
}
func (p *AffinityLabelVmsService) List() *AffinityLabelVmsServiceListRequest {
	return &AffinityLabelVmsServiceListRequest{affinityLabelVmsService: p}
}

//
// A link to the specific label-vm assignment to
// allow label removal.
//
func (op *AffinityLabelVmsService) VmService(id string) *AffinityLabelVmService {
	return NewAffinityLabelVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelVmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelVmsService) String() string {
	return fmt.Sprintf("AffinityLabelVmsService:%s", op.Path)
}

//
//
type CopyableService struct {
	BaseService
}

func NewCopyableService(connection *Connection, path string) *CopyableService {
	var result CopyableService
	result.Connection = connection
	result.Path = path
	return &result
}

type CopyableServiceCopyRequest struct {
	copyableService *CopyableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *CopyableServiceCopyRequest) Header(key, value string) *CopyableServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CopyableServiceCopyRequest) Query(key, value string) *CopyableServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CopyableServiceCopyRequest) Async(async bool) *CopyableServiceCopyRequest {
	p.async = &async
	return p
}
func (p *CopyableServiceCopyRequest) Send() (*CopyableServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.copyableService.Connection.URL(), p.copyableService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.copyableService.Connection.username, p.copyableService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.copyableService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(CopyableServiceCopyResponse), nil
}

type CopyableServiceCopyResponse struct {
}

func (p *CopyableService) Copy() *CopyableServiceCopyRequest {
	return &CopyableServiceCopyRequest{copyableService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CopyableService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *CopyableService) String() string {
	return fmt.Sprintf("CopyableService:%s", op.Path)
}

//
// Manages the affinity labels available in the system.
//
type AffinityLabelsService struct {
	BaseService
}

func NewAffinityLabelsService(connection *Connection, path string) *AffinityLabelsService {
	var result AffinityLabelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelsServiceAddRequest struct {
	affinityLabelsService *AffinityLabelsService
	header                map[string]string
	query                 map[string]string
	label                 *AffinityLabel
}

func (p *AffinityLabelsServiceAddRequest) Header(key, value string) *AffinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelsServiceAddRequest) Query(key, value string) *AffinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelsServiceAddRequest) Label(label *AffinityLabel) *AffinityLabelsServiceAddRequest {
	p.label = label
	return p
}
func (p *AffinityLabelsServiceAddRequest) Send() (*AffinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.Connection.URL(), p.affinityLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.label)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelsService.Connection.username, p.affinityLabelsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelsServiceAddResponse AffinityLabelsServiceAddResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	affinityLabelsServiceAddResponse.label = &labelVar
	return &affinityLabelsServiceAddResponse, nil
}

type AffinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelsServiceAddResponse) Label() *AffinityLabel {
	return p.label
}
func (p *AffinityLabelsService) Add() *AffinityLabelsServiceAddRequest {
	return &AffinityLabelsServiceAddRequest{affinityLabelsService: p}
}

type AffinityLabelsServiceListRequest struct {
	affinityLabelsService *AffinityLabelsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *AffinityLabelsServiceListRequest) Header(key, value string) *AffinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelsServiceListRequest) Query(key, value string) *AffinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelsServiceListRequest) Max(max int64) *AffinityLabelsServiceListRequest {
	p.max = &max
	return p
}
func (p *AffinityLabelsServiceListRequest) Send() (*AffinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.Connection.URL(), p.affinityLabelsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelsService.Connection.username, p.affinityLabelsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelsServiceListResponse AffinityLabelsServiceListResponse
	var labelsVar AffinityLabels
	xml.Unmarshal(respBodyBytes, &labelsVar)
	affinityLabelsServiceListResponse.labels = labelsVar.AffinityLabels
	return &affinityLabelsServiceListResponse, nil
}

type AffinityLabelsServiceListResponse struct {
	labels []AffinityLabel
}

func (p *AffinityLabelsServiceListResponse) Labels() []AffinityLabel {
	return p.labels
}
func (p *AffinityLabelsService) List() *AffinityLabelsServiceListRequest {
	return &AffinityLabelsServiceListRequest{affinityLabelsService: p}
}

//
// Link to a single label details.
//
func (op *AffinityLabelsService) LabelService(id string) *AffinityLabelService {
	return NewAffinityLabelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LabelService(path)), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelsService) String() string {
	return fmt.Sprintf("AffinityLabelsService:%s", op.Path)
}

//
//
type VmGraphicsConsoleService struct {
	BaseService
}

func NewVmGraphicsConsoleService(connection *Connection, path string) *VmGraphicsConsoleService {
	var result VmGraphicsConsoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmGraphicsConsoleServiceGetRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	current                  *bool
}

func (p *VmGraphicsConsoleServiceGetRequest) Header(key, value string) *VmGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Query(key, value string) *VmGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Current(current bool) *VmGraphicsConsoleServiceGetRequest {
	p.current = &current
	return p
}
func (p *VmGraphicsConsoleServiceGetRequest) Send() (*VmGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsoleService.Connection.URL(), p.vmGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsoleService.Connection.username, p.vmGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmGraphicsConsoleServiceGetResponse VmGraphicsConsoleServiceGetResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	vmGraphicsConsoleServiceGetResponse.console = &consoleVar
	return &vmGraphicsConsoleServiceGetResponse, nil
}

type VmGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *VmGraphicsConsoleServiceGetResponse) Console() *GraphicsConsole {
	return p.console
}
func (p *VmGraphicsConsoleService) Get() *VmGraphicsConsoleServiceGetRequest {
	return &VmGraphicsConsoleServiceGetRequest{vmGraphicsConsoleService: p}
}

type VmGraphicsConsoleServiceProxyTicketRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Header(key, value string) *VmGraphicsConsoleServiceProxyTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Query(key, value string) *VmGraphicsConsoleServiceProxyTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Async(async bool) *VmGraphicsConsoleServiceProxyTicketRequest {
	p.async = &async
	return p
}
func (p *VmGraphicsConsoleServiceProxyTicketRequest) Send() (*VmGraphicsConsoleServiceProxyTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/proxyticket", p.vmGraphicsConsoleService.Connection.URL(), p.vmGraphicsConsoleService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsoleService.Connection.username, p.vmGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &VmGraphicsConsoleServiceProxyTicketResponse{proxyTicket: action.ProxyTicket}, nil
}

type VmGraphicsConsoleServiceProxyTicketResponse struct {
	proxyTicket *ProxyTicket
}

func (p *VmGraphicsConsoleServiceProxyTicketResponse) ProxyTicket() *ProxyTicket {
	return p.proxyTicket
}
func (p *VmGraphicsConsoleService) ProxyTicket() *VmGraphicsConsoleServiceProxyTicketRequest {
	return &VmGraphicsConsoleServiceProxyTicketRequest{vmGraphicsConsoleService: p}
}

type VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Header(key, value string) *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Query(key, value string) *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Send() (*VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/remoteviewerconnectionfile", p.vmGraphicsConsoleService.Connection.URL(), p.vmGraphicsConsoleService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsoleService.Connection.username, p.vmGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse{remoteViewerConnectionFile: *action.RemoteViewerConnectionFile}, nil
}

type VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse struct {
	remoteViewerConnectionFile string
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse) RemoteViewerConnectionFile() string {
	return p.remoteViewerConnectionFile
}
func (p *VmGraphicsConsoleService) RemoteViewerConnectionFile() *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	return &VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest{vmGraphicsConsoleService: p}
}

type VmGraphicsConsoleServiceRemoveRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Header(key, value string) *VmGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Query(key, value string) *VmGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Async(async bool) *VmGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmGraphicsConsoleServiceRemoveRequest) Send() (*VmGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsoleService.Connection.URL(), p.vmGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsoleService.Connection.username, p.vmGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmGraphicsConsoleServiceRemoveResponse), nil
}

type VmGraphicsConsoleServiceRemoveResponse struct {
}

func (p *VmGraphicsConsoleService) Remove() *VmGraphicsConsoleServiceRemoveRequest {
	return &VmGraphicsConsoleServiceRemoveRequest{vmGraphicsConsoleService: p}
}

type VmGraphicsConsoleServiceTicketRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	ticket                   *Ticket
}

func (p *VmGraphicsConsoleServiceTicketRequest) Header(key, value string) *VmGraphicsConsoleServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceTicketRequest) Query(key, value string) *VmGraphicsConsoleServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceTicketRequest) Ticket(ticket *Ticket) *VmGraphicsConsoleServiceTicketRequest {
	p.ticket = ticket
	return p
}
func (p *VmGraphicsConsoleServiceTicketRequest) Send() (*VmGraphicsConsoleServiceTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/ticket", p.vmGraphicsConsoleService.Connection.URL(), p.vmGraphicsConsoleService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Ticket(p.ticket)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsoleService.Connection.username, p.vmGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &VmGraphicsConsoleServiceTicketResponse{ticket: action.Ticket}, nil
}

type VmGraphicsConsoleServiceTicketResponse struct {
	ticket *Ticket
}

func (p *VmGraphicsConsoleServiceTicketResponse) Ticket() *Ticket {
	return p.ticket
}
func (p *VmGraphicsConsoleService) Ticket() *VmGraphicsConsoleServiceTicketRequest {
	return &VmGraphicsConsoleServiceTicketRequest{vmGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmGraphicsConsoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmGraphicsConsoleService) String() string {
	return fmt.Sprintf("VmGraphicsConsoleService:%s", op.Path)
}

//
// This service represents a host that has a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type AffinityLabelHostService struct {
	BaseService
}

func NewAffinityLabelHostService(connection *Connection, path string) *AffinityLabelHostService {
	var result AffinityLabelHostService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelHostServiceGetRequest struct {
	affinityLabelHostService *AffinityLabelHostService
	header                   map[string]string
	query                    map[string]string
}

func (p *AffinityLabelHostServiceGetRequest) Header(key, value string) *AffinityLabelHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostServiceGetRequest) Query(key, value string) *AffinityLabelHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostServiceGetRequest) Send() (*AffinityLabelHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostService.Connection.URL(), p.affinityLabelHostService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelHostService.Connection.username, p.affinityLabelHostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelHostServiceGetResponse AffinityLabelHostServiceGetResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	affinityLabelHostServiceGetResponse.host = &hostVar
	return &affinityLabelHostServiceGetResponse, nil
}

type AffinityLabelHostServiceGetResponse struct {
	host *Host
}

func (p *AffinityLabelHostServiceGetResponse) Host() *Host {
	return p.host
}
func (p *AffinityLabelHostService) Get() *AffinityLabelHostServiceGetRequest {
	return &AffinityLabelHostServiceGetRequest{affinityLabelHostService: p}
}

type AffinityLabelHostServiceRemoveRequest struct {
	affinityLabelHostService *AffinityLabelHostService
	header                   map[string]string
	query                    map[string]string
}

func (p *AffinityLabelHostServiceRemoveRequest) Header(key, value string) *AffinityLabelHostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostServiceRemoveRequest) Query(key, value string) *AffinityLabelHostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostServiceRemoveRequest) Send() (*AffinityLabelHostServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostService.Connection.URL(), p.affinityLabelHostService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelHostService.Connection.username, p.affinityLabelHostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityLabelHostServiceRemoveResponse), nil
}

type AffinityLabelHostServiceRemoveResponse struct {
}

func (p *AffinityLabelHostService) Remove() *AffinityLabelHostServiceRemoveRequest {
	return &AffinityLabelHostServiceRemoveRequest{affinityLabelHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelHostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelHostService) String() string {
	return fmt.Sprintf("AffinityLabelHostService:%s", op.Path)
}

//
// A service to manage assignment of specific tag to specific entities in system.
//
type AssignedTagService struct {
	BaseService
}

func NewAssignedTagService(connection *Connection, path string) *AssignedTagService {
	var result AssignedTagService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedTagServiceGetRequest struct {
	assignedTagService *AssignedTagService
	header             map[string]string
	query              map[string]string
}

func (p *AssignedTagServiceGetRequest) Header(key, value string) *AssignedTagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagServiceGetRequest) Query(key, value string) *AssignedTagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagServiceGetRequest) Send() (*AssignedTagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagService.Connection.URL(), p.assignedTagService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedTagService.Connection.username, p.assignedTagService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedTagService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedTagServiceGetResponse AssignedTagServiceGetResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	assignedTagServiceGetResponse.tag = &tagVar
	return &assignedTagServiceGetResponse, nil
}

type AssignedTagServiceGetResponse struct {
	tag *Tag
}

func (p *AssignedTagServiceGetResponse) Tag() *Tag {
	return p.tag
}
func (p *AssignedTagService) Get() *AssignedTagServiceGetRequest {
	return &AssignedTagServiceGetRequest{assignedTagService: p}
}

type AssignedTagServiceRemoveRequest struct {
	assignedTagService *AssignedTagService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *AssignedTagServiceRemoveRequest) Header(key, value string) *AssignedTagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagServiceRemoveRequest) Query(key, value string) *AssignedTagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagServiceRemoveRequest) Async(async bool) *AssignedTagServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedTagServiceRemoveRequest) Send() (*AssignedTagServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagService.Connection.URL(), p.assignedTagService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedTagService.Connection.username, p.assignedTagService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedTagService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedTagServiceRemoveResponse), nil
}

type AssignedTagServiceRemoveResponse struct {
}

func (p *AssignedTagService) Remove() *AssignedTagServiceRemoveRequest {
	return &AssignedTagServiceRemoveRequest{assignedTagService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedTagService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedTagService) String() string {
	return fmt.Sprintf("AssignedTagService:%s", op.Path)
}

//
// Manages a single disk.
//
type DiskService struct {
	BaseService
}

func NewDiskService(connection *Connection, path string) *DiskService {
	var result DiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskServiceCopyRequest struct {
	diskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
	filter        *bool
	storageDomain *StorageDomain
}

func (p *DiskServiceCopyRequest) Header(key, value string) *DiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceCopyRequest) Query(key, value string) *DiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceCopyRequest) Async(async bool) *DiskServiceCopyRequest {
	p.async = &async
	return p
}
func (p *DiskServiceCopyRequest) Disk(disk *Disk) *DiskServiceCopyRequest {
	p.disk = disk
	return p
}
func (p *DiskServiceCopyRequest) Filter(filter bool) *DiskServiceCopyRequest {
	p.filter = &filter
	return p
}
func (p *DiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *DiskServiceCopyRequest) Send() (*DiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.diskService.Connection.URL(), p.diskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Disk(p.disk)
	actionBuilder.Filter(*p.filter)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceCopyResponse), nil
}

type DiskServiceCopyResponse struct {
}

func (p *DiskService) Copy() *DiskServiceCopyRequest {
	return &DiskServiceCopyRequest{diskService: p}
}

type DiskServiceExportRequest struct {
	diskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
	storageDomain *StorageDomain
}

func (p *DiskServiceExportRequest) Header(key, value string) *DiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceExportRequest) Query(key, value string) *DiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceExportRequest) Async(async bool) *DiskServiceExportRequest {
	p.async = &async
	return p
}
func (p *DiskServiceExportRequest) Filter(filter bool) *DiskServiceExportRequest {
	p.filter = &filter
	return p
}
func (p *DiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *DiskServiceExportRequest) Send() (*DiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.diskService.Connection.URL(), p.diskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceExportResponse), nil
}

type DiskServiceExportResponse struct {
}

func (p *DiskService) Export() *DiskServiceExportRequest {
	return &DiskServiceExportRequest{diskService: p}
}

type DiskServiceGetRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
}

func (p *DiskServiceGetRequest) Header(key, value string) *DiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceGetRequest) Query(key, value string) *DiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceGetRequest) Send() (*DiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskService.Connection.URL(), p.diskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskServiceGetResponse DiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	diskServiceGetResponse.disk = &diskVar
	return &diskServiceGetResponse, nil
}

type DiskServiceGetResponse struct {
	disk *Disk
}

func (p *DiskServiceGetResponse) Disk() *Disk {
	return p.disk
}
func (p *DiskService) Get() *DiskServiceGetRequest {
	return &DiskServiceGetRequest{diskService: p}
}

type DiskServiceMoveRequest struct {
	diskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
	storageDomain *StorageDomain
}

func (p *DiskServiceMoveRequest) Header(key, value string) *DiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceMoveRequest) Query(key, value string) *DiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceMoveRequest) Async(async bool) *DiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *DiskServiceMoveRequest) Filter(filter bool) *DiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *DiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *DiskServiceMoveRequest) Send() (*DiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.diskService.Connection.URL(), p.diskService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Filter(*p.filter)
	actionBuilder.StorageDomain(p.storageDomain)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceMoveResponse), nil
}

type DiskServiceMoveResponse struct {
}

func (p *DiskService) Move() *DiskServiceMoveRequest {
	return &DiskServiceMoveRequest{diskService: p}
}

type DiskServiceRemoveRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *DiskServiceRemoveRequest) Header(key, value string) *DiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceRemoveRequest) Query(key, value string) *DiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceRemoveRequest) Async(async bool) *DiskServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DiskServiceRemoveRequest) Send() (*DiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskService.Connection.URL(), p.diskService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskServiceRemoveResponse), nil
}

type DiskServiceRemoveResponse struct {
}

func (p *DiskService) Remove() *DiskServiceRemoveRequest {
	return &DiskServiceRemoveRequest{diskService: p}
}

type DiskServiceSparsifyRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
}

func (p *DiskServiceSparsifyRequest) Header(key, value string) *DiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceSparsifyRequest) Query(key, value string) *DiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceSparsifyRequest) Send() (*DiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.diskService.Connection.URL(), p.diskService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceSparsifyResponse), nil
}

type DiskServiceSparsifyResponse struct {
}

func (p *DiskService) Sparsify() *DiskServiceSparsifyRequest {
	return &DiskServiceSparsifyRequest{diskService: p}
}

type DiskServiceUpdateRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
	disk        *Disk
}

func (p *DiskServiceUpdateRequest) Header(key, value string) *DiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceUpdateRequest) Query(key, value string) *DiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceUpdateRequest) Disk(disk *Disk) *DiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *DiskServiceUpdateRequest) Send() (*DiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskService.Connection.URL(), p.diskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskServiceUpdateResponse DiskServiceUpdateResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	diskServiceUpdateResponse.disk = &diskVar
	return &diskServiceUpdateResponse, nil
}

type DiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *DiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}
func (p *DiskService) Update() *DiskServiceUpdateRequest {
	return &DiskServiceUpdateRequest{diskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *DiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *DiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskService) String() string {
	return fmt.Sprintf("DiskService:%s", op.Path)
}

//
// This service manages the set of disks attached to a template. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>.
//
type TemplateDiskAttachmentsService struct {
	BaseService
}

func NewTemplateDiskAttachmentsService(connection *Connection, path string) *TemplateDiskAttachmentsService {
	var result TemplateDiskAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDiskAttachmentsServiceListRequest struct {
	templateDiskAttachmentsService *TemplateDiskAttachmentsService
	header                         map[string]string
	query                          map[string]string
}

func (p *TemplateDiskAttachmentsServiceListRequest) Header(key, value string) *TemplateDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentsServiceListRequest) Query(key, value string) *TemplateDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentsServiceListRequest) Send() (*TemplateDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentsService.Connection.URL(), p.templateDiskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskAttachmentsService.Connection.username, p.templateDiskAttachmentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateDiskAttachmentsServiceListResponse TemplateDiskAttachmentsServiceListResponse
	var attachmentsVar DiskAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	templateDiskAttachmentsServiceListResponse.attachments = attachmentsVar.DiskAttachments
	return &templateDiskAttachmentsServiceListResponse, nil
}

type TemplateDiskAttachmentsServiceListResponse struct {
	attachments []DiskAttachment
}

func (p *TemplateDiskAttachmentsServiceListResponse) Attachments() []DiskAttachment {
	return p.attachments
}
func (p *TemplateDiskAttachmentsService) List() *TemplateDiskAttachmentsServiceListRequest {
	return &TemplateDiskAttachmentsServiceListRequest{templateDiskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *TemplateDiskAttachmentsService) AttachmentService(id string) *TemplateDiskAttachmentService {
	return NewTemplateDiskAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *TemplateDiskAttachmentsService) String() string {
	return fmt.Sprintf("TemplateDiskAttachmentsService:%s", op.Path)
}

//
//
type StorageDomainContentDisksService struct {
	BaseService
}

func NewStorageDomainContentDisksService(connection *Connection, path string) *StorageDomainContentDisksService {
	var result StorageDomainContentDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainContentDisksServiceListRequest struct {
	storageDomainContentDisksService *StorageDomainContentDisksService
	header                           map[string]string
	query                            map[string]string
	caseSensitive                    *bool
	max                              *int64
	search                           *string
}

func (p *StorageDomainContentDisksServiceListRequest) Header(key, value string) *StorageDomainContentDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) Query(key, value string) *StorageDomainContentDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) CaseSensitive(caseSensitive bool) *StorageDomainContentDisksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *StorageDomainContentDisksServiceListRequest) Max(max int64) *StorageDomainContentDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainContentDisksServiceListRequest) Search(search string) *StorageDomainContentDisksServiceListRequest {
	p.search = &search
	return p
}
func (p *StorageDomainContentDisksServiceListRequest) Send() (*StorageDomainContentDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDisksService.Connection.URL(), p.storageDomainContentDisksService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainContentDisksService.Connection.username, p.storageDomainContentDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainContentDisksServiceListResponse StorageDomainContentDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	storageDomainContentDisksServiceListResponse.disks = disksVar.Disks
	return &storageDomainContentDisksServiceListResponse, nil
}

type StorageDomainContentDisksServiceListResponse struct {
	disks []Disk
}

func (p *StorageDomainContentDisksServiceListResponse) Disks() []Disk {
	return p.disks
}
func (p *StorageDomainContentDisksService) List() *StorageDomainContentDisksServiceListRequest {
	return &StorageDomainContentDisksServiceListRequest{storageDomainContentDisksService: p}
}

//
//
func (op *StorageDomainContentDisksService) DiskService(id string) *StorageDomainContentDiskService {
	return NewStorageDomainContentDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainContentDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainContentDisksService) String() string {
	return fmt.Sprintf("StorageDomainContentDisksService:%s", op.Path)
}

//
// A service to access host devices.
//
type HostDevicesService struct {
	BaseService
}

func NewHostDevicesService(connection *Connection, path string) *HostDevicesService {
	var result HostDevicesService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostDevicesServiceListRequest struct {
	hostDevicesService *HostDevicesService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *HostDevicesServiceListRequest) Header(key, value string) *HostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostDevicesServiceListRequest) Query(key, value string) *HostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostDevicesServiceListRequest) Max(max int64) *HostDevicesServiceListRequest {
	p.max = &max
	return p
}
func (p *HostDevicesServiceListRequest) Send() (*HostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostDevicesService.Connection.URL(), p.hostDevicesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostDevicesService.Connection.username, p.hostDevicesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostDevicesServiceListResponse HostDevicesServiceListResponse
	var devicesVar HostDevices
	xml.Unmarshal(respBodyBytes, &devicesVar)
	hostDevicesServiceListResponse.devices = devicesVar.HostDevices
	return &hostDevicesServiceListResponse, nil
}

type HostDevicesServiceListResponse struct {
	devices []HostDevice
}

func (p *HostDevicesServiceListResponse) Devices() []HostDevice {
	return p.devices
}
func (p *HostDevicesService) List() *HostDevicesServiceListRequest {
	return &HostDevicesServiceListRequest{hostDevicesService: p}
}

//
// Reference to the service that can be used to access a specific host device.
//
func (op *HostDevicesService) DeviceService(id string) *HostDeviceService {
	return NewHostDeviceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostDevicesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DeviceService(path)), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *HostDevicesService) String() string {
	return fmt.Sprintf("HostDevicesService:%s", op.Path)
}

//
//
type AssignedNetworksService struct {
	BaseService
}

func NewAssignedNetworksService(connection *Connection, path string) *AssignedNetworksService {
	var result AssignedNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedNetworksServiceAddRequest struct {
	assignedNetworksService *AssignedNetworksService
	header                  map[string]string
	query                   map[string]string
	network                 *Network
}

func (p *AssignedNetworksServiceAddRequest) Header(key, value string) *AssignedNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworksServiceAddRequest) Query(key, value string) *AssignedNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworksServiceAddRequest) Network(network *Network) *AssignedNetworksServiceAddRequest {
	p.network = network
	return p
}
func (p *AssignedNetworksServiceAddRequest) Send() (*AssignedNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworksService.Connection.URL(), p.assignedNetworksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworksService.Connection.username, p.assignedNetworksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedNetworksServiceAddResponse AssignedNetworksServiceAddResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	assignedNetworksServiceAddResponse.network = &networkVar
	return &assignedNetworksServiceAddResponse, nil
}

type AssignedNetworksServiceAddResponse struct {
	network *Network
}

func (p *AssignedNetworksServiceAddResponse) Network() *Network {
	return p.network
}
func (p *AssignedNetworksService) Add() *AssignedNetworksServiceAddRequest {
	return &AssignedNetworksServiceAddRequest{assignedNetworksService: p}
}

type AssignedNetworksServiceListRequest struct {
	assignedNetworksService *AssignedNetworksService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *AssignedNetworksServiceListRequest) Header(key, value string) *AssignedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworksServiceListRequest) Query(key, value string) *AssignedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworksServiceListRequest) Max(max int64) *AssignedNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedNetworksServiceListRequest) Send() (*AssignedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworksService.Connection.URL(), p.assignedNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworksService.Connection.username, p.assignedNetworksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedNetworksServiceListResponse AssignedNetworksServiceListResponse
	var networksVar Networks
	xml.Unmarshal(respBodyBytes, &networksVar)
	assignedNetworksServiceListResponse.networks = networksVar.Networks
	return &assignedNetworksServiceListResponse, nil
}

type AssignedNetworksServiceListResponse struct {
	networks []Network
}

func (p *AssignedNetworksServiceListResponse) Networks() []Network {
	return p.networks
}
func (p *AssignedNetworksService) List() *AssignedNetworksServiceListRequest {
	return &AssignedNetworksServiceListRequest{assignedNetworksService: p}
}

//
//
func (op *AssignedNetworksService) NetworkService(id string) *AssignedNetworkService {
	return NewAssignedNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *AssignedNetworksService) String() string {
	return fmt.Sprintf("AssignedNetworksService:%s", op.Path)
}

//
//
type StorageService struct {
	BaseService
}

func NewStorageService(connection *Connection, path string) *StorageService {
	var result StorageService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServiceGetRequest struct {
	storageService *StorageService
	header         map[string]string
	query          map[string]string
	reportStatus   *bool
}

func (p *StorageServiceGetRequest) Header(key, value string) *StorageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServiceGetRequest) Query(key, value string) *StorageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServiceGetRequest) ReportStatus(reportStatus bool) *StorageServiceGetRequest {
	p.reportStatus = &reportStatus
	return p
}
func (p *StorageServiceGetRequest) Send() (*StorageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageService.Connection.URL(), p.storageService.Path)
	values := make(url.Values)
	if p.reportStatus != nil {
		values["reportStatus"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageService.Connection.username, p.storageService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServiceGetResponse StorageServiceGetResponse
	var storageVar HostStorage
	xml.Unmarshal(respBodyBytes, &storageVar)
	storageServiceGetResponse.storage = &storageVar
	return &storageServiceGetResponse, nil
}

type StorageServiceGetResponse struct {
	storage *HostStorage
}

func (p *StorageServiceGetResponse) Storage() *HostStorage {
	return p.storage
}
func (p *StorageService) Get() *StorageServiceGetRequest {
	return &StorageServiceGetRequest{storageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageService) String() string {
	return fmt.Sprintf("StorageService:%s", op.Path)
}

//
//
type UnmanagedNetworkService struct {
	BaseService
}

func NewUnmanagedNetworkService(connection *Connection, path string) *UnmanagedNetworkService {
	var result UnmanagedNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type UnmanagedNetworkServiceGetRequest struct {
	unmanagedNetworkService *UnmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
}

func (p *UnmanagedNetworkServiceGetRequest) Header(key, value string) *UnmanagedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworkServiceGetRequest) Query(key, value string) *UnmanagedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworkServiceGetRequest) Send() (*UnmanagedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworkService.Connection.URL(), p.unmanagedNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.unmanagedNetworkService.Connection.username, p.unmanagedNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var unmanagedNetworkServiceGetResponse UnmanagedNetworkServiceGetResponse
	var networkVar UnmanagedNetwork
	xml.Unmarshal(respBodyBytes, &networkVar)
	unmanagedNetworkServiceGetResponse.network = &networkVar
	return &unmanagedNetworkServiceGetResponse, nil
}

type UnmanagedNetworkServiceGetResponse struct {
	network *UnmanagedNetwork
}

func (p *UnmanagedNetworkServiceGetResponse) Network() *UnmanagedNetwork {
	return p.network
}
func (p *UnmanagedNetworkService) Get() *UnmanagedNetworkServiceGetRequest {
	return &UnmanagedNetworkServiceGetRequest{unmanagedNetworkService: p}
}

type UnmanagedNetworkServiceRemoveRequest struct {
	unmanagedNetworkService *UnmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *UnmanagedNetworkServiceRemoveRequest) Header(key, value string) *UnmanagedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworkServiceRemoveRequest) Query(key, value string) *UnmanagedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworkServiceRemoveRequest) Async(async bool) *UnmanagedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *UnmanagedNetworkServiceRemoveRequest) Send() (*UnmanagedNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworkService.Connection.URL(), p.unmanagedNetworkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.unmanagedNetworkService.Connection.username, p.unmanagedNetworkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(UnmanagedNetworkServiceRemoveResponse), nil
}

type UnmanagedNetworkServiceRemoveResponse struct {
}

func (p *UnmanagedNetworkService) Remove() *UnmanagedNetworkServiceRemoveRequest {
	return &UnmanagedNetworkServiceRemoveRequest{unmanagedNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UnmanagedNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *UnmanagedNetworkService) String() string {
	return fmt.Sprintf("UnmanagedNetworkService:%s", op.Path)
}

//
//
type QuotaService struct {
	BaseService
}

func NewQuotaService(connection *Connection, path string) *QuotaService {
	var result QuotaService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaServiceGetRequest struct {
	quotaService *QuotaService
	header       map[string]string
	query        map[string]string
}

func (p *QuotaServiceGetRequest) Header(key, value string) *QuotaServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceGetRequest) Query(key, value string) *QuotaServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceGetRequest) Send() (*QuotaServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.Connection.URL(), p.quotaService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaService.Connection.username, p.quotaService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaServiceGetResponse QuotaServiceGetResponse
	var quotaVar Quota
	xml.Unmarshal(respBodyBytes, &quotaVar)
	quotaServiceGetResponse.quota = &quotaVar
	return &quotaServiceGetResponse, nil
}

type QuotaServiceGetResponse struct {
	quota *Quota
}

func (p *QuotaServiceGetResponse) Quota() *Quota {
	return p.quota
}
func (p *QuotaService) Get() *QuotaServiceGetRequest {
	return &QuotaServiceGetRequest{quotaService: p}
}

type QuotaServiceRemoveRequest struct {
	quotaService *QuotaService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *QuotaServiceRemoveRequest) Header(key, value string) *QuotaServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceRemoveRequest) Query(key, value string) *QuotaServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceRemoveRequest) Async(async bool) *QuotaServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QuotaServiceRemoveRequest) Send() (*QuotaServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.Connection.URL(), p.quotaService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaService.Connection.username, p.quotaService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QuotaServiceRemoveResponse), nil
}

type QuotaServiceRemoveResponse struct {
}

func (p *QuotaService) Remove() *QuotaServiceRemoveRequest {
	return &QuotaServiceRemoveRequest{quotaService: p}
}

type QuotaServiceUpdateRequest struct {
	quotaService *QuotaService
	header       map[string]string
	query        map[string]string
	async        *bool
	quota        *Quota
}

func (p *QuotaServiceUpdateRequest) Header(key, value string) *QuotaServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceUpdateRequest) Query(key, value string) *QuotaServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceUpdateRequest) Async(async bool) *QuotaServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *QuotaServiceUpdateRequest) Quota(quota *Quota) *QuotaServiceUpdateRequest {
	p.quota = quota
	return p
}
func (p *QuotaServiceUpdateRequest) Send() (*QuotaServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.Connection.URL(), p.quotaService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.quota)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaService.Connection.username, p.quotaService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var quotaServiceUpdateResponse QuotaServiceUpdateResponse
	var quotaVar Quota
	xml.Unmarshal(respBodyBytes, &quotaVar)
	quotaServiceUpdateResponse.quota = &quotaVar
	return &quotaServiceUpdateResponse, nil
}

type QuotaServiceUpdateResponse struct {
	quota *Quota
}

func (p *QuotaServiceUpdateResponse) Quota() *Quota {
	return p.quota
}
func (p *QuotaService) Update() *QuotaServiceUpdateRequest {
	return &QuotaServiceUpdateRequest{quotaService: p}
}

//
//
func (op *QuotaService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *QuotaService) QuotaClusterLimitsService() *QuotaClusterLimitsService {
	return NewQuotaClusterLimitsService(op.Connection, fmt.Sprintf("%s/quotaclusterlimits", op.Path))
}

//
//
func (op *QuotaService) QuotaStorageLimitsService() *QuotaStorageLimitsService {
	return NewQuotaStorageLimitsService(op.Connection, fmt.Sprintf("%s/quotastoragelimits", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "quotaclusterlimits" {
		return op.QuotaClusterLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotaclusterlimits/") {
		return op.QuotaClusterLimitsService().Service(path[19:])
	}
	if path == "quotastoragelimits" {
		return op.QuotaStorageLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotastoragelimits/") {
		return op.QuotaStorageLimitsService().Service(path[19:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaService) String() string {
	return fmt.Sprintf("QuotaService:%s", op.Path)
}

//
//
type SnapshotDiskService struct {
	BaseService
}

func NewSnapshotDiskService(connection *Connection, path string) *SnapshotDiskService {
	var result SnapshotDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotDiskServiceGetRequest struct {
	snapshotDiskService *SnapshotDiskService
	header              map[string]string
	query               map[string]string
}

func (p *SnapshotDiskServiceGetRequest) Header(key, value string) *SnapshotDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotDiskServiceGetRequest) Query(key, value string) *SnapshotDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotDiskServiceGetRequest) Send() (*SnapshotDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDiskService.Connection.URL(), p.snapshotDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotDiskService.Connection.username, p.snapshotDiskService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotDiskServiceGetResponse SnapshotDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	snapshotDiskServiceGetResponse.disk = &diskVar
	return &snapshotDiskServiceGetResponse, nil
}

type SnapshotDiskServiceGetResponse struct {
	disk *Disk
}

func (p *SnapshotDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}
func (p *SnapshotDiskService) Get() *SnapshotDiskServiceGetRequest {
	return &SnapshotDiskServiceGetRequest{snapshotDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotDiskService) String() string {
	return fmt.Sprintf("SnapshotDiskService:%s", op.Path)
}

//
//
type QossService struct {
	BaseService
}

func NewQossService(connection *Connection, path string) *QossService {
	var result QossService
	result.Connection = connection
	result.Path = path
	return &result
}

type QossServiceAddRequest struct {
	qossService *QossService
	header      map[string]string
	query       map[string]string
	qos         *Qos
}

func (p *QossServiceAddRequest) Header(key, value string) *QossServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QossServiceAddRequest) Query(key, value string) *QossServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QossServiceAddRequest) Qos(qos *Qos) *QossServiceAddRequest {
	p.qos = qos
	return p
}
func (p *QossServiceAddRequest) Send() (*QossServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qossService.Connection.URL(), p.qossService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.qos)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qossService.Connection.username, p.qossService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qossService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var qossServiceAddResponse QossServiceAddResponse
	var qosVar Qos
	xml.Unmarshal(respBodyBytes, &qosVar)
	qossServiceAddResponse.qos = &qosVar
	return &qossServiceAddResponse, nil
}

type QossServiceAddResponse struct {
	qos *Qos
}

func (p *QossServiceAddResponse) Qos() *Qos {
	return p.qos
}
func (p *QossService) Add() *QossServiceAddRequest {
	return &QossServiceAddRequest{qossService: p}
}

type QossServiceListRequest struct {
	qossService *QossService
	header      map[string]string
	query       map[string]string
	max         *int64
}

func (p *QossServiceListRequest) Header(key, value string) *QossServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QossServiceListRequest) Query(key, value string) *QossServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QossServiceListRequest) Max(max int64) *QossServiceListRequest {
	p.max = &max
	return p
}
func (p *QossServiceListRequest) Send() (*QossServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qossService.Connection.URL(), p.qossService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qossService.Connection.username, p.qossService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qossService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var qossServiceListResponse QossServiceListResponse
	var qossVar Qoss
	xml.Unmarshal(respBodyBytes, &qossVar)
	qossServiceListResponse.qoss = qossVar.Qoss
	return &qossServiceListResponse, nil
}

type QossServiceListResponse struct {
	qoss []Qos
}

func (p *QossServiceListResponse) Qoss() []Qos {
	return p.qoss
}
func (p *QossService) List() *QossServiceListRequest {
	return &QossServiceListRequest{qossService: p}
}

//
//
func (op *QossService) QosService(id string) *QosService {
	return NewQosService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QossService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.QosService(path)), nil
	}
	return op.QosService(path[:index]).Service(path[index+1:])
}

func (op *QossService) String() string {
	return fmt.Sprintf("QossService:%s", op.Path)
}

//
// A service managing a network
//
type NetworkService struct {
	BaseService
}

func NewNetworkService(connection *Connection, path string) *NetworkService {
	var result NetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkServiceGetRequest struct {
	networkService *NetworkService
	header         map[string]string
	query          map[string]string
}

func (p *NetworkServiceGetRequest) Header(key, value string) *NetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceGetRequest) Query(key, value string) *NetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceGetRequest) Send() (*NetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkService.Connection.URL(), p.networkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkService.Connection.username, p.networkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkServiceGetResponse NetworkServiceGetResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	networkServiceGetResponse.network = &networkVar
	return &networkServiceGetResponse, nil
}

type NetworkServiceGetResponse struct {
	network *Network
}

func (p *NetworkServiceGetResponse) Network() *Network {
	return p.network
}
func (p *NetworkService) Get() *NetworkServiceGetRequest {
	return &NetworkServiceGetRequest{networkService: p}
}

type NetworkServiceRemoveRequest struct {
	networkService *NetworkService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *NetworkServiceRemoveRequest) Header(key, value string) *NetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceRemoveRequest) Query(key, value string) *NetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceRemoveRequest) Async(async bool) *NetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *NetworkServiceRemoveRequest) Send() (*NetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkService.Connection.URL(), p.networkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkService.Connection.username, p.networkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NetworkServiceRemoveResponse), nil
}

type NetworkServiceRemoveResponse struct {
}

func (p *NetworkService) Remove() *NetworkServiceRemoveRequest {
	return &NetworkServiceRemoveRequest{networkService: p}
}

type NetworkServiceUpdateRequest struct {
	networkService *NetworkService
	header         map[string]string
	query          map[string]string
	async          *bool
	network        *Network
}

func (p *NetworkServiceUpdateRequest) Header(key, value string) *NetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceUpdateRequest) Query(key, value string) *NetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceUpdateRequest) Async(async bool) *NetworkServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *NetworkServiceUpdateRequest) Network(network *Network) *NetworkServiceUpdateRequest {
	p.network = network
	return p
}
func (p *NetworkServiceUpdateRequest) Send() (*NetworkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkService.Connection.URL(), p.networkService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkService.Connection.username, p.networkService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkServiceUpdateResponse NetworkServiceUpdateResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	networkServiceUpdateResponse.network = &networkVar
	return &networkServiceUpdateResponse, nil
}

type NetworkServiceUpdateResponse struct {
	network *Network
}

func (p *NetworkServiceUpdateResponse) Network() *Network {
	return p.network
}
func (p *NetworkService) Update() *NetworkServiceUpdateRequest {
	return &NetworkServiceUpdateRequest{networkService: p}
}

//
// Reference to the service that manages the network labels assigned to this network.
//
func (op *NetworkService) NetworkLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.Connection, fmt.Sprintf("%s/networklabels", op.Path))
}

//
// Reference to the service that manages the permissions assigned to this network.
//
func (op *NetworkService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Reference to the service that manages the vNIC profiles assigned to this network.
//
func (op *NetworkService) VnicProfilesService() *AssignedVnicProfilesService {
	return NewAssignedVnicProfilesService(op.Connection, fmt.Sprintf("%s/vnicprofiles", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkService) String() string {
	return fmt.Sprintf("NetworkService:%s", op.Path)
}

//
//
type InstanceTypeService struct {
	BaseService
}

func NewInstanceTypeService(connection *Connection, path string) *InstanceTypeService {
	var result InstanceTypeService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeServiceGetRequest struct {
	instanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
}

func (p *InstanceTypeServiceGetRequest) Header(key, value string) *InstanceTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceGetRequest) Query(key, value string) *InstanceTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceGetRequest) Send() (*InstanceTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.Connection.URL(), p.instanceTypeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeService.Connection.username, p.instanceTypeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeServiceGetResponse InstanceTypeServiceGetResponse
	var instanceTypeVar InstanceType
	xml.Unmarshal(respBodyBytes, &instanceTypeVar)
	instanceTypeServiceGetResponse.instanceType = &instanceTypeVar
	return &instanceTypeServiceGetResponse, nil
}

type InstanceTypeServiceGetResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypeServiceGetResponse) InstanceType() *InstanceType {
	return p.instanceType
}
func (p *InstanceTypeService) Get() *InstanceTypeServiceGetRequest {
	return &InstanceTypeServiceGetRequest{instanceTypeService: p}
}

type InstanceTypeServiceRemoveRequest struct {
	instanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *InstanceTypeServiceRemoveRequest) Header(key, value string) *InstanceTypeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceRemoveRequest) Query(key, value string) *InstanceTypeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceRemoveRequest) Async(async bool) *InstanceTypeServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeServiceRemoveRequest) Send() (*InstanceTypeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.Connection.URL(), p.instanceTypeService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeService.Connection.username, p.instanceTypeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeServiceRemoveResponse), nil
}

type InstanceTypeServiceRemoveResponse struct {
}

func (p *InstanceTypeService) Remove() *InstanceTypeServiceRemoveRequest {
	return &InstanceTypeServiceRemoveRequest{instanceTypeService: p}
}

type InstanceTypeServiceUpdateRequest struct {
	instanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
	instanceType        *InstanceType
}

func (p *InstanceTypeServiceUpdateRequest) Header(key, value string) *InstanceTypeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceUpdateRequest) Query(key, value string) *InstanceTypeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceUpdateRequest) Async(async bool) *InstanceTypeServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeServiceUpdateRequest) InstanceType(instanceType *InstanceType) *InstanceTypeServiceUpdateRequest {
	p.instanceType = instanceType
	return p
}
func (p *InstanceTypeServiceUpdateRequest) Send() (*InstanceTypeServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.Connection.URL(), p.instanceTypeService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.instanceType)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeService.Connection.username, p.instanceTypeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeServiceUpdateResponse InstanceTypeServiceUpdateResponse
	var instanceTypeVar InstanceType
	xml.Unmarshal(respBodyBytes, &instanceTypeVar)
	instanceTypeServiceUpdateResponse.instanceType = &instanceTypeVar
	return &instanceTypeServiceUpdateResponse, nil
}

type InstanceTypeServiceUpdateResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypeServiceUpdateResponse) InstanceType() *InstanceType {
	return p.instanceType
}
func (p *InstanceTypeService) Update() *InstanceTypeServiceUpdateRequest {
	return &InstanceTypeServiceUpdateRequest{instanceTypeService: p}
}

//
// Reference to the service that manages the graphic consoles that are attached to this
// instance type.
//
func (op *InstanceTypeService) GraphicsConsolesService() *InstanceTypeGraphicsConsolesService {
	return NewInstanceTypeGraphicsConsolesService(op.Connection, fmt.Sprintf("%s/graphicsconsoles", op.Path))
}

//
// Reference to the service that manages the NICs that are attached to this instance type.
//
func (op *InstanceTypeService) NicsService() *InstanceTypeNicsService {
	return NewInstanceTypeNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Reference to the service that manages the watchdogs that are attached to this instance type.
//
func (op *InstanceTypeService) WatchdogsService() *InstanceTypeWatchdogsService {
	return NewInstanceTypeWatchdogsService(op.Connection, fmt.Sprintf("%s/watchdogs", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeService) String() string {
	return fmt.Sprintf("InstanceTypeService:%s", op.Path)
}

//
//
type VirtualFunctionAllowedNetworksService struct {
	BaseService
}

func NewVirtualFunctionAllowedNetworksService(connection *Connection, path string) *VirtualFunctionAllowedNetworksService {
	var result VirtualFunctionAllowedNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type VirtualFunctionAllowedNetworksServiceAddRequest struct {
	virtualFunctionAllowedNetworksService *VirtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	network                               *Network
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Header(key, value string) *VirtualFunctionAllowedNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Query(key, value string) *VirtualFunctionAllowedNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Network(network *Network) *VirtualFunctionAllowedNetworksServiceAddRequest {
	p.network = network
	return p
}
func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Send() (*VirtualFunctionAllowedNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.Connection.URL(), p.virtualFunctionAllowedNetworksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.virtualFunctionAllowedNetworksService.Connection.username, p.virtualFunctionAllowedNetworksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var virtualFunctionAllowedNetworksServiceAddResponse VirtualFunctionAllowedNetworksServiceAddResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	virtualFunctionAllowedNetworksServiceAddResponse.network = &networkVar
	return &virtualFunctionAllowedNetworksServiceAddResponse, nil
}

type VirtualFunctionAllowedNetworksServiceAddResponse struct {
	network *Network
}

func (p *VirtualFunctionAllowedNetworksServiceAddResponse) Network() *Network {
	return p.network
}
func (p *VirtualFunctionAllowedNetworksService) Add() *VirtualFunctionAllowedNetworksServiceAddRequest {
	return &VirtualFunctionAllowedNetworksServiceAddRequest{virtualFunctionAllowedNetworksService: p}
}

type VirtualFunctionAllowedNetworksServiceListRequest struct {
	virtualFunctionAllowedNetworksService *VirtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	max                                   *int64
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Header(key, value string) *VirtualFunctionAllowedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Query(key, value string) *VirtualFunctionAllowedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Max(max int64) *VirtualFunctionAllowedNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *VirtualFunctionAllowedNetworksServiceListRequest) Send() (*VirtualFunctionAllowedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.Connection.URL(), p.virtualFunctionAllowedNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.virtualFunctionAllowedNetworksService.Connection.username, p.virtualFunctionAllowedNetworksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var virtualFunctionAllowedNetworksServiceListResponse VirtualFunctionAllowedNetworksServiceListResponse
	var networksVar Networks
	xml.Unmarshal(respBodyBytes, &networksVar)
	virtualFunctionAllowedNetworksServiceListResponse.networks = networksVar.Networks
	return &virtualFunctionAllowedNetworksServiceListResponse, nil
}

type VirtualFunctionAllowedNetworksServiceListResponse struct {
	networks []Network
}

func (p *VirtualFunctionAllowedNetworksServiceListResponse) Networks() []Network {
	return p.networks
}
func (p *VirtualFunctionAllowedNetworksService) List() *VirtualFunctionAllowedNetworksServiceListRequest {
	return &VirtualFunctionAllowedNetworksServiceListRequest{virtualFunctionAllowedNetworksService: p}
}

//
//
func (op *VirtualFunctionAllowedNetworksService) NetworkService(id string) *VirtualFunctionAllowedNetworkService {
	return NewVirtualFunctionAllowedNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VirtualFunctionAllowedNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *VirtualFunctionAllowedNetworksService) String() string {
	return fmt.Sprintf("VirtualFunctionAllowedNetworksService:%s", op.Path)
}

//
//
type HostHookService struct {
	BaseService
}

func NewHostHookService(connection *Connection, path string) *HostHookService {
	var result HostHookService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostHookServiceGetRequest struct {
	hostHookService *HostHookService
	header          map[string]string
	query           map[string]string
}

func (p *HostHookServiceGetRequest) Header(key, value string) *HostHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostHookServiceGetRequest) Query(key, value string) *HostHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostHookServiceGetRequest) Send() (*HostHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostHookService.Connection.URL(), p.hostHookService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostHookService.Connection.username, p.hostHookService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostHookServiceGetResponse HostHookServiceGetResponse
	var hookVar Hook
	xml.Unmarshal(respBodyBytes, &hookVar)
	hostHookServiceGetResponse.hook = &hookVar
	return &hostHookServiceGetResponse, nil
}

type HostHookServiceGetResponse struct {
	hook *Hook
}

func (p *HostHookServiceGetResponse) Hook() *Hook {
	return p.hook
}
func (p *HostHookService) Get() *HostHookServiceGetRequest {
	return &HostHookServiceGetRequest{hostHookService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostHookService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostHookService) String() string {
	return fmt.Sprintf("HostHookService:%s", op.Path)
}

//
//
type ImagesService struct {
	BaseService
}

func NewImagesService(connection *Connection, path string) *ImagesService {
	var result ImagesService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImagesServiceListRequest struct {
	imagesService *ImagesService
	header        map[string]string
	query         map[string]string
	max           *int64
}

func (p *ImagesServiceListRequest) Header(key, value string) *ImagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImagesServiceListRequest) Query(key, value string) *ImagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImagesServiceListRequest) Max(max int64) *ImagesServiceListRequest {
	p.max = &max
	return p
}
func (p *ImagesServiceListRequest) Send() (*ImagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imagesService.Connection.URL(), p.imagesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imagesService.Connection.username, p.imagesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imagesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var imagesServiceListResponse ImagesServiceListResponse
	var imagesVar Images
	xml.Unmarshal(respBodyBytes, &imagesVar)
	imagesServiceListResponse.images = imagesVar.Images
	return &imagesServiceListResponse, nil
}

type ImagesServiceListResponse struct {
	images []Image
}

func (p *ImagesServiceListResponse) Images() []Image {
	return p.images
}
func (p *ImagesService) List() *ImagesServiceListRequest {
	return &ImagesServiceListRequest{imagesService: p}
}

//
//
func (op *ImagesService) ImageService(id string) *ImageService {
	return NewImageService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImagesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ImageService(path)), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *ImagesService) String() string {
	return fmt.Sprintf("ImagesService:%s", op.Path)
}

//
//
type SnapshotCdromsService struct {
	BaseService
}

func NewSnapshotCdromsService(connection *Connection, path string) *SnapshotCdromsService {
	var result SnapshotCdromsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotCdromsServiceListRequest struct {
	snapshotCdromsService *SnapshotCdromsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *SnapshotCdromsServiceListRequest) Header(key, value string) *SnapshotCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotCdromsServiceListRequest) Query(key, value string) *SnapshotCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotCdromsServiceListRequest) Max(max int64) *SnapshotCdromsServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotCdromsServiceListRequest) Send() (*SnapshotCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromsService.Connection.URL(), p.snapshotCdromsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotCdromsService.Connection.username, p.snapshotCdromsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotCdromsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotCdromsServiceListResponse SnapshotCdromsServiceListResponse
	var cdromsVar Cdroms
	xml.Unmarshal(respBodyBytes, &cdromsVar)
	snapshotCdromsServiceListResponse.cdroms = cdromsVar.Cdroms
	return &snapshotCdromsServiceListResponse, nil
}

type SnapshotCdromsServiceListResponse struct {
	cdroms []Cdrom
}

func (p *SnapshotCdromsServiceListResponse) Cdroms() []Cdrom {
	return p.cdroms
}
func (p *SnapshotCdromsService) List() *SnapshotCdromsServiceListRequest {
	return &SnapshotCdromsServiceListRequest{snapshotCdromsService: p}
}

//
//
func (op *SnapshotCdromsService) CdromService(id string) *SnapshotCdromService {
	return NewSnapshotCdromService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotCdromsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CdromService(path)), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotCdromsService) String() string {
	return fmt.Sprintf("SnapshotCdromsService:%s", op.Path)
}

//
//
type BalancesService struct {
	BaseService
}

func NewBalancesService(connection *Connection, path string) *BalancesService {
	var result BalancesService
	result.Connection = connection
	result.Path = path
	return &result
}

type BalancesServiceAddRequest struct {
	balancesService *BalancesService
	header          map[string]string
	query           map[string]string
	balance         *Balance
}

func (p *BalancesServiceAddRequest) Header(key, value string) *BalancesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalancesServiceAddRequest) Query(key, value string) *BalancesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalancesServiceAddRequest) Balance(balance *Balance) *BalancesServiceAddRequest {
	p.balance = balance
	return p
}
func (p *BalancesServiceAddRequest) Send() (*BalancesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.Connection.URL(), p.balancesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.balance)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.balancesService.Connection.username, p.balancesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.balancesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var balancesServiceAddResponse BalancesServiceAddResponse
	var balanceVar Balance
	xml.Unmarshal(respBodyBytes, &balanceVar)
	balancesServiceAddResponse.balance = &balanceVar
	return &balancesServiceAddResponse, nil
}

type BalancesServiceAddResponse struct {
	balance *Balance
}

func (p *BalancesServiceAddResponse) Balance() *Balance {
	return p.balance
}
func (p *BalancesService) Add() *BalancesServiceAddRequest {
	return &BalancesServiceAddRequest{balancesService: p}
}

type BalancesServiceListRequest struct {
	balancesService *BalancesService
	header          map[string]string
	query           map[string]string
	filter          *bool
	max             *int64
}

func (p *BalancesServiceListRequest) Header(key, value string) *BalancesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalancesServiceListRequest) Query(key, value string) *BalancesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalancesServiceListRequest) Filter(filter bool) *BalancesServiceListRequest {
	p.filter = &filter
	return p
}
func (p *BalancesServiceListRequest) Max(max int64) *BalancesServiceListRequest {
	p.max = &max
	return p
}
func (p *BalancesServiceListRequest) Send() (*BalancesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.Connection.URL(), p.balancesService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.balancesService.Connection.username, p.balancesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.balancesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var balancesServiceListResponse BalancesServiceListResponse
	var balancesVar Balances
	xml.Unmarshal(respBodyBytes, &balancesVar)
	balancesServiceListResponse.balances = balancesVar.Balances
	return &balancesServiceListResponse, nil
}

type BalancesServiceListResponse struct {
	balances []Balance
}

func (p *BalancesServiceListResponse) Balances() []Balance {
	return p.balances
}
func (p *BalancesService) List() *BalancesServiceListRequest {
	return &BalancesServiceListRequest{balancesService: p}
}

//
//
func (op *BalancesService) BalanceService(id string) *BalanceService {
	return NewBalanceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BalancesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.BalanceService(path)), nil
	}
	return op.BalanceService(path[:index]).Service(path[index+1:])
}

func (op *BalancesService) String() string {
	return fmt.Sprintf("BalancesService:%s", op.Path)
}

//
// A service managing a CD-ROM device on templates.
//
type TemplateCdromService struct {
	BaseService
}

func NewTemplateCdromService(connection *Connection, path string) *TemplateCdromService {
	var result TemplateCdromService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateCdromServiceGetRequest struct {
	templateCdromService *TemplateCdromService
	header               map[string]string
	query                map[string]string
}

func (p *TemplateCdromServiceGetRequest) Header(key, value string) *TemplateCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateCdromServiceGetRequest) Query(key, value string) *TemplateCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateCdromServiceGetRequest) Send() (*TemplateCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromService.Connection.URL(), p.templateCdromService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateCdromService.Connection.username, p.templateCdromService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateCdromService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateCdromServiceGetResponse TemplateCdromServiceGetResponse
	var cdromVar Cdrom
	xml.Unmarshal(respBodyBytes, &cdromVar)
	templateCdromServiceGetResponse.cdrom = &cdromVar
	return &templateCdromServiceGetResponse, nil
}

type TemplateCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *TemplateCdromServiceGetResponse) Cdrom() *Cdrom {
	return p.cdrom
}
func (p *TemplateCdromService) Get() *TemplateCdromServiceGetRequest {
	return &TemplateCdromServiceGetRequest{templateCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateCdromService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateCdromService) String() string {
	return fmt.Sprintf("TemplateCdromService:%s", op.Path)
}

//
//
type MoveableService struct {
	BaseService
}

func NewMoveableService(connection *Connection, path string) *MoveableService {
	var result MoveableService
	result.Connection = connection
	result.Path = path
	return &result
}

type MoveableServiceMoveRequest struct {
	moveableService *MoveableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *MoveableServiceMoveRequest) Header(key, value string) *MoveableServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MoveableServiceMoveRequest) Query(key, value string) *MoveableServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MoveableServiceMoveRequest) Async(async bool) *MoveableServiceMoveRequest {
	p.async = &async
	return p
}
func (p *MoveableServiceMoveRequest) Send() (*MoveableServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.moveableService.Connection.URL(), p.moveableService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.moveableService.Connection.username, p.moveableService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.moveableService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(MoveableServiceMoveResponse), nil
}

type MoveableServiceMoveResponse struct {
}

func (p *MoveableService) Move() *MoveableServiceMoveRequest {
	return &MoveableServiceMoveRequest{moveableService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MoveableService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MoveableService) String() string {
	return fmt.Sprintf("MoveableService:%s", op.Path)
}

//
//
type CpuProfileService struct {
	BaseService
}

func NewCpuProfileService(connection *Connection, path string) *CpuProfileService {
	var result CpuProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type CpuProfileServiceGetRequest struct {
	cpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
}

func (p *CpuProfileServiceGetRequest) Header(key, value string) *CpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceGetRequest) Query(key, value string) *CpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceGetRequest) Send() (*CpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.Connection.URL(), p.cpuProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfileService.Connection.username, p.cpuProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var cpuProfileServiceGetResponse CpuProfileServiceGetResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	cpuProfileServiceGetResponse.profile = &profileVar
	return &cpuProfileServiceGetResponse, nil
}

type CpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *CpuProfileServiceGetResponse) Profile() *CpuProfile {
	return p.profile
}
func (p *CpuProfileService) Get() *CpuProfileServiceGetRequest {
	return &CpuProfileServiceGetRequest{cpuProfileService: p}
}

type CpuProfileServiceRemoveRequest struct {
	cpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *CpuProfileServiceRemoveRequest) Header(key, value string) *CpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceRemoveRequest) Query(key, value string) *CpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceRemoveRequest) Async(async bool) *CpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *CpuProfileServiceRemoveRequest) Send() (*CpuProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.Connection.URL(), p.cpuProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfileService.Connection.username, p.cpuProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(CpuProfileServiceRemoveResponse), nil
}

type CpuProfileServiceRemoveResponse struct {
}

func (p *CpuProfileService) Remove() *CpuProfileServiceRemoveRequest {
	return &CpuProfileServiceRemoveRequest{cpuProfileService: p}
}

type CpuProfileServiceUpdateRequest struct {
	cpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
	profile           *CpuProfile
}

func (p *CpuProfileServiceUpdateRequest) Header(key, value string) *CpuProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceUpdateRequest) Query(key, value string) *CpuProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceUpdateRequest) Async(async bool) *CpuProfileServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *CpuProfileServiceUpdateRequest) Profile(profile *CpuProfile) *CpuProfileServiceUpdateRequest {
	p.profile = profile
	return p
}
func (p *CpuProfileServiceUpdateRequest) Send() (*CpuProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.Connection.URL(), p.cpuProfileService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfileService.Connection.username, p.cpuProfileService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var cpuProfileServiceUpdateResponse CpuProfileServiceUpdateResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	cpuProfileServiceUpdateResponse.profile = &profileVar
	return &cpuProfileServiceUpdateResponse, nil
}

type CpuProfileServiceUpdateResponse struct {
	profile *CpuProfile
}

func (p *CpuProfileServiceUpdateResponse) Profile() *CpuProfile {
	return p.profile
}
func (p *CpuProfileService) Update() *CpuProfileServiceUpdateRequest {
	return &CpuProfileServiceUpdateRequest{cpuProfileService: p}
}

//
//
func (op *CpuProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CpuProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *CpuProfileService) String() string {
	return fmt.Sprintf("CpuProfileService:%s", op.Path)
}

//
//
type MeasurableService struct {
	BaseService
}

func NewMeasurableService(connection *Connection, path string) *MeasurableService {
	var result MeasurableService
	result.Connection = connection
	result.Path = path
	return &result
}

//
//
func (op *MeasurableService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MeasurableService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MeasurableService) String() string {
	return fmt.Sprintf("MeasurableService:%s", op.Path)
}

//
//
type StorageServerConnectionExtensionService struct {
	BaseService
}

func NewStorageServerConnectionExtensionService(connection *Connection, path string) *StorageServerConnectionExtensionService {
	var result StorageServerConnectionExtensionService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionExtensionServiceGetRequest struct {
	storageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Header(key, value string) *StorageServerConnectionExtensionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Query(key, value string) *StorageServerConnectionExtensionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Send() (*StorageServerConnectionExtensionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.Connection.URL(), p.storageServerConnectionExtensionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionService.Connection.username, p.storageServerConnectionExtensionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionExtensionServiceGetResponse StorageServerConnectionExtensionServiceGetResponse
	var extensionVar StorageConnectionExtension
	xml.Unmarshal(respBodyBytes, &extensionVar)
	storageServerConnectionExtensionServiceGetResponse.extension = &extensionVar
	return &storageServerConnectionExtensionServiceGetResponse, nil
}

type StorageServerConnectionExtensionServiceGetResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceGetResponse) Extension() *StorageConnectionExtension {
	return p.extension
}
func (p *StorageServerConnectionExtensionService) Get() *StorageServerConnectionExtensionServiceGetRequest {
	return &StorageServerConnectionExtensionServiceGetRequest{storageServerConnectionExtensionService: p}
}

type StorageServerConnectionExtensionServiceRemoveRequest struct {
	storageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Header(key, value string) *StorageServerConnectionExtensionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Query(key, value string) *StorageServerConnectionExtensionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Async(async bool) *StorageServerConnectionExtensionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionExtensionServiceRemoveRequest) Send() (*StorageServerConnectionExtensionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.Connection.URL(), p.storageServerConnectionExtensionService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionService.Connection.username, p.storageServerConnectionExtensionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageServerConnectionExtensionServiceRemoveResponse), nil
}

type StorageServerConnectionExtensionServiceRemoveResponse struct {
}

func (p *StorageServerConnectionExtensionService) Remove() *StorageServerConnectionExtensionServiceRemoveRequest {
	return &StorageServerConnectionExtensionServiceRemoveRequest{storageServerConnectionExtensionService: p}
}

type StorageServerConnectionExtensionServiceUpdateRequest struct {
	storageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
	extension                               *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Header(key, value string) *StorageServerConnectionExtensionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Query(key, value string) *StorageServerConnectionExtensionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Async(async bool) *StorageServerConnectionExtensionServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionExtensionServiceUpdateRequest) Extension(extension *StorageConnectionExtension) *StorageServerConnectionExtensionServiceUpdateRequest {
	p.extension = extension
	return p
}
func (p *StorageServerConnectionExtensionServiceUpdateRequest) Send() (*StorageServerConnectionExtensionServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.Connection.URL(), p.storageServerConnectionExtensionService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.extension)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionService.Connection.username, p.storageServerConnectionExtensionService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionExtensionServiceUpdateResponse StorageServerConnectionExtensionServiceUpdateResponse
	var extensionVar StorageConnectionExtension
	xml.Unmarshal(respBodyBytes, &extensionVar)
	storageServerConnectionExtensionServiceUpdateResponse.extension = &extensionVar
	return &storageServerConnectionExtensionServiceUpdateResponse, nil
}

type StorageServerConnectionExtensionServiceUpdateResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceUpdateResponse) Extension() *StorageConnectionExtension {
	return p.extension
}
func (p *StorageServerConnectionExtensionService) Update() *StorageServerConnectionExtensionServiceUpdateRequest {
	return &StorageServerConnectionExtensionServiceUpdateRequest{storageServerConnectionExtensionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionExtensionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageServerConnectionExtensionService) String() string {
	return fmt.Sprintf("StorageServerConnectionExtensionService:%s", op.Path)
}

//
// Provides information about the capabilities of different cluster levels supported by the engine. Version 4.0 of the
// engine supports levels 4.0 and 3.6. Each of these levels support different sets of CPU types, for example. This
// service provides that information.
//
type ClusterLevelsService struct {
	BaseService
}

func NewClusterLevelsService(connection *Connection, path string) *ClusterLevelsService {
	var result ClusterLevelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClusterLevelsServiceListRequest struct {
	clusterLevelsService *ClusterLevelsService
	header               map[string]string
	query                map[string]string
}

func (p *ClusterLevelsServiceListRequest) Header(key, value string) *ClusterLevelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterLevelsServiceListRequest) Query(key, value string) *ClusterLevelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterLevelsServiceListRequest) Send() (*ClusterLevelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelsService.Connection.URL(), p.clusterLevelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterLevelsService.Connection.username, p.clusterLevelsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterLevelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var clusterLevelsServiceListResponse ClusterLevelsServiceListResponse
	var levelsVar ClusterLevels
	xml.Unmarshal(respBodyBytes, &levelsVar)
	clusterLevelsServiceListResponse.levels = levelsVar.ClusterLevels
	return &clusterLevelsServiceListResponse, nil
}

type ClusterLevelsServiceListResponse struct {
	levels []ClusterLevel
}

func (p *ClusterLevelsServiceListResponse) Levels() []ClusterLevel {
	return p.levels
}
func (p *ClusterLevelsService) List() *ClusterLevelsServiceListRequest {
	return &ClusterLevelsServiceListRequest{clusterLevelsService: p}
}

//
// Reference to the service that provides information about an specific cluster level.
//
func (op *ClusterLevelsService) LevelService(id string) *ClusterLevelService {
	return NewClusterLevelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterLevelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LevelService(path)), nil
	}
	return op.LevelService(path[:index]).Service(path[index+1:])
}

func (op *ClusterLevelsService) String() string {
	return fmt.Sprintf("ClusterLevelsService:%s", op.Path)
}

//
// This service manages a collection of parameters for network filters.
//
type NetworkFilterParametersService struct {
	BaseService
}

func NewNetworkFilterParametersService(connection *Connection, path string) *NetworkFilterParametersService {
	var result NetworkFilterParametersService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFilterParametersServiceAddRequest struct {
	networkFilterParametersService *NetworkFilterParametersService
	header                         map[string]string
	query                          map[string]string
	parameter                      *NetworkFilterParameter
}

func (p *NetworkFilterParametersServiceAddRequest) Header(key, value string) *NetworkFilterParametersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParametersServiceAddRequest) Query(key, value string) *NetworkFilterParametersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParametersServiceAddRequest) Parameter(parameter *NetworkFilterParameter) *NetworkFilterParametersServiceAddRequest {
	p.parameter = parameter
	return p
}
func (p *NetworkFilterParametersServiceAddRequest) Send() (*NetworkFilterParametersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParametersService.Connection.URL(), p.networkFilterParametersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.parameter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParametersService.Connection.username, p.networkFilterParametersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParametersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkFilterParametersServiceAddResponse NetworkFilterParametersServiceAddResponse
	var parameterVar NetworkFilterParameter
	xml.Unmarshal(respBodyBytes, &parameterVar)
	networkFilterParametersServiceAddResponse.parameter = &parameterVar
	return &networkFilterParametersServiceAddResponse, nil
}

type NetworkFilterParametersServiceAddResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NetworkFilterParametersServiceAddResponse) Parameter() *NetworkFilterParameter {
	return p.parameter
}
func (p *NetworkFilterParametersService) Add() *NetworkFilterParametersServiceAddRequest {
	return &NetworkFilterParametersServiceAddRequest{networkFilterParametersService: p}
}

type NetworkFilterParametersServiceListRequest struct {
	networkFilterParametersService *NetworkFilterParametersService
	header                         map[string]string
	query                          map[string]string
}

func (p *NetworkFilterParametersServiceListRequest) Header(key, value string) *NetworkFilterParametersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParametersServiceListRequest) Query(key, value string) *NetworkFilterParametersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParametersServiceListRequest) Send() (*NetworkFilterParametersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParametersService.Connection.URL(), p.networkFilterParametersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParametersService.Connection.username, p.networkFilterParametersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParametersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var networkFilterParametersServiceListResponse NetworkFilterParametersServiceListResponse
	var parametersVar NetworkFilterParameters
	xml.Unmarshal(respBodyBytes, &parametersVar)
	networkFilterParametersServiceListResponse.parameters = parametersVar.NetworkFilterParameters
	return &networkFilterParametersServiceListResponse, nil
}

type NetworkFilterParametersServiceListResponse struct {
	parameters []NetworkFilterParameter
}

func (p *NetworkFilterParametersServiceListResponse) Parameters() []NetworkFilterParameter {
	return p.parameters
}
func (p *NetworkFilterParametersService) List() *NetworkFilterParametersServiceListRequest {
	return &NetworkFilterParametersServiceListRequest{networkFilterParametersService: p}
}

//
// Reference to the service that manages a specific network filter parameter.
//
func (op *NetworkFilterParametersService) ParameterService(id string) *NetworkFilterParameterService {
	return NewNetworkFilterParameterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFilterParametersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ParameterService(path)), nil
	}
	return op.ParameterService(path[:index]).Service(path[index+1:])
}

func (op *NetworkFilterParametersService) String() string {
	return fmt.Sprintf("NetworkFilterParametersService:%s", op.Path)
}

//
//
type VmNicsService struct {
	BaseService
}

func NewVmNicsService(connection *Connection, path string) *VmNicsService {
	var result VmNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNicsServiceAddRequest struct {
	vmNicsService *VmNicsService
	header        map[string]string
	query         map[string]string
	nic           *Nic
}

func (p *VmNicsServiceAddRequest) Header(key, value string) *VmNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicsServiceAddRequest) Query(key, value string) *VmNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicsServiceAddRequest) Nic(nic *Nic) *VmNicsServiceAddRequest {
	p.nic = nic
	return p
}
func (p *VmNicsServiceAddRequest) Send() (*VmNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.Connection.URL(), p.vmNicsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicsService.Connection.username, p.vmNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNicsServiceAddResponse VmNicsServiceAddResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	vmNicsServiceAddResponse.nic = &nicVar
	return &vmNicsServiceAddResponse, nil
}

type VmNicsServiceAddResponse struct {
	nic *Nic
}

func (p *VmNicsServiceAddResponse) Nic() *Nic {
	return p.nic
}
func (p *VmNicsService) Add() *VmNicsServiceAddRequest {
	return &VmNicsServiceAddRequest{vmNicsService: p}
}

type VmNicsServiceListRequest struct {
	vmNicsService *VmNicsService
	header        map[string]string
	query         map[string]string
	max           *int64
}

func (p *VmNicsServiceListRequest) Header(key, value string) *VmNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicsServiceListRequest) Query(key, value string) *VmNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicsServiceListRequest) Max(max int64) *VmNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmNicsServiceListRequest) Send() (*VmNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.Connection.URL(), p.vmNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicsService.Connection.username, p.vmNicsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmNicsServiceListResponse VmNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	vmNicsServiceListResponse.nics = nicsVar.Nics
	return &vmNicsServiceListResponse, nil
}

type VmNicsServiceListResponse struct {
	nics []Nic
}

func (p *VmNicsServiceListResponse) Nics() []Nic {
	return p.nics
}
func (p *VmNicsService) List() *VmNicsServiceListRequest {
	return &VmNicsServiceListRequest{vmNicsService: p}
}

//
//
func (op *VmNicsService) NicService(id string) *VmNicService {
	return NewVmNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *VmNicsService) String() string {
	return fmt.Sprintf("VmNicsService:%s", op.Path)
}

//
//
type VmReportedDevicesService struct {
	BaseService
}

func NewVmReportedDevicesService(connection *Connection, path string) *VmReportedDevicesService {
	var result VmReportedDevicesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmReportedDevicesServiceListRequest struct {
	vmReportedDevicesService *VmReportedDevicesService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *VmReportedDevicesServiceListRequest) Header(key, value string) *VmReportedDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmReportedDevicesServiceListRequest) Query(key, value string) *VmReportedDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmReportedDevicesServiceListRequest) Max(max int64) *VmReportedDevicesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmReportedDevicesServiceListRequest) Send() (*VmReportedDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDevicesService.Connection.URL(), p.vmReportedDevicesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmReportedDevicesService.Connection.username, p.vmReportedDevicesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmReportedDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var vmReportedDevicesServiceListResponse VmReportedDevicesServiceListResponse
	var reportedDeviceVar ReportedDevices
	xml.Unmarshal(respBodyBytes, &reportedDeviceVar)
	vmReportedDevicesServiceListResponse.reportedDevice = reportedDeviceVar.ReportedDevices
	return &vmReportedDevicesServiceListResponse, nil
}

type VmReportedDevicesServiceListResponse struct {
	reportedDevice []ReportedDevice
}

func (p *VmReportedDevicesServiceListResponse) ReportedDevice() []ReportedDevice {
	return p.reportedDevice
}
func (p *VmReportedDevicesService) List() *VmReportedDevicesServiceListRequest {
	return &VmReportedDevicesServiceListRequest{vmReportedDevicesService: p}
}

//
//
func (op *VmReportedDevicesService) ReportedDeviceService(id string) *VmReportedDeviceService {
	return NewVmReportedDeviceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmReportedDevicesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ReportedDeviceService(path)), nil
	}
	return op.ReportedDeviceService(path[:index]).Service(path[index+1:])
}

func (op *VmReportedDevicesService) String() string {
	return fmt.Sprintf("VmReportedDevicesService:%s", op.Path)
}

//
//
type BalanceService struct {
	BaseService
}

func NewBalanceService(connection *Connection, path string) *BalanceService {
	var result BalanceService
	result.Connection = connection
	result.Path = path
	return &result
}

type BalanceServiceGetRequest struct {
	balanceService *BalanceService
	header         map[string]string
	query          map[string]string
	filter         *bool
}

func (p *BalanceServiceGetRequest) Header(key, value string) *BalanceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalanceServiceGetRequest) Query(key, value string) *BalanceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalanceServiceGetRequest) Filter(filter bool) *BalanceServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *BalanceServiceGetRequest) Send() (*BalanceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balanceService.Connection.URL(), p.balanceService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.balanceService.Connection.username, p.balanceService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.balanceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var balanceServiceGetResponse BalanceServiceGetResponse
	var balanceVar Balance
	xml.Unmarshal(respBodyBytes, &balanceVar)
	balanceServiceGetResponse.balance = &balanceVar
	return &balanceServiceGetResponse, nil
}

type BalanceServiceGetResponse struct {
	balance *Balance
}

func (p *BalanceServiceGetResponse) Balance() *Balance {
	return p.balance
}
func (p *BalanceService) Get() *BalanceServiceGetRequest {
	return &BalanceServiceGetRequest{balanceService: p}
}

type BalanceServiceRemoveRequest struct {
	balanceService *BalanceService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *BalanceServiceRemoveRequest) Header(key, value string) *BalanceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalanceServiceRemoveRequest) Query(key, value string) *BalanceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalanceServiceRemoveRequest) Async(async bool) *BalanceServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *BalanceServiceRemoveRequest) Send() (*BalanceServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balanceService.Connection.URL(), p.balanceService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.balanceService.Connection.username, p.balanceService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.balanceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(BalanceServiceRemoveResponse), nil
}

type BalanceServiceRemoveResponse struct {
}

func (p *BalanceService) Remove() *BalanceServiceRemoveRequest {
	return &BalanceServiceRemoveRequest{balanceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BalanceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *BalanceService) String() string {
	return fmt.Sprintf("BalanceService:%s", op.Path)
}

//
// Represents a permits sub-collection of the specific role.
//
type PermitsService struct {
	BaseService
}

func NewPermitsService(connection *Connection, path string) *PermitsService {
	var result PermitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type PermitsServiceAddRequest struct {
	permitsService *PermitsService
	header         map[string]string
	query          map[string]string
	permit         *Permit
}

func (p *PermitsServiceAddRequest) Header(key, value string) *PermitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitsServiceAddRequest) Query(key, value string) *PermitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitsServiceAddRequest) Permit(permit *Permit) *PermitsServiceAddRequest {
	p.permit = permit
	return p
}
func (p *PermitsServiceAddRequest) Send() (*PermitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.Connection.URL(), p.permitsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.permit)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permitsService.Connection.username, p.permitsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var permitsServiceAddResponse PermitsServiceAddResponse
	var permitVar Permit
	xml.Unmarshal(respBodyBytes, &permitVar)
	permitsServiceAddResponse.permit = &permitVar
	return &permitsServiceAddResponse, nil
}

type PermitsServiceAddResponse struct {
	permit *Permit
}

func (p *PermitsServiceAddResponse) Permit() *Permit {
	return p.permit
}
func (p *PermitsService) Add() *PermitsServiceAddRequest {
	return &PermitsServiceAddRequest{permitsService: p}
}

type PermitsServiceListRequest struct {
	permitsService *PermitsService
	header         map[string]string
	query          map[string]string
	max            *int64
}

func (p *PermitsServiceListRequest) Header(key, value string) *PermitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitsServiceListRequest) Query(key, value string) *PermitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitsServiceListRequest) Max(max int64) *PermitsServiceListRequest {
	p.max = &max
	return p
}
func (p *PermitsServiceListRequest) Send() (*PermitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.Connection.URL(), p.permitsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permitsService.Connection.username, p.permitsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var permitsServiceListResponse PermitsServiceListResponse
	var permitsVar Permits
	xml.Unmarshal(respBodyBytes, &permitsVar)
	permitsServiceListResponse.permits = permitsVar.Permits
	return &permitsServiceListResponse, nil
}

type PermitsServiceListResponse struct {
	permits []Permit
}

func (p *PermitsServiceListResponse) Permits() []Permit {
	return p.permits
}
func (p *PermitsService) List() *PermitsServiceListRequest {
	return &PermitsServiceListRequest{permitsService: p}
}

//
// Sub-resource locator method, returns individual permit resource on which the remainder of the URI is dispatched.
//
func (op *PermitsService) PermitService(id string) *PermitService {
	return NewPermitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PermitService(path)), nil
	}
	return op.PermitService(path[:index]).Service(path[index+1:])
}

func (op *PermitsService) String() string {
	return fmt.Sprintf("PermitsService:%s", op.Path)
}

//
//
type StorageDomainTemplatesService struct {
	BaseService
}

func NewStorageDomainTemplatesService(connection *Connection, path string) *StorageDomainTemplatesService {
	var result StorageDomainTemplatesService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainTemplatesServiceListRequest struct {
	storageDomainTemplatesService *StorageDomainTemplatesService
	header                        map[string]string
	query                         map[string]string
	max                           *int64
}

func (p *StorageDomainTemplatesServiceListRequest) Header(key, value string) *StorageDomainTemplatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Query(key, value string) *StorageDomainTemplatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Max(max int64) *StorageDomainTemplatesServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainTemplatesServiceListRequest) Send() (*StorageDomainTemplatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplatesService.Connection.URL(), p.storageDomainTemplatesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainTemplatesService.Connection.username, p.storageDomainTemplatesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainTemplatesServiceListResponse StorageDomainTemplatesServiceListResponse
	var templatesVar Templates
	xml.Unmarshal(respBodyBytes, &templatesVar)
	storageDomainTemplatesServiceListResponse.templates = templatesVar.Templates
	return &storageDomainTemplatesServiceListResponse, nil
}

type StorageDomainTemplatesServiceListResponse struct {
	templates []Template
}

func (p *StorageDomainTemplatesServiceListResponse) Templates() []Template {
	return p.templates
}
func (p *StorageDomainTemplatesService) List() *StorageDomainTemplatesServiceListRequest {
	return &StorageDomainTemplatesServiceListRequest{storageDomainTemplatesService: p}
}

//
//
func (op *StorageDomainTemplatesService) TemplateService(id string) *StorageDomainTemplateService {
	return NewStorageDomainTemplateService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainTemplatesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TemplateService(path)), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainTemplatesService) String() string {
	return fmt.Sprintf("StorageDomainTemplatesService:%s", op.Path)
}

//
//
type SystemService struct {
	BaseService
}

func NewSystemService(connection *Connection, path string) *SystemService {
	var result SystemService
	result.Connection = connection
	result.Path = path
	return &result
}

type SystemServiceGetRequest struct {
	systemService *SystemService
	header        map[string]string
	query         map[string]string
}

func (p *SystemServiceGetRequest) Header(key, value string) *SystemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemServiceGetRequest) Query(key, value string) *SystemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemServiceGetRequest) Send() (*SystemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemService.Connection.URL(), p.systemService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.systemService.Connection.username, p.systemService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.systemService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var systemServiceGetResponse SystemServiceGetResponse
	var apiVar Api
	xml.Unmarshal(respBodyBytes, &apiVar)
	systemServiceGetResponse.api = &apiVar
	return &systemServiceGetResponse, nil
}

type SystemServiceGetResponse struct {
	api *Api
}

func (p *SystemServiceGetResponse) Api() *Api {
	return p.api
}
func (p *SystemService) Get() *SystemServiceGetRequest {
	return &SystemServiceGetRequest{systemService: p}
}

type SystemServiceReloadConfigurationsRequest struct {
	systemService *SystemService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *SystemServiceReloadConfigurationsRequest) Header(key, value string) *SystemServiceReloadConfigurationsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemServiceReloadConfigurationsRequest) Query(key, value string) *SystemServiceReloadConfigurationsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemServiceReloadConfigurationsRequest) Async(async bool) *SystemServiceReloadConfigurationsRequest {
	p.async = &async
	return p
}
func (p *SystemServiceReloadConfigurationsRequest) Send() (*SystemServiceReloadConfigurationsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reloadconfigurations", p.systemService.Connection.URL(), p.systemService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.systemService.Connection.username, p.systemService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.systemService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(SystemServiceReloadConfigurationsResponse), nil
}

type SystemServiceReloadConfigurationsResponse struct {
}

func (p *SystemService) ReloadConfigurations() *SystemServiceReloadConfigurationsRequest {
	return &SystemServiceReloadConfigurationsRequest{systemService: p}
}

//
// List all known affinity labels.
//
func (op *SystemService) AffinityLabelsService() *AffinityLabelsService {
	return NewAffinityLabelsService(op.Connection, fmt.Sprintf("%s/affinitylabels", op.Path))
}

//
//
func (op *SystemService) BookmarksService() *BookmarksService {
	return NewBookmarksService(op.Connection, fmt.Sprintf("%s/bookmarks", op.Path))
}

//
// Reference to the service that provides information about the cluster levels supported by the system.
//
func (op *SystemService) ClusterLevelsService() *ClusterLevelsService {
	return NewClusterLevelsService(op.Connection, fmt.Sprintf("%s/clusterlevels", op.Path))
}

//
//
func (op *SystemService) ClustersService() *ClustersService {
	return NewClustersService(op.Connection, fmt.Sprintf("%s/clusters", op.Path))
}

//
//
func (op *SystemService) CpuProfilesService() *CpuProfilesService {
	return NewCpuProfilesService(op.Connection, fmt.Sprintf("%s/cpuprofiles", op.Path))
}

//
//
func (op *SystemService) DataCentersService() *DataCentersService {
	return NewDataCentersService(op.Connection, fmt.Sprintf("%s/datacenters", op.Path))
}

//
//
func (op *SystemService) DiskProfilesService() *DiskProfilesService {
	return NewDiskProfilesService(op.Connection, fmt.Sprintf("%s/diskprofiles", op.Path))
}

//
//
func (op *SystemService) DisksService() *DisksService {
	return NewDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
//
func (op *SystemService) DomainsService() *DomainsService {
	return NewDomainsService(op.Connection, fmt.Sprintf("%s/domains", op.Path))
}

//
//
func (op *SystemService) EventsService() *EventsService {
	return NewEventsService(op.Connection, fmt.Sprintf("%s/events", op.Path))
}

//
//
func (op *SystemService) ExternalHostProvidersService() *ExternalHostProvidersService {
	return NewExternalHostProvidersService(op.Connection, fmt.Sprintf("%s/externalhostproviders", op.Path))
}

//
// Reference to service facilitating import of external virtual machines.
//
func (op *SystemService) ExternalVmImportsService() *ExternalVmImportsService {
	return NewExternalVmImportsService(op.Connection, fmt.Sprintf("%s/externalvmimports", op.Path))
}

//
//
func (op *SystemService) GroupsService() *GroupsService {
	return NewGroupsService(op.Connection, fmt.Sprintf("%s/groups", op.Path))
}

//
//
func (op *SystemService) HostsService() *HostsService {
	return NewHostsService(op.Connection, fmt.Sprintf("%s/hosts", op.Path))
}

//
//
func (op *SystemService) IconsService() *IconsService {
	return NewIconsService(op.Connection, fmt.Sprintf("%s/icons", op.Path))
}

//
// List of all image transfers being performed for image I/O in oVirt.
//
func (op *SystemService) ImageTransfersService() *ImageTransfersService {
	return NewImageTransfersService(op.Connection, fmt.Sprintf("%s/imagetransfers", op.Path))
}

//
//
func (op *SystemService) InstanceTypesService() *InstanceTypesService {
	return NewInstanceTypesService(op.Connection, fmt.Sprintf("%s/instancetypes", op.Path))
}

//
// List all the jobs monitored by the engine.
//
func (op *SystemService) JobsService() *JobsService {
	return NewJobsService(op.Connection, fmt.Sprintf("%s/jobs", op.Path))
}

//
// List the available Katello errata assigned to the engine.
//
func (op *SystemService) KatelloErrataService() *EngineKatelloErrataService {
	return NewEngineKatelloErrataService(op.Connection, fmt.Sprintf("%s/katelloerrata", op.Path))
}

//
//
func (op *SystemService) MacPoolsService() *MacPoolsService {
	return NewMacPoolsService(op.Connection, fmt.Sprintf("%s/macpools", op.Path))
}

//
// Network filters will enhance the admin ability to manage the network packets traffic from/to the participated
// VMs.
//
func (op *SystemService) NetworkFiltersService() *NetworkFiltersService {
	return NewNetworkFiltersService(op.Connection, fmt.Sprintf("%s/networkfilters", op.Path))
}

//
//
func (op *SystemService) NetworksService() *NetworksService {
	return NewNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
//
func (op *SystemService) OpenstackImageProvidersService() *OpenstackImageProvidersService {
	return NewOpenstackImageProvidersService(op.Connection, fmt.Sprintf("%s/openstackimageproviders", op.Path))
}

//
//
func (op *SystemService) OpenstackNetworkProvidersService() *OpenstackNetworkProvidersService {
	return NewOpenstackNetworkProvidersService(op.Connection, fmt.Sprintf("%s/openstacknetworkproviders", op.Path))
}

//
//
func (op *SystemService) OpenstackVolumeProvidersService() *OpenstackVolumeProvidersService {
	return NewOpenstackVolumeProvidersService(op.Connection, fmt.Sprintf("%s/openstackvolumeproviders", op.Path))
}

//
//
func (op *SystemService) OperatingSystemsService() *OperatingSystemsService {
	return NewOperatingSystemsService(op.Connection, fmt.Sprintf("%s/operatingsystems", op.Path))
}

//
//
func (op *SystemService) PermissionsService() *SystemPermissionsService {
	return NewSystemPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *SystemService) RolesService() *RolesService {
	return NewRolesService(op.Connection, fmt.Sprintf("%s/roles", op.Path))
}

//
//
func (op *SystemService) SchedulingPoliciesService() *SchedulingPoliciesService {
	return NewSchedulingPoliciesService(op.Connection, fmt.Sprintf("%s/schedulingpolicies", op.Path))
}

//
//
func (op *SystemService) SchedulingPolicyUnitsService() *SchedulingPolicyUnitsService {
	return NewSchedulingPolicyUnitsService(op.Connection, fmt.Sprintf("%s/schedulingpolicyunits", op.Path))
}

//
//
func (op *SystemService) StorageConnectionsService() *StorageServerConnectionsService {
	return NewStorageServerConnectionsService(op.Connection, fmt.Sprintf("%s/storageconnections", op.Path))
}

//
//
func (op *SystemService) StorageDomainsService() *StorageDomainsService {
	return NewStorageDomainsService(op.Connection, fmt.Sprintf("%s/storagedomains", op.Path))
}

//
//
func (op *SystemService) TagsService() *TagsService {
	return NewTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
//
func (op *SystemService) TemplatesService() *TemplatesService {
	return NewTemplatesService(op.Connection, fmt.Sprintf("%s/templates", op.Path))
}

//
//
func (op *SystemService) UsersService() *UsersService {
	return NewUsersService(op.Connection, fmt.Sprintf("%s/users", op.Path))
}

//
//
func (op *SystemService) VmPoolsService() *VmPoolsService {
	return NewVmPoolsService(op.Connection, fmt.Sprintf("%s/vmpools", op.Path))
}

//
//
func (op *SystemService) VmsService() *VmsService {
	return NewVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
//
func (op *SystemService) VnicProfilesService() *VnicProfilesService {
	return NewVnicProfilesService(op.Connection, fmt.Sprintf("%s/vnicprofiles", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "bookmarks" {
		return op.BookmarksService(), nil
	}
	if strings.HasPrefix(path, "bookmarks/") {
		return op.BookmarksService().Service(path[10:])
	}
	if path == "clusterlevels" {
		return op.ClusterLevelsService(), nil
	}
	if strings.HasPrefix(path, "clusterlevels/") {
		return op.ClusterLevelsService().Service(path[14:])
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "datacenters" {
		return op.DataCentersService(), nil
	}
	if strings.HasPrefix(path, "datacenters/") {
		return op.DataCentersService().Service(path[12:])
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "domains" {
		return op.DomainsService(), nil
	}
	if strings.HasPrefix(path, "domains/") {
		return op.DomainsService().Service(path[8:])
	}
	if path == "events" {
		return op.EventsService(), nil
	}
	if strings.HasPrefix(path, "events/") {
		return op.EventsService().Service(path[7:])
	}
	if path == "externalhostproviders" {
		return op.ExternalHostProvidersService(), nil
	}
	if strings.HasPrefix(path, "externalhostproviders/") {
		return op.ExternalHostProvidersService().Service(path[22:])
	}
	if path == "externalvmimports" {
		return op.ExternalVmImportsService(), nil
	}
	if strings.HasPrefix(path, "externalvmimports/") {
		return op.ExternalVmImportsService().Service(path[18:])
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "icons" {
		return op.IconsService(), nil
	}
	if strings.HasPrefix(path, "icons/") {
		return op.IconsService().Service(path[6:])
	}
	if path == "imagetransfers" {
		return op.ImageTransfersService(), nil
	}
	if strings.HasPrefix(path, "imagetransfers/") {
		return op.ImageTransfersService().Service(path[15:])
	}
	if path == "instancetypes" {
		return op.InstanceTypesService(), nil
	}
	if strings.HasPrefix(path, "instancetypes/") {
		return op.InstanceTypesService().Service(path[14:])
	}
	if path == "jobs" {
		return op.JobsService(), nil
	}
	if strings.HasPrefix(path, "jobs/") {
		return op.JobsService().Service(path[5:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "macpools" {
		return op.MacPoolsService(), nil
	}
	if strings.HasPrefix(path, "macpools/") {
		return op.MacPoolsService().Service(path[9:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "openstackimageproviders" {
		return op.OpenstackImageProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackimageproviders/") {
		return op.OpenstackImageProvidersService().Service(path[24:])
	}
	if path == "openstacknetworkproviders" {
		return op.OpenstackNetworkProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstacknetworkproviders/") {
		return op.OpenstackNetworkProvidersService().Service(path[26:])
	}
	if path == "openstackvolumeproviders" {
		return op.OpenstackVolumeProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackvolumeproviders/") {
		return op.OpenstackVolumeProvidersService().Service(path[25:])
	}
	if path == "operatingsystems" {
		return op.OperatingSystemsService(), nil
	}
	if strings.HasPrefix(path, "operatingsystems/") {
		return op.OperatingSystemsService().Service(path[17:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "schedulingpolicies" {
		return op.SchedulingPoliciesService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicies/") {
		return op.SchedulingPoliciesService().Service(path[19:])
	}
	if path == "schedulingpolicyunits" {
		return op.SchedulingPolicyUnitsService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicyunits/") {
		return op.SchedulingPolicyUnitsService().Service(path[22:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	if path == "vmpools" {
		return op.VmPoolsService(), nil
	}
	if strings.HasPrefix(path, "vmpools/") {
		return op.VmPoolsService().Service(path[8:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SystemService) String() string {
	return fmt.Sprintf("SystemService:%s", op.Path)
}

//
//
type ExternalHostService struct {
	BaseService
}

func NewExternalHostService(connection *Connection, path string) *ExternalHostService {
	var result ExternalHostService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostServiceGetRequest struct {
	externalHostService *ExternalHostService
	header              map[string]string
	query               map[string]string
}

func (p *ExternalHostServiceGetRequest) Header(key, value string) *ExternalHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostServiceGetRequest) Query(key, value string) *ExternalHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostServiceGetRequest) Send() (*ExternalHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostService.Connection.URL(), p.externalHostService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostService.Connection.username, p.externalHostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostServiceGetResponse ExternalHostServiceGetResponse
	var hostVar ExternalHost
	xml.Unmarshal(respBodyBytes, &hostVar)
	externalHostServiceGetResponse.host = &hostVar
	return &externalHostServiceGetResponse, nil
}

type ExternalHostServiceGetResponse struct {
	host *ExternalHost
}

func (p *ExternalHostServiceGetResponse) Host() *ExternalHost {
	return p.host
}
func (p *ExternalHostService) Get() *ExternalHostServiceGetRequest {
	return &ExternalHostServiceGetRequest{externalHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostService) String() string {
	return fmt.Sprintf("ExternalHostService:%s", op.Path)
}

//
//
type ExternalHostGroupService struct {
	BaseService
}

func NewExternalHostGroupService(connection *Connection, path string) *ExternalHostGroupService {
	var result ExternalHostGroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostGroupServiceGetRequest struct {
	externalHostGroupService *ExternalHostGroupService
	header                   map[string]string
	query                    map[string]string
}

func (p *ExternalHostGroupServiceGetRequest) Header(key, value string) *ExternalHostGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostGroupServiceGetRequest) Query(key, value string) *ExternalHostGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostGroupServiceGetRequest) Send() (*ExternalHostGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupService.Connection.URL(), p.externalHostGroupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostGroupService.Connection.username, p.externalHostGroupService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostGroupServiceGetResponse ExternalHostGroupServiceGetResponse
	var groupVar ExternalHostGroup
	xml.Unmarshal(respBodyBytes, &groupVar)
	externalHostGroupServiceGetResponse.group = &groupVar
	return &externalHostGroupServiceGetResponse, nil
}

type ExternalHostGroupServiceGetResponse struct {
	group *ExternalHostGroup
}

func (p *ExternalHostGroupServiceGetResponse) Group() *ExternalHostGroup {
	return p.group
}
func (p *ExternalHostGroupService) Get() *ExternalHostGroupServiceGetRequest {
	return &ExternalHostGroupServiceGetRequest{externalHostGroupService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostGroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostGroupService) String() string {
	return fmt.Sprintf("ExternalHostGroupService:%s", op.Path)
}

//
// A service to manage a Katello erratum.
//
type KatelloErratumService struct {
	BaseService
}

func NewKatelloErratumService(connection *Connection, path string) *KatelloErratumService {
	var result KatelloErratumService
	result.Connection = connection
	result.Path = path
	return &result
}

type KatelloErratumServiceGetRequest struct {
	katelloErratumService *KatelloErratumService
	header                map[string]string
	query                 map[string]string
}

func (p *KatelloErratumServiceGetRequest) Header(key, value string) *KatelloErratumServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *KatelloErratumServiceGetRequest) Query(key, value string) *KatelloErratumServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *KatelloErratumServiceGetRequest) Send() (*KatelloErratumServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.katelloErratumService.Connection.URL(), p.katelloErratumService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.katelloErratumService.Connection.username, p.katelloErratumService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.katelloErratumService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var katelloErratumServiceGetResponse KatelloErratumServiceGetResponse
	var erratumVar KatelloErratum
	xml.Unmarshal(respBodyBytes, &erratumVar)
	katelloErratumServiceGetResponse.erratum = &erratumVar
	return &katelloErratumServiceGetResponse, nil
}

type KatelloErratumServiceGetResponse struct {
	erratum *KatelloErratum
}

func (p *KatelloErratumServiceGetResponse) Erratum() *KatelloErratum {
	return p.erratum
}
func (p *KatelloErratumService) Get() *KatelloErratumServiceGetRequest {
	return &KatelloErratumServiceGetRequest{katelloErratumService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *KatelloErratumService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *KatelloErratumService) String() string {
	return fmt.Sprintf("KatelloErratumService:%s", op.Path)
}

//
//
type ExternalDiscoveredHostService struct {
	BaseService
}

func NewExternalDiscoveredHostService(connection *Connection, path string) *ExternalDiscoveredHostService {
	var result ExternalDiscoveredHostService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalDiscoveredHostServiceGetRequest struct {
	externalDiscoveredHostService *ExternalDiscoveredHostService
	header                        map[string]string
	query                         map[string]string
}

func (p *ExternalDiscoveredHostServiceGetRequest) Header(key, value string) *ExternalDiscoveredHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalDiscoveredHostServiceGetRequest) Query(key, value string) *ExternalDiscoveredHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalDiscoveredHostServiceGetRequest) Send() (*ExternalDiscoveredHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostService.Connection.URL(), p.externalDiscoveredHostService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalDiscoveredHostService.Connection.username, p.externalDiscoveredHostService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalDiscoveredHostServiceGetResponse ExternalDiscoveredHostServiceGetResponse
	var hostVar ExternalDiscoveredHost
	xml.Unmarshal(respBodyBytes, &hostVar)
	externalDiscoveredHostServiceGetResponse.host = &hostVar
	return &externalDiscoveredHostServiceGetResponse, nil
}

type ExternalDiscoveredHostServiceGetResponse struct {
	host *ExternalDiscoveredHost
}

func (p *ExternalDiscoveredHostServiceGetResponse) Host() *ExternalDiscoveredHost {
	return p.host
}
func (p *ExternalDiscoveredHostService) Get() *ExternalDiscoveredHostServiceGetRequest {
	return &ExternalDiscoveredHostServiceGetRequest{externalDiscoveredHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalDiscoveredHostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalDiscoveredHostService) String() string {
	return fmt.Sprintf("ExternalDiscoveredHostService:%s", op.Path)
}

//
// A service to manage Katello errata assigned to the engine.
// The information is retrieved from Katello.
//
type EngineKatelloErrataService struct {
	BaseService
}

func NewEngineKatelloErrataService(connection *Connection, path string) *EngineKatelloErrataService {
	var result EngineKatelloErrataService
	result.Connection = connection
	result.Path = path
	return &result
}

type EngineKatelloErrataServiceListRequest struct {
	engineKatelloErrataService *EngineKatelloErrataService
	header                     map[string]string
	query                      map[string]string
	max                        *int64
}

func (p *EngineKatelloErrataServiceListRequest) Header(key, value string) *EngineKatelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Query(key, value string) *EngineKatelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Max(max int64) *EngineKatelloErrataServiceListRequest {
	p.max = &max
	return p
}
func (p *EngineKatelloErrataServiceListRequest) Send() (*EngineKatelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.engineKatelloErrataService.Connection.URL(), p.engineKatelloErrataService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.engineKatelloErrataService.Connection.username, p.engineKatelloErrataService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.engineKatelloErrataService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var engineKatelloErrataServiceListResponse EngineKatelloErrataServiceListResponse
	var errataVar KatelloErratums
	xml.Unmarshal(respBodyBytes, &errataVar)
	engineKatelloErrataServiceListResponse.errata = errataVar.KatelloErratums
	return &engineKatelloErrataServiceListResponse, nil
}

type EngineKatelloErrataServiceListResponse struct {
	errata []KatelloErratum
}

func (p *EngineKatelloErrataServiceListResponse) Errata() []KatelloErratum {
	return p.errata
}
func (p *EngineKatelloErrataService) List() *EngineKatelloErrataServiceListRequest {
	return &EngineKatelloErrataServiceListRequest{engineKatelloErrataService: p}
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *EngineKatelloErrataService) KatelloErratumService(id string) *KatelloErratumService {
	return NewKatelloErratumService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EngineKatelloErrataService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KatelloErratumService(path)), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *EngineKatelloErrataService) String() string {
	return fmt.Sprintf("EngineKatelloErrataService:%s", op.Path)
}

//
//
type ExternalComputeResourceService struct {
	BaseService
}

func NewExternalComputeResourceService(connection *Connection, path string) *ExternalComputeResourceService {
	var result ExternalComputeResourceService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalComputeResourceServiceGetRequest struct {
	externalComputeResourceService *ExternalComputeResourceService
	header                         map[string]string
	query                          map[string]string
}

func (p *ExternalComputeResourceServiceGetRequest) Header(key, value string) *ExternalComputeResourceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalComputeResourceServiceGetRequest) Query(key, value string) *ExternalComputeResourceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalComputeResourceServiceGetRequest) Send() (*ExternalComputeResourceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourceService.Connection.URL(), p.externalComputeResourceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalComputeResourceService.Connection.username, p.externalComputeResourceService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalComputeResourceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalComputeResourceServiceGetResponse ExternalComputeResourceServiceGetResponse
	var resourceVar ExternalComputeResource
	xml.Unmarshal(respBodyBytes, &resourceVar)
	externalComputeResourceServiceGetResponse.resource = &resourceVar
	return &externalComputeResourceServiceGetResponse, nil
}

type ExternalComputeResourceServiceGetResponse struct {
	resource *ExternalComputeResource
}

func (p *ExternalComputeResourceServiceGetResponse) Resource() *ExternalComputeResource {
	return p.resource
}
func (p *ExternalComputeResourceService) Get() *ExternalComputeResourceServiceGetRequest {
	return &ExternalComputeResourceServiceGetRequest{externalComputeResourceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalComputeResourceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalComputeResourceService) String() string {
	return fmt.Sprintf("ExternalComputeResourceService:%s", op.Path)
}

//
//
type ExternalHostGroupsService struct {
	BaseService
}

func NewExternalHostGroupsService(connection *Connection, path string) *ExternalHostGroupsService {
	var result ExternalHostGroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostGroupsServiceListRequest struct {
	externalHostGroupsService *ExternalHostGroupsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *ExternalHostGroupsServiceListRequest) Header(key, value string) *ExternalHostGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Query(key, value string) *ExternalHostGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Max(max int64) *ExternalHostGroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalHostGroupsServiceListRequest) Send() (*ExternalHostGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupsService.Connection.URL(), p.externalHostGroupsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostGroupsService.Connection.username, p.externalHostGroupsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostGroupsServiceListResponse ExternalHostGroupsServiceListResponse
	var groupsVar ExternalHostGroups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	externalHostGroupsServiceListResponse.groups = groupsVar.ExternalHostGroups
	return &externalHostGroupsServiceListResponse, nil
}

type ExternalHostGroupsServiceListResponse struct {
	groups []ExternalHostGroup
}

func (p *ExternalHostGroupsServiceListResponse) Groups() []ExternalHostGroup {
	return p.groups
}
func (p *ExternalHostGroupsService) List() *ExternalHostGroupsServiceListRequest {
	return &ExternalHostGroupsServiceListRequest{externalHostGroupsService: p}
}

//
//
func (op *ExternalHostGroupsService) GroupService(id string) *ExternalHostGroupService {
	return NewExternalHostGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostGroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostGroupsService) String() string {
	return fmt.Sprintf("ExternalHostGroupsService:%s", op.Path)
}

//
//
type ExternalHostProviderService struct {
	BaseService
}

func NewExternalHostProviderService(connection *Connection, path string) *ExternalHostProviderService {
	var result ExternalHostProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostProviderServiceGetRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
}

func (p *ExternalHostProviderServiceGetRequest) Header(key, value string) *ExternalHostProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceGetRequest) Query(key, value string) *ExternalHostProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceGetRequest) Send() (*ExternalHostProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.Connection.URL(), p.externalHostProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProviderService.Connection.username, p.externalHostProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostProviderServiceGetResponse ExternalHostProviderServiceGetResponse
	var providerVar ExternalHostProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	externalHostProviderServiceGetResponse.provider = &providerVar
	return &externalHostProviderServiceGetResponse, nil
}

type ExternalHostProviderServiceGetResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProviderServiceGetResponse) Provider() *ExternalHostProvider {
	return p.provider
}
func (p *ExternalHostProviderService) Get() *ExternalHostProviderServiceGetRequest {
	return &ExternalHostProviderServiceGetRequest{externalHostProviderService: p}
}

type ExternalHostProviderServiceImportCertificatesRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	certificates                []Certificate
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Header(key, value string) *ExternalHostProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Query(key, value string) *ExternalHostProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *ExternalHostProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *ExternalHostProviderServiceImportCertificatesRequest) Send() (*ExternalHostProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.externalHostProviderService.Connection.URL(), p.externalHostProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProviderService.Connection.username, p.externalHostProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalHostProviderServiceImportCertificatesResponse), nil
}

type ExternalHostProviderServiceImportCertificatesResponse struct {
}

func (p *ExternalHostProviderService) ImportCertificates() *ExternalHostProviderServiceImportCertificatesRequest {
	return &ExternalHostProviderServiceImportCertificatesRequest{externalHostProviderService: p}
}

type ExternalHostProviderServiceRemoveRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *ExternalHostProviderServiceRemoveRequest) Header(key, value string) *ExternalHostProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceRemoveRequest) Query(key, value string) *ExternalHostProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceRemoveRequest) Async(async bool) *ExternalHostProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *ExternalHostProviderServiceRemoveRequest) Send() (*ExternalHostProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.Connection.URL(), p.externalHostProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProviderService.Connection.username, p.externalHostProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(ExternalHostProviderServiceRemoveResponse), nil
}

type ExternalHostProviderServiceRemoveResponse struct {
}

func (p *ExternalHostProviderService) Remove() *ExternalHostProviderServiceRemoveRequest {
	return &ExternalHostProviderServiceRemoveRequest{externalHostProviderService: p}
}

type ExternalHostProviderServiceTestConnectivityRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Header(key, value string) *ExternalHostProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Query(key, value string) *ExternalHostProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Async(async bool) *ExternalHostProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *ExternalHostProviderServiceTestConnectivityRequest) Send() (*ExternalHostProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.externalHostProviderService.Connection.URL(), p.externalHostProviderService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProviderService.Connection.username, p.externalHostProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalHostProviderServiceTestConnectivityResponse), nil
}

type ExternalHostProviderServiceTestConnectivityResponse struct {
}

func (p *ExternalHostProviderService) TestConnectivity() *ExternalHostProviderServiceTestConnectivityRequest {
	return &ExternalHostProviderServiceTestConnectivityRequest{externalHostProviderService: p}
}

type ExternalHostProviderServiceUpdateRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	provider                    *ExternalHostProvider
}

func (p *ExternalHostProviderServiceUpdateRequest) Header(key, value string) *ExternalHostProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Query(key, value string) *ExternalHostProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Async(async bool) *ExternalHostProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *ExternalHostProviderServiceUpdateRequest) Provider(provider *ExternalHostProvider) *ExternalHostProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *ExternalHostProviderServiceUpdateRequest) Send() (*ExternalHostProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.Connection.URL(), p.externalHostProviderService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProviderService.Connection.username, p.externalHostProviderService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostProviderServiceUpdateResponse ExternalHostProviderServiceUpdateResponse
	var providerVar ExternalHostProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	externalHostProviderServiceUpdateResponse.provider = &providerVar
	return &externalHostProviderServiceUpdateResponse, nil
}

type ExternalHostProviderServiceUpdateResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProviderServiceUpdateResponse) Provider() *ExternalHostProvider {
	return p.provider
}
func (p *ExternalHostProviderService) Update() *ExternalHostProviderServiceUpdateRequest {
	return &ExternalHostProviderServiceUpdateRequest{externalHostProviderService: p}
}

//
//
func (op *ExternalHostProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
//
func (op *ExternalHostProviderService) ComputeResourcesService() *ExternalComputeResourcesService {
	return NewExternalComputeResourcesService(op.Connection, fmt.Sprintf("%s/computeresources", op.Path))
}

//
//
func (op *ExternalHostProviderService) DiscoveredHostsService() *ExternalDiscoveredHostsService {
	return NewExternalDiscoveredHostsService(op.Connection, fmt.Sprintf("%s/discoveredhosts", op.Path))
}

//
//
func (op *ExternalHostProviderService) HostGroupsService() *ExternalHostGroupsService {
	return NewExternalHostGroupsService(op.Connection, fmt.Sprintf("%s/hostgroups", op.Path))
}

//
//
func (op *ExternalHostProviderService) HostsService() *ExternalHostsService {
	return NewExternalHostsService(op.Connection, fmt.Sprintf("%s/hosts", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "computeresources" {
		return op.ComputeResourcesService(), nil
	}
	if strings.HasPrefix(path, "computeresources/") {
		return op.ComputeResourcesService().Service(path[17:])
	}
	if path == "discoveredhosts" {
		return op.DiscoveredHostsService(), nil
	}
	if strings.HasPrefix(path, "discoveredhosts/") {
		return op.DiscoveredHostsService().Service(path[16:])
	}
	if path == "hostgroups" {
		return op.HostGroupsService(), nil
	}
	if strings.HasPrefix(path, "hostgroups/") {
		return op.HostGroupsService().Service(path[11:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostProviderService) String() string {
	return fmt.Sprintf("ExternalHostProviderService:%s", op.Path)
}

//
// A service to manage Katello errata.
// The information is retrieved from Katello.
//
type KatelloErrataService struct {
	BaseService
}

func NewKatelloErrataService(connection *Connection, path string) *KatelloErrataService {
	var result KatelloErrataService
	result.Connection = connection
	result.Path = path
	return &result
}

type KatelloErrataServiceListRequest struct {
	katelloErrataService *KatelloErrataService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *KatelloErrataServiceListRequest) Header(key, value string) *KatelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *KatelloErrataServiceListRequest) Query(key, value string) *KatelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *KatelloErrataServiceListRequest) Max(max int64) *KatelloErrataServiceListRequest {
	p.max = &max
	return p
}
func (p *KatelloErrataServiceListRequest) Send() (*KatelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.katelloErrataService.Connection.URL(), p.katelloErrataService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.katelloErrataService.Connection.username, p.katelloErrataService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.katelloErrataService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var katelloErrataServiceListResponse KatelloErrataServiceListResponse
	var errataVar KatelloErratums
	xml.Unmarshal(respBodyBytes, &errataVar)
	katelloErrataServiceListResponse.errata = errataVar.KatelloErratums
	return &katelloErrataServiceListResponse, nil
}

type KatelloErrataServiceListResponse struct {
	errata []KatelloErratum
}

func (p *KatelloErrataServiceListResponse) Errata() []KatelloErratum {
	return p.errata
}
func (p *KatelloErrataService) List() *KatelloErrataServiceListRequest {
	return &KatelloErrataServiceListRequest{katelloErrataService: p}
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *KatelloErrataService) KatelloErratumService(id string) *KatelloErratumService {
	return NewKatelloErratumService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *KatelloErrataService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KatelloErratumService(path)), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *KatelloErrataService) String() string {
	return fmt.Sprintf("KatelloErrataService:%s", op.Path)
}

//
//
type ExternalDiscoveredHostsService struct {
	BaseService
}

func NewExternalDiscoveredHostsService(connection *Connection, path string) *ExternalDiscoveredHostsService {
	var result ExternalDiscoveredHostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalDiscoveredHostsServiceListRequest struct {
	externalDiscoveredHostsService *ExternalDiscoveredHostsService
	header                         map[string]string
	query                          map[string]string
	max                            *int64
}

func (p *ExternalDiscoveredHostsServiceListRequest) Header(key, value string) *ExternalDiscoveredHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Query(key, value string) *ExternalDiscoveredHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Max(max int64) *ExternalDiscoveredHostsServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalDiscoveredHostsServiceListRequest) Send() (*ExternalDiscoveredHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostsService.Connection.URL(), p.externalDiscoveredHostsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalDiscoveredHostsService.Connection.username, p.externalDiscoveredHostsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalDiscoveredHostsServiceListResponse ExternalDiscoveredHostsServiceListResponse
	var hostsVar ExternalDiscoveredHosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	externalDiscoveredHostsServiceListResponse.hosts = hostsVar.ExternalDiscoveredHosts
	return &externalDiscoveredHostsServiceListResponse, nil
}

type ExternalDiscoveredHostsServiceListResponse struct {
	hosts []ExternalDiscoveredHost
}

func (p *ExternalDiscoveredHostsServiceListResponse) Hosts() []ExternalDiscoveredHost {
	return p.hosts
}
func (p *ExternalDiscoveredHostsService) List() *ExternalDiscoveredHostsServiceListRequest {
	return &ExternalDiscoveredHostsServiceListRequest{externalDiscoveredHostsService: p}
}

//
//
func (op *ExternalDiscoveredHostsService) HostService(id string) *ExternalDiscoveredHostService {
	return NewExternalDiscoveredHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalDiscoveredHostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *ExternalDiscoveredHostsService) String() string {
	return fmt.Sprintf("ExternalDiscoveredHostsService:%s", op.Path)
}

//
//
type ExternalHostsService struct {
	BaseService
}

func NewExternalHostsService(connection *Connection, path string) *ExternalHostsService {
	var result ExternalHostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostsServiceListRequest struct {
	externalHostsService *ExternalHostsService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *ExternalHostsServiceListRequest) Header(key, value string) *ExternalHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostsServiceListRequest) Query(key, value string) *ExternalHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostsServiceListRequest) Max(max int64) *ExternalHostsServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalHostsServiceListRequest) Send() (*ExternalHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostsService.Connection.URL(), p.externalHostsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostsService.Connection.username, p.externalHostsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostsServiceListResponse ExternalHostsServiceListResponse
	var hostsVar ExternalHosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	externalHostsServiceListResponse.hosts = hostsVar.ExternalHosts
	return &externalHostsServiceListResponse, nil
}

type ExternalHostsServiceListResponse struct {
	hosts []ExternalHost
}

func (p *ExternalHostsServiceListResponse) Hosts() []ExternalHost {
	return p.hosts
}
func (p *ExternalHostsService) List() *ExternalHostsServiceListRequest {
	return &ExternalHostsServiceListRequest{externalHostsService: p}
}

//
//
func (op *ExternalHostsService) HostService(id string) *ExternalHostService {
	return NewExternalHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostsService) String() string {
	return fmt.Sprintf("ExternalHostsService:%s", op.Path)
}

//
//
type ExternalComputeResourcesService struct {
	BaseService
}

func NewExternalComputeResourcesService(connection *Connection, path string) *ExternalComputeResourcesService {
	var result ExternalComputeResourcesService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalComputeResourcesServiceListRequest struct {
	externalComputeResourcesService *ExternalComputeResourcesService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *ExternalComputeResourcesServiceListRequest) Header(key, value string) *ExternalComputeResourcesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Query(key, value string) *ExternalComputeResourcesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Max(max int64) *ExternalComputeResourcesServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalComputeResourcesServiceListRequest) Send() (*ExternalComputeResourcesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourcesService.Connection.URL(), p.externalComputeResourcesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalComputeResourcesService.Connection.username, p.externalComputeResourcesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalComputeResourcesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalComputeResourcesServiceListResponse ExternalComputeResourcesServiceListResponse
	var resourcesVar ExternalComputeResources
	xml.Unmarshal(respBodyBytes, &resourcesVar)
	externalComputeResourcesServiceListResponse.resources = resourcesVar.ExternalComputeResources
	return &externalComputeResourcesServiceListResponse, nil
}

type ExternalComputeResourcesServiceListResponse struct {
	resources []ExternalComputeResource
}

func (p *ExternalComputeResourcesServiceListResponse) Resources() []ExternalComputeResource {
	return p.resources
}
func (p *ExternalComputeResourcesService) List() *ExternalComputeResourcesServiceListRequest {
	return &ExternalComputeResourcesServiceListRequest{externalComputeResourcesService: p}
}

//
//
func (op *ExternalComputeResourcesService) ResourceService(id string) *ExternalComputeResourceService {
	return NewExternalComputeResourceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalComputeResourcesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ResourceService(path)), nil
	}
	return op.ResourceService(path[:index]).Service(path[index+1:])
}

func (op *ExternalComputeResourcesService) String() string {
	return fmt.Sprintf("ExternalComputeResourcesService:%s", op.Path)
}

//
//
type ExternalHostProvidersService struct {
	BaseService
}

func NewExternalHostProvidersService(connection *Connection, path string) *ExternalHostProvidersService {
	var result ExternalHostProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostProvidersServiceAddRequest struct {
	externalHostProvidersService *ExternalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	provider                     *ExternalHostProvider
}

func (p *ExternalHostProvidersServiceAddRequest) Header(key, value string) *ExternalHostProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProvidersServiceAddRequest) Query(key, value string) *ExternalHostProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProvidersServiceAddRequest) Provider(provider *ExternalHostProvider) *ExternalHostProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *ExternalHostProvidersServiceAddRequest) Send() (*ExternalHostProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.Connection.URL(), p.externalHostProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProvidersService.Connection.username, p.externalHostProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostProvidersServiceAddResponse ExternalHostProvidersServiceAddResponse
	var providerVar ExternalHostProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	externalHostProvidersServiceAddResponse.provider = &providerVar
	return &externalHostProvidersServiceAddResponse, nil
}

type ExternalHostProvidersServiceAddResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProvidersServiceAddResponse) Provider() *ExternalHostProvider {
	return p.provider
}
func (p *ExternalHostProvidersService) Add() *ExternalHostProvidersServiceAddRequest {
	return &ExternalHostProvidersServiceAddRequest{externalHostProvidersService: p}
}

type ExternalHostProvidersServiceListRequest struct {
	externalHostProvidersService *ExternalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	max                          *int64
}

func (p *ExternalHostProvidersServiceListRequest) Header(key, value string) *ExternalHostProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Query(key, value string) *ExternalHostProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Max(max int64) *ExternalHostProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalHostProvidersServiceListRequest) Send() (*ExternalHostProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.Connection.URL(), p.externalHostProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProvidersService.Connection.username, p.externalHostProvidersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var externalHostProvidersServiceListResponse ExternalHostProvidersServiceListResponse
	var providersVar ExternalHostProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	externalHostProvidersServiceListResponse.providers = providersVar.ExternalHostProviders
	return &externalHostProvidersServiceListResponse, nil
}

type ExternalHostProvidersServiceListResponse struct {
	providers []ExternalHostProvider
}

func (p *ExternalHostProvidersServiceListResponse) Providers() []ExternalHostProvider {
	return p.providers
}
func (p *ExternalHostProvidersService) List() *ExternalHostProvidersServiceListRequest {
	return &ExternalHostProvidersServiceListRequest{externalHostProvidersService: p}
}

//
//
func (op *ExternalHostProvidersService) ProviderService(id string) *ExternalHostProviderService {
	return NewExternalHostProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostProvidersService) String() string {
	return fmt.Sprintf("ExternalHostProvidersService:%s", op.Path)
}

//
// This service manages a single gluster brick.
//
type GlusterBrickService struct {
	BaseService
}

func NewGlusterBrickService(connection *Connection, path string) *GlusterBrickService {
	var result GlusterBrickService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterBrickServiceGetRequest struct {
	glusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
}

func (p *GlusterBrickServiceGetRequest) Header(key, value string) *GlusterBrickServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceGetRequest) Query(key, value string) *GlusterBrickServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceGetRequest) Send() (*GlusterBrickServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBrickService.Connection.URL(), p.glusterBrickService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBrickService.Connection.username, p.glusterBrickService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterBrickServiceGetResponse GlusterBrickServiceGetResponse
	var brickVar GlusterBrick
	xml.Unmarshal(respBodyBytes, &brickVar)
	glusterBrickServiceGetResponse.brick = &brickVar
	return &glusterBrickServiceGetResponse, nil
}

type GlusterBrickServiceGetResponse struct {
	brick *GlusterBrick
}

func (p *GlusterBrickServiceGetResponse) Brick() *GlusterBrick {
	return p.brick
}
func (p *GlusterBrickService) Get() *GlusterBrickServiceGetRequest {
	return &GlusterBrickServiceGetRequest{glusterBrickService: p}
}

type GlusterBrickServiceRemoveRequest struct {
	glusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *GlusterBrickServiceRemoveRequest) Header(key, value string) *GlusterBrickServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceRemoveRequest) Query(key, value string) *GlusterBrickServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceRemoveRequest) Async(async bool) *GlusterBrickServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterBrickServiceRemoveRequest) Send() (*GlusterBrickServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBrickService.Connection.URL(), p.glusterBrickService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBrickService.Connection.username, p.glusterBrickService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterBrickServiceRemoveResponse), nil
}

type GlusterBrickServiceRemoveResponse struct {
}

func (p *GlusterBrickService) Remove() *GlusterBrickServiceRemoveRequest {
	return &GlusterBrickServiceRemoveRequest{glusterBrickService: p}
}

type GlusterBrickServiceReplaceRequest struct {
	glusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
	force               *bool
}

func (p *GlusterBrickServiceReplaceRequest) Header(key, value string) *GlusterBrickServiceReplaceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Query(key, value string) *GlusterBrickServiceReplaceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Async(async bool) *GlusterBrickServiceReplaceRequest {
	p.async = &async
	return p
}
func (p *GlusterBrickServiceReplaceRequest) Force(force bool) *GlusterBrickServiceReplaceRequest {
	p.force = &force
	return p
}
func (p *GlusterBrickServiceReplaceRequest) Send() (*GlusterBrickServiceReplaceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/replace", p.glusterBrickService.Connection.URL(), p.glusterBrickService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Force(*p.force)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBrickService.Connection.username, p.glusterBrickService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBrickServiceReplaceResponse), nil
}

type GlusterBrickServiceReplaceResponse struct {
}

func (p *GlusterBrickService) Replace() *GlusterBrickServiceReplaceRequest {
	return &GlusterBrickServiceReplaceRequest{glusterBrickService: p}
}

//
//
func (op *GlusterBrickService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterBrickService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterBrickService) String() string {
	return fmt.Sprintf("GlusterBrickService:%s", op.Path)
}

//
// This service manages a collection of gluster volumes available in a cluster.
//
type GlusterVolumesService struct {
	BaseService
}

func NewGlusterVolumesService(connection *Connection, path string) *GlusterVolumesService {
	var result GlusterVolumesService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterVolumesServiceAddRequest struct {
	glusterVolumesService *GlusterVolumesService
	header                map[string]string
	query                 map[string]string
	volume                *GlusterVolume
}

func (p *GlusterVolumesServiceAddRequest) Header(key, value string) *GlusterVolumesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumesServiceAddRequest) Query(key, value string) *GlusterVolumesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumesServiceAddRequest) Volume(volume *GlusterVolume) *GlusterVolumesServiceAddRequest {
	p.volume = volume
	return p
}
func (p *GlusterVolumesServiceAddRequest) Send() (*GlusterVolumesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.Connection.URL(), p.glusterVolumesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.volume)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumesService.Connection.username, p.glusterVolumesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterVolumesServiceAddResponse GlusterVolumesServiceAddResponse
	var volumeVar GlusterVolume
	xml.Unmarshal(respBodyBytes, &volumeVar)
	glusterVolumesServiceAddResponse.volume = &volumeVar
	return &glusterVolumesServiceAddResponse, nil
}

type GlusterVolumesServiceAddResponse struct {
	volume *GlusterVolume
}

func (p *GlusterVolumesServiceAddResponse) Volume() *GlusterVolume {
	return p.volume
}
func (p *GlusterVolumesService) Add() *GlusterVolumesServiceAddRequest {
	return &GlusterVolumesServiceAddRequest{glusterVolumesService: p}
}

type GlusterVolumesServiceListRequest struct {
	glusterVolumesService *GlusterVolumesService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	max                   *int64
	search                *string
}

func (p *GlusterVolumesServiceListRequest) Header(key, value string) *GlusterVolumesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumesServiceListRequest) Query(key, value string) *GlusterVolumesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumesServiceListRequest) CaseSensitive(caseSensitive bool) *GlusterVolumesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *GlusterVolumesServiceListRequest) Max(max int64) *GlusterVolumesServiceListRequest {
	p.max = &max
	return p
}
func (p *GlusterVolumesServiceListRequest) Search(search string) *GlusterVolumesServiceListRequest {
	p.search = &search
	return p
}
func (p *GlusterVolumesServiceListRequest) Send() (*GlusterVolumesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.Connection.URL(), p.glusterVolumesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumesService.Connection.username, p.glusterVolumesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterVolumesServiceListResponse GlusterVolumesServiceListResponse
	var volumesVar GlusterVolumes
	xml.Unmarshal(respBodyBytes, &volumesVar)
	glusterVolumesServiceListResponse.volumes = volumesVar.GlusterVolumes
	return &glusterVolumesServiceListResponse, nil
}

type GlusterVolumesServiceListResponse struct {
	volumes []GlusterVolume
}

func (p *GlusterVolumesServiceListResponse) Volumes() []GlusterVolume {
	return p.volumes
}
func (p *GlusterVolumesService) List() *GlusterVolumesServiceListRequest {
	return &GlusterVolumesServiceListRequest{glusterVolumesService: p}
}

//
// Reference to a service managing gluster volume.
//
func (op *GlusterVolumesService) VolumeService(id string) *GlusterVolumeService {
	return NewGlusterVolumeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterVolumesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VolumeService(path)), nil
	}
	return op.VolumeService(path[:index]).Service(path[index+1:])
}

func (op *GlusterVolumesService) String() string {
	return fmt.Sprintf("GlusterVolumesService:%s", op.Path)
}

//
// This service manages a single gluster volume.
//
type GlusterVolumeService struct {
	BaseService
}

func NewGlusterVolumeService(connection *Connection, path string) *GlusterVolumeService {
	var result GlusterVolumeService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterVolumeServiceGetRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
}

func (p *GlusterVolumeServiceGetRequest) Header(key, value string) *GlusterVolumeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceGetRequest) Query(key, value string) *GlusterVolumeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceGetRequest) Send() (*GlusterVolumeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterVolumeServiceGetResponse GlusterVolumeServiceGetResponse
	var volumeVar GlusterVolume
	xml.Unmarshal(respBodyBytes, &volumeVar)
	glusterVolumeServiceGetResponse.volume = &volumeVar
	return &glusterVolumeServiceGetResponse, nil
}

type GlusterVolumeServiceGetResponse struct {
	volume *GlusterVolume
}

func (p *GlusterVolumeServiceGetResponse) Volume() *GlusterVolume {
	return p.volume
}
func (p *GlusterVolumeService) Get() *GlusterVolumeServiceGetRequest {
	return &GlusterVolumeServiceGetRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceGetProfileStatisticsRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Header(key, value string) *GlusterVolumeServiceGetProfileStatisticsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Query(key, value string) *GlusterVolumeServiceGetProfileStatisticsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Send() (*GlusterVolumeServiceGetProfileStatisticsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/getprofilestatistics", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return &GlusterVolumeServiceGetProfileStatisticsResponse{details: action.Details}, nil
}

type GlusterVolumeServiceGetProfileStatisticsResponse struct {
	details *GlusterVolumeProfileDetails
}

func (p *GlusterVolumeServiceGetProfileStatisticsResponse) Details() *GlusterVolumeProfileDetails {
	return p.details
}
func (p *GlusterVolumeService) GetProfileStatistics() *GlusterVolumeServiceGetProfileStatisticsRequest {
	return &GlusterVolumeServiceGetProfileStatisticsRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceRebalanceRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	fixLayout            *bool
	force                *bool
}

func (p *GlusterVolumeServiceRebalanceRequest) Header(key, value string) *GlusterVolumeServiceRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Query(key, value string) *GlusterVolumeServiceRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Async(async bool) *GlusterVolumeServiceRebalanceRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceRebalanceRequest) FixLayout(fixLayout bool) *GlusterVolumeServiceRebalanceRequest {
	p.fixLayout = &fixLayout
	return p
}
func (p *GlusterVolumeServiceRebalanceRequest) Force(force bool) *GlusterVolumeServiceRebalanceRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceRebalanceRequest) Send() (*GlusterVolumeServiceRebalanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/rebalance", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.FixLayout(*p.fixLayout)
	actionBuilder.Force(*p.force)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceRebalanceResponse), nil
}

type GlusterVolumeServiceRebalanceResponse struct {
}

func (p *GlusterVolumeService) Rebalance() *GlusterVolumeServiceRebalanceRequest {
	return &GlusterVolumeServiceRebalanceRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceRemoveRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceRemoveRequest) Header(key, value string) *GlusterVolumeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceRemoveRequest) Query(key, value string) *GlusterVolumeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceRemoveRequest) Async(async bool) *GlusterVolumeServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceRemoveRequest) Send() (*GlusterVolumeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterVolumeServiceRemoveResponse), nil
}

type GlusterVolumeServiceRemoveResponse struct {
}

func (p *GlusterVolumeService) Remove() *GlusterVolumeServiceRemoveRequest {
	return &GlusterVolumeServiceRemoveRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceResetAllOptionsRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Header(key, value string) *GlusterVolumeServiceResetAllOptionsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Query(key, value string) *GlusterVolumeServiceResetAllOptionsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Async(async bool) *GlusterVolumeServiceResetAllOptionsRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceResetAllOptionsRequest) Send() (*GlusterVolumeServiceResetAllOptionsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetalloptions", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceResetAllOptionsResponse), nil
}

type GlusterVolumeServiceResetAllOptionsResponse struct {
}

func (p *GlusterVolumeService) ResetAllOptions() *GlusterVolumeServiceResetAllOptionsRequest {
	return &GlusterVolumeServiceResetAllOptionsRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceResetOptionRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
	option               *Option
}

func (p *GlusterVolumeServiceResetOptionRequest) Header(key, value string) *GlusterVolumeServiceResetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Query(key, value string) *GlusterVolumeServiceResetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Async(async bool) *GlusterVolumeServiceResetOptionRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceResetOptionRequest) Force(force bool) *GlusterVolumeServiceResetOptionRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceResetOptionRequest) Option(option *Option) *GlusterVolumeServiceResetOptionRequest {
	p.option = option
	return p
}
func (p *GlusterVolumeServiceResetOptionRequest) Send() (*GlusterVolumeServiceResetOptionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetoption", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Force(*p.force)
	actionBuilder.Option(p.option)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceResetOptionResponse), nil
}

type GlusterVolumeServiceResetOptionResponse struct {
}

func (p *GlusterVolumeService) ResetOption() *GlusterVolumeServiceResetOptionRequest {
	return &GlusterVolumeServiceResetOptionRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceSetOptionRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	option               *Option
}

func (p *GlusterVolumeServiceSetOptionRequest) Header(key, value string) *GlusterVolumeServiceSetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Query(key, value string) *GlusterVolumeServiceSetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Async(async bool) *GlusterVolumeServiceSetOptionRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceSetOptionRequest) Option(option *Option) *GlusterVolumeServiceSetOptionRequest {
	p.option = option
	return p
}
func (p *GlusterVolumeServiceSetOptionRequest) Send() (*GlusterVolumeServiceSetOptionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/setoption", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Option(p.option)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceSetOptionResponse), nil
}

type GlusterVolumeServiceSetOptionResponse struct {
}

func (p *GlusterVolumeService) SetOption() *GlusterVolumeServiceSetOptionRequest {
	return &GlusterVolumeServiceSetOptionRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceStartRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *GlusterVolumeServiceStartRequest) Header(key, value string) *GlusterVolumeServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStartRequest) Query(key, value string) *GlusterVolumeServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStartRequest) Async(async bool) *GlusterVolumeServiceStartRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStartRequest) Force(force bool) *GlusterVolumeServiceStartRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceStartRequest) Send() (*GlusterVolumeServiceStartResponse, error) {
	rawURL := fmt.Sprintf("%s%s/start", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Force(*p.force)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStartResponse), nil
}

type GlusterVolumeServiceStartResponse struct {
}

func (p *GlusterVolumeService) Start() *GlusterVolumeServiceStartRequest {
	return &GlusterVolumeServiceStartRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceStartProfileRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStartProfileRequest) Header(key, value string) *GlusterVolumeServiceStartProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStartProfileRequest) Query(key, value string) *GlusterVolumeServiceStartProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStartProfileRequest) Async(async bool) *GlusterVolumeServiceStartProfileRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStartProfileRequest) Send() (*GlusterVolumeServiceStartProfileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/startprofile", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStartProfileResponse), nil
}

type GlusterVolumeServiceStartProfileResponse struct {
}

func (p *GlusterVolumeService) StartProfile() *GlusterVolumeServiceStartProfileRequest {
	return &GlusterVolumeServiceStartProfileRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceStopRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *GlusterVolumeServiceStopRequest) Header(key, value string) *GlusterVolumeServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRequest) Query(key, value string) *GlusterVolumeServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRequest) Async(async bool) *GlusterVolumeServiceStopRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStopRequest) Force(force bool) *GlusterVolumeServiceStopRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceStopRequest) Send() (*GlusterVolumeServiceStopResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stop", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Force(*p.force)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStopResponse), nil
}

type GlusterVolumeServiceStopResponse struct {
}

func (p *GlusterVolumeService) Stop() *GlusterVolumeServiceStopRequest {
	return &GlusterVolumeServiceStopRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceStopProfileRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStopProfileRequest) Header(key, value string) *GlusterVolumeServiceStopProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopProfileRequest) Query(key, value string) *GlusterVolumeServiceStopProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopProfileRequest) Async(async bool) *GlusterVolumeServiceStopProfileRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStopProfileRequest) Send() (*GlusterVolumeServiceStopProfileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stopprofile", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStopProfileResponse), nil
}

type GlusterVolumeServiceStopProfileResponse struct {
}

func (p *GlusterVolumeService) StopProfile() *GlusterVolumeServiceStopProfileRequest {
	return &GlusterVolumeServiceStopProfileRequest{glusterVolumeService: p}
}

type GlusterVolumeServiceStopRebalanceRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Header(key, value string) *GlusterVolumeServiceStopRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Query(key, value string) *GlusterVolumeServiceStopRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Async(async bool) *GlusterVolumeServiceStopRebalanceRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStopRebalanceRequest) Send() (*GlusterVolumeServiceStopRebalanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stoprebalance", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStopRebalanceResponse), nil
}

type GlusterVolumeServiceStopRebalanceResponse struct {
}

func (p *GlusterVolumeService) StopRebalance() *GlusterVolumeServiceStopRebalanceRequest {
	return &GlusterVolumeServiceStopRebalanceRequest{glusterVolumeService: p}
}

//
// Reference to a service managing gluster bricks.
//
func (op *GlusterVolumeService) GlusterBricksService() *GlusterBricksService {
	return NewGlusterBricksService(op.Connection, fmt.Sprintf("%s/glusterbricks", op.Path))
}

//
//
func (op *GlusterVolumeService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterVolumeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "glusterbricks" {
		return op.GlusterBricksService(), nil
	}
	if strings.HasPrefix(path, "glusterbricks/") {
		return op.GlusterBricksService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterVolumeService) String() string {
	return fmt.Sprintf("GlusterVolumeService:%s", op.Path)
}

//
//
type GlusterHookService struct {
	BaseService
}

func NewGlusterHookService(connection *Connection, path string) *GlusterHookService {
	var result GlusterHookService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterHookServiceDisableRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceDisableRequest) Header(key, value string) *GlusterHookServiceDisableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceDisableRequest) Query(key, value string) *GlusterHookServiceDisableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceDisableRequest) Async(async bool) *GlusterHookServiceDisableRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceDisableRequest) Send() (*GlusterHookServiceDisableResponse, error) {
	rawURL := fmt.Sprintf("%s%s/disable", p.glusterHookService.Connection.URL(), p.glusterHookService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHookService.Connection.username, p.glusterHookService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterHookServiceDisableResponse), nil
}

type GlusterHookServiceDisableResponse struct {
}

func (p *GlusterHookService) Disable() *GlusterHookServiceDisableRequest {
	return &GlusterHookServiceDisableRequest{glusterHookService: p}
}

type GlusterHookServiceEnableRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceEnableRequest) Header(key, value string) *GlusterHookServiceEnableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceEnableRequest) Query(key, value string) *GlusterHookServiceEnableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceEnableRequest) Async(async bool) *GlusterHookServiceEnableRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceEnableRequest) Send() (*GlusterHookServiceEnableResponse, error) {
	rawURL := fmt.Sprintf("%s%s/enable", p.glusterHookService.Connection.URL(), p.glusterHookService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHookService.Connection.username, p.glusterHookService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterHookServiceEnableResponse), nil
}

type GlusterHookServiceEnableResponse struct {
}

func (p *GlusterHookService) Enable() *GlusterHookServiceEnableRequest {
	return &GlusterHookServiceEnableRequest{glusterHookService: p}
}

type GlusterHookServiceGetRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
}

func (p *GlusterHookServiceGetRequest) Header(key, value string) *GlusterHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceGetRequest) Query(key, value string) *GlusterHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceGetRequest) Send() (*GlusterHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHookService.Connection.URL(), p.glusterHookService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHookService.Connection.username, p.glusterHookService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterHookServiceGetResponse GlusterHookServiceGetResponse
	var hookVar GlusterHook
	xml.Unmarshal(respBodyBytes, &hookVar)
	glusterHookServiceGetResponse.hook = &hookVar
	return &glusterHookServiceGetResponse, nil
}

type GlusterHookServiceGetResponse struct {
	hook *GlusterHook
}

func (p *GlusterHookServiceGetResponse) Hook() *GlusterHook {
	return p.hook
}
func (p *GlusterHookService) Get() *GlusterHookServiceGetRequest {
	return &GlusterHookServiceGetRequest{glusterHookService: p}
}

type GlusterHookServiceRemoveRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceRemoveRequest) Header(key, value string) *GlusterHookServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceRemoveRequest) Query(key, value string) *GlusterHookServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceRemoveRequest) Async(async bool) *GlusterHookServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceRemoveRequest) Send() (*GlusterHookServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHookService.Connection.URL(), p.glusterHookService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHookService.Connection.username, p.glusterHookService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterHookServiceRemoveResponse), nil
}

type GlusterHookServiceRemoveResponse struct {
}

func (p *GlusterHookService) Remove() *GlusterHookServiceRemoveRequest {
	return &GlusterHookServiceRemoveRequest{glusterHookService: p}
}

type GlusterHookServiceResolveRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
	host               *Host
	resolutionType     *string
}

func (p *GlusterHookServiceResolveRequest) Header(key, value string) *GlusterHookServiceResolveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceResolveRequest) Query(key, value string) *GlusterHookServiceResolveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceResolveRequest) Async(async bool) *GlusterHookServiceResolveRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceResolveRequest) Host(host *Host) *GlusterHookServiceResolveRequest {
	p.host = host
	return p
}
func (p *GlusterHookServiceResolveRequest) ResolutionType(resolutionType string) *GlusterHookServiceResolveRequest {
	p.resolutionType = &resolutionType
	return p
}
func (p *GlusterHookServiceResolveRequest) Send() (*GlusterHookServiceResolveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resolve", p.glusterHookService.Connection.URL(), p.glusterHookService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Host(p.host)
	actionBuilder.ResolutionType(*p.resolutionType)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHookService.Connection.username, p.glusterHookService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterHookServiceResolveResponse), nil
}

type GlusterHookServiceResolveResponse struct {
}

func (p *GlusterHookService) Resolve() *GlusterHookServiceResolveRequest {
	return &GlusterHookServiceResolveRequest{glusterHookService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterHookService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterHookService) String() string {
	return fmt.Sprintf("GlusterHookService:%s", op.Path)
}

//
// This service manages the gluster bricks in a gluster volume
//
type GlusterBricksService struct {
	BaseService
}

func NewGlusterBricksService(connection *Connection, path string) *GlusterBricksService {
	var result GlusterBricksService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterBricksServiceActivateRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
}

func (p *GlusterBricksServiceActivateRequest) Header(key, value string) *GlusterBricksServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceActivateRequest) Query(key, value string) *GlusterBricksServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceActivateRequest) Async(async bool) *GlusterBricksServiceActivateRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceActivateRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceActivateRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceActivateRequest) Send() (*GlusterBricksServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Bricks(p.bricks)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBricksServiceActivateResponse), nil
}

type GlusterBricksServiceActivateResponse struct {
}

func (p *GlusterBricksService) Activate() *GlusterBricksServiceActivateRequest {
	return &GlusterBricksServiceActivateRequest{glusterBricksService: p}
}

type GlusterBricksServiceAddRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	bricks               []GlusterBrick
	replicaCount         *int64
	stripeCount          *int64
}

func (p *GlusterBricksServiceAddRequest) Header(key, value string) *GlusterBricksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceAddRequest) Query(key, value string) *GlusterBricksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceAddRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceAddRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceAddRequest) ReplicaCount(replicaCount int64) *GlusterBricksServiceAddRequest {
	p.replicaCount = &replicaCount
	return p
}
func (p *GlusterBricksServiceAddRequest) StripeCount(stripeCount int64) *GlusterBricksServiceAddRequest {
	p.stripeCount = &stripeCount
	return p
}
func (p *GlusterBricksServiceAddRequest) Send() (*GlusterBricksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	values := make(url.Values)
	if p.replicaCount != nil {
		values["replicaCount"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}
	if p.stripeCount != nil {
		values["stripeCount"] = []string{fmt.Sprintf("%v", *p.stripeCount)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bricks)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterBricksServiceAddResponse GlusterBricksServiceAddResponse
	var bricksVar GlusterBricks
	xml.Unmarshal(respBodyBytes, &bricksVar)
	glusterBricksServiceAddResponse.bricks = bricksVar.GlusterBricks
	return &glusterBricksServiceAddResponse, nil
}

type GlusterBricksServiceAddResponse struct {
	bricks []GlusterBrick
}

func (p *GlusterBricksServiceAddResponse) Bricks() []GlusterBrick {
	return p.bricks
}
func (p *GlusterBricksService) Add() *GlusterBricksServiceAddRequest {
	return &GlusterBricksServiceAddRequest{glusterBricksService: p}
}

type GlusterBricksServiceListRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *GlusterBricksServiceListRequest) Header(key, value string) *GlusterBricksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceListRequest) Query(key, value string) *GlusterBricksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceListRequest) Max(max int64) *GlusterBricksServiceListRequest {
	p.max = &max
	return p
}
func (p *GlusterBricksServiceListRequest) Send() (*GlusterBricksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterBricksServiceListResponse GlusterBricksServiceListResponse
	var bricksVar GlusterBricks
	xml.Unmarshal(respBodyBytes, &bricksVar)
	glusterBricksServiceListResponse.bricks = bricksVar.GlusterBricks
	return &glusterBricksServiceListResponse, nil
}

type GlusterBricksServiceListResponse struct {
	bricks []GlusterBrick
}

func (p *GlusterBricksServiceListResponse) Bricks() []GlusterBrick {
	return p.bricks
}
func (p *GlusterBricksService) List() *GlusterBricksServiceListRequest {
	return &GlusterBricksServiceListRequest{glusterBricksService: p}
}

type GlusterBricksServiceMigrateRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
}

func (p *GlusterBricksServiceMigrateRequest) Header(key, value string) *GlusterBricksServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Query(key, value string) *GlusterBricksServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Async(async bool) *GlusterBricksServiceMigrateRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceMigrateRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceMigrateRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceMigrateRequest) Send() (*GlusterBricksServiceMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/migrate", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Bricks(p.bricks)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBricksServiceMigrateResponse), nil
}

type GlusterBricksServiceMigrateResponse struct {
}

func (p *GlusterBricksService) Migrate() *GlusterBricksServiceMigrateRequest {
	return &GlusterBricksServiceMigrateRequest{glusterBricksService: p}
}

type GlusterBricksServiceRemoveRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
	replicaCount         *int64
}

func (p *GlusterBricksServiceRemoveRequest) Header(key, value string) *GlusterBricksServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Query(key, value string) *GlusterBricksServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Async(async bool) *GlusterBricksServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceRemoveRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceRemoveRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceRemoveRequest) ReplicaCount(replicaCount int64) *GlusterBricksServiceRemoveRequest {
	p.replicaCount = &replicaCount
	return p
}
func (p *GlusterBricksServiceRemoveRequest) Send() (*GlusterBricksServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.replicaCount != nil {
		values["replicaCount"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterBricksServiceRemoveResponse), nil
}

type GlusterBricksServiceRemoveResponse struct {
}

func (p *GlusterBricksService) Remove() *GlusterBricksServiceRemoveRequest {
	return &GlusterBricksServiceRemoveRequest{glusterBricksService: p}
}

type GlusterBricksServiceStopMigrateRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
}

func (p *GlusterBricksServiceStopMigrateRequest) Header(key, value string) *GlusterBricksServiceStopMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Query(key, value string) *GlusterBricksServiceStopMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Async(async bool) *GlusterBricksServiceStopMigrateRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceStopMigrateRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceStopMigrateRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceStopMigrateRequest) Send() (*GlusterBricksServiceStopMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stopmigrate", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Async(*p.async)
	actionBuilder.Bricks(p.bricks)
	action, errBuilder := actionBuilder.Build()
	if errBuilder != nil {
		return nil, errBuilder
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(action)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("PUT", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBricksServiceStopMigrateResponse), nil
}

type GlusterBricksServiceStopMigrateResponse struct {
}

func (p *GlusterBricksService) StopMigrate() *GlusterBricksServiceStopMigrateRequest {
	return &GlusterBricksServiceStopMigrateRequest{glusterBricksService: p}
}

//
// Returns a reference to the service managing a single gluster brick.
//
func (op *GlusterBricksService) BrickService(id string) *GlusterBrickService {
	return NewGlusterBrickService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterBricksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.BrickService(path)), nil
	}
	return op.BrickService(path[:index]).Service(path[index+1:])
}

func (op *GlusterBricksService) String() string {
	return fmt.Sprintf("GlusterBricksService:%s", op.Path)
}

//
//
type GlusterHooksService struct {
	BaseService
}

func NewGlusterHooksService(connection *Connection, path string) *GlusterHooksService {
	var result GlusterHooksService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterHooksServiceListRequest struct {
	glusterHooksService *GlusterHooksService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *GlusterHooksServiceListRequest) Header(key, value string) *GlusterHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHooksServiceListRequest) Query(key, value string) *GlusterHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHooksServiceListRequest) Max(max int64) *GlusterHooksServiceListRequest {
	p.max = &max
	return p
}
func (p *GlusterHooksServiceListRequest) Send() (*GlusterHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHooksService.Connection.URL(), p.glusterHooksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHooksService.Connection.username, p.glusterHooksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHooksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var glusterHooksServiceListResponse GlusterHooksServiceListResponse
	var hooksVar GlusterHooks
	xml.Unmarshal(respBodyBytes, &hooksVar)
	glusterHooksServiceListResponse.hooks = hooksVar.GlusterHooks
	return &glusterHooksServiceListResponse, nil
}

type GlusterHooksServiceListResponse struct {
	hooks []GlusterHook
}

func (p *GlusterHooksServiceListResponse) Hooks() []GlusterHook {
	return p.hooks
}
func (p *GlusterHooksService) List() *GlusterHooksServiceListRequest {
	return &GlusterHooksServiceListRequest{glusterHooksService: p}
}

//
//
func (op *GlusterHooksService) HookService(id string) *GlusterHookService {
	return NewGlusterHookService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterHooksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HookService(path)), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *GlusterHooksService) String() string {
	return fmt.Sprintf("GlusterHooksService:%s", op.Path)
}

//
// Manages the collection of disks available in the system.
//
type DisksService struct {
	BaseService
}

func NewDisksService(connection *Connection, path string) *DisksService {
	var result DisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type DisksServiceAddRequest struct {
	disksService *DisksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *DisksServiceAddRequest) Header(key, value string) *DisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceAddRequest) Query(key, value string) *DisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceAddRequest) Disk(disk *Disk) *DisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *DisksServiceAddRequest) Send() (*DisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.disksService.Connection.URL(), p.disksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.disksService.Connection.username, p.disksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.disksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var disksServiceAddResponse DisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	disksServiceAddResponse.disk = &diskVar
	return &disksServiceAddResponse, nil
}

type DisksServiceAddResponse struct {
	disk *Disk
}

func (p *DisksServiceAddResponse) Disk() *Disk {
	return p.disk
}
func (p *DisksService) Add() *DisksServiceAddRequest {
	return &DisksServiceAddRequest{disksService: p}
}

type DisksServiceListRequest struct {
	disksService  *DisksService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *DisksServiceListRequest) Header(key, value string) *DisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceListRequest) Query(key, value string) *DisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceListRequest) CaseSensitive(caseSensitive bool) *DisksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DisksServiceListRequest) Max(max int64) *DisksServiceListRequest {
	p.max = &max
	return p
}
func (p *DisksServiceListRequest) Search(search string) *DisksServiceListRequest {
	p.search = &search
	return p
}
func (p *DisksServiceListRequest) Send() (*DisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.disksService.Connection.URL(), p.disksService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.disksService.Connection.username, p.disksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.disksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var disksServiceListResponse DisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	disksServiceListResponse.disks = disksVar.Disks
	return &disksServiceListResponse, nil
}

type DisksServiceListResponse struct {
	disks []Disk
}

func (p *DisksServiceListResponse) Disks() []Disk {
	return p.disks
}
func (p *DisksService) List() *DisksServiceListRequest {
	return &DisksServiceListRequest{disksService: p}
}

//
// Reference to a service managing a specific disk.
//
func (op *DisksService) DiskService(id string) *DiskService {
	return NewDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *DisksService) String() string {
	return fmt.Sprintf("DisksService:%s", op.Path)
}

//
//
type InstanceTypeWatchdogsService struct {
	BaseService
}

func NewInstanceTypeWatchdogsService(connection *Connection, path string) *InstanceTypeWatchdogsService {
	var result InstanceTypeWatchdogsService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeWatchdogsServiceAddRequest struct {
	instanceTypeWatchdogsService *InstanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	watchdog                     *Watchdog
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Header(key, value string) *InstanceTypeWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Query(key, value string) *InstanceTypeWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *InstanceTypeWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}
func (p *InstanceTypeWatchdogsServiceAddRequest) Send() (*InstanceTypeWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.Connection.URL(), p.instanceTypeWatchdogsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogsService.Connection.username, p.instanceTypeWatchdogsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeWatchdogsServiceAddResponse InstanceTypeWatchdogsServiceAddResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	instanceTypeWatchdogsServiceAddResponse.watchdog = &watchdogVar
	return &instanceTypeWatchdogsServiceAddResponse, nil
}

type InstanceTypeWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogsServiceAddResponse) Watchdog() *Watchdog {
	return p.watchdog
}
func (p *InstanceTypeWatchdogsService) Add() *InstanceTypeWatchdogsServiceAddRequest {
	return &InstanceTypeWatchdogsServiceAddRequest{instanceTypeWatchdogsService: p}
}

type InstanceTypeWatchdogsServiceListRequest struct {
	instanceTypeWatchdogsService *InstanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	max                          *int64
	search                       *string
}

func (p *InstanceTypeWatchdogsServiceListRequest) Header(key, value string) *InstanceTypeWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Query(key, value string) *InstanceTypeWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Max(max int64) *InstanceTypeWatchdogsServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypeWatchdogsServiceListRequest) Search(search string) *InstanceTypeWatchdogsServiceListRequest {
	p.search = &search
	return p
}
func (p *InstanceTypeWatchdogsServiceListRequest) Send() (*InstanceTypeWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.Connection.URL(), p.instanceTypeWatchdogsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogsService.Connection.username, p.instanceTypeWatchdogsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var instanceTypeWatchdogsServiceListResponse InstanceTypeWatchdogsServiceListResponse
	var watchdogsVar Watchdogs
	xml.Unmarshal(respBodyBytes, &watchdogsVar)
	instanceTypeWatchdogsServiceListResponse.watchdogs = watchdogsVar.Watchdogs
	return &instanceTypeWatchdogsServiceListResponse, nil
}

type InstanceTypeWatchdogsServiceListResponse struct {
	watchdogs []Watchdog
}

func (p *InstanceTypeWatchdogsServiceListResponse) Watchdogs() []Watchdog {
	return p.watchdogs
}
func (p *InstanceTypeWatchdogsService) List() *InstanceTypeWatchdogsServiceListRequest {
	return &InstanceTypeWatchdogsServiceListRequest{instanceTypeWatchdogsService: p}
}

//
//
func (op *InstanceTypeWatchdogsService) WatchdogService(id string) *InstanceTypeWatchdogService {
	return NewInstanceTypeWatchdogService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeWatchdogsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WatchdogService(path)), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeWatchdogsService) String() string {
	return fmt.Sprintf("InstanceTypeWatchdogsService:%s", op.Path)
}

//
// A service to manage jobs.
//
type JobsService struct {
	BaseService
}

func NewJobsService(connection *Connection, path string) *JobsService {
	var result JobsService
	result.Connection = connection
	result.Path = path
	return &result
}

type JobsServiceAddRequest struct {
	jobsService *JobsService
	header      map[string]string
	query       map[string]string
	job         *Job
}

func (p *JobsServiceAddRequest) Header(key, value string) *JobsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobsServiceAddRequest) Query(key, value string) *JobsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobsServiceAddRequest) Job(job *Job) *JobsServiceAddRequest {
	p.job = job
	return p
}
func (p *JobsServiceAddRequest) Send() (*JobsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.Connection.URL(), p.jobsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.job)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobsService.Connection.username, p.jobsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var jobsServiceAddResponse JobsServiceAddResponse
	var jobVar Job
	xml.Unmarshal(respBodyBytes, &jobVar)
	jobsServiceAddResponse.job = &jobVar
	return &jobsServiceAddResponse, nil
}

type JobsServiceAddResponse struct {
	job *Job
}

func (p *JobsServiceAddResponse) Job() *Job {
	return p.job
}
func (p *JobsService) Add() *JobsServiceAddRequest {
	return &JobsServiceAddRequest{jobsService: p}
}

type JobsServiceListRequest struct {
	jobsService *JobsService
	header      map[string]string
	query       map[string]string
	max         *int64
}

func (p *JobsServiceListRequest) Header(key, value string) *JobsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobsServiceListRequest) Query(key, value string) *JobsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobsServiceListRequest) Max(max int64) *JobsServiceListRequest {
	p.max = &max
	return p
}
func (p *JobsServiceListRequest) Send() (*JobsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.Connection.URL(), p.jobsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobsService.Connection.username, p.jobsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var jobsServiceListResponse JobsServiceListResponse
	var jobsVar Jobs
	xml.Unmarshal(respBodyBytes, &jobsVar)
	jobsServiceListResponse.jobs = jobsVar.Jobs
	return &jobsServiceListResponse, nil
}

type JobsServiceListResponse struct {
	jobs []Job
}

func (p *JobsServiceListResponse) Jobs() []Job {
	return p.jobs
}
func (p *JobsService) List() *JobsServiceListRequest {
	return &JobsServiceListRequest{jobsService: p}
}

//
// Reference to the job service.
//
func (op *JobsService) JobService(id string) *JobService {
	return NewJobService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *JobsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.JobService(path)), nil
	}
	return op.JobService(path[:index]).Service(path[index+1:])
}

func (op *JobsService) String() string {
	return fmt.Sprintf("JobsService:%s", op.Path)
}

//
// A service to manage icons.
//
type IconsService struct {
	BaseService
}

func NewIconsService(connection *Connection, path string) *IconsService {
	var result IconsService
	result.Connection = connection
	result.Path = path
	return &result
}

type IconsServiceListRequest struct {
	iconsService *IconsService
	header       map[string]string
	query        map[string]string
	max          *int64
}

func (p *IconsServiceListRequest) Header(key, value string) *IconsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IconsServiceListRequest) Query(key, value string) *IconsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IconsServiceListRequest) Max(max int64) *IconsServiceListRequest {
	p.max = &max
	return p
}
func (p *IconsServiceListRequest) Send() (*IconsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iconsService.Connection.URL(), p.iconsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iconsService.Connection.username, p.iconsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iconsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var iconsServiceListResponse IconsServiceListResponse
	var iconsVar Icons
	xml.Unmarshal(respBodyBytes, &iconsVar)
	iconsServiceListResponse.icons = iconsVar.Icons
	return &iconsServiceListResponse, nil
}

type IconsServiceListResponse struct {
	icons []Icon
}

func (p *IconsServiceListResponse) Icons() []Icon {
	return p.icons
}
func (p *IconsService) List() *IconsServiceListRequest {
	return &IconsServiceListRequest{iconsService: p}
}

//
// Reference to the service that manages an specific icon.
//
func (op *IconsService) IconService(id string) *IconService {
	return NewIconService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IconsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.IconService(path)), nil
	}
	return op.IconService(path[:index]).Service(path[index+1:])
}

func (op *IconsService) String() string {
	return fmt.Sprintf("IconsService:%s", op.Path)
}

//
// This service manages the virtual machine templates available in the system.
//
type TemplatesService struct {
	BaseService
}

func NewTemplatesService(connection *Connection, path string) *TemplatesService {
	var result TemplatesService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplatesServiceAddRequest struct {
	templatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	clonePermissions *bool
	template         *Template
}

func (p *TemplatesServiceAddRequest) Header(key, value string) *TemplatesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceAddRequest) Query(key, value string) *TemplatesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceAddRequest) ClonePermissions(clonePermissions bool) *TemplatesServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}
func (p *TemplatesServiceAddRequest) Template(template *Template) *TemplatesServiceAddRequest {
	p.template = template
	return p
}
func (p *TemplatesServiceAddRequest) Send() (*TemplatesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.Connection.URL(), p.templatesService.Path)
	values := make(url.Values)
	if p.clonePermissions != nil {
		values["clonePermissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.template)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templatesService.Connection.username, p.templatesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templatesServiceAddResponse TemplatesServiceAddResponse
	var templateVar Template
	xml.Unmarshal(respBodyBytes, &templateVar)
	templatesServiceAddResponse.template = &templateVar
	return &templatesServiceAddResponse, nil
}

type TemplatesServiceAddResponse struct {
	template *Template
}

func (p *TemplatesServiceAddResponse) Template() *Template {
	return p.template
}
func (p *TemplatesService) Add() *TemplatesServiceAddRequest {
	return &TemplatesServiceAddRequest{templatesService: p}
}

type TemplatesServiceListRequest struct {
	templatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	caseSensitive    *bool
	filter           *bool
	max              *int64
	search           *string
}

func (p *TemplatesServiceListRequest) Header(key, value string) *TemplatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceListRequest) Query(key, value string) *TemplatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceListRequest) CaseSensitive(caseSensitive bool) *TemplatesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *TemplatesServiceListRequest) Filter(filter bool) *TemplatesServiceListRequest {
	p.filter = &filter
	return p
}
func (p *TemplatesServiceListRequest) Max(max int64) *TemplatesServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplatesServiceListRequest) Search(search string) *TemplatesServiceListRequest {
	p.search = &search
	return p
}
func (p *TemplatesServiceListRequest) Send() (*TemplatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.Connection.URL(), p.templatesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templatesService.Connection.username, p.templatesService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templatesServiceListResponse TemplatesServiceListResponse
	var templatesVar Templates
	xml.Unmarshal(respBodyBytes, &templatesVar)
	templatesServiceListResponse.templates = templatesVar.Templates
	return &templatesServiceListResponse, nil
}

type TemplatesServiceListResponse struct {
	templates []Template
}

func (p *TemplatesServiceListResponse) Templates() []Template {
	return p.templates
}
func (p *TemplatesService) List() *TemplatesServiceListRequest {
	return &TemplatesServiceListRequest{templatesService: p}
}

//
// Returns a reference to the service that manages a specific virtual machine template.
//
func (op *TemplatesService) TemplateService(id string) *TemplateService {
	return NewTemplateService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplatesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TemplateService(path)), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *TemplatesService) String() string {
	return fmt.Sprintf("TemplatesService:%s", op.Path)
}

//
//
type FilterService struct {
	BaseService
}

func NewFilterService(connection *Connection, path string) *FilterService {
	var result FilterService
	result.Connection = connection
	result.Path = path
	return &result
}

type FilterServiceGetRequest struct {
	filterService *FilterService
	header        map[string]string
	query         map[string]string
	filter        *bool
}

func (p *FilterServiceGetRequest) Header(key, value string) *FilterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilterServiceGetRequest) Query(key, value string) *FilterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilterServiceGetRequest) Filter(filter bool) *FilterServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *FilterServiceGetRequest) Send() (*FilterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filterService.Connection.URL(), p.filterService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filterService.Connection.username, p.filterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var filterServiceGetResponse FilterServiceGetResponse
	var resultVar Filter
	xml.Unmarshal(respBodyBytes, &resultVar)
	filterServiceGetResponse.result = &resultVar
	return &filterServiceGetResponse, nil
}

type FilterServiceGetResponse struct {
	result *Filter
}

func (p *FilterServiceGetResponse) Result() *Filter {
	return p.result
}
func (p *FilterService) Get() *FilterServiceGetRequest {
	return &FilterServiceGetRequest{filterService: p}
}

type FilterServiceRemoveRequest struct {
	filterService *FilterService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *FilterServiceRemoveRequest) Header(key, value string) *FilterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilterServiceRemoveRequest) Query(key, value string) *FilterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilterServiceRemoveRequest) Async(async bool) *FilterServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *FilterServiceRemoveRequest) Send() (*FilterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filterService.Connection.URL(), p.filterService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filterService.Connection.username, p.filterService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(FilterServiceRemoveResponse), nil
}

type FilterServiceRemoveResponse struct {
}

func (p *FilterService) Remove() *FilterServiceRemoveRequest {
	return &FilterServiceRemoveRequest{filterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FilterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FilterService) String() string {
	return fmt.Sprintf("FilterService:%s", op.Path)
}

//
// This service is used to list and manipulate affinity labels that are
// assigned to supported entities when accessed using entities/affinitylabels.
//
type AssignedAffinityLabelsService struct {
	BaseService
}

func NewAssignedAffinityLabelsService(connection *Connection, path string) *AssignedAffinityLabelsService {
	var result AssignedAffinityLabelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedAffinityLabelsServiceAddRequest struct {
	assignedAffinityLabelsService *AssignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
	label                         *AffinityLabel
}

func (p *AssignedAffinityLabelsServiceAddRequest) Header(key, value string) *AssignedAffinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceAddRequest) Query(key, value string) *AssignedAffinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceAddRequest) Label(label *AffinityLabel) *AssignedAffinityLabelsServiceAddRequest {
	p.label = label
	return p
}
func (p *AssignedAffinityLabelsServiceAddRequest) Send() (*AssignedAffinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.Connection.URL(), p.assignedAffinityLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.label)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedAffinityLabelsService.Connection.username, p.assignedAffinityLabelsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedAffinityLabelsServiceAddResponse AssignedAffinityLabelsServiceAddResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	assignedAffinityLabelsServiceAddResponse.label = &labelVar
	return &assignedAffinityLabelsServiceAddResponse, nil
}

type AssignedAffinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AssignedAffinityLabelsServiceAddResponse) Label() *AffinityLabel {
	return p.label
}
func (p *AssignedAffinityLabelsService) Add() *AssignedAffinityLabelsServiceAddRequest {
	return &AssignedAffinityLabelsServiceAddRequest{assignedAffinityLabelsService: p}
}

type AssignedAffinityLabelsServiceListRequest struct {
	assignedAffinityLabelsService *AssignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
}

func (p *AssignedAffinityLabelsServiceListRequest) Header(key, value string) *AssignedAffinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceListRequest) Query(key, value string) *AssignedAffinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceListRequest) Send() (*AssignedAffinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.Connection.URL(), p.assignedAffinityLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedAffinityLabelsService.Connection.username, p.assignedAffinityLabelsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedAffinityLabelsServiceListResponse AssignedAffinityLabelsServiceListResponse
	var labelVar AffinityLabels
	xml.Unmarshal(respBodyBytes, &labelVar)
	assignedAffinityLabelsServiceListResponse.label = labelVar.AffinityLabels
	return &assignedAffinityLabelsServiceListResponse, nil
}

type AssignedAffinityLabelsServiceListResponse struct {
	label []AffinityLabel
}

func (p *AssignedAffinityLabelsServiceListResponse) Label() []AffinityLabel {
	return p.label
}
func (p *AssignedAffinityLabelsService) List() *AssignedAffinityLabelsServiceListRequest {
	return &AssignedAffinityLabelsServiceListRequest{assignedAffinityLabelsService: p}
}

//
// Link to the specific entity-label assignment to allow
// removal.
//
func (op *AssignedAffinityLabelsService) LabelService(id string) *AssignedAffinityLabelService {
	return NewAssignedAffinityLabelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedAffinityLabelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LabelService(path)), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AssignedAffinityLabelsService) String() string {
	return fmt.Sprintf("AssignedAffinityLabelsService:%s", op.Path)
}

//
//
type SnapshotCdromService struct {
	BaseService
}

func NewSnapshotCdromService(connection *Connection, path string) *SnapshotCdromService {
	var result SnapshotCdromService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotCdromServiceGetRequest struct {
	snapshotCdromService *SnapshotCdromService
	header               map[string]string
	query                map[string]string
}

func (p *SnapshotCdromServiceGetRequest) Header(key, value string) *SnapshotCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotCdromServiceGetRequest) Query(key, value string) *SnapshotCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotCdromServiceGetRequest) Send() (*SnapshotCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromService.Connection.URL(), p.snapshotCdromService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotCdromService.Connection.username, p.snapshotCdromService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotCdromService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var snapshotCdromServiceGetResponse SnapshotCdromServiceGetResponse
	var cdromVar Cdrom
	xml.Unmarshal(respBodyBytes, &cdromVar)
	snapshotCdromServiceGetResponse.cdrom = &cdromVar
	return &snapshotCdromServiceGetResponse, nil
}

type SnapshotCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *SnapshotCdromServiceGetResponse) Cdrom() *Cdrom {
	return p.cdrom
}
func (p *SnapshotCdromService) Get() *SnapshotCdromServiceGetRequest {
	return &SnapshotCdromServiceGetRequest{snapshotCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotCdromService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotCdromService) String() string {
	return fmt.Sprintf("SnapshotCdromService:%s", op.Path)
}

//
//
type HostNumaNodeService struct {
	BaseService
}

func NewHostNumaNodeService(connection *Connection, path string) *HostNumaNodeService {
	var result HostNumaNodeService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNumaNodeServiceGetRequest struct {
	hostNumaNodeService *HostNumaNodeService
	header              map[string]string
	query               map[string]string
}

func (p *HostNumaNodeServiceGetRequest) Header(key, value string) *HostNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNumaNodeServiceGetRequest) Query(key, value string) *HostNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNumaNodeServiceGetRequest) Send() (*HostNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodeService.Connection.URL(), p.hostNumaNodeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNumaNodeService.Connection.username, p.hostNumaNodeService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNumaNodeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostNumaNodeServiceGetResponse HostNumaNodeServiceGetResponse
	var nodeVar NumaNode
	xml.Unmarshal(respBodyBytes, &nodeVar)
	hostNumaNodeServiceGetResponse.node = &nodeVar
	return &hostNumaNodeServiceGetResponse, nil
}

type HostNumaNodeServiceGetResponse struct {
	node *NumaNode
}

func (p *HostNumaNodeServiceGetResponse) Node() *NumaNode {
	return p.node
}
func (p *HostNumaNodeService) Get() *HostNumaNodeServiceGetRequest {
	return &HostNumaNodeServiceGetRequest{hostNumaNodeService: p}
}

//
//
func (op *HostNumaNodeService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNumaNodeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostNumaNodeService) String() string {
	return fmt.Sprintf("HostNumaNodeService:%s", op.Path)
}

//
//
type TemplateGraphicsConsoleService struct {
	BaseService
}

func NewTemplateGraphicsConsoleService(connection *Connection, path string) *TemplateGraphicsConsoleService {
	var result TemplateGraphicsConsoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateGraphicsConsoleServiceGetRequest struct {
	templateGraphicsConsoleService *TemplateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Header(key, value string) *TemplateGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Query(key, value string) *TemplateGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Send() (*TemplateGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsoleService.Connection.URL(), p.templateGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateGraphicsConsoleService.Connection.username, p.templateGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var templateGraphicsConsoleServiceGetResponse TemplateGraphicsConsoleServiceGetResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	templateGraphicsConsoleServiceGetResponse.console = &consoleVar
	return &templateGraphicsConsoleServiceGetResponse, nil
}

type TemplateGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *TemplateGraphicsConsoleServiceGetResponse) Console() *GraphicsConsole {
	return p.console
}
func (p *TemplateGraphicsConsoleService) Get() *TemplateGraphicsConsoleServiceGetRequest {
	return &TemplateGraphicsConsoleServiceGetRequest{templateGraphicsConsoleService: p}
}

type TemplateGraphicsConsoleServiceRemoveRequest struct {
	templateGraphicsConsoleService *TemplateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Header(key, value string) *TemplateGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Query(key, value string) *TemplateGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Async(async bool) *TemplateGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateGraphicsConsoleServiceRemoveRequest) Send() (*TemplateGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsoleService.Connection.URL(), p.templateGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateGraphicsConsoleService.Connection.username, p.templateGraphicsConsoleService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateGraphicsConsoleServiceRemoveResponse), nil
}

type TemplateGraphicsConsoleServiceRemoveResponse struct {
}

func (p *TemplateGraphicsConsoleService) Remove() *TemplateGraphicsConsoleServiceRemoveRequest {
	return &TemplateGraphicsConsoleServiceRemoveRequest{templateGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateGraphicsConsoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateGraphicsConsoleService) String() string {
	return fmt.Sprintf("TemplateGraphicsConsoleService:%s", op.Path)
}

//
// This service represents list of hosts that have a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type AffinityLabelHostsService struct {
	BaseService
}

func NewAffinityLabelHostsService(connection *Connection, path string) *AffinityLabelHostsService {
	var result AffinityLabelHostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelHostsServiceAddRequest struct {
	affinityLabelHostsService *AffinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
	host                      *Host
}

func (p *AffinityLabelHostsServiceAddRequest) Header(key, value string) *AffinityLabelHostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostsServiceAddRequest) Query(key, value string) *AffinityLabelHostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostsServiceAddRequest) Host(host *Host) *AffinityLabelHostsServiceAddRequest {
	p.host = host
	return p
}
func (p *AffinityLabelHostsServiceAddRequest) Send() (*AffinityLabelHostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.Connection.URL(), p.affinityLabelHostsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.host)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelHostsService.Connection.username, p.affinityLabelHostsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelHostsServiceAddResponse AffinityLabelHostsServiceAddResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	affinityLabelHostsServiceAddResponse.host = &hostVar
	return &affinityLabelHostsServiceAddResponse, nil
}

type AffinityLabelHostsServiceAddResponse struct {
	host *Host
}

func (p *AffinityLabelHostsServiceAddResponse) Host() *Host {
	return p.host
}
func (p *AffinityLabelHostsService) Add() *AffinityLabelHostsServiceAddRequest {
	return &AffinityLabelHostsServiceAddRequest{affinityLabelHostsService: p}
}

type AffinityLabelHostsServiceListRequest struct {
	affinityLabelHostsService *AffinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
}

func (p *AffinityLabelHostsServiceListRequest) Header(key, value string) *AffinityLabelHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostsServiceListRequest) Query(key, value string) *AffinityLabelHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostsServiceListRequest) Send() (*AffinityLabelHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.Connection.URL(), p.affinityLabelHostsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelHostsService.Connection.username, p.affinityLabelHostsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var affinityLabelHostsServiceListResponse AffinityLabelHostsServiceListResponse
	var hostsVar Hosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	affinityLabelHostsServiceListResponse.hosts = hostsVar.Hosts
	return &affinityLabelHostsServiceListResponse, nil
}

type AffinityLabelHostsServiceListResponse struct {
	hosts []Host
}

func (p *AffinityLabelHostsServiceListResponse) Hosts() []Host {
	return p.hosts
}
func (p *AffinityLabelHostsService) List() *AffinityLabelHostsServiceListRequest {
	return &AffinityLabelHostsServiceListRequest{affinityLabelHostsService: p}
}

//
// A link to the specific label-host assignment to
// allow label removal.
//
func (op *AffinityLabelHostsService) HostService(id string) *AffinityLabelHostService {
	return NewAffinityLabelHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelHostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelHostsService) String() string {
	return fmt.Sprintf("AffinityLabelHostsService:%s", op.Path)
}

//
//
type DiskSnapshotsService struct {
	BaseService
}

func NewDiskSnapshotsService(connection *Connection, path string) *DiskSnapshotsService {
	var result DiskSnapshotsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskSnapshotsServiceListRequest struct {
	diskSnapshotsService *DiskSnapshotsService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *DiskSnapshotsServiceListRequest) Header(key, value string) *DiskSnapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotsServiceListRequest) Query(key, value string) *DiskSnapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotsServiceListRequest) Max(max int64) *DiskSnapshotsServiceListRequest {
	p.max = &max
	return p
}
func (p *DiskSnapshotsServiceListRequest) Send() (*DiskSnapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotsService.Connection.URL(), p.diskSnapshotsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskSnapshotsService.Connection.username, p.diskSnapshotsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskSnapshotsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var diskSnapshotsServiceListResponse DiskSnapshotsServiceListResponse
	var snapshotsVar DiskSnapshots
	xml.Unmarshal(respBodyBytes, &snapshotsVar)
	diskSnapshotsServiceListResponse.snapshots = snapshotsVar.DiskSnapshots
	return &diskSnapshotsServiceListResponse, nil
}

type DiskSnapshotsServiceListResponse struct {
	snapshots []DiskSnapshot
}

func (p *DiskSnapshotsServiceListResponse) Snapshots() []DiskSnapshot {
	return p.snapshots
}
func (p *DiskSnapshotsService) List() *DiskSnapshotsServiceListRequest {
	return &DiskSnapshotsServiceListRequest{diskSnapshotsService: p}
}

//
//
func (op *DiskSnapshotsService) SnapshotService(id string) *DiskSnapshotService {
	return NewDiskSnapshotService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskSnapshotsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SnapshotService(path)), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *DiskSnapshotsService) String() string {
	return fmt.Sprintf("DiskSnapshotsService:%s", op.Path)
}

//
// Lists the virtual machines of an export storage domain.
// For example, to retrieve the virtual machines that are available in the storage domain with identifier `123` send the
// following request:
// [source]
// ----
// GET /ovirt-engine/api/storagedomains/123/vms
// ----
// This will return the following response body:
// [source,xml]
// ----
// <vms>
//   <vm id="456" href="/api/storagedomains/123/vms/456">
//     <name>vm1</name>
//     ...
//     <storage_domain id="123" href="/api/storagedomains/123"/>
//     <actions>
//       <link rel="import" href="/api/storagedomains/123/vms/456/import"/>
//     </actions>
//   </vm>
// </vms>
// ----
// Virtual machines and templates in these collections have a similar representation to their counterparts in the
// top-level <<types/vm, Vm>> and <<types/template, Template>> collections, except they also contain a
// <<types/storage_domain, StorageDomain>> reference and an <<services/storage_domain_vm/methods/import, import>>
// action.
//
type StorageDomainVmsService struct {
	BaseService
}

func NewStorageDomainVmsService(connection *Connection, path string) *StorageDomainVmsService {
	var result StorageDomainVmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmsServiceListRequest struct {
	storageDomainVmsService *StorageDomainVmsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *StorageDomainVmsServiceListRequest) Header(key, value string) *StorageDomainVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmsServiceListRequest) Query(key, value string) *StorageDomainVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmsServiceListRequest) Max(max int64) *StorageDomainVmsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainVmsServiceListRequest) Send() (*StorageDomainVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmsService.Connection.URL(), p.storageDomainVmsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmsService.Connection.username, p.storageDomainVmsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainVmsServiceListResponse StorageDomainVmsServiceListResponse
	var vmVar Vms
	xml.Unmarshal(respBodyBytes, &vmVar)
	storageDomainVmsServiceListResponse.vm = vmVar.Vms
	return &storageDomainVmsServiceListResponse, nil
}

type StorageDomainVmsServiceListResponse struct {
	vm []Vm
}

func (p *StorageDomainVmsServiceListResponse) Vm() []Vm {
	return p.vm
}
func (p *StorageDomainVmsService) List() *StorageDomainVmsServiceListRequest {
	return &StorageDomainVmsServiceListRequest{storageDomainVmsService: p}
}

//
//
func (op *StorageDomainVmsService) VmService(id string) *StorageDomainVmService {
	return NewStorageDomainVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainVmsService) String() string {
	return fmt.Sprintf("StorageDomainVmsService:%s", op.Path)
}

//
// A service that manages hosts.
//
type HostsService struct {
	BaseService
}

func NewHostsService(connection *Connection, path string) *HostsService {
	var result HostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostsServiceAddRequest struct {
	hostsService         *HostsService
	header               map[string]string
	query                map[string]string
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *HostsServiceAddRequest) Header(key, value string) *HostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceAddRequest) Query(key, value string) *HostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceAddRequest) DeployHostedEngine(deployHostedEngine bool) *HostsServiceAddRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}
func (p *HostsServiceAddRequest) Host(host *Host) *HostsServiceAddRequest {
	p.host = host
	return p
}
func (p *HostsServiceAddRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostsServiceAddRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}
func (p *HostsServiceAddRequest) Send() (*HostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.Connection.URL(), p.hostsService.Path)
	values := make(url.Values)
	if p.deployHostedEngine != nil {
		values["deployHostedEngine"] = []string{fmt.Sprintf("%v", *p.deployHostedEngine)}
	}
	if p.undeployHostedEngine != nil {
		values["undeployHostedEngine"] = []string{fmt.Sprintf("%v", *p.undeployHostedEngine)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.host)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostsService.Connection.username, p.hostsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostsServiceAddResponse HostsServiceAddResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	hostsServiceAddResponse.host = &hostVar
	return &hostsServiceAddResponse, nil
}

type HostsServiceAddResponse struct {
	host *Host
}

func (p *HostsServiceAddResponse) Host() *Host {
	return p.host
}
func (p *HostsService) Add() *HostsServiceAddRequest {
	return &HostsServiceAddRequest{hostsService: p}
}

type HostsServiceListRequest struct {
	hostsService  *HostsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	filter        *bool
	max           *int64
	search        *string
}

func (p *HostsServiceListRequest) Header(key, value string) *HostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceListRequest) Query(key, value string) *HostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceListRequest) CaseSensitive(caseSensitive bool) *HostsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *HostsServiceListRequest) Filter(filter bool) *HostsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *HostsServiceListRequest) Max(max int64) *HostsServiceListRequest {
	p.max = &max
	return p
}
func (p *HostsServiceListRequest) Search(search string) *HostsServiceListRequest {
	p.search = &search
	return p
}
func (p *HostsServiceListRequest) Send() (*HostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.Connection.URL(), p.hostsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostsService.Connection.username, p.hostsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var hostsServiceListResponse HostsServiceListResponse
	var hostsVar Hosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	hostsServiceListResponse.hosts = hostsVar.Hosts
	return &hostsServiceListResponse, nil
}

type HostsServiceListResponse struct {
	hosts []Host
}

func (p *HostsServiceListResponse) Hosts() []Host {
	return p.hosts
}
func (p *HostsService) List() *HostsServiceListRequest {
	return &HostsServiceListRequest{hostsService: p}
}

//
// A Reference to service managing a specific host.
//
func (op *HostsService) HostService(id string) *HostService {
	return NewHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *HostsService) String() string {
	return fmt.Sprintf("HostsService:%s", op.Path)
}

//
// Manages the collection of disks available inside an specific storage domain.
//
type StorageDomainDisksService struct {
	BaseService
}

func NewStorageDomainDisksService(connection *Connection, path string) *StorageDomainDisksService {
	var result StorageDomainDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainDisksServiceAddRequest struct {
	storageDomainDisksService *StorageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	disk                      *Disk
	unregistered              *bool
}

func (p *StorageDomainDisksServiceAddRequest) Header(key, value string) *StorageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Query(key, value string) *StorageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Disk(disk *Disk) *StorageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *StorageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *StorageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}
func (p *StorageDomainDisksServiceAddRequest) Send() (*StorageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.Connection.URL(), p.storageDomainDisksService.Path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDisksService.Connection.username, p.storageDomainDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainDisksServiceAddResponse StorageDomainDisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	storageDomainDisksServiceAddResponse.disk = &diskVar
	return &storageDomainDisksServiceAddResponse, nil
}

type StorageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *StorageDomainDisksServiceAddResponse) Disk() *Disk {
	return p.disk
}
func (p *StorageDomainDisksService) Add() *StorageDomainDisksServiceAddRequest {
	return &StorageDomainDisksServiceAddRequest{storageDomainDisksService: p}
}

type StorageDomainDisksServiceListRequest struct {
	storageDomainDisksService *StorageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *StorageDomainDisksServiceListRequest) Header(key, value string) *StorageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDisksServiceListRequest) Query(key, value string) *StorageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDisksServiceListRequest) Max(max int64) *StorageDomainDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainDisksServiceListRequest) Send() (*StorageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.Connection.URL(), p.storageDomainDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDisksService.Connection.username, p.storageDomainDisksService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageDomainDisksServiceListResponse StorageDomainDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	storageDomainDisksServiceListResponse.disks = disksVar.Disks
	return &storageDomainDisksServiceListResponse, nil
}

type StorageDomainDisksServiceListResponse struct {
	disks []Disk
}

func (p *StorageDomainDisksServiceListResponse) Disks() []Disk {
	return p.disks
}
func (p *StorageDomainDisksService) List() *StorageDomainDisksServiceListRequest {
	return &StorageDomainDisksServiceListRequest{storageDomainDisksService: p}
}

//
// Reference to the service that manages a specific disk.
//
func (op *StorageDomainDisksService) DiskService(id string) *StorageDomainDiskService {
	return NewStorageDomainDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainDisksService) String() string {
	return fmt.Sprintf("StorageDomainDisksService:%s", op.Path)
}

//
//
type FiltersService struct {
	BaseService
}

func NewFiltersService(connection *Connection, path string) *FiltersService {
	var result FiltersService
	result.Connection = connection
	result.Path = path
	return &result
}

type FiltersServiceAddRequest struct {
	filtersService *FiltersService
	header         map[string]string
	query          map[string]string
	filter         *Filter
}

func (p *FiltersServiceAddRequest) Header(key, value string) *FiltersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FiltersServiceAddRequest) Query(key, value string) *FiltersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FiltersServiceAddRequest) Filter(filter *Filter) *FiltersServiceAddRequest {
	p.filter = filter
	return p
}
func (p *FiltersServiceAddRequest) Send() (*FiltersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.Connection.URL(), p.filtersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.filter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filtersService.Connection.username, p.filtersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filtersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var filtersServiceAddResponse FiltersServiceAddResponse
	var filterVar Filter
	xml.Unmarshal(respBodyBytes, &filterVar)
	filtersServiceAddResponse.filter = &filterVar
	return &filtersServiceAddResponse, nil
}

type FiltersServiceAddResponse struct {
	filter *Filter
}

func (p *FiltersServiceAddResponse) Filter() *Filter {
	return p.filter
}
func (p *FiltersService) Add() *FiltersServiceAddRequest {
	return &FiltersServiceAddRequest{filtersService: p}
}

type FiltersServiceListRequest struct {
	filtersService *FiltersService
	header         map[string]string
	query          map[string]string
	filter         *bool
	max            *int64
}

func (p *FiltersServiceListRequest) Header(key, value string) *FiltersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FiltersServiceListRequest) Query(key, value string) *FiltersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FiltersServiceListRequest) Filter(filter bool) *FiltersServiceListRequest {
	p.filter = &filter
	return p
}
func (p *FiltersServiceListRequest) Max(max int64) *FiltersServiceListRequest {
	p.max = &max
	return p
}
func (p *FiltersServiceListRequest) Send() (*FiltersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.Connection.URL(), p.filtersService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filtersService.Connection.username, p.filtersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filtersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var filtersServiceListResponse FiltersServiceListResponse
	var filtersVar Filters
	xml.Unmarshal(respBodyBytes, &filtersVar)
	filtersServiceListResponse.filters = filtersVar.Filters
	return &filtersServiceListResponse, nil
}

type FiltersServiceListResponse struct {
	filters []Filter
}

func (p *FiltersServiceListResponse) Filters() []Filter {
	return p.filters
}
func (p *FiltersService) List() *FiltersServiceListRequest {
	return &FiltersServiceListRequest{filtersService: p}
}

//
//
func (op *FiltersService) FilterService(id string) *FilterService {
	return NewFilterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FiltersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.FilterService(path)), nil
	}
	return op.FilterService(path[:index]).Service(path[index+1:])
}

func (op *FiltersService) String() string {
	return fmt.Sprintf("FiltersService:%s", op.Path)
}

//
//
type StorageServerConnectionsService struct {
	BaseService
}

func NewStorageServerConnectionsService(connection *Connection, path string) *StorageServerConnectionsService {
	var result StorageServerConnectionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionsServiceAddRequest struct {
	storageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddRequest) Header(key, value string) *StorageServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddRequest) Query(key, value string) *StorageServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}
func (p *StorageServerConnectionsServiceAddRequest) Send() (*StorageServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.Connection.URL(), p.storageServerConnectionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.connection)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionsService.Connection.username, p.storageServerConnectionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionsServiceAddResponse StorageServerConnectionsServiceAddResponse
	var connectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &connectionVar)
	storageServerConnectionsServiceAddResponse.connection = &connectionVar
	return &storageServerConnectionsServiceAddResponse, nil
}

type StorageServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddResponse) Connection() *StorageConnection {
	return p.connection
}
func (p *StorageServerConnectionsService) Add() *StorageServerConnectionsServiceAddRequest {
	return &StorageServerConnectionsServiceAddRequest{storageServerConnectionsService: p}
}

type StorageServerConnectionsServiceListRequest struct {
	storageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *StorageServerConnectionsServiceListRequest) Header(key, value string) *StorageServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Query(key, value string) *StorageServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Max(max int64) *StorageServerConnectionsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageServerConnectionsServiceListRequest) Send() (*StorageServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.Connection.URL(), p.storageServerConnectionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionsService.Connection.username, p.storageServerConnectionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var storageServerConnectionsServiceListResponse StorageServerConnectionsServiceListResponse
	var connectionsVar StorageConnections
	xml.Unmarshal(respBodyBytes, &connectionsVar)
	storageServerConnectionsServiceListResponse.connections = connectionsVar.StorageConnections
	return &storageServerConnectionsServiceListResponse, nil
}

type StorageServerConnectionsServiceListResponse struct {
	connections []StorageConnection
}

func (p *StorageServerConnectionsServiceListResponse) Connections() []StorageConnection {
	return p.connections
}
func (p *StorageServerConnectionsService) List() *StorageServerConnectionsServiceListRequest {
	return &StorageServerConnectionsServiceListRequest{storageServerConnectionsService: p}
}

//
//
func (op *StorageServerConnectionsService) StorageConnectionService(id string) *StorageServerConnectionService {
	return NewStorageServerConnectionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageConnectionService(path)), nil
	}
	return op.StorageConnectionService(path[:index]).Service(path[index+1:])
}

func (op *StorageServerConnectionsService) String() string {
	return fmt.Sprintf("StorageServerConnectionsService:%s", op.Path)
}

//
//
type FenceAgentsService struct {
	BaseService
}

func NewFenceAgentsService(connection *Connection, path string) *FenceAgentsService {
	var result FenceAgentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type FenceAgentsServiceAddRequest struct {
	fenceAgentsService *FenceAgentsService
	header             map[string]string
	query              map[string]string
	agent              *Agent
}

func (p *FenceAgentsServiceAddRequest) Header(key, value string) *FenceAgentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentsServiceAddRequest) Query(key, value string) *FenceAgentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentsServiceAddRequest) Agent(agent *Agent) *FenceAgentsServiceAddRequest {
	p.agent = agent
	return p
}
func (p *FenceAgentsServiceAddRequest) Send() (*FenceAgentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.Connection.URL(), p.fenceAgentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.agent)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentsService.Connection.username, p.fenceAgentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var fenceAgentsServiceAddResponse FenceAgentsServiceAddResponse
	var agentVar Agent
	xml.Unmarshal(respBodyBytes, &agentVar)
	fenceAgentsServiceAddResponse.agent = &agentVar
	return &fenceAgentsServiceAddResponse, nil
}

type FenceAgentsServiceAddResponse struct {
	agent *Agent
}

func (p *FenceAgentsServiceAddResponse) Agent() *Agent {
	return p.agent
}
func (p *FenceAgentsService) Add() *FenceAgentsServiceAddRequest {
	return &FenceAgentsServiceAddRequest{fenceAgentsService: p}
}

type FenceAgentsServiceListRequest struct {
	fenceAgentsService *FenceAgentsService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *FenceAgentsServiceListRequest) Header(key, value string) *FenceAgentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentsServiceListRequest) Query(key, value string) *FenceAgentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentsServiceListRequest) Max(max int64) *FenceAgentsServiceListRequest {
	p.max = &max
	return p
}
func (p *FenceAgentsServiceListRequest) Send() (*FenceAgentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.Connection.URL(), p.fenceAgentsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentsService.Connection.username, p.fenceAgentsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var fenceAgentsServiceListResponse FenceAgentsServiceListResponse
	var agentsVar Agents
	xml.Unmarshal(respBodyBytes, &agentsVar)
	fenceAgentsServiceListResponse.agents = agentsVar.Agents
	return &fenceAgentsServiceListResponse, nil
}

type FenceAgentsServiceListResponse struct {
	agents []Agent
}

func (p *FenceAgentsServiceListResponse) Agents() []Agent {
	return p.agents
}
func (p *FenceAgentsService) List() *FenceAgentsServiceListRequest {
	return &FenceAgentsServiceListRequest{fenceAgentsService: p}
}

//
//
func (op *FenceAgentsService) AgentService(id string) *FenceAgentService {
	return NewFenceAgentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FenceAgentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AgentService(path)), nil
	}
	return op.AgentService(path[:index]).Service(path[index+1:])
}

func (op *FenceAgentsService) String() string {
	return fmt.Sprintf("FenceAgentsService:%s", op.Path)
}

//
// A service to manage clusters.
//
type ClustersService struct {
	BaseService
}

func NewClustersService(connection *Connection, path string) *ClustersService {
	var result ClustersService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClustersServiceAddRequest struct {
	clustersService *ClustersService
	header          map[string]string
	query           map[string]string
	cluster         *Cluster
}

func (p *ClustersServiceAddRequest) Header(key, value string) *ClustersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClustersServiceAddRequest) Query(key, value string) *ClustersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClustersServiceAddRequest) Cluster(cluster *Cluster) *ClustersServiceAddRequest {
	p.cluster = cluster
	return p
}
func (p *ClustersServiceAddRequest) Send() (*ClustersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.Connection.URL(), p.clustersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.cluster)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clustersService.Connection.username, p.clustersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clustersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var clustersServiceAddResponse ClustersServiceAddResponse
	var clusterVar Cluster
	xml.Unmarshal(respBodyBytes, &clusterVar)
	clustersServiceAddResponse.cluster = &clusterVar
	return &clustersServiceAddResponse, nil
}

type ClustersServiceAddResponse struct {
	cluster *Cluster
}

func (p *ClustersServiceAddResponse) Cluster() *Cluster {
	return p.cluster
}
func (p *ClustersService) Add() *ClustersServiceAddRequest {
	return &ClustersServiceAddRequest{clustersService: p}
}

type ClustersServiceListRequest struct {
	clustersService *ClustersService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	filter          *bool
	max             *int64
	search          *string
}

func (p *ClustersServiceListRequest) Header(key, value string) *ClustersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClustersServiceListRequest) Query(key, value string) *ClustersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClustersServiceListRequest) CaseSensitive(caseSensitive bool) *ClustersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *ClustersServiceListRequest) Filter(filter bool) *ClustersServiceListRequest {
	p.filter = &filter
	return p
}
func (p *ClustersServiceListRequest) Max(max int64) *ClustersServiceListRequest {
	p.max = &max
	return p
}
func (p *ClustersServiceListRequest) Search(search string) *ClustersServiceListRequest {
	p.search = &search
	return p
}
func (p *ClustersServiceListRequest) Send() (*ClustersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.Connection.URL(), p.clustersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clustersService.Connection.username, p.clustersService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clustersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var clustersServiceListResponse ClustersServiceListResponse
	var clustersVar Clusters
	xml.Unmarshal(respBodyBytes, &clustersVar)
	clustersServiceListResponse.clusters = clustersVar.Clusters
	return &clustersServiceListResponse, nil
}

type ClustersServiceListResponse struct {
	clusters []Cluster
}

func (p *ClustersServiceListResponse) Clusters() []Cluster {
	return p.clusters
}
func (p *ClustersService) List() *ClustersServiceListRequest {
	return &ClustersServiceListRequest{clustersService: p}
}

//
// Reference to the service that manages a specific cluster.
//
func (op *ClustersService) ClusterService(id string) *ClusterService {
	return NewClusterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClustersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ClusterService(path)), nil
	}
	return op.ClusterService(path[:index]).Service(path[index+1:])
}

func (op *ClustersService) String() string {
	return fmt.Sprintf("ClustersService:%s", op.Path)
}

//
// Represents a permission sub-collection, scoped by user, group or some entity type.
//
type AssignedPermissionsService struct {
	BaseService
}

func NewAssignedPermissionsService(connection *Connection, path string) *AssignedPermissionsService {
	var result AssignedPermissionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedPermissionsServiceAddRequest struct {
	assignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddRequest) Header(key, value string) *AssignedPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddRequest) Query(key, value string) *AssignedPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddRequest {
	p.permission = permission
	return p
}
func (p *AssignedPermissionsServiceAddRequest) Send() (*AssignedPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.Connection.URL(), p.assignedPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.permission)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedPermissionsService.Connection.username, p.assignedPermissionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedPermissionsServiceAddResponse AssignedPermissionsServiceAddResponse
	var permissionVar Permission
	xml.Unmarshal(respBodyBytes, &permissionVar)
	assignedPermissionsServiceAddResponse.permission = &permissionVar
	return &assignedPermissionsServiceAddResponse, nil
}

type AssignedPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddResponse) Permission() *Permission {
	return p.permission
}
func (p *AssignedPermissionsService) Add() *AssignedPermissionsServiceAddRequest {
	return &AssignedPermissionsServiceAddRequest{assignedPermissionsService: p}
}

type AssignedPermissionsServiceListRequest struct {
	assignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
}

func (p *AssignedPermissionsServiceListRequest) Header(key, value string) *AssignedPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceListRequest) Query(key, value string) *AssignedPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceListRequest) Send() (*AssignedPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.Connection.URL(), p.assignedPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedPermissionsService.Connection.username, p.assignedPermissionsService.Connection.password)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	var assignedPermissionsServiceListResponse AssignedPermissionsServiceListResponse
	var permissionsVar Permissions
	xml.Unmarshal(respBodyBytes, &permissionsVar)
	assignedPermissionsServiceListResponse.permissions = permissionsVar.Permissions
	return &assignedPermissionsServiceListResponse, nil
}

type AssignedPermissionsServiceListResponse struct {
	permissions []Permission
}

func (p *AssignedPermissionsServiceListResponse) Permissions() []Permission {
	return p.permissions
}
func (p *AssignedPermissionsService) List() *AssignedPermissionsServiceListRequest {
	return &AssignedPermissionsServiceListRequest{assignedPermissionsService: p}
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *AssignedPermissionsService) PermissionService(id string) *PermissionService {
	return NewPermissionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedPermissionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PermissionService(path)), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *AssignedPermissionsService) String() string {
	return fmt.Sprintf("AssignedPermissionsService:%s", op.Path)
}
