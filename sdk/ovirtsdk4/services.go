//
// Copyright (c) 2017 Red Hat, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package ovirtsdk4

import (
	"bytes"
	"encoding/base64"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

//
// This annotation is intended to specify what oVirt area is the annotated concept related to. Currently the following
// areas are in use, and they are closely related to the oVirt teams, but not necessarily the same:
// - Infrastructure
// - Network
// - SLA
// - Storage
// - Virtualization
// A concept may be associated to more than one area, or to no area.
// The value of this annotation is intended for reporting only, and it doesn't affect at all the generated code or the
// validity of the model
//
type AreaService struct {
	BaseService
}

func NewAreaService(connection *Connection, path string) *AreaService {
	var result AreaService
	result.Connection = connection
	result.Path = path
	return &result
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AreaService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AreaService) String() string {
	return fmt.Sprintf("AreaService:%s", op.Path)
}

//
// This service manages the collection of all vNIC profiles.
//
type VnicProfilesService struct {
	BaseService
}

func NewVnicProfilesService(connection *Connection, path string) *VnicProfilesService {
	var result VnicProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VnicProfilesServiceAddRequest struct {
	vnicProfilesService *VnicProfilesService
	header              map[string]string
	query               map[string]string
	profile             *VnicProfile
}

func (p *VnicProfilesServiceAddRequest) Header(key, value string) *VnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfilesServiceAddRequest) Query(key, value string) *VnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *VnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *VnicProfilesServiceAddRequest) Send() (*VnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.Connection.URL(), p.vnicProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfilesService.Connection.username, p.vnicProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vnicProfilesServiceAddResponse VnicProfilesServiceAddResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	vnicProfilesServiceAddResponse.profile = &profileVar
	return &vnicProfilesServiceAddResponse, nil
}

type VnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *VnicProfilesServiceAddResponse) Profile() *VnicProfile {
	return p.profile
}

//
// Add a vNIC profile.
// For example to add vNIC profile `123` to network `456` send a request to:
// [source]
// ----
// POST /ovirt-engine/api/networks/456/vnicprofiles
// ----
// With the following body:
// [source,xml]
// ----
// <vnic_profile id="123">
//   <name>new_vNIC_name</name>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
// </vnic_profile>
// ----
// Please note that there is a default network filter to each VNIC profile.
// For more details of how the default network filter is calculated please refer to
// the documentation in <<services/network_filters,NetworkFilters>>.
// The output of creating a new VNIC profile depends in the  body  arguments that were given.
// In case no network filter was given, the default network filter will be configured. For example:
// [source,xml]
// ----
// <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
//   <name>new_vNIC_name</name>
//   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
//   <network href="/ovirt-engine/api/networks/456" id="456"/>
//   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
// </vnic_profile>
// ----
// In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
// regardless of the VNIC profile's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>no_network_filter</name>
//   <network_filter/>
// </vnic_profile>
// ----
// In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
// network filter regardless of the VNIC profiles's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>user_choice_network_filter</name>
//   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
// </vnic_profile>
// ----
// This method supports the following parameters:
// `Profile`:: The vNIC profile that is being added.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VnicProfilesService) Add(
	profile *VnicProfile,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VnicProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar VnicProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type VnicProfilesServiceListRequest struct {
	vnicProfilesService *VnicProfilesService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *VnicProfilesServiceListRequest) Header(key, value string) *VnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfilesServiceListRequest) Query(key, value string) *VnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfilesServiceListRequest) Max(max int64) *VnicProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *VnicProfilesServiceListRequest) Send() (*VnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.Connection.URL(), p.vnicProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfilesService.Connection.username, p.vnicProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vnicProfilesServiceListResponse VnicProfilesServiceListResponse
	var profilesVar VnicProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	vnicProfilesServiceListResponse.profiles = profilesVar.VnicProfiles
	return &vnicProfilesServiceListResponse, nil
}

type VnicProfilesServiceListResponse struct {
	profiles []VnicProfile
}

func (p *VnicProfilesServiceListResponse) Profiles() []VnicProfile {
	return p.profiles
}

//
// List all vNIC profiles.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of profiles to return. If not specified all the profiles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VnicProfilesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]VnicProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profilesVar VnicProfiles
	xml.Unmarshal([]byte(ovResp.Body), &profilesVar)
	return profilesVar.VnicProfiles, nil
}

//
//
func (op *VnicProfilesService) ProfileService(id string) *VnicProfileService {
	return NewVnicProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VnicProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *VnicProfilesService) String() string {
	return fmt.Sprintf("VnicProfilesService:%s", op.Path)
}

//
//
type SchedulingPolicyUnitService struct {
	BaseService
}

func NewSchedulingPolicyUnitService(connection *Connection, path string) *SchedulingPolicyUnitService {
	var result SchedulingPolicyUnitService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPolicyUnitServiceGetRequest struct {
	schedulingPolicyUnitService *SchedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	filter                      *bool
}

func (p *SchedulingPolicyUnitServiceGetRequest) Header(key, value string) *SchedulingPolicyUnitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Query(key, value string) *SchedulingPolicyUnitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Filter(filter bool) *SchedulingPolicyUnitServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPolicyUnitServiceGetRequest) Send() (*SchedulingPolicyUnitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitService.Connection.URL(), p.schedulingPolicyUnitService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyUnitService.Connection.username, p.schedulingPolicyUnitService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var schedulingPolicyUnitServiceGetResponse SchedulingPolicyUnitServiceGetResponse
	var unitVar SchedulingPolicyUnit
	xml.Unmarshal(respBodyBytes, &unitVar)
	schedulingPolicyUnitServiceGetResponse.unit = &unitVar
	return &schedulingPolicyUnitServiceGetResponse, nil
}

type SchedulingPolicyUnitServiceGetResponse struct {
	unit *SchedulingPolicyUnit
}

func (p *SchedulingPolicyUnitServiceGetResponse) Unit() *SchedulingPolicyUnit {
	return p.unit
}

//
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SchedulingPolicyUnitService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*SchedulingPolicyUnit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var unitVar SchedulingPolicyUnit
	xml.Unmarshal([]byte(ovResp.Body), &unitVar)
	return &unitVar, nil
}

type SchedulingPolicyUnitServiceRemoveRequest struct {
	schedulingPolicyUnitService *SchedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Header(key, value string) *SchedulingPolicyUnitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Query(key, value string) *SchedulingPolicyUnitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Async(async bool) *SchedulingPolicyUnitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SchedulingPolicyUnitServiceRemoveRequest) Send() (*SchedulingPolicyUnitServiceRemoveResponse, error) {
}

type SchedulingPolicyUnitServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SchedulingPolicyUnitService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyUnitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SchedulingPolicyUnitService) String() string {
	return fmt.Sprintf("SchedulingPolicyUnitService:%s", op.Path)
}

//
//
type VirtualFunctionAllowedNetworkService struct {
	BaseService
}

func NewVirtualFunctionAllowedNetworkService(connection *Connection, path string) *VirtualFunctionAllowedNetworkService {
	var result VirtualFunctionAllowedNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type VirtualFunctionAllowedNetworkServiceGetRequest struct {
	virtualFunctionAllowedNetworkService *VirtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Header(key, value string) *VirtualFunctionAllowedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Query(key, value string) *VirtualFunctionAllowedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Send() (*VirtualFunctionAllowedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworkService.Connection.URL(), p.virtualFunctionAllowedNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.virtualFunctionAllowedNetworkService.Connection.username, p.virtualFunctionAllowedNetworkService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var virtualFunctionAllowedNetworkServiceGetResponse VirtualFunctionAllowedNetworkServiceGetResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	virtualFunctionAllowedNetworkServiceGetResponse.network = &networkVar
	return &virtualFunctionAllowedNetworkServiceGetResponse, nil
}

type VirtualFunctionAllowedNetworkServiceGetResponse struct {
	network *Network
}

func (p *VirtualFunctionAllowedNetworkServiceGetResponse) Network() *Network {
	return p.network
}

//
//
func (op *VirtualFunctionAllowedNetworkService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type VirtualFunctionAllowedNetworkServiceRemoveRequest struct {
	virtualFunctionAllowedNetworkService *VirtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Header(key, value string) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Query(key, value string) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Async(async bool) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Send() (*VirtualFunctionAllowedNetworkServiceRemoveResponse, error) {
}

type VirtualFunctionAllowedNetworkServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VirtualFunctionAllowedNetworkService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VirtualFunctionAllowedNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VirtualFunctionAllowedNetworkService) String() string {
	return fmt.Sprintf("VirtualFunctionAllowedNetworkService:%s", op.Path)
}

//
//
type TemplateNicsService struct {
	BaseService
}

func NewTemplateNicsService(connection *Connection, path string) *TemplateNicsService {
	var result TemplateNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateNicsServiceAddRequest struct {
	templateNicsService *TemplateNicsService
	header              map[string]string
	query               map[string]string
	nic                 *Nic
}

func (p *TemplateNicsServiceAddRequest) Header(key, value string) *TemplateNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicsServiceAddRequest) Query(key, value string) *TemplateNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicsServiceAddRequest) Nic(nic *Nic) *TemplateNicsServiceAddRequest {
	p.nic = nic
	return p
}
func (p *TemplateNicsServiceAddRequest) Send() (*TemplateNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.Connection.URL(), p.templateNicsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicsService.Connection.username, p.templateNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateNicsServiceAddResponse TemplateNicsServiceAddResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	templateNicsServiceAddResponse.nic = &nicVar
	return &templateNicsServiceAddResponse, nil
}

type TemplateNicsServiceAddResponse struct {
	nic *Nic
}

func (p *TemplateNicsServiceAddResponse) Nic() *Nic {
	return p.nic
}

//
//
func (op *TemplateNicsService) Add(
	nic *Nic,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(nic, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

type TemplateNicsServiceListRequest struct {
	templateNicsService *TemplateNicsService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *TemplateNicsServiceListRequest) Header(key, value string) *TemplateNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicsServiceListRequest) Query(key, value string) *TemplateNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicsServiceListRequest) Max(max int64) *TemplateNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateNicsServiceListRequest) Send() (*TemplateNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.Connection.URL(), p.templateNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicsService.Connection.username, p.templateNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateNicsServiceListResponse TemplateNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	templateNicsServiceListResponse.nics = nicsVar.Nics
	return &templateNicsServiceListResponse, nil
}

type TemplateNicsServiceListResponse struct {
	nics []Nic
}

func (p *TemplateNicsServiceListResponse) Nics() []Nic {
	return p.nics
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of NICs to return. If not specified all the NICs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateNicsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicsVar Nics
	xml.Unmarshal([]byte(ovResp.Body), &nicsVar)
	return nicsVar.Nics, nil
}

//
//
func (op *TemplateNicsService) NicService(id string) *TemplateNicService {
	return NewTemplateNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *TemplateNicsService) String() string {
	return fmt.Sprintf("TemplateNicsService:%s", op.Path)
}

//
// The details of a single affinity label.
//
type AffinityLabelService struct {
	BaseService
}

func NewAffinityLabelService(connection *Connection, path string) *AffinityLabelService {
	var result AffinityLabelService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelServiceGetRequest struct {
	affinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
}

func (p *AffinityLabelServiceGetRequest) Header(key, value string) *AffinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceGetRequest) Query(key, value string) *AffinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceGetRequest) Send() (*AffinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.Connection.URL(), p.affinityLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelService.Connection.username, p.affinityLabelService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelServiceGetResponse AffinityLabelServiceGetResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	affinityLabelServiceGetResponse.label = &labelVar
	return &affinityLabelServiceGetResponse, nil
}

type AffinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelServiceGetResponse) Label() *AffinityLabel {
	return p.label
}

//
// Retrieves the details of a label.
//
func (op *AffinityLabelService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar AffinityLabel
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return &labelVar, nil
}

type AffinityLabelServiceRemoveRequest struct {
	affinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
}

func (p *AffinityLabelServiceRemoveRequest) Header(key, value string) *AffinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceRemoveRequest) Query(key, value string) *AffinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceRemoveRequest) Send() (*AffinityLabelServiceRemoveResponse, error) {
}

type AffinityLabelServiceRemoveResponse struct {
}

//
// Removes a label from the system and clears all assignments
// of the removed label.
//
func (op *AffinityLabelService) Remove(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type AffinityLabelServiceUpdateRequest struct {
	affinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
	label                *AffinityLabel
}

func (p *AffinityLabelServiceUpdateRequest) Header(key, value string) *AffinityLabelServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceUpdateRequest) Query(key, value string) *AffinityLabelServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceUpdateRequest) Label(label *AffinityLabel) *AffinityLabelServiceUpdateRequest {
	p.label = label
	return p
}
func (p *AffinityLabelServiceUpdateRequest) Send() (*AffinityLabelServiceUpdateResponse, error) {
}

type AffinityLabelServiceUpdateResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelServiceUpdateResponse) Label() *AffinityLabel {
	return p.label
}

//
// Updates a label. This call will update all metadata, such as the name
// or description.
//
func (op *AffinityLabelService) Update(
	label *AffinityLabel,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request
	ovResp, err := op.internalUpdate(label, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar AffinityLabel
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return &labelVar, nil
}

//
// List all hosts with this label.
//
func (op *AffinityLabelService) HostsService() *AffinityLabelHostsService {
	return NewAffinityLabelHostsService(op.Connection, fmt.Sprintf("%s/hosts", op.Path))
}

//
// List all virtual machines with this label.
//
func (op *AffinityLabelService) VmsService() *AffinityLabelVmsService {
	return NewAffinityLabelVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelService) String() string {
	return fmt.Sprintf("AffinityLabelService:%s", op.Path)
}

//
// A service to manage bookmarks.
//
type BookmarksService struct {
	BaseService
}

func NewBookmarksService(connection *Connection, path string) *BookmarksService {
	var result BookmarksService
	result.Connection = connection
	result.Path = path
	return &result
}

type BookmarksServiceAddRequest struct {
	bookmarksService *BookmarksService
	header           map[string]string
	query            map[string]string
	bookmark         *Bookmark
}

func (p *BookmarksServiceAddRequest) Header(key, value string) *BookmarksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarksServiceAddRequest) Query(key, value string) *BookmarksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarksServiceAddRequest) Bookmark(bookmark *Bookmark) *BookmarksServiceAddRequest {
	p.bookmark = bookmark
	return p
}
func (p *BookmarksServiceAddRequest) Send() (*BookmarksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.Connection.URL(), p.bookmarksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bookmark)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarksService.Connection.username, p.bookmarksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var bookmarksServiceAddResponse BookmarksServiceAddResponse
	var bookmarkVar Bookmark
	xml.Unmarshal(respBodyBytes, &bookmarkVar)
	bookmarksServiceAddResponse.bookmark = &bookmarkVar
	return &bookmarksServiceAddResponse, nil
}

type BookmarksServiceAddResponse struct {
	bookmark *Bookmark
}

func (p *BookmarksServiceAddResponse) Bookmark() *Bookmark {
	return p.bookmark
}

//
// Adding a new bookmark.
// Example of adding a bookmark:
// [source]
// ----
// POST /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
// This method supports the following parameters:
// `Bookmark`:: The added bookmark.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *BookmarksService) Add(
	bookmark *Bookmark,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Bookmark,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(bookmark, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bookmarkVar Bookmark
	xml.Unmarshal([]byte(ovResp.Body), &bookmarkVar)
	return &bookmarkVar, nil
}

type BookmarksServiceListRequest struct {
	bookmarksService *BookmarksService
	header           map[string]string
	query            map[string]string
	max              *int64
}

func (p *BookmarksServiceListRequest) Header(key, value string) *BookmarksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarksServiceListRequest) Query(key, value string) *BookmarksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarksServiceListRequest) Max(max int64) *BookmarksServiceListRequest {
	p.max = &max
	return p
}
func (p *BookmarksServiceListRequest) Send() (*BookmarksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.Connection.URL(), p.bookmarksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarksService.Connection.username, p.bookmarksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var bookmarksServiceListResponse BookmarksServiceListResponse
	var bookmarksVar Bookmarks
	xml.Unmarshal(respBodyBytes, &bookmarksVar)
	bookmarksServiceListResponse.bookmarks = bookmarksVar.Bookmarks
	return &bookmarksServiceListResponse, nil
}

type BookmarksServiceListResponse struct {
	bookmarks []Bookmark
}

func (p *BookmarksServiceListResponse) Bookmarks() []Bookmark {
	return p.bookmarks
}

//
// Listing all the available bookmarks.
// Example of listing bookmarks:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmarks>
//   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//     <name>database</name>
//     <value>vm: name=database*</value>
//   </bookmark>
//   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
//     <name>example</name>
//     <value>vm: name=example*</value>
//   </bookmark>
// </bookmarks>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of bookmarks to return. If not specified all the bookmarks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *BookmarksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Bookmark,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bookmarksVar Bookmarks
	xml.Unmarshal([]byte(ovResp.Body), &bookmarksVar)
	return bookmarksVar.Bookmarks, nil
}

//
// A reference to the service managing a specific bookmark.
//
func (op *BookmarksService) BookmarkService(id string) *BookmarkService {
	return NewBookmarkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BookmarksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.BookmarkService(path)), nil
	}
	return op.BookmarkService(path[:index]).Service(path[index+1:])
}

func (op *BookmarksService) String() string {
	return fmt.Sprintf("BookmarksService:%s", op.Path)
}

//
//
type NetworkAttachmentsService struct {
	BaseService
}

func NewNetworkAttachmentsService(connection *Connection, path string) *NetworkAttachmentsService {
	var result NetworkAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkAttachmentsServiceAddRequest struct {
	networkAttachmentsService *NetworkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	attachment                *NetworkAttachment
}

func (p *NetworkAttachmentsServiceAddRequest) Header(key, value string) *NetworkAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentsServiceAddRequest) Query(key, value string) *NetworkAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentsServiceAddRequest) Attachment(attachment *NetworkAttachment) *NetworkAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}
func (p *NetworkAttachmentsServiceAddRequest) Send() (*NetworkAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.Connection.URL(), p.networkAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.attachment)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentsService.Connection.username, p.networkAttachmentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkAttachmentsServiceAddResponse NetworkAttachmentsServiceAddResponse
	var attachmentVar NetworkAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	networkAttachmentsServiceAddResponse.attachment = &attachmentVar
	return &networkAttachmentsServiceAddResponse, nil
}

type NetworkAttachmentsServiceAddResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentsServiceAddResponse) Attachment() *NetworkAttachment {
	return p.attachment
}

//
//
func (op *NetworkAttachmentsService) Add(
	attachment *NetworkAttachment,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(attachment, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentVar NetworkAttachment
	xml.Unmarshal([]byte(ovResp.Body), &attachmentVar)
	return &attachmentVar, nil
}

type NetworkAttachmentsServiceListRequest struct {
	networkAttachmentsService *NetworkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *NetworkAttachmentsServiceListRequest) Header(key, value string) *NetworkAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Query(key, value string) *NetworkAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Max(max int64) *NetworkAttachmentsServiceListRequest {
	p.max = &max
	return p
}
func (p *NetworkAttachmentsServiceListRequest) Send() (*NetworkAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.Connection.URL(), p.networkAttachmentsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentsService.Connection.username, p.networkAttachmentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkAttachmentsServiceListResponse NetworkAttachmentsServiceListResponse
	var attachmentsVar NetworkAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	networkAttachmentsServiceListResponse.attachments = attachmentsVar.NetworkAttachments
	return &networkAttachmentsServiceListResponse, nil
}

type NetworkAttachmentsServiceListResponse struct {
	attachments []NetworkAttachment
}

func (p *NetworkAttachmentsServiceListResponse) Attachments() []NetworkAttachment {
	return p.attachments
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of attachments to return. If not specified all the attachments are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworkAttachmentsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]NetworkAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentsVar NetworkAttachments
	xml.Unmarshal([]byte(ovResp.Body), &attachmentsVar)
	return attachmentsVar.NetworkAttachments, nil
}

//
//
func (op *NetworkAttachmentsService) AttachmentService(id string) *NetworkAttachmentService {
	return NewNetworkAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *NetworkAttachmentsService) String() string {
	return fmt.Sprintf("NetworkAttachmentsService:%s", op.Path)
}

//
//
type OperatingSystemService struct {
	BaseService
}

func NewOperatingSystemService(connection *Connection, path string) *OperatingSystemService {
	var result OperatingSystemService
	result.Connection = connection
	result.Path = path
	return &result
}

type OperatingSystemServiceGetRequest struct {
	operatingSystemService *OperatingSystemService
	header                 map[string]string
	query                  map[string]string
}

func (p *OperatingSystemServiceGetRequest) Header(key, value string) *OperatingSystemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OperatingSystemServiceGetRequest) Query(key, value string) *OperatingSystemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OperatingSystemServiceGetRequest) Send() (*OperatingSystemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemService.Connection.URL(), p.operatingSystemService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.operatingSystemService.Connection.username, p.operatingSystemService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.operatingSystemService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var operatingSystemServiceGetResponse OperatingSystemServiceGetResponse
	var operatingSystemVar OperatingSystemInfo
	xml.Unmarshal(respBodyBytes, &operatingSystemVar)
	operatingSystemServiceGetResponse.operatingSystem = &operatingSystemVar
	return &operatingSystemServiceGetResponse, nil
}

type OperatingSystemServiceGetResponse struct {
	operatingSystem *OperatingSystemInfo
}

func (p *OperatingSystemServiceGetResponse) OperatingSystem() *OperatingSystemInfo {
	return p.operatingSystem
}

//
//
func (op *OperatingSystemService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OperatingSystemInfo,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var operatingSystemVar OperatingSystemInfo
	xml.Unmarshal([]byte(ovResp.Body), &operatingSystemVar)
	return &operatingSystemVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OperatingSystemService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OperatingSystemService) String() string {
	return fmt.Sprintf("OperatingSystemService:%s", op.Path)
}

//
//
type TemplateDisksService struct {
	BaseService
}

func NewTemplateDisksService(connection *Connection, path string) *TemplateDisksService {
	var result TemplateDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDisksServiceListRequest struct {
	templateDisksService *TemplateDisksService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *TemplateDisksServiceListRequest) Header(key, value string) *TemplateDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDisksServiceListRequest) Query(key, value string) *TemplateDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDisksServiceListRequest) Max(max int64) *TemplateDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateDisksServiceListRequest) Send() (*TemplateDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDisksService.Connection.URL(), p.templateDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDisksService.Connection.username, p.templateDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateDisksServiceListResponse TemplateDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	templateDisksServiceListResponse.disks = disksVar.Disks
	return &templateDisksServiceListResponse, nil
}

type TemplateDisksServiceListResponse struct {
	disks []Disk
}

func (p *TemplateDisksServiceListResponse) Disks() []Disk {
	return p.disks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of disks to return. If not specified all the disks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateDisksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var disksVar Disks
	xml.Unmarshal([]byte(ovResp.Body), &disksVar)
	return disksVar.Disks, nil
}

//
//
func (op *TemplateDisksService) DiskService(id string) *TemplateDiskService {
	return NewTemplateDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *TemplateDisksService) String() string {
	return fmt.Sprintf("TemplateDisksService:%s", op.Path)
}

//
// This service doesn't add any new methods, it is just a placeholder for the annotation that specifies the path of the
// resource that manages the permissions assigned to the system object.
//
type SystemPermissionsService struct {
	BaseService
}

func NewSystemPermissionsService(connection *Connection, path string) *SystemPermissionsService {
	var result SystemPermissionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SystemPermissionsServiceAddRequest struct {
	systemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddRequest) Header(key, value string) *SystemPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddRequest) Query(key, value string) *SystemPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddRequest) Permission(permission *Permission) *SystemPermissionsServiceAddRequest {
	p.permission = permission
	return p
}
func (p *SystemPermissionsServiceAddRequest) Send() (*SystemPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.Connection.URL(), p.systemPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.permission)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.systemPermissionsService.Connection.username, p.systemPermissionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var systemPermissionsServiceAddResponse SystemPermissionsServiceAddResponse
	var permissionVar Permission
	xml.Unmarshal(respBodyBytes, &permissionVar)
	systemPermissionsServiceAddResponse.permission = &permissionVar
	return &systemPermissionsServiceAddResponse, nil
}

type SystemPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddResponse) Permission() *Permission {
	return p.permission
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
// This method supports the following parameters:
// `Permission`:: The permission.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SystemPermissionsService) Add(
	permission *Permission,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Permission,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(permission, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permissionVar Permission
	xml.Unmarshal([]byte(ovResp.Body), &permissionVar)
	return &permissionVar, nil
}

type SystemPermissionsServiceListRequest struct {
	systemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
}

func (p *SystemPermissionsServiceListRequest) Header(key, value string) *SystemPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceListRequest) Query(key, value string) *SystemPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceListRequest) Send() (*SystemPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.Connection.URL(), p.systemPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.systemPermissionsService.Connection.username, p.systemPermissionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var systemPermissionsServiceListResponse SystemPermissionsServiceListResponse
	var permissionsVar Permissions
	xml.Unmarshal(respBodyBytes, &permissionsVar)
	systemPermissionsServiceListResponse.permissions = permissionsVar.Permissions
	return &systemPermissionsServiceListResponse, nil
}

type SystemPermissionsServiceListResponse struct {
	permissions []Permission
}

func (p *SystemPermissionsServiceListResponse) Permissions() []Permission {
	return p.permissions
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
//
func (op *SystemPermissionsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Permission,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permissionsVar Permissions
	xml.Unmarshal([]byte(ovResp.Body), &permissionsVar)
	return permissionsVar.Permissions, nil
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *SystemPermissionsService) PermissionService(id string) *PermissionService {
	return NewPermissionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemPermissionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PermissionService(path)), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *SystemPermissionsService) String() string {
	return fmt.Sprintf("SystemPermissionsService:%s", op.Path)
}

//
//
type VmReportedDeviceService struct {
	BaseService
}

func NewVmReportedDeviceService(connection *Connection, path string) *VmReportedDeviceService {
	var result VmReportedDeviceService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmReportedDeviceServiceGetRequest struct {
	vmReportedDeviceService *VmReportedDeviceService
	header                  map[string]string
	query                   map[string]string
}

func (p *VmReportedDeviceServiceGetRequest) Header(key, value string) *VmReportedDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmReportedDeviceServiceGetRequest) Query(key, value string) *VmReportedDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmReportedDeviceServiceGetRequest) Send() (*VmReportedDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDeviceService.Connection.URL(), p.vmReportedDeviceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmReportedDeviceService.Connection.username, p.vmReportedDeviceService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmReportedDeviceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmReportedDeviceServiceGetResponse VmReportedDeviceServiceGetResponse
	var reportedDeviceVar ReportedDevice
	xml.Unmarshal(respBodyBytes, &reportedDeviceVar)
	vmReportedDeviceServiceGetResponse.reportedDevice = &reportedDeviceVar
	return &vmReportedDeviceServiceGetResponse, nil
}

type VmReportedDeviceServiceGetResponse struct {
	reportedDevice *ReportedDevice
}

func (p *VmReportedDeviceServiceGetResponse) ReportedDevice() *ReportedDevice {
	return p.reportedDevice
}

//
//
func (op *VmReportedDeviceService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ReportedDevice,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var reportedDeviceVar ReportedDevice
	xml.Unmarshal([]byte(ovResp.Body), &reportedDeviceVar)
	return &reportedDeviceVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmReportedDeviceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmReportedDeviceService) String() string {
	return fmt.Sprintf("VmReportedDeviceService:%s", op.Path)
}

//
//
type SnapshotNicsService struct {
	BaseService
}

func NewSnapshotNicsService(connection *Connection, path string) *SnapshotNicsService {
	var result SnapshotNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotNicsServiceListRequest struct {
	snapshotNicsService *SnapshotNicsService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *SnapshotNicsServiceListRequest) Header(key, value string) *SnapshotNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotNicsServiceListRequest) Query(key, value string) *SnapshotNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotNicsServiceListRequest) Max(max int64) *SnapshotNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotNicsServiceListRequest) Send() (*SnapshotNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicsService.Connection.URL(), p.snapshotNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotNicsService.Connection.username, p.snapshotNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotNicsServiceListResponse SnapshotNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	snapshotNicsServiceListResponse.nics = nicsVar.Nics
	return &snapshotNicsServiceListResponse, nil
}

type SnapshotNicsServiceListResponse struct {
	nics []Nic
}

func (p *SnapshotNicsServiceListResponse) Nics() []Nic {
	return p.nics
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of NICs to return. If not specified all the NICs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SnapshotNicsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicsVar Nics
	xml.Unmarshal([]byte(ovResp.Body), &nicsVar)
	return nicsVar.Nics, nil
}

//
//
func (op *SnapshotNicsService) NicService(id string) *SnapshotNicService {
	return NewSnapshotNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotNicsService) String() string {
	return fmt.Sprintf("SnapshotNicsService:%s", op.Path)
}

//
//
type AssignedVnicProfilesService struct {
	BaseService
}

func NewAssignedVnicProfilesService(connection *Connection, path string) *AssignedVnicProfilesService {
	var result AssignedVnicProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedVnicProfilesServiceAddRequest struct {
	assignedVnicProfilesService *AssignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *VnicProfile
}

func (p *AssignedVnicProfilesServiceAddRequest) Header(key, value string) *AssignedVnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceAddRequest) Query(key, value string) *AssignedVnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *AssignedVnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *AssignedVnicProfilesServiceAddRequest) Send() (*AssignedVnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.Connection.URL(), p.assignedVnicProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedVnicProfilesService.Connection.username, p.assignedVnicProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedVnicProfilesServiceAddResponse AssignedVnicProfilesServiceAddResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedVnicProfilesServiceAddResponse.profile = &profileVar
	return &assignedVnicProfilesServiceAddResponse, nil
}

type AssignedVnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *AssignedVnicProfilesServiceAddResponse) Profile() *VnicProfile {
	return p.profile
}

//
//
func (op *AssignedVnicProfilesService) Add(
	profile *VnicProfile,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VnicProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar VnicProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type AssignedVnicProfilesServiceListRequest struct {
	assignedVnicProfilesService *AssignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	max                         *int64
}

func (p *AssignedVnicProfilesServiceListRequest) Header(key, value string) *AssignedVnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Query(key, value string) *AssignedVnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Max(max int64) *AssignedVnicProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedVnicProfilesServiceListRequest) Send() (*AssignedVnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.Connection.URL(), p.assignedVnicProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedVnicProfilesService.Connection.username, p.assignedVnicProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedVnicProfilesServiceListResponse AssignedVnicProfilesServiceListResponse
	var profilesVar VnicProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	assignedVnicProfilesServiceListResponse.profiles = profilesVar.VnicProfiles
	return &assignedVnicProfilesServiceListResponse, nil
}

type AssignedVnicProfilesServiceListResponse struct {
	profiles []VnicProfile
}

func (p *AssignedVnicProfilesServiceListResponse) Profiles() []VnicProfile {
	return p.profiles
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of profiles to return. If not specified all the profiles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedVnicProfilesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]VnicProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profilesVar VnicProfiles
	xml.Unmarshal([]byte(ovResp.Body), &profilesVar)
	return profilesVar.VnicProfiles, nil
}

//
//
func (op *AssignedVnicProfilesService) ProfileService(id string) *AssignedVnicProfileService {
	return NewAssignedVnicProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedVnicProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedVnicProfilesService) String() string {
	return fmt.Sprintf("AssignedVnicProfilesService:%s", op.Path)
}

//
//
type QuotaClusterLimitsService struct {
	BaseService
}

func NewQuotaClusterLimitsService(connection *Connection, path string) *QuotaClusterLimitsService {
	var result QuotaClusterLimitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaClusterLimitsServiceAddRequest struct {
	quotaClusterLimitsService *QuotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceAddRequest) Header(key, value string) *QuotaClusterLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceAddRequest) Query(key, value string) *QuotaClusterLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceAddRequest) Limit(limit *QuotaClusterLimit) *QuotaClusterLimitsServiceAddRequest {
	p.limit = limit
	return p
}
func (p *QuotaClusterLimitsServiceAddRequest) Send() (*QuotaClusterLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.Connection.URL(), p.quotaClusterLimitsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.limit)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaClusterLimitsService.Connection.username, p.quotaClusterLimitsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotaClusterLimitsServiceAddResponse QuotaClusterLimitsServiceAddResponse
	var limitVar QuotaClusterLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaClusterLimitsServiceAddResponse.limit = &limitVar
	return &quotaClusterLimitsServiceAddResponse, nil
}

type QuotaClusterLimitsServiceAddResponse struct {
	limit *QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceAddResponse) Limit() *QuotaClusterLimit {
	return p.limit
}

//
//
func (op *QuotaClusterLimitsService) Add(
	limit *QuotaClusterLimit,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*QuotaClusterLimit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(limit, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var limitVar QuotaClusterLimit
	xml.Unmarshal([]byte(ovResp.Body), &limitVar)
	return &limitVar, nil
}

type QuotaClusterLimitsServiceListRequest struct {
	quotaClusterLimitsService *QuotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *QuotaClusterLimitsServiceListRequest) Header(key, value string) *QuotaClusterLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Query(key, value string) *QuotaClusterLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Max(max int64) *QuotaClusterLimitsServiceListRequest {
	p.max = &max
	return p
}
func (p *QuotaClusterLimitsServiceListRequest) Send() (*QuotaClusterLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.Connection.URL(), p.quotaClusterLimitsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaClusterLimitsService.Connection.username, p.quotaClusterLimitsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotaClusterLimitsServiceListResponse QuotaClusterLimitsServiceListResponse
	var limitsVar QuotaClusterLimits
	xml.Unmarshal(respBodyBytes, &limitsVar)
	quotaClusterLimitsServiceListResponse.limits = limitsVar.QuotaClusterLimits
	return &quotaClusterLimitsServiceListResponse, nil
}

type QuotaClusterLimitsServiceListResponse struct {
	limits []QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceListResponse) Limits() []QuotaClusterLimit {
	return p.limits
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of limits to return. If not specified all the limits are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QuotaClusterLimitsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]QuotaClusterLimit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var limitsVar QuotaClusterLimits
	xml.Unmarshal([]byte(ovResp.Body), &limitsVar)
	return limitsVar.QuotaClusterLimits, nil
}

//
//
func (op *QuotaClusterLimitsService) LimitService(id string) *QuotaClusterLimitService {
	return NewQuotaClusterLimitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaClusterLimitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LimitService(path)), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *QuotaClusterLimitsService) String() string {
	return fmt.Sprintf("QuotaClusterLimitsService:%s", op.Path)
}

//
// Manages logical networks.
// The engine creates a default `ovirtmgmt` network on installation. This network acts as the management network for
// access to hypervisor hosts. This network is associated with the `Default` cluster and is a member of the `Default`
// data center.
//
type NetworksService struct {
	BaseService
}

func NewNetworksService(connection *Connection, path string) *NetworksService {
	var result NetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworksServiceAddRequest struct {
	networksService *NetworksService
	header          map[string]string
	query           map[string]string
	network         *Network
}

func (p *NetworksServiceAddRequest) Header(key, value string) *NetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworksServiceAddRequest) Query(key, value string) *NetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworksServiceAddRequest) Network(network *Network) *NetworksServiceAddRequest {
	p.network = network
	return p
}
func (p *NetworksServiceAddRequest) Send() (*NetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networksService.Connection.URL(), p.networksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networksService.Connection.username, p.networksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networksServiceAddResponse NetworksServiceAddResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	networksServiceAddResponse.network = &networkVar
	return &networksServiceAddResponse, nil
}

type NetworksServiceAddResponse struct {
	network *Network
}

func (p *NetworksServiceAddResponse) Network() *Network {
	return p.network
}

//
// Creates a new logical network, or associates an existing network with a data center.
// Creation of a new network requires the `name` and `data_center` elements.
// For example, to create a network named `mynetwork` for data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
//   <data_center id="123"/>
// </network>
// ----
// To associate the existing network `456` with the data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>ovirtmgmt</name>
// </network>
// ----
//
func (op *NetworksService) Add(
	network *Network,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(network, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type NetworksServiceListRequest struct {
	networksService *NetworksService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	max             *int64
	search          *string
}

func (p *NetworksServiceListRequest) Header(key, value string) *NetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworksServiceListRequest) Query(key, value string) *NetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworksServiceListRequest) CaseSensitive(caseSensitive bool) *NetworksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *NetworksServiceListRequest) Max(max int64) *NetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *NetworksServiceListRequest) Search(search string) *NetworksServiceListRequest {
	p.search = &search
	return p
}
func (p *NetworksServiceListRequest) Send() (*NetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networksService.Connection.URL(), p.networksService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networksService.Connection.username, p.networksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networksServiceListResponse NetworksServiceListResponse
	var networksVar Networks
	xml.Unmarshal(respBodyBytes, &networksVar)
	networksServiceListResponse.networks = networksVar.Networks
	return &networksServiceListResponse, nil
}

type NetworksServiceListResponse struct {
	networks []Network
}

func (p *NetworksServiceListResponse) Networks() []Network {
	return p.networks
}

//
// List logical networks.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks
// ----
// Will respond:
// [source,xml]
// ----
// <networks>
//   <network href="/ovirt-engine/api/networks/123" id="123">
//     <name>ovirtmgmt</name>
//     <description>Default Management Network</description>
//     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//     <mtu>0</mtu>
//     <stp>false</stp>
//     <usages>
//       <usage>vm</usage>
//     </usages>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </network>
//   ...
// </networks>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of networks to return. If not specified all the networks are returned.
// `Search`:: A query string used to restrict the returned networks.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworksService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networksVar Networks
	xml.Unmarshal([]byte(ovResp.Body), &networksVar)
	return networksVar.Networks, nil
}

//
// Reference to the service that manages a specific network.
//
func (op *NetworksService) NetworkService(id string) *NetworkService {
	return NewNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *NetworksService) String() string {
	return fmt.Sprintf("NetworksService:%s", op.Path)
}

//
// The affinity groups service manages virtual machine relationships and dependencies.
//
type AffinityGroupsService struct {
	BaseService
}

func NewAffinityGroupsService(connection *Connection, path string) *AffinityGroupsService {
	var result AffinityGroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupsServiceAddRequest struct {
	affinityGroupsService *AffinityGroupsService
	header                map[string]string
	query                 map[string]string
	group                 *AffinityGroup
}

func (p *AffinityGroupsServiceAddRequest) Header(key, value string) *AffinityGroupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupsServiceAddRequest) Query(key, value string) *AffinityGroupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupsServiceAddRequest) Group(group *AffinityGroup) *AffinityGroupsServiceAddRequest {
	p.group = group
	return p
}
func (p *AffinityGroupsServiceAddRequest) Send() (*AffinityGroupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.Connection.URL(), p.affinityGroupsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.group)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupsService.Connection.username, p.affinityGroupsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityGroupsServiceAddResponse AffinityGroupsServiceAddResponse
	var groupVar AffinityGroup
	xml.Unmarshal(respBodyBytes, &groupVar)
	affinityGroupsServiceAddResponse.group = &groupVar
	return &affinityGroupsServiceAddResponse, nil
}

type AffinityGroupsServiceAddResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupsServiceAddResponse) Group() *AffinityGroup {
	return p.group
}

//
// Create a new affinity group.
// Post a request like in the example below to create a new affinity group:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups
// ----
// And use the following example in its body:
// [source,xml]
// ----
// <affinity_group>
//   <name>AF_GROUP_001</name>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
// This method supports the following parameters:
// `Group`:: The affinity group object to create.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AffinityGroupsService) Add(
	group *AffinityGroup,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityGroup,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(group, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupVar AffinityGroup
	xml.Unmarshal([]byte(ovResp.Body), &groupVar)
	return &groupVar, nil
}

type AffinityGroupsServiceListRequest struct {
	affinityGroupsService *AffinityGroupsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *AffinityGroupsServiceListRequest) Header(key, value string) *AffinityGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupsServiceListRequest) Query(key, value string) *AffinityGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupsServiceListRequest) Max(max int64) *AffinityGroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *AffinityGroupsServiceListRequest) Send() (*AffinityGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.Connection.URL(), p.affinityGroupsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupsService.Connection.username, p.affinityGroupsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityGroupsServiceListResponse AffinityGroupsServiceListResponse
	var groupsVar AffinityGroups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	affinityGroupsServiceListResponse.groups = groupsVar.AffinityGroups
	return &affinityGroupsServiceListResponse, nil
}

type AffinityGroupsServiceListResponse struct {
	groups []AffinityGroup
}

func (p *AffinityGroupsServiceListResponse) Groups() []AffinityGroup {
	return p.groups
}

//
// List existing affinity groups.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of affinity groups to return. If not specified all the affinity groups are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AffinityGroupsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]AffinityGroup,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupsVar AffinityGroups
	xml.Unmarshal([]byte(ovResp.Body), &groupsVar)
	return groupsVar.AffinityGroups, nil
}

//
// Access the affinity group service that manages the affinity group specified by an ID.
//
func (op *AffinityGroupsService) GroupService(id string) *AffinityGroupService {
	return NewAffinityGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupsService) String() string {
	return fmt.Sprintf("AffinityGroupsService:%s", op.Path)
}

//
//
type DiskSnapshotService struct {
	BaseService
}

func NewDiskSnapshotService(connection *Connection, path string) *DiskSnapshotService {
	var result DiskSnapshotService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskSnapshotServiceGetRequest struct {
	diskSnapshotService *DiskSnapshotService
	header              map[string]string
	query               map[string]string
}

func (p *DiskSnapshotServiceGetRequest) Header(key, value string) *DiskSnapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotServiceGetRequest) Query(key, value string) *DiskSnapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotServiceGetRequest) Send() (*DiskSnapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotService.Connection.URL(), p.diskSnapshotService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskSnapshotService.Connection.username, p.diskSnapshotService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskSnapshotService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskSnapshotServiceGetResponse DiskSnapshotServiceGetResponse
	var snapshotVar DiskSnapshot
	xml.Unmarshal(respBodyBytes, &snapshotVar)
	diskSnapshotServiceGetResponse.snapshot = &snapshotVar
	return &diskSnapshotServiceGetResponse, nil
}

type DiskSnapshotServiceGetResponse struct {
	snapshot *DiskSnapshot
}

func (p *DiskSnapshotServiceGetResponse) Snapshot() *DiskSnapshot {
	return p.snapshot
}

//
//
func (op *DiskSnapshotService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskSnapshot,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var snapshotVar DiskSnapshot
	xml.Unmarshal([]byte(ovResp.Body), &snapshotVar)
	return &snapshotVar, nil
}

type DiskSnapshotServiceRemoveRequest struct {
	diskSnapshotService *DiskSnapshotService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *DiskSnapshotServiceRemoveRequest) Header(key, value string) *DiskSnapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotServiceRemoveRequest) Query(key, value string) *DiskSnapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotServiceRemoveRequest) Async(async bool) *DiskSnapshotServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DiskSnapshotServiceRemoveRequest) Send() (*DiskSnapshotServiceRemoveResponse, error) {
}

type DiskSnapshotServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskSnapshotService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskSnapshotService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskSnapshotService) String() string {
	return fmt.Sprintf("DiskSnapshotService:%s", op.Path)
}

//
//
type SchedulingPolicyService struct {
	BaseService
}

func NewSchedulingPolicyService(connection *Connection, path string) *SchedulingPolicyService {
	var result SchedulingPolicyService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPolicyServiceGetRequest struct {
	schedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	filter                  *bool
}

func (p *SchedulingPolicyServiceGetRequest) Header(key, value string) *SchedulingPolicyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Query(key, value string) *SchedulingPolicyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Filter(filter bool) *SchedulingPolicyServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPolicyServiceGetRequest) Send() (*SchedulingPolicyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.Connection.URL(), p.schedulingPolicyService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyService.Connection.username, p.schedulingPolicyService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var schedulingPolicyServiceGetResponse SchedulingPolicyServiceGetResponse
	var policyVar SchedulingPolicy
	xml.Unmarshal(respBodyBytes, &policyVar)
	schedulingPolicyServiceGetResponse.policy = &policyVar
	return &schedulingPolicyServiceGetResponse, nil
}

type SchedulingPolicyServiceGetResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPolicyServiceGetResponse) Policy() *SchedulingPolicy {
	return p.policy
}

//
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SchedulingPolicyService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*SchedulingPolicy,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var policyVar SchedulingPolicy
	xml.Unmarshal([]byte(ovResp.Body), &policyVar)
	return &policyVar, nil
}

type SchedulingPolicyServiceRemoveRequest struct {
	schedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *SchedulingPolicyServiceRemoveRequest) Header(key, value string) *SchedulingPolicyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceRemoveRequest) Query(key, value string) *SchedulingPolicyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceRemoveRequest) Async(async bool) *SchedulingPolicyServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SchedulingPolicyServiceRemoveRequest) Send() (*SchedulingPolicyServiceRemoveResponse, error) {
}

type SchedulingPolicyServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SchedulingPolicyService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type SchedulingPolicyServiceUpdateRequest struct {
	schedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	policy                  *SchedulingPolicy
}

func (p *SchedulingPolicyServiceUpdateRequest) Header(key, value string) *SchedulingPolicyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Query(key, value string) *SchedulingPolicyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Async(async bool) *SchedulingPolicyServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *SchedulingPolicyServiceUpdateRequest) Policy(policy *SchedulingPolicy) *SchedulingPolicyServiceUpdateRequest {
	p.policy = policy
	return p
}
func (p *SchedulingPolicyServiceUpdateRequest) Send() (*SchedulingPolicyServiceUpdateResponse, error) {
}

type SchedulingPolicyServiceUpdateResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPolicyServiceUpdateResponse) Policy() *SchedulingPolicy {
	return p.policy
}

//
//
func (op *SchedulingPolicyService) Update(
	policy *SchedulingPolicy,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*SchedulingPolicy,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(policy, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var policyVar SchedulingPolicy
	xml.Unmarshal([]byte(ovResp.Body), &policyVar)
	return &policyVar, nil
}

//
//
func (op *SchedulingPolicyService) BalancesService() *BalancesService {
	return NewBalancesService(op.Connection, fmt.Sprintf("%s/balances", op.Path))
}

//
//
func (op *SchedulingPolicyService) FiltersService() *FiltersService {
	return NewFiltersService(op.Connection, fmt.Sprintf("%s/filters", op.Path))
}

//
//
func (op *SchedulingPolicyService) WeightsService() *WeightsService {
	return NewWeightsService(op.Connection, fmt.Sprintf("%s/weights", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "balances" {
		return op.BalancesService(), nil
	}
	if strings.HasPrefix(path, "balances/") {
		return op.BalancesService().Service(path[9:])
	}
	if path == "filters" {
		return op.FiltersService(), nil
	}
	if strings.HasPrefix(path, "filters/") {
		return op.FiltersService().Service(path[8:])
	}
	if path == "weights" {
		return op.WeightsService(), nil
	}
	if strings.HasPrefix(path, "weights/") {
		return op.WeightsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SchedulingPolicyService) String() string {
	return fmt.Sprintf("SchedulingPolicyService:%s", op.Path)
}

//
//
type NetworkAttachmentService struct {
	BaseService
}

func NewNetworkAttachmentService(connection *Connection, path string) *NetworkAttachmentService {
	var result NetworkAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkAttachmentServiceGetRequest struct {
	networkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
}

func (p *NetworkAttachmentServiceGetRequest) Header(key, value string) *NetworkAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceGetRequest) Query(key, value string) *NetworkAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceGetRequest) Send() (*NetworkAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.Connection.URL(), p.networkAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkAttachmentService.Connection.username, p.networkAttachmentService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkAttachmentServiceGetResponse NetworkAttachmentServiceGetResponse
	var attachmentVar NetworkAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	networkAttachmentServiceGetResponse.attachment = &attachmentVar
	return &networkAttachmentServiceGetResponse, nil
}

type NetworkAttachmentServiceGetResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentServiceGetResponse) Attachment() *NetworkAttachment {
	return p.attachment
}

//
//
func (op *NetworkAttachmentService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentVar NetworkAttachment
	xml.Unmarshal([]byte(ovResp.Body), &attachmentVar)
	return &attachmentVar, nil
}

type NetworkAttachmentServiceRemoveRequest struct {
	networkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *NetworkAttachmentServiceRemoveRequest) Header(key, value string) *NetworkAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceRemoveRequest) Query(key, value string) *NetworkAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceRemoveRequest) Async(async bool) *NetworkAttachmentServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *NetworkAttachmentServiceRemoveRequest) Send() (*NetworkAttachmentServiceRemoveResponse, error) {
}

type NetworkAttachmentServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworkAttachmentService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type NetworkAttachmentServiceUpdateRequest struct {
	networkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	attachment               *NetworkAttachment
}

func (p *NetworkAttachmentServiceUpdateRequest) Header(key, value string) *NetworkAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Query(key, value string) *NetworkAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Async(async bool) *NetworkAttachmentServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *NetworkAttachmentServiceUpdateRequest) Attachment(attachment *NetworkAttachment) *NetworkAttachmentServiceUpdateRequest {
	p.attachment = attachment
	return p
}
func (p *NetworkAttachmentServiceUpdateRequest) Send() (*NetworkAttachmentServiceUpdateResponse, error) {
}

type NetworkAttachmentServiceUpdateResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentServiceUpdateResponse) Attachment() *NetworkAttachment {
	return p.attachment
}

//
//
func (op *NetworkAttachmentService) Update(
	attachment *NetworkAttachment,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(attachment, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentVar NetworkAttachment
	xml.Unmarshal([]byte(ovResp.Body), &attachmentVar)
	return &attachmentVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkAttachmentService) String() string {
	return fmt.Sprintf("NetworkAttachmentService:%s", op.Path)
}

//
//
type DiskProfilesService struct {
	BaseService
}

func NewDiskProfilesService(connection *Connection, path string) *DiskProfilesService {
	var result DiskProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskProfilesServiceAddRequest struct {
	diskProfilesService *DiskProfilesService
	header              map[string]string
	query               map[string]string
	profile             *DiskProfile
}

func (p *DiskProfilesServiceAddRequest) Header(key, value string) *DiskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfilesServiceAddRequest) Query(key, value string) *DiskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfilesServiceAddRequest) Profile(profile *DiskProfile) *DiskProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *DiskProfilesServiceAddRequest) Send() (*DiskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.Connection.URL(), p.diskProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfilesService.Connection.username, p.diskProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskProfilesServiceAddResponse DiskProfilesServiceAddResponse
	var profileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	diskProfilesServiceAddResponse.profile = &profileVar
	return &diskProfilesServiceAddResponse, nil
}

type DiskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *DiskProfilesServiceAddResponse) Profile() *DiskProfile {
	return p.profile
}

//
//
func (op *DiskProfilesService) Add(
	profile *DiskProfile,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar DiskProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type DiskProfilesServiceListRequest struct {
	diskProfilesService *DiskProfilesService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *DiskProfilesServiceListRequest) Header(key, value string) *DiskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfilesServiceListRequest) Query(key, value string) *DiskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfilesServiceListRequest) Max(max int64) *DiskProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *DiskProfilesServiceListRequest) Send() (*DiskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.Connection.URL(), p.diskProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfilesService.Connection.username, p.diskProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskProfilesServiceListResponse DiskProfilesServiceListResponse
	var profileVar DiskProfiles
	xml.Unmarshal(respBodyBytes, &profileVar)
	diskProfilesServiceListResponse.profile = profileVar.DiskProfiles
	return &diskProfilesServiceListResponse, nil
}

type DiskProfilesServiceListResponse struct {
	profile []DiskProfile
}

func (p *DiskProfilesServiceListResponse) Profile() []DiskProfile {
	return p.profile
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of profiles to return. If not specified all the profiles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskProfilesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]DiskProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar DiskProfiles
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return profileVar.DiskProfiles, nil
}

//
//
func (op *DiskProfilesService) DiskProfileService(id string) *DiskProfileService {
	return NewDiskProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskProfileService(path)), nil
	}
	return op.DiskProfileService(path[:index]).Service(path[index+1:])
}

func (op *DiskProfilesService) String() string {
	return fmt.Sprintf("DiskProfilesService:%s", op.Path)
}

//
// A service to manage an icon (read-only).
//
type IconService struct {
	BaseService
}

func NewIconService(connection *Connection, path string) *IconService {
	var result IconService
	result.Connection = connection
	result.Path = path
	return &result
}

type IconServiceGetRequest struct {
	iconService *IconService
	header      map[string]string
	query       map[string]string
}

func (p *IconServiceGetRequest) Header(key, value string) *IconServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IconServiceGetRequest) Query(key, value string) *IconServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IconServiceGetRequest) Send() (*IconServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iconService.Connection.URL(), p.iconService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iconService.Connection.username, p.iconService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iconService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var iconServiceGetResponse IconServiceGetResponse
	var iconVar Icon
	xml.Unmarshal(respBodyBytes, &iconVar)
	iconServiceGetResponse.icon = &iconVar
	return &iconServiceGetResponse, nil
}

type IconServiceGetResponse struct {
	icon *Icon
}

func (p *IconServiceGetResponse) Icon() *Icon {
	return p.icon
}

//
// Get an icon.
// [source]
// ----
// GET /ovirt-engine/api/icons/123
// ----
// You will get a XML response like this one:
// [source,xml]
// ----
// <icon id="123">
//   <data>Some binary data here</data>
//   <media_type>image/png</media_type>
// </icon>
// ----
//
func (op *IconService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Icon,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var iconVar Icon
	xml.Unmarshal([]byte(ovResp.Body), &iconVar)
	return &iconVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IconService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *IconService) String() string {
	return fmt.Sprintf("IconService:%s", op.Path)
}

//
// This service represents one label to entity assignment
// when accessed using the entities/affinitylabels subcollection.
//
type AssignedAffinityLabelService struct {
	BaseService
}

func NewAssignedAffinityLabelService(connection *Connection, path string) *AssignedAffinityLabelService {
	var result AssignedAffinityLabelService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedAffinityLabelServiceGetRequest struct {
	assignedAffinityLabelService *AssignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
}

func (p *AssignedAffinityLabelServiceGetRequest) Header(key, value string) *AssignedAffinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceGetRequest) Query(key, value string) *AssignedAffinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceGetRequest) Send() (*AssignedAffinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelService.Connection.URL(), p.assignedAffinityLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedAffinityLabelService.Connection.username, p.assignedAffinityLabelService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedAffinityLabelServiceGetResponse AssignedAffinityLabelServiceGetResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	assignedAffinityLabelServiceGetResponse.label = &labelVar
	return &assignedAffinityLabelServiceGetResponse, nil
}

type AssignedAffinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *AssignedAffinityLabelServiceGetResponse) Label() *AffinityLabel {
	return p.label
}

//
// Retrieves details about the attached label.
//
func (op *AssignedAffinityLabelService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar AffinityLabel
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return &labelVar, nil
}

type AssignedAffinityLabelServiceRemoveRequest struct {
	assignedAffinityLabelService *AssignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Header(key, value string) *AssignedAffinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Query(key, value string) *AssignedAffinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Send() (*AssignedAffinityLabelServiceRemoveResponse, error) {
}

type AssignedAffinityLabelServiceRemoveResponse struct {
}

//
// Removes the label from an entity. Does not touch the label itself.
//
func (op *AssignedAffinityLabelService) Remove(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedAffinityLabelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedAffinityLabelService) String() string {
	return fmt.Sprintf("AssignedAffinityLabelService:%s", op.Path)
}

//
//
type CpuProfilesService struct {
	BaseService
}

func NewCpuProfilesService(connection *Connection, path string) *CpuProfilesService {
	var result CpuProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type CpuProfilesServiceAddRequest struct {
	cpuProfilesService *CpuProfilesService
	header             map[string]string
	query              map[string]string
	profile            *CpuProfile
}

func (p *CpuProfilesServiceAddRequest) Header(key, value string) *CpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfilesServiceAddRequest) Query(key, value string) *CpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *CpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *CpuProfilesServiceAddRequest) Send() (*CpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.Connection.URL(), p.cpuProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfilesService.Connection.username, p.cpuProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var cpuProfilesServiceAddResponse CpuProfilesServiceAddResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	cpuProfilesServiceAddResponse.profile = &profileVar
	return &cpuProfilesServiceAddResponse, nil
}

type CpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *CpuProfilesServiceAddResponse) Profile() *CpuProfile {
	return p.profile
}

//
//
func (op *CpuProfilesService) Add(
	profile *CpuProfile,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*CpuProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar CpuProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type CpuProfilesServiceListRequest struct {
	cpuProfilesService *CpuProfilesService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *CpuProfilesServiceListRequest) Header(key, value string) *CpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfilesServiceListRequest) Query(key, value string) *CpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfilesServiceListRequest) Max(max int64) *CpuProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *CpuProfilesServiceListRequest) Send() (*CpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.Connection.URL(), p.cpuProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfilesService.Connection.username, p.cpuProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var cpuProfilesServiceListResponse CpuProfilesServiceListResponse
	var profileVar CpuProfiles
	xml.Unmarshal(respBodyBytes, &profileVar)
	cpuProfilesServiceListResponse.profile = profileVar.CpuProfiles
	return &cpuProfilesServiceListResponse, nil
}

type CpuProfilesServiceListResponse struct {
	profile []CpuProfile
}

func (p *CpuProfilesServiceListResponse) Profile() []CpuProfile {
	return p.profile
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of profiles to return. If not specified all the profiles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *CpuProfilesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]CpuProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar CpuProfiles
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return profileVar.CpuProfiles, nil
}

//
//
func (op *CpuProfilesService) ProfileService(id string) *CpuProfileService {
	return NewCpuProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CpuProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *CpuProfilesService) String() string {
	return fmt.Sprintf("CpuProfilesService:%s", op.Path)
}

//
//
type MacPoolsService struct {
	BaseService
}

func NewMacPoolsService(connection *Connection, path string) *MacPoolsService {
	var result MacPoolsService
	result.Connection = connection
	result.Path = path
	return &result
}

type MacPoolsServiceAddRequest struct {
	macPoolsService *MacPoolsService
	header          map[string]string
	query           map[string]string
	pool            *MacPool
}

func (p *MacPoolsServiceAddRequest) Header(key, value string) *MacPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolsServiceAddRequest) Query(key, value string) *MacPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolsServiceAddRequest) Pool(pool *MacPool) *MacPoolsServiceAddRequest {
	p.pool = pool
	return p
}
func (p *MacPoolsServiceAddRequest) Send() (*MacPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.Connection.URL(), p.macPoolsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.pool)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolsService.Connection.username, p.macPoolsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var macPoolsServiceAddResponse MacPoolsServiceAddResponse
	var poolVar MacPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	macPoolsServiceAddResponse.pool = &poolVar
	return &macPoolsServiceAddResponse, nil
}

type MacPoolsServiceAddResponse struct {
	pool *MacPool
}

func (p *MacPoolsServiceAddResponse) Pool() *MacPool {
	return p.pool
}

//
// Creates a new MAC address pool.
// Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
// For example, to create MAC address pool send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/macpools
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>MACPool</name>
//   <description>A MAC address pool</description>
//   <allow_duplicates>true</allow_duplicates>
//   <default_pool>false</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
func (op *MacPoolsService) Add(
	pool *MacPool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*MacPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(pool, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolVar MacPool
	xml.Unmarshal([]byte(ovResp.Body), &poolVar)
	return &poolVar, nil
}

type MacPoolsServiceListRequest struct {
	macPoolsService *MacPoolsService
	header          map[string]string
	query           map[string]string
	max             *int64
}

func (p *MacPoolsServiceListRequest) Header(key, value string) *MacPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolsServiceListRequest) Query(key, value string) *MacPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolsServiceListRequest) Max(max int64) *MacPoolsServiceListRequest {
	p.max = &max
	return p
}
func (p *MacPoolsServiceListRequest) Send() (*MacPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.Connection.URL(), p.macPoolsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolsService.Connection.username, p.macPoolsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var macPoolsServiceListResponse MacPoolsServiceListResponse
	var poolsVar MacPools
	xml.Unmarshal(respBodyBytes, &poolsVar)
	macPoolsServiceListResponse.pools = poolsVar.MacPools
	return &macPoolsServiceListResponse, nil
}

type MacPoolsServiceListResponse struct {
	pools []MacPool
}

func (p *MacPoolsServiceListResponse) Pools() []MacPool {
	return p.pools
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of pools to return. If not specified all the pools are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *MacPoolsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]MacPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolsVar MacPools
	xml.Unmarshal([]byte(ovResp.Body), &poolsVar)
	return poolsVar.MacPools, nil
}

//
//
func (op *MacPoolsService) MacPoolService(id string) *MacPoolService {
	return NewMacPoolService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MacPoolsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.MacPoolService(path)), nil
	}
	return op.MacPoolService(path[:index]).Service(path[index+1:])
}

func (op *MacPoolsService) String() string {
	return fmt.Sprintf("MacPoolsService:%s", op.Path)
}

//
// This service manages a collection of all the virtual machines assigned to an affinity group.
//
type AffinityGroupVmsService struct {
	BaseService
}

func NewAffinityGroupVmsService(connection *Connection, path string) *AffinityGroupVmsService {
	var result AffinityGroupVmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupVmsServiceAddRequest struct {
	affinityGroupVmsService *AffinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *AffinityGroupVmsServiceAddRequest) Header(key, value string) *AffinityGroupVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmsServiceAddRequest) Query(key, value string) *AffinityGroupVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmsServiceAddRequest) Vm(vm *Vm) *AffinityGroupVmsServiceAddRequest {
	p.vm = vm
	return p
}
func (p *AffinityGroupVmsServiceAddRequest) Send() (*AffinityGroupVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.Connection.URL(), p.affinityGroupVmsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.vm)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupVmsService.Connection.username, p.affinityGroupVmsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityGroupVmsServiceAddResponse AffinityGroupVmsServiceAddResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	affinityGroupVmsServiceAddResponse.vm = &vmVar
	return &affinityGroupVmsServiceAddResponse, nil
}

type AffinityGroupVmsServiceAddResponse struct {
	vm *Vm
}

func (p *AffinityGroupVmsServiceAddResponse) Vm() *Vm {
	return p.vm
}

//
// Add a virtual machine to the affinity group.
// For example, to add the virtual machine 000-000 to affinity group 123-456 send a request to:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups/123-456/vms
// ----
// With the following body:
// [source,xml]
// ----
// <vm id="000-000"/>
// ----
//
func (op *AffinityGroupVmsService) Add(
	vm *Vm,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(vm, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vm
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return &vmVar, nil
}

type AffinityGroupVmsServiceListRequest struct {
	affinityGroupVmsService *AffinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *AffinityGroupVmsServiceListRequest) Header(key, value string) *AffinityGroupVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Query(key, value string) *AffinityGroupVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Max(max int64) *AffinityGroupVmsServiceListRequest {
	p.max = &max
	return p
}
func (p *AffinityGroupVmsServiceListRequest) Send() (*AffinityGroupVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.Connection.URL(), p.affinityGroupVmsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupVmsService.Connection.username, p.affinityGroupVmsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityGroupVmsServiceListResponse AffinityGroupVmsServiceListResponse
	var vmsVar Vms
	xml.Unmarshal(respBodyBytes, &vmsVar)
	affinityGroupVmsServiceListResponse.vms = vmsVar.Vms
	return &affinityGroupVmsServiceListResponse, nil
}

type AffinityGroupVmsServiceListResponse struct {
	vms []Vm
}

func (p *AffinityGroupVmsServiceListResponse) Vms() []Vm {
	return p.vms
}

//
// List all virtual machines assigned to this affinity group.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of virtual machines to return. If not specified, all the virtual machines are
// returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AffinityGroupVmsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmsVar Vms
	xml.Unmarshal([]byte(ovResp.Body), &vmsVar)
	return vmsVar.Vms, nil
}

//
// Access the service that manages the virtual machine assignment to this affinity group.
//
func (op *AffinityGroupVmsService) VmService(id string) *AffinityGroupVmService {
	return NewAffinityGroupVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupVmsService) String() string {
	return fmt.Sprintf("AffinityGroupVmsService:%s", op.Path)
}

//
//
type QosService struct {
	BaseService
}

func NewQosService(connection *Connection, path string) *QosService {
	var result QosService
	result.Connection = connection
	result.Path = path
	return &result
}

type QosServiceGetRequest struct {
	qosService *QosService
	header     map[string]string
	query      map[string]string
}

func (p *QosServiceGetRequest) Header(key, value string) *QosServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceGetRequest) Query(key, value string) *QosServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceGetRequest) Send() (*QosServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qosService.Connection.URL(), p.qosService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qosService.Connection.username, p.qosService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qosService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var qosServiceGetResponse QosServiceGetResponse
	var qosVar Qos
	xml.Unmarshal(respBodyBytes, &qosVar)
	qosServiceGetResponse.qos = &qosVar
	return &qosServiceGetResponse, nil
}

type QosServiceGetResponse struct {
	qos *Qos
}

func (p *QosServiceGetResponse) Qos() *Qos {
	return p.qos
}

//
//
func (op *QosService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Qos,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var qosVar Qos
	xml.Unmarshal([]byte(ovResp.Body), &qosVar)
	return &qosVar, nil
}

type QosServiceRemoveRequest struct {
	qosService *QosService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *QosServiceRemoveRequest) Header(key, value string) *QosServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceRemoveRequest) Query(key, value string) *QosServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceRemoveRequest) Async(async bool) *QosServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QosServiceRemoveRequest) Send() (*QosServiceRemoveResponse, error) {
}

type QosServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QosService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type QosServiceUpdateRequest struct {
	qosService *QosService
	header     map[string]string
	query      map[string]string
	async      *bool
	qos        *Qos
}

func (p *QosServiceUpdateRequest) Header(key, value string) *QosServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceUpdateRequest) Query(key, value string) *QosServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceUpdateRequest) Async(async bool) *QosServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *QosServiceUpdateRequest) Qos(qos *Qos) *QosServiceUpdateRequest {
	p.qos = qos
	return p
}
func (p *QosServiceUpdateRequest) Send() (*QosServiceUpdateResponse, error) {
}

type QosServiceUpdateResponse struct {
	qos *Qos
}

func (p *QosServiceUpdateResponse) Qos() *Qos {
	return p.qos
}

//
//
func (op *QosService) Update(
	qos *Qos,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Qos,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(qos, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var qosVar Qos
	xml.Unmarshal([]byte(ovResp.Body), &qosVar)
	return &qosVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QosService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QosService) String() string {
	return fmt.Sprintf("QosService:%s", op.Path)
}

//
// Represents a service to manage collection of the tags in the system.
//
type TagsService struct {
	BaseService
}

func NewTagsService(connection *Connection, path string) *TagsService {
	var result TagsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TagsServiceAddRequest struct {
	tagsService *TagsService
	header      map[string]string
	query       map[string]string
	tag         *Tag
}

func (p *TagsServiceAddRequest) Header(key, value string) *TagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagsServiceAddRequest) Query(key, value string) *TagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagsServiceAddRequest) Tag(tag *Tag) *TagsServiceAddRequest {
	p.tag = tag
	return p
}
func (p *TagsServiceAddRequest) Send() (*TagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.Connection.URL(), p.tagsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.tag)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagsService.Connection.username, p.tagsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var tagsServiceAddResponse TagsServiceAddResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	tagsServiceAddResponse.tag = &tagVar
	return &tagsServiceAddResponse, nil
}

type TagsServiceAddResponse struct {
	tag *Tag
}

func (p *TagsServiceAddResponse) Tag() *Tag {
	return p.tag
}

//
// Add a new tag to the system.
// For example, to add new tag with name `mytag` to the system send a request like this:
// ....
// POST /ovirt-engine/api/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
// The root tag cannot be deleted nor assigned a parent tag.
// To create new tag with specific parent tag send a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
//   <parent>
//     <name>myparenttag</name>
//   </parent>
// </tag>
// ----
// This method supports the following parameters:
// `Tag`:: The added tag.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TagsService) Add(
	tag *Tag,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Tag,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(tag, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var tagVar Tag
	xml.Unmarshal([]byte(ovResp.Body), &tagVar)
	return &tagVar, nil
}

type TagsServiceListRequest struct {
	tagsService *TagsService
	header      map[string]string
	query       map[string]string
	max         *int64
}

func (p *TagsServiceListRequest) Header(key, value string) *TagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagsServiceListRequest) Query(key, value string) *TagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagsServiceListRequest) Max(max int64) *TagsServiceListRequest {
	p.max = &max
	return p
}
func (p *TagsServiceListRequest) Send() (*TagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.Connection.URL(), p.tagsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagsService.Connection.username, p.tagsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var tagsServiceListResponse TagsServiceListResponse
	var tagsVar Tags
	xml.Unmarshal(respBodyBytes, &tagsVar)
	tagsServiceListResponse.tags = tagsVar.Tags
	return &tagsServiceListResponse, nil
}

type TagsServiceListResponse struct {
	tags []Tag
}

func (p *TagsServiceListResponse) Tags() []Tag {
	return p.tags
}

//
// List the tags in the system.
// For example to list the full hierarchy of the tags in the system send a request like this:
// ....
// GET /ovirt-engine/api/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>root2</name>
//     <description>root2</description>
//     <parent href="/ovirt-engine/api/tags/111" id="111"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/333" id="333">
//     <name>root3</name>
//     <description>root3</description>
//     <parent href="/ovirt-engine/api/tags/222" id="222"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/111" id="111">
//     <name>root</name>
//     <description>root</description>
//   </tag>
// </tags>
// ----
// In the previous XML output you can see the following hierarchy of the tags:
// ....
// root:        (id: 111)
//   - root2    (id: 222)
//     - root3  (id: 333)
// ....
// This method supports the following parameters:
// `Max`:: Sets the maximum number of tags to return. If not specified all the tags are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TagsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Tag,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var tagsVar Tags
	xml.Unmarshal([]byte(ovResp.Body), &tagsVar)
	return tagsVar.Tags, nil
}

//
// Reference to the service that manages a specific tag.
//
func (op *TagsService) TagService(id string) *TagService {
	return NewTagService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TagsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TagService(path)), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *TagsService) String() string {
	return fmt.Sprintf("TagsService:%s", op.Path)
}

//
//
type ExternalProviderCertificateService struct {
	BaseService
}

func NewExternalProviderCertificateService(connection *Connection, path string) *ExternalProviderCertificateService {
	var result ExternalProviderCertificateService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalProviderCertificateServiceGetRequest struct {
	externalProviderCertificateService *ExternalProviderCertificateService
	header                             map[string]string
	query                              map[string]string
}

func (p *ExternalProviderCertificateServiceGetRequest) Header(key, value string) *ExternalProviderCertificateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderCertificateServiceGetRequest) Query(key, value string) *ExternalProviderCertificateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderCertificateServiceGetRequest) Send() (*ExternalProviderCertificateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificateService.Connection.URL(), p.externalProviderCertificateService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalProviderCertificateService.Connection.username, p.externalProviderCertificateService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalProviderCertificateServiceGetResponse ExternalProviderCertificateServiceGetResponse
	var certificateVar Certificate
	xml.Unmarshal(respBodyBytes, &certificateVar)
	externalProviderCertificateServiceGetResponse.certificate = &certificateVar
	return &externalProviderCertificateServiceGetResponse, nil
}

type ExternalProviderCertificateServiceGetResponse struct {
	certificate *Certificate
}

func (p *ExternalProviderCertificateServiceGetResponse) Certificate() *Certificate {
	return p.certificate
}

//
//
func (op *ExternalProviderCertificateService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Certificate,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var certificateVar Certificate
	xml.Unmarshal([]byte(ovResp.Body), &certificateVar)
	return &certificateVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderCertificateService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalProviderCertificateService) String() string {
	return fmt.Sprintf("ExternalProviderCertificateService:%s", op.Path)
}

//
// A service to manage events in the system.
//
type EventsService struct {
	BaseService
}

func NewEventsService(connection *Connection, path string) *EventsService {
	var result EventsService
	result.Connection = connection
	result.Path = path
	return &result
}

type EventsServiceAddRequest struct {
	eventsService *EventsService
	header        map[string]string
	query         map[string]string
	event         *Event
}

func (p *EventsServiceAddRequest) Header(key, value string) *EventsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceAddRequest) Query(key, value string) *EventsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceAddRequest) Event(event *Event) *EventsServiceAddRequest {
	p.event = event
	return p
}
func (p *EventsServiceAddRequest) Send() (*EventsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.Connection.URL(), p.eventsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.event)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventsService.Connection.username, p.eventsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var eventsServiceAddResponse EventsServiceAddResponse
	var eventVar Event
	xml.Unmarshal(respBodyBytes, &eventVar)
	eventsServiceAddResponse.event = &eventVar
	return &eventsServiceAddResponse, nil
}

type EventsServiceAddResponse struct {
	event *Event
}

func (p *EventsServiceAddResponse) Event() *Event {
	return p.event
}

//
// Adds an external event to the internal audit log.
// This is intended for integration with external systems that detect or produce events relevant for the
// administrator of the system. For example, an external monitoring tool may be able to detect that a file system
// is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
// log sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
// </event>
// ----
// Events can also be linked to specific objects. For example, the above event could be linked to the specific
// virtual machine where it happened, using the `vm` link:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
//   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
// </event>
// ----
// NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
// attribute, if provided, is simply ignored.
//
func (op *EventsService) Add(
	event *Event,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Event,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(event, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var eventVar Event
	xml.Unmarshal([]byte(ovResp.Body), &eventVar)
	return &eventVar, nil
}

type EventsServiceListRequest struct {
	eventsService *EventsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	from          *int64
	max           *int64
	search        *string
}

func (p *EventsServiceListRequest) Header(key, value string) *EventsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceListRequest) Query(key, value string) *EventsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceListRequest) CaseSensitive(caseSensitive bool) *EventsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *EventsServiceListRequest) From(from int64) *EventsServiceListRequest {
	p.from = &from
	return p
}
func (p *EventsServiceListRequest) Max(max int64) *EventsServiceListRequest {
	p.max = &max
	return p
}
func (p *EventsServiceListRequest) Search(search string) *EventsServiceListRequest {
	p.search = &search
	return p
}
func (p *EventsServiceListRequest) Send() (*EventsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.Connection.URL(), p.eventsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.from != nil {
		values["from"] = []string{fmt.Sprintf("%v", *p.from)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventsService.Connection.username, p.eventsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var eventsServiceListResponse EventsServiceListResponse
	var eventsVar Events
	xml.Unmarshal(respBodyBytes, &eventsVar)
	eventsServiceListResponse.events = eventsVar.Events
	return &eventsServiceListResponse, nil
}

type EventsServiceListResponse struct {
	events []Event
}

func (p *EventsServiceListResponse) Events() []Event {
	return p.events
}

//
// Get list of events.
// [source]
// ----
// GET /ovirt-engine/api/events
// ----
// To the above request we get following response:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1e892ea9</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T12:14:34.541+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>User admin logged in.</description>
//     <code>30</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
// </events>
// ----
// The following events occur:
// * id="1" - The API logs in the admin user account.
// * id="2" - The API logs out of the admin user account.
// This method supports the following parameters:
// `From`:: Indicates the identifier of the the first event that should be returned. The identifiers of events are
// strictly increasing, so when this parameter is used only the events with that identifiers equal or greater
// than the given value will be returned. For example, the following request will return only the events
// with identifiers greater or equal than `123`:
// [source]
// ----
// GET /ovirt-engine/api/events?from=123
// ----
// This parameter is optional, and if not specified then the first event returned will be most recently
// generated.
// `Max`:: Sets the maximum number of events to return. If not specified all the events are returned.
// `Search`:: The events service provides search queries similar to other resource services.
// We can search by providing specific severity.
// [source]
// ----
// GET /ovirt-engine/api/events?search=severity%3Dnormal
// ----
// To the above request we get a list of events which severity is equal to `normal`:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>Affinity Rules Enforcement Manager started.</description>
//     <code>10780</code>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:52:18.861+02:00</time>
//   </event>
// </events>
// ----
// A virtualization environment generates a large amount of events after
// a period of time. However, the API only displays a default number of
// events for one search query. To display more than the default, the API
// separates results into pages with the page command in a search query.
// The following search query tells the API to paginate results using a
// page value in combination with the sortby clause:
// [source]
// ----
// sortby time asc page 1
// ----
// Below example paginates event resources. The URL-encoded request is:
// [source]
// ----
// GET /ovirt-engine/api/events?search=sortby%20time%20asc%20page%201
// ----
// Increase the page value to view the next page of results.
// [source]
// ----
// GET /ovirt-engine/api/events?search=sortby%20time%20asc%20page%202
// ----
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *EventsService) List(
	caseSensitive bool,
	from int64,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Event,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["from"] = fmt.Sprintf("%v", from)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var eventsVar Events
	xml.Unmarshal([]byte(ovResp.Body), &eventsVar)
	return eventsVar.Events, nil
}

type EventsServiceUndeleteRequest struct {
	eventsService *EventsService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *EventsServiceUndeleteRequest) Header(key, value string) *EventsServiceUndeleteRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceUndeleteRequest) Query(key, value string) *EventsServiceUndeleteRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceUndeleteRequest) Async(async bool) *EventsServiceUndeleteRequest {
	p.async = &async
	return p
}
func (p *EventsServiceUndeleteRequest) Send() (*EventsServiceUndeleteResponse, error) {
}

type EventsServiceUndeleteResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the un-delete should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *EventsService) Undelete(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "undelete", headers, query, wait)
	return err
}

//
// Reference to the service that manages a specific event.
//
func (op *EventsService) EventService(id string) *EventService {
	return NewEventService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.EventService(path)), nil
	}
	return op.EventService(path[:index]).Service(path[index+1:])
}

func (op *EventsService) String() string {
	return fmt.Sprintf("EventsService:%s", op.Path)
}

//
// A service managing a watchdog on virtual machines.
//
type VmWatchdogService struct {
	BaseService
}

func NewVmWatchdogService(connection *Connection, path string) *VmWatchdogService {
	var result VmWatchdogService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmWatchdogServiceGetRequest struct {
	vmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
}

func (p *VmWatchdogServiceGetRequest) Header(key, value string) *VmWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceGetRequest) Query(key, value string) *VmWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceGetRequest) Send() (*VmWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.Connection.URL(), p.vmWatchdogService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogService.Connection.username, p.vmWatchdogService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmWatchdogServiceGetResponse VmWatchdogServiceGetResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	vmWatchdogServiceGetResponse.watchdog = &watchdogVar
	return &vmWatchdogServiceGetResponse, nil
}

type VmWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogServiceGetResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
// Returns the information about the watchdog.
//
func (op *VmWatchdogService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

type VmWatchdogServiceRemoveRequest struct {
	vmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *VmWatchdogServiceRemoveRequest) Header(key, value string) *VmWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceRemoveRequest) Query(key, value string) *VmWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceRemoveRequest) Async(async bool) *VmWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmWatchdogServiceRemoveRequest) Send() (*VmWatchdogServiceRemoveResponse, error) {
}

type VmWatchdogServiceRemoveResponse struct {
}

//
// Removes the watchdog from the virtual machine.
// For example, to remove a watchdog from a virtual machine, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmWatchdogService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VmWatchdogServiceUpdateRequest struct {
	vmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
	watchdog          *Watchdog
}

func (p *VmWatchdogServiceUpdateRequest) Header(key, value string) *VmWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Query(key, value string) *VmWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Async(async bool) *VmWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *VmWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}
func (p *VmWatchdogServiceUpdateRequest) Send() (*VmWatchdogServiceUpdateResponse, error) {
}

type VmWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogServiceUpdateResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
// Updates the information about the watchdog.
// You can update the information using `action` and `model` elements.
// For example, to update a watchdog, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>reset</action>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>reset</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// This method supports the following parameters:
// `Watchdog`:: The information about the watchdog.
// The request data must contain at least one of `model` and `action`
// elements. The response data contains complete information about the
// updated watchdog.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmWatchdogService) Update(
	watchdog *Watchdog,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(watchdog, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmWatchdogService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmWatchdogService) String() string {
	return fmt.Sprintf("VmWatchdogService:%s", op.Path)
}

//
//
type AttachedStorageDomainService struct {
	BaseService
}

func NewAttachedStorageDomainService(connection *Connection, path string) *AttachedStorageDomainService {
	var result AttachedStorageDomainService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainServiceActivateRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceActivateRequest) Header(key, value string) *AttachedStorageDomainServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceActivateRequest) Query(key, value string) *AttachedStorageDomainServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceActivateRequest) Async(async bool) *AttachedStorageDomainServiceActivateRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainServiceActivateRequest) Send() (*AttachedStorageDomainServiceActivateResponse, error) {
}

type AttachedStorageDomainServiceActivateResponse struct {
}

//
// This operation activates an attached storage domain.
// Once the storage domain is activated it is ready for use with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
// ----
// The activate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the activation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainService) Activate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "activate", headers, query, wait)
	return err
}

type AttachedStorageDomainServiceDeactivateRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Header(key, value string) *AttachedStorageDomainServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Query(key, value string) *AttachedStorageDomainServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Async(async bool) *AttachedStorageDomainServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainServiceDeactivateRequest) Send() (*AttachedStorageDomainServiceDeactivateResponse, error) {
}

type AttachedStorageDomainServiceDeactivateResponse struct {
}

//
// This operation deactivates an attached storage domain.
// Once the storage domain is deactivated it will not be used with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
// ----
// The deactivate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the deactivation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainService) Deactivate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "deactivate", headers, query, wait)
	return err
}

type AttachedStorageDomainServiceGetRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
}

func (p *AttachedStorageDomainServiceGetRequest) Header(key, value string) *AttachedStorageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceGetRequest) Query(key, value string) *AttachedStorageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceGetRequest) Send() (*AttachedStorageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainService.Connection.URL(), p.attachedStorageDomainService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainService.Connection.username, p.attachedStorageDomainService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var attachedStorageDomainServiceGetResponse AttachedStorageDomainServiceGetResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	attachedStorageDomainServiceGetResponse.storageDomain = &storageDomainVar
	return &attachedStorageDomainServiceGetResponse, nil
}

type AttachedStorageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *AttachedStorageDomainServiceGetResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}

//
//
func (op *AttachedStorageDomainService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageDomain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainVar StorageDomain
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainVar)
	return &storageDomainVar, nil
}

type AttachedStorageDomainServiceRemoveRequest struct {
	attachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceRemoveRequest) Header(key, value string) *AttachedStorageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceRemoveRequest) Query(key, value string) *AttachedStorageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceRemoveRequest) Async(async bool) *AttachedStorageDomainServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainServiceRemoveRequest) Send() (*AttachedStorageDomainServiceRemoveResponse, error) {
}

type AttachedStorageDomainServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
//
func (op *AttachedStorageDomainService) DisksService() *AttachedStorageDomainDisksService {
	return NewAttachedStorageDomainDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AttachedStorageDomainService) String() string {
	return fmt.Sprintf("AttachedStorageDomainService:%s", op.Path)
}

//
//
type AttachedStorageDomainsService struct {
	BaseService
}

func NewAttachedStorageDomainsService(connection *Connection, path string) *AttachedStorageDomainsService {
	var result AttachedStorageDomainsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainsServiceAddRequest struct {
	attachedStorageDomainsService *AttachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	storageDomain                 *StorageDomain
}

func (p *AttachedStorageDomainsServiceAddRequest) Header(key, value string) *AttachedStorageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceAddRequest) Query(key, value string) *AttachedStorageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainsServiceAddRequest) Send() (*AttachedStorageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.Connection.URL(), p.attachedStorageDomainsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.storageDomain)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainsService.Connection.username, p.attachedStorageDomainsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var attachedStorageDomainsServiceAddResponse AttachedStorageDomainsServiceAddResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	attachedStorageDomainsServiceAddResponse.storageDomain = &storageDomainVar
	return &attachedStorageDomainsServiceAddResponse, nil
}

type AttachedStorageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *AttachedStorageDomainsServiceAddResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}

//
//
func (op *AttachedStorageDomainsService) Add(
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageDomain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(storageDomain, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainVar StorageDomain
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainVar)
	return &storageDomainVar, nil
}

type AttachedStorageDomainsServiceListRequest struct {
	attachedStorageDomainsService *AttachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	max                           *int64
}

func (p *AttachedStorageDomainsServiceListRequest) Header(key, value string) *AttachedStorageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Query(key, value string) *AttachedStorageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Max(max int64) *AttachedStorageDomainsServiceListRequest {
	p.max = &max
	return p
}
func (p *AttachedStorageDomainsServiceListRequest) Send() (*AttachedStorageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.Connection.URL(), p.attachedStorageDomainsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainsService.Connection.username, p.attachedStorageDomainsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var attachedStorageDomainsServiceListResponse AttachedStorageDomainsServiceListResponse
	var storageDomainsVar StorageDomains
	xml.Unmarshal(respBodyBytes, &storageDomainsVar)
	attachedStorageDomainsServiceListResponse.storageDomains = storageDomainsVar.StorageDomains
	return &attachedStorageDomainsServiceListResponse, nil
}

type AttachedStorageDomainsServiceListResponse struct {
	storageDomains []StorageDomain
}

func (p *AttachedStorageDomainsServiceListResponse) StorageDomains() []StorageDomain {
	return p.storageDomains
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of storage domains to return. If not specified all the storage domains are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]StorageDomain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainsVar StorageDomains
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainsVar)
	return storageDomainsVar.StorageDomains, nil
}

//
//
func (op *AttachedStorageDomainsService) StorageDomainService(id string) *AttachedStorageDomainService {
	return NewAttachedStorageDomainService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageDomainService(path)), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *AttachedStorageDomainsService) String() string {
	return fmt.Sprintf("AttachedStorageDomainsService:%s", op.Path)
}

//
//
type InstanceTypeWatchdogService struct {
	BaseService
}

func NewInstanceTypeWatchdogService(connection *Connection, path string) *InstanceTypeWatchdogService {
	var result InstanceTypeWatchdogService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeWatchdogServiceGetRequest struct {
	instanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
}

func (p *InstanceTypeWatchdogServiceGetRequest) Header(key, value string) *InstanceTypeWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceGetRequest) Query(key, value string) *InstanceTypeWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceGetRequest) Send() (*InstanceTypeWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.Connection.URL(), p.instanceTypeWatchdogService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogService.Connection.username, p.instanceTypeWatchdogService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeWatchdogServiceGetResponse InstanceTypeWatchdogServiceGetResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	instanceTypeWatchdogServiceGetResponse.watchdog = &watchdogVar
	return &instanceTypeWatchdogServiceGetResponse, nil
}

type InstanceTypeWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogServiceGetResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
// Gets watchdog configuration of the instance type.
//
func (op *InstanceTypeWatchdogService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

type InstanceTypeWatchdogServiceRemoveRequest struct {
	instanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Header(key, value string) *InstanceTypeWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Query(key, value string) *InstanceTypeWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Async(async bool) *InstanceTypeWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeWatchdogServiceRemoveRequest) Send() (*InstanceTypeWatchdogServiceRemoveResponse, error) {
}

type InstanceTypeWatchdogServiceRemoveResponse struct {
}

//
// Remove a watchdog from the instance type.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypeWatchdogService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type InstanceTypeWatchdogServiceUpdateRequest struct {
	instanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	watchdog                    *Watchdog
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Header(key, value string) *InstanceTypeWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Query(key, value string) *InstanceTypeWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Async(async bool) *InstanceTypeWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *InstanceTypeWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}
func (p *InstanceTypeWatchdogServiceUpdateRequest) Send() (*InstanceTypeWatchdogServiceUpdateResponse, error) {
}

type InstanceTypeWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogServiceUpdateResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
// Updates the watchdog configuration of the instance type.
//
func (op *InstanceTypeWatchdogService) Update(
	watchdog *Watchdog,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(watchdog, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeWatchdogService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeWatchdogService) String() string {
	return fmt.Sprintf("InstanceTypeWatchdogService:%s", op.Path)
}

//
//
type QuotaStorageLimitService struct {
	BaseService
}

func NewQuotaStorageLimitService(connection *Connection, path string) *QuotaStorageLimitService {
	var result QuotaStorageLimitService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaStorageLimitServiceGetRequest struct {
	quotaStorageLimitService *QuotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
}

func (p *QuotaStorageLimitServiceGetRequest) Header(key, value string) *QuotaStorageLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitServiceGetRequest) Query(key, value string) *QuotaStorageLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitServiceGetRequest) Send() (*QuotaStorageLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitService.Connection.URL(), p.quotaStorageLimitService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaStorageLimitService.Connection.username, p.quotaStorageLimitService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotaStorageLimitServiceGetResponse QuotaStorageLimitServiceGetResponse
	var limitVar QuotaStorageLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaStorageLimitServiceGetResponse.limit = &limitVar
	return &quotaStorageLimitServiceGetResponse, nil
}

type QuotaStorageLimitServiceGetResponse struct {
	limit *QuotaStorageLimit
}

func (p *QuotaStorageLimitServiceGetResponse) Limit() *QuotaStorageLimit {
	return p.limit
}

//
//
func (op *QuotaStorageLimitService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*QuotaStorageLimit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var limitVar QuotaStorageLimit
	xml.Unmarshal([]byte(ovResp.Body), &limitVar)
	return &limitVar, nil
}

type QuotaStorageLimitServiceRemoveRequest struct {
	quotaStorageLimitService *QuotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *QuotaStorageLimitServiceRemoveRequest) Header(key, value string) *QuotaStorageLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitServiceRemoveRequest) Query(key, value string) *QuotaStorageLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitServiceRemoveRequest) Async(async bool) *QuotaStorageLimitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QuotaStorageLimitServiceRemoveRequest) Send() (*QuotaStorageLimitServiceRemoveResponse, error) {
}

type QuotaStorageLimitServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the update should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QuotaStorageLimitService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaStorageLimitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaStorageLimitService) String() string {
	return fmt.Sprintf("QuotaStorageLimitService:%s", op.Path)
}

//
//
type RoleService struct {
	BaseService
}

func NewRoleService(connection *Connection, path string) *RoleService {
	var result RoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type RoleServiceGetRequest struct {
	roleService *RoleService
	header      map[string]string
	query       map[string]string
}

func (p *RoleServiceGetRequest) Header(key, value string) *RoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceGetRequest) Query(key, value string) *RoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceGetRequest) Send() (*RoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.roleService.Connection.URL(), p.roleService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.roleService.Connection.username, p.roleService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.roleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var roleServiceGetResponse RoleServiceGetResponse
	var roleVar Role
	xml.Unmarshal(respBodyBytes, &roleVar)
	roleServiceGetResponse.role = &roleVar
	return &roleServiceGetResponse, nil
}

type RoleServiceGetResponse struct {
	role *Role
}

func (p *RoleServiceGetResponse) Role() *Role {
	return p.role
}

//
// Get the role.
// [source]
// ----
// GET /ovirt-engine/api/roles/123
// ----
// You will receive XML response like this one:
// [source,xml]
// ----
// <role id="123">
//   <name>MyRole</name>
//   <description>MyRole description</description>
//   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//   <administrative>true</administrative>
//   <mutable>false</mutable>
// </role>
// ----
//
func (op *RoleService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Role,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var roleVar Role
	xml.Unmarshal([]byte(ovResp.Body), &roleVar)
	return &roleVar, nil
}

type RoleServiceRemoveRequest struct {
	roleService *RoleService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *RoleServiceRemoveRequest) Header(key, value string) *RoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceRemoveRequest) Query(key, value string) *RoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceRemoveRequest) Async(async bool) *RoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *RoleServiceRemoveRequest) Send() (*RoleServiceRemoveResponse, error) {
}

type RoleServiceRemoveResponse struct {
}

//
// Removes the role.
// To remove the role you need to know its id, then send request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/roles/{role_id}
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *RoleService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type RoleServiceUpdateRequest struct {
	roleService *RoleService
	header      map[string]string
	query       map[string]string
	async       *bool
	role        *Role
}

func (p *RoleServiceUpdateRequest) Header(key, value string) *RoleServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceUpdateRequest) Query(key, value string) *RoleServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceUpdateRequest) Async(async bool) *RoleServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *RoleServiceUpdateRequest) Role(role *Role) *RoleServiceUpdateRequest {
	p.role = role
	return p
}
func (p *RoleServiceUpdateRequest) Send() (*RoleServiceUpdateResponse, error) {
}

type RoleServiceUpdateResponse struct {
	role *Role
}

func (p *RoleServiceUpdateResponse) Role() *Role {
	return p.role
}

//
// Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
// created. Within this endpoint you can't add or remove roles permits you need to use
// <<services/permits, service>> that manages permits of role.
// For example to update role's `name`, `description` and `administrative` attributes send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/roles/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyNewRoleName</name>
//   <description>My new description of the role</description>
//   <administrative>true</administrative>
// </group>
// ----
// This method supports the following parameters:
// `Role`:: Updated role.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *RoleService) Update(
	role *Role,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Role,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(role, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var roleVar Role
	xml.Unmarshal([]byte(ovResp.Body), &roleVar)
	return &roleVar, nil
}

//
// Sub-resource locator method, returns permits service.
//
func (op *RoleService) PermitsService() *PermitsService {
	return NewPermitsService(op.Connection, fmt.Sprintf("%s/permits", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *RoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permits" {
		return op.PermitsService(), nil
	}
	if strings.HasPrefix(path, "permits/") {
		return op.PermitsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *RoleService) String() string {
	return fmt.Sprintf("RoleService:%s", op.Path)
}

//
//
type AssignedNetworkService struct {
	BaseService
}

func NewAssignedNetworkService(connection *Connection, path string) *AssignedNetworkService {
	var result AssignedNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedNetworkServiceGetRequest struct {
	assignedNetworkService *AssignedNetworkService
	header                 map[string]string
	query                  map[string]string
}

func (p *AssignedNetworkServiceGetRequest) Header(key, value string) *AssignedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworkServiceGetRequest) Query(key, value string) *AssignedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworkServiceGetRequest) Send() (*AssignedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworkService.Connection.URL(), p.assignedNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworkService.Connection.username, p.assignedNetworkService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedNetworkServiceGetResponse AssignedNetworkServiceGetResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	assignedNetworkServiceGetResponse.network = &networkVar
	return &assignedNetworkServiceGetResponse, nil
}

type AssignedNetworkServiceGetResponse struct {
	network *Network
}

func (p *AssignedNetworkServiceGetResponse) Network() *Network {
	return p.network
}

//
//
func (op *AssignedNetworkService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type AssignedNetworkServiceRemoveRequest struct {
	assignedNetworkService *AssignedNetworkService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *AssignedNetworkServiceRemoveRequest) Header(key, value string) *AssignedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworkServiceRemoveRequest) Query(key, value string) *AssignedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworkServiceRemoveRequest) Async(async bool) *AssignedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedNetworkServiceRemoveRequest) Send() (*AssignedNetworkServiceRemoveResponse, error) {
}

type AssignedNetworkServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedNetworkService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type AssignedNetworkServiceUpdateRequest struct {
	assignedNetworkService *AssignedNetworkService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	network                *Network
}

func (p *AssignedNetworkServiceUpdateRequest) Header(key, value string) *AssignedNetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworkServiceUpdateRequest) Query(key, value string) *AssignedNetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworkServiceUpdateRequest) Async(async bool) *AssignedNetworkServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *AssignedNetworkServiceUpdateRequest) Network(network *Network) *AssignedNetworkServiceUpdateRequest {
	p.network = network
	return p
}
func (p *AssignedNetworkServiceUpdateRequest) Send() (*AssignedNetworkServiceUpdateResponse, error) {
}

type AssignedNetworkServiceUpdateResponse struct {
	network *Network
}

func (p *AssignedNetworkServiceUpdateResponse) Network() *Network {
	return p.network
}

//
//
func (op *AssignedNetworkService) Update(
	network *Network,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(network, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedNetworkService) String() string {
	return fmt.Sprintf("AssignedNetworkService:%s", op.Path)
}

//
// Returns the details of the disks attached to a virtual machine in the export domain.
//
type StorageDomainVmDiskAttachmentService struct {
	BaseService
}

func NewStorageDomainVmDiskAttachmentService(connection *Connection, path string) *StorageDomainVmDiskAttachmentService {
	var result StorageDomainVmDiskAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmDiskAttachmentServiceGetRequest struct {
	storageDomainVmDiskAttachmentService *StorageDomainVmDiskAttachmentService
	header                               map[string]string
	query                                map[string]string
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Header(key, value string) *StorageDomainVmDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Query(key, value string) *StorageDomainVmDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Send() (*StorageDomainVmDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentService.Connection.URL(), p.storageDomainVmDiskAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmDiskAttachmentService.Connection.username, p.storageDomainVmDiskAttachmentService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainVmDiskAttachmentServiceGetResponse StorageDomainVmDiskAttachmentServiceGetResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	storageDomainVmDiskAttachmentServiceGetResponse.attachment = &attachmentVar
	return &storageDomainVmDiskAttachmentServiceGetResponse, nil
}

type StorageDomainVmDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *StorageDomainVmDiskAttachmentServiceGetResponse) Attachment() *DiskAttachment {
	return p.attachment
}

//
// Returns the details of the attachment with all its properties and a link to the disk.
//
func (op *StorageDomainVmDiskAttachmentService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentVar DiskAttachment
	xml.Unmarshal([]byte(ovResp.Body), &attachmentVar)
	return &attachmentVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmDiskAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainVmDiskAttachmentService) String() string {
	return fmt.Sprintf("StorageDomainVmDiskAttachmentService:%s", op.Path)
}

//
// A service to manage the network interfaces of a host.
//
type HostNicsService struct {
	BaseService
}

func NewHostNicsService(connection *Connection, path string) *HostNicsService {
	var result HostNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNicsServiceListRequest struct {
	hostNicsService *HostNicsService
	header          map[string]string
	query           map[string]string
	max             *int64
}

func (p *HostNicsServiceListRequest) Header(key, value string) *HostNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicsServiceListRequest) Query(key, value string) *HostNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicsServiceListRequest) Max(max int64) *HostNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *HostNicsServiceListRequest) Send() (*HostNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNicsService.Connection.URL(), p.hostNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNicsService.Connection.username, p.hostNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostNicsServiceListResponse HostNicsServiceListResponse
	var nicsVar HostNics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	hostNicsServiceListResponse.nics = nicsVar.HostNics
	return &hostNicsServiceListResponse, nil
}

type HostNicsServiceListResponse struct {
	nics []HostNic
}

func (p *HostNicsServiceListResponse) Nics() []HostNic {
	return p.nics
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of NICs to return. If not specified all the NICs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostNicsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]HostNic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicsVar HostNics
	xml.Unmarshal([]byte(ovResp.Body), &nicsVar)
	return nicsVar.HostNics, nil
}

//
// Reference to the service that manages a single network interface.
//
func (op *HostNicsService) NicService(id string) *HostNicService {
	return NewHostNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *HostNicsService) String() string {
	return fmt.Sprintf("HostNicsService:%s", op.Path)
}

//
//
type VmNumaNodeService struct {
	BaseService
}

func NewVmNumaNodeService(connection *Connection, path string) *VmNumaNodeService {
	var result VmNumaNodeService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNumaNodeServiceGetRequest struct {
	vmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
}

func (p *VmNumaNodeServiceGetRequest) Header(key, value string) *VmNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceGetRequest) Query(key, value string) *VmNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceGetRequest) Send() (*VmNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.Connection.URL(), p.vmNumaNodeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodeService.Connection.username, p.vmNumaNodeService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmNumaNodeServiceGetResponse VmNumaNodeServiceGetResponse
	var nodeVar VirtualNumaNode
	xml.Unmarshal(respBodyBytes, &nodeVar)
	vmNumaNodeServiceGetResponse.node = &nodeVar
	return &vmNumaNodeServiceGetResponse, nil
}

type VmNumaNodeServiceGetResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodeServiceGetResponse) Node() *VirtualNumaNode {
	return p.node
}

//
//
func (op *VmNumaNodeService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VirtualNumaNode,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nodeVar VirtualNumaNode
	xml.Unmarshal([]byte(ovResp.Body), &nodeVar)
	return &nodeVar, nil
}

type VmNumaNodeServiceRemoveRequest struct {
	vmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *VmNumaNodeServiceRemoveRequest) Header(key, value string) *VmNumaNodeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceRemoveRequest) Query(key, value string) *VmNumaNodeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceRemoveRequest) Async(async bool) *VmNumaNodeServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmNumaNodeServiceRemoveRequest) Send() (*VmNumaNodeServiceRemoveResponse, error) {
}

type VmNumaNodeServiceRemoveResponse struct {
}

//
// Removes a virtual NUMA node.
// An example of removing a virtual NUMA node:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/numanodes/456
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmNumaNodeService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VmNumaNodeServiceUpdateRequest struct {
	vmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
	node              *VirtualNumaNode
}

func (p *VmNumaNodeServiceUpdateRequest) Header(key, value string) *VmNumaNodeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Query(key, value string) *VmNumaNodeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Async(async bool) *VmNumaNodeServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmNumaNodeServiceUpdateRequest) Node(node *VirtualNumaNode) *VmNumaNodeServiceUpdateRequest {
	p.node = node
	return p
}
func (p *VmNumaNodeServiceUpdateRequest) Send() (*VmNumaNodeServiceUpdateResponse, error) {
}

type VmNumaNodeServiceUpdateResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodeServiceUpdateResponse) Node() *VirtualNumaNode {
	return p.node
}

//
// Updates a virtual NUMA node.
// An example of pinning a virtual NUMA node to a physical NUMA node on the host:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/numanodes/456
// ----
// The request body should contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
// </vm_numa_node>
// ----
//
func (op *VmNumaNodeService) Update(
	node *VirtualNumaNode,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VirtualNumaNode,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(node, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nodeVar VirtualNumaNode
	xml.Unmarshal([]byte(ovResp.Body), &nodeVar)
	return &nodeVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNumaNodeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmNumaNodeService) String() string {
	return fmt.Sprintf("VmNumaNodeService:%s", op.Path)
}

//
// Lists the CD-ROM devices of a template.
//
type TemplateCdromsService struct {
	BaseService
}

func NewTemplateCdromsService(connection *Connection, path string) *TemplateCdromsService {
	var result TemplateCdromsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateCdromsServiceListRequest struct {
	templateCdromsService *TemplateCdromsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *TemplateCdromsServiceListRequest) Header(key, value string) *TemplateCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateCdromsServiceListRequest) Query(key, value string) *TemplateCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateCdromsServiceListRequest) Max(max int64) *TemplateCdromsServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateCdromsServiceListRequest) Send() (*TemplateCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromsService.Connection.URL(), p.templateCdromsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateCdromsService.Connection.username, p.templateCdromsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateCdromsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateCdromsServiceListResponse TemplateCdromsServiceListResponse
	var cdromsVar Cdroms
	xml.Unmarshal(respBodyBytes, &cdromsVar)
	templateCdromsServiceListResponse.cdroms = cdromsVar.Cdroms
	return &templateCdromsServiceListResponse, nil
}

type TemplateCdromsServiceListResponse struct {
	cdroms []Cdrom
}

func (p *TemplateCdromsServiceListResponse) Cdroms() []Cdrom {
	return p.cdroms
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of CD-ROMs to return. If not specified all the CD-ROMs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateCdromsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Cdrom,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var cdromsVar Cdroms
	xml.Unmarshal([]byte(ovResp.Body), &cdromsVar)
	return cdromsVar.Cdroms, nil
}

//
// Returns a reference to the service that manages a specific CD-ROM device.
//
func (op *TemplateCdromsService) CdromService(id string) *TemplateCdromService {
	return NewTemplateCdromService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateCdromsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CdromService(path)), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *TemplateCdromsService) String() string {
	return fmt.Sprintf("TemplateCdromsService:%s", op.Path)
}

//
//
type SnapshotService struct {
	BaseService
}

func NewSnapshotService(connection *Connection, path string) *SnapshotService {
	var result SnapshotService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotServiceGetRequest struct {
	snapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
}

func (p *SnapshotServiceGetRequest) Header(key, value string) *SnapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceGetRequest) Query(key, value string) *SnapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceGetRequest) Send() (*SnapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotService.Connection.URL(), p.snapshotService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotService.Connection.username, p.snapshotService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotServiceGetResponse SnapshotServiceGetResponse
	var snapshotVar Snapshot
	xml.Unmarshal(respBodyBytes, &snapshotVar)
	snapshotServiceGetResponse.snapshot = &snapshotVar
	return &snapshotServiceGetResponse, nil
}

type SnapshotServiceGetResponse struct {
	snapshot *Snapshot
}

func (p *SnapshotServiceGetResponse) Snapshot() *Snapshot {
	return p.snapshot
}

//
//
func (op *SnapshotService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Snapshot,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var snapshotVar Snapshot
	xml.Unmarshal([]byte(ovResp.Body), &snapshotVar)
	return &snapshotVar, nil
}

type SnapshotServiceRemoveRequest struct {
	snapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
	allContent      *bool
	async           *bool
}

func (p *SnapshotServiceRemoveRequest) Header(key, value string) *SnapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceRemoveRequest) Query(key, value string) *SnapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceRemoveRequest) AllContent(allContent bool) *SnapshotServiceRemoveRequest {
	p.allContent = &allContent
	return p
}
func (p *SnapshotServiceRemoveRequest) Async(async bool) *SnapshotServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SnapshotServiceRemoveRequest) Send() (*SnapshotServiceRemoveResponse, error) {
}

type SnapshotServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `AllContent`:: Indicates if all the attributes of the virtual machine snapshot should be included in the response.
// By default the attribute `initialization.configuration.data` is excluded.
// For example, to retrieve the complete representation of the snapshot with id `456` of the virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/snapshots/456?all_content=true
// ....
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SnapshotService) Remove(
	async bool,
	allContent bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)
	query["all_content"] = fmt.Sprintf("%v", allContent)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type SnapshotServiceRestoreRequest struct {
	snapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
	async           *bool
	disks           []Disk
	restoreMemory   *bool
}

func (p *SnapshotServiceRestoreRequest) Header(key, value string) *SnapshotServiceRestoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceRestoreRequest) Query(key, value string) *SnapshotServiceRestoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceRestoreRequest) Async(async bool) *SnapshotServiceRestoreRequest {
	p.async = &async
	return p
}
func (p *SnapshotServiceRestoreRequest) Disks(disks []Disk) *SnapshotServiceRestoreRequest {
	p.disks = disks
	return p
}
func (p *SnapshotServiceRestoreRequest) RestoreMemory(restoreMemory bool) *SnapshotServiceRestoreRequest {
	p.restoreMemory = &restoreMemory
	return p
}
func (p *SnapshotServiceRestoreRequest) Send() (*SnapshotServiceRestoreResponse, error) {
}

type SnapshotServiceRestoreResponse struct {
}

//
// Restores a virtual machine snapshot.
// For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots/456/restore
// ----
// With an empty `action` in the body:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the restore should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SnapshotService) Restore(
	async bool,
	disks []Disk,
	restoreMemory bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Disks:         disks,
		RestoreMemory: &restoreMemory,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "restore", headers, query, wait)
	return err
}

//
//
func (op *SnapshotService) CdromsService() *SnapshotCdromsService {
	return NewSnapshotCdromsService(op.Connection, fmt.Sprintf("%s/cdroms", op.Path))
}

//
//
func (op *SnapshotService) DisksService() *SnapshotDisksService {
	return NewSnapshotDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
//
func (op *SnapshotService) NicsService() *SnapshotNicsService {
	return NewSnapshotNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotService) String() string {
	return fmt.Sprintf("SnapshotService:%s", op.Path)
}

//
//
type SchedulingPoliciesService struct {
	BaseService
}

func NewSchedulingPoliciesService(connection *Connection, path string) *SchedulingPoliciesService {
	var result SchedulingPoliciesService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPoliciesServiceAddRequest struct {
	schedulingPoliciesService *SchedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	policy                    *SchedulingPolicy
}

func (p *SchedulingPoliciesServiceAddRequest) Header(key, value string) *SchedulingPoliciesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPoliciesServiceAddRequest) Query(key, value string) *SchedulingPoliciesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPoliciesServiceAddRequest) Policy(policy *SchedulingPolicy) *SchedulingPoliciesServiceAddRequest {
	p.policy = policy
	return p
}
func (p *SchedulingPoliciesServiceAddRequest) Send() (*SchedulingPoliciesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.Connection.URL(), p.schedulingPoliciesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.policy)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPoliciesService.Connection.username, p.schedulingPoliciesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var schedulingPoliciesServiceAddResponse SchedulingPoliciesServiceAddResponse
	var policyVar SchedulingPolicy
	xml.Unmarshal(respBodyBytes, &policyVar)
	schedulingPoliciesServiceAddResponse.policy = &policyVar
	return &schedulingPoliciesServiceAddResponse, nil
}

type SchedulingPoliciesServiceAddResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPoliciesServiceAddResponse) Policy() *SchedulingPolicy {
	return p.policy
}

//
//
func (op *SchedulingPoliciesService) Add(
	policy *SchedulingPolicy,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*SchedulingPolicy,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(policy, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var policyVar SchedulingPolicy
	xml.Unmarshal([]byte(ovResp.Body), &policyVar)
	return &policyVar, nil
}

type SchedulingPoliciesServiceListRequest struct {
	schedulingPoliciesService *SchedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	filter                    *bool
	max                       *int64
}

func (p *SchedulingPoliciesServiceListRequest) Header(key, value string) *SchedulingPoliciesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Query(key, value string) *SchedulingPoliciesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Filter(filter bool) *SchedulingPoliciesServiceListRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPoliciesServiceListRequest) Max(max int64) *SchedulingPoliciesServiceListRequest {
	p.max = &max
	return p
}
func (p *SchedulingPoliciesServiceListRequest) Send() (*SchedulingPoliciesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.Connection.URL(), p.schedulingPoliciesService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPoliciesService.Connection.username, p.schedulingPoliciesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var schedulingPoliciesServiceListResponse SchedulingPoliciesServiceListResponse
	var policiesVar SchedulingPolicys
	xml.Unmarshal(respBodyBytes, &policiesVar)
	schedulingPoliciesServiceListResponse.policies = policiesVar.SchedulingPolicys
	return &schedulingPoliciesServiceListResponse, nil
}

type SchedulingPoliciesServiceListResponse struct {
	policies []SchedulingPolicy
}

func (p *SchedulingPoliciesServiceListResponse) Policies() []SchedulingPolicy {
	return p.policies
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of policies to return. If not specified all the policies are returned.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SchedulingPoliciesService) List(
	filter bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]SchedulingPolicy,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var policiesVar SchedulingPolicys
	xml.Unmarshal([]byte(ovResp.Body), &policiesVar)
	return policiesVar.SchedulingPolicys, nil
}

//
//
func (op *SchedulingPoliciesService) PolicyService(id string) *SchedulingPolicyService {
	return NewSchedulingPolicyService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPoliciesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PolicyService(path)), nil
	}
	return op.PolicyService(path[:index]).Service(path[index+1:])
}

func (op *SchedulingPoliciesService) String() string {
	return fmt.Sprintf("SchedulingPoliciesService:%s", op.Path)
}

//
//
type WeightsService struct {
	BaseService
}

func NewWeightsService(connection *Connection, path string) *WeightsService {
	var result WeightsService
	result.Connection = connection
	result.Path = path
	return &result
}

type WeightsServiceAddRequest struct {
	weightsService *WeightsService
	header         map[string]string
	query          map[string]string
	weight         *Weight
}

func (p *WeightsServiceAddRequest) Header(key, value string) *WeightsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightsServiceAddRequest) Query(key, value string) *WeightsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightsServiceAddRequest) Weight(weight *Weight) *WeightsServiceAddRequest {
	p.weight = weight
	return p
}
func (p *WeightsServiceAddRequest) Send() (*WeightsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.Connection.URL(), p.weightsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.weight)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.weightsService.Connection.username, p.weightsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.weightsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var weightsServiceAddResponse WeightsServiceAddResponse
	var weightVar Weight
	xml.Unmarshal(respBodyBytes, &weightVar)
	weightsServiceAddResponse.weight = &weightVar
	return &weightsServiceAddResponse, nil
}

type WeightsServiceAddResponse struct {
	weight *Weight
}

func (p *WeightsServiceAddResponse) Weight() *Weight {
	return p.weight
}

//
//
func (op *WeightsService) Add(
	weight *Weight,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Weight,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(weight, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var weightVar Weight
	xml.Unmarshal([]byte(ovResp.Body), &weightVar)
	return &weightVar, nil
}

type WeightsServiceListRequest struct {
	weightsService *WeightsService
	header         map[string]string
	query          map[string]string
	filter         *bool
	max            *int64
}

func (p *WeightsServiceListRequest) Header(key, value string) *WeightsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightsServiceListRequest) Query(key, value string) *WeightsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightsServiceListRequest) Filter(filter bool) *WeightsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *WeightsServiceListRequest) Max(max int64) *WeightsServiceListRequest {
	p.max = &max
	return p
}
func (p *WeightsServiceListRequest) Send() (*WeightsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.Connection.URL(), p.weightsService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.weightsService.Connection.username, p.weightsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.weightsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var weightsServiceListResponse WeightsServiceListResponse
	var weightsVar Weights
	xml.Unmarshal(respBodyBytes, &weightsVar)
	weightsServiceListResponse.weights = weightsVar.Weights
	return &weightsServiceListResponse, nil
}

type WeightsServiceListResponse struct {
	weights []Weight
}

func (p *WeightsServiceListResponse) Weights() []Weight {
	return p.weights
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of weights to return. If not specified all the weights are returned.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *WeightsService) List(
	filter bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Weight,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var weightsVar Weights
	xml.Unmarshal([]byte(ovResp.Body), &weightsVar)
	return weightsVar.Weights, nil
}

//
//
func (op *WeightsService) WeightService(id string) *WeightService {
	return NewWeightService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *WeightsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WeightService(path)), nil
	}
	return op.WeightService(path[:index]).Service(path[index+1:])
}

func (op *WeightsService) String() string {
	return fmt.Sprintf("WeightsService:%s", op.Path)
}

//
// A service to manage host devices attached to a virtual machine.
//
type VmHostDevicesService struct {
	BaseService
}

func NewVmHostDevicesService(connection *Connection, path string) *VmHostDevicesService {
	var result VmHostDevicesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmHostDevicesServiceAddRequest struct {
	vmHostDevicesService *VmHostDevicesService
	header               map[string]string
	query                map[string]string
	device               *HostDevice
}

func (p *VmHostDevicesServiceAddRequest) Header(key, value string) *VmHostDevicesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDevicesServiceAddRequest) Query(key, value string) *VmHostDevicesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDevicesServiceAddRequest) Device(device *HostDevice) *VmHostDevicesServiceAddRequest {
	p.device = device
	return p
}
func (p *VmHostDevicesServiceAddRequest) Send() (*VmHostDevicesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.Connection.URL(), p.vmHostDevicesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.device)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmHostDevicesService.Connection.username, p.vmHostDevicesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmHostDevicesServiceAddResponse VmHostDevicesServiceAddResponse
	var deviceVar HostDevice
	xml.Unmarshal(respBodyBytes, &deviceVar)
	vmHostDevicesServiceAddResponse.device = &deviceVar
	return &vmHostDevicesServiceAddResponse, nil
}

type VmHostDevicesServiceAddResponse struct {
	device *HostDevice
}

func (p *VmHostDevicesServiceAddResponse) Device() *HostDevice {
	return p.device
}

//
// Attach target device to given virtual machine.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/hostdevices
// ----
// With request body of type <<types/host_device,HostDevice>>, for example
// [source,xml]
// ----
// <host_device id="123" />
// ----
// NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
// to *exactly* one host. The device ID is then taken relative to this host.
// NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
// devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
// attribute of the <<types/host_device,HostDevice>> type set to `true`.
// In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
// for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
// This method supports the following parameters:
// `Device`:: The host device to be attached to given virtual machine.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmHostDevicesService) Add(
	device *HostDevice,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*HostDevice,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(device, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var deviceVar HostDevice
	xml.Unmarshal([]byte(ovResp.Body), &deviceVar)
	return &deviceVar, nil
}

type VmHostDevicesServiceListRequest struct {
	vmHostDevicesService *VmHostDevicesService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *VmHostDevicesServiceListRequest) Header(key, value string) *VmHostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDevicesServiceListRequest) Query(key, value string) *VmHostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDevicesServiceListRequest) Max(max int64) *VmHostDevicesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmHostDevicesServiceListRequest) Send() (*VmHostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.Connection.URL(), p.vmHostDevicesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmHostDevicesService.Connection.username, p.vmHostDevicesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmHostDevicesServiceListResponse VmHostDevicesServiceListResponse
	var deviceVar HostDevices
	xml.Unmarshal(respBodyBytes, &deviceVar)
	vmHostDevicesServiceListResponse.device = deviceVar.HostDevices
	return &vmHostDevicesServiceListResponse, nil
}

type VmHostDevicesServiceListResponse struct {
	device []HostDevice
}

func (p *VmHostDevicesServiceListResponse) Device() []HostDevice {
	return p.device
}

//
// List the host devices assigned to given virtual machine.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of devices to return. If not specified all the devices are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmHostDevicesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]HostDevice,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var deviceVar HostDevices
	xml.Unmarshal([]byte(ovResp.Body), &deviceVar)
	return deviceVar.HostDevices, nil
}

//
// Returns a reference to the service that manages a specific host device attached to given virtual machine.
//
func (op *VmHostDevicesService) DeviceService(id string) *VmHostDeviceService {
	return NewVmHostDeviceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmHostDevicesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DeviceService(path)), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *VmHostDevicesService) String() string {
	return fmt.Sprintf("VmHostDevicesService:%s", op.Path)
}

//
//
type AssignedCpuProfileService struct {
	BaseService
}

func NewAssignedCpuProfileService(connection *Connection, path string) *AssignedCpuProfileService {
	var result AssignedCpuProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedCpuProfileServiceGetRequest struct {
	assignedCpuProfileService *AssignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
}

func (p *AssignedCpuProfileServiceGetRequest) Header(key, value string) *AssignedCpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfileServiceGetRequest) Query(key, value string) *AssignedCpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfileServiceGetRequest) Send() (*AssignedCpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfileService.Connection.URL(), p.assignedCpuProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedCpuProfileService.Connection.username, p.assignedCpuProfileService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedCpuProfileServiceGetResponse AssignedCpuProfileServiceGetResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedCpuProfileServiceGetResponse.profile = &profileVar
	return &assignedCpuProfileServiceGetResponse, nil
}

type AssignedCpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *AssignedCpuProfileServiceGetResponse) Profile() *CpuProfile {
	return p.profile
}

//
//
func (op *AssignedCpuProfileService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*CpuProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar CpuProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type AssignedCpuProfileServiceRemoveRequest struct {
	assignedCpuProfileService *AssignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
	async                     *bool
}

func (p *AssignedCpuProfileServiceRemoveRequest) Header(key, value string) *AssignedCpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfileServiceRemoveRequest) Query(key, value string) *AssignedCpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfileServiceRemoveRequest) Async(async bool) *AssignedCpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedCpuProfileServiceRemoveRequest) Send() (*AssignedCpuProfileServiceRemoveResponse, error) {
}

type AssignedCpuProfileServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedCpuProfileService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedCpuProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedCpuProfileService) String() string {
	return fmt.Sprintf("AssignedCpuProfileService:%s", op.Path)
}

//
//
type SnapshotNicService struct {
	BaseService
}

func NewSnapshotNicService(connection *Connection, path string) *SnapshotNicService {
	var result SnapshotNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotNicServiceGetRequest struct {
	snapshotNicService *SnapshotNicService
	header             map[string]string
	query              map[string]string
}

func (p *SnapshotNicServiceGetRequest) Header(key, value string) *SnapshotNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotNicServiceGetRequest) Query(key, value string) *SnapshotNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotNicServiceGetRequest) Send() (*SnapshotNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicService.Connection.URL(), p.snapshotNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotNicService.Connection.username, p.snapshotNicService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotNicServiceGetResponse SnapshotNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	snapshotNicServiceGetResponse.nic = &nicVar
	return &snapshotNicServiceGetResponse, nil
}

type SnapshotNicServiceGetResponse struct {
	nic *Nic
}

func (p *SnapshotNicServiceGetResponse) Nic() *Nic {
	return p.nic
}

//
//
func (op *SnapshotNicService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotNicService) String() string {
	return fmt.Sprintf("SnapshotNicService:%s", op.Path)
}

//
// A service to access a particular device of a host.
//
type HostDeviceService struct {
	BaseService
}

func NewHostDeviceService(connection *Connection, path string) *HostDeviceService {
	var result HostDeviceService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostDeviceServiceGetRequest struct {
	hostDeviceService *HostDeviceService
	header            map[string]string
	query             map[string]string
}

func (p *HostDeviceServiceGetRequest) Header(key, value string) *HostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostDeviceServiceGetRequest) Query(key, value string) *HostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostDeviceServiceGetRequest) Send() (*HostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostDeviceService.Connection.URL(), p.hostDeviceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostDeviceService.Connection.username, p.hostDeviceService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostDeviceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostDeviceServiceGetResponse HostDeviceServiceGetResponse
	var deviceVar HostDevice
	xml.Unmarshal(respBodyBytes, &deviceVar)
	hostDeviceServiceGetResponse.device = &deviceVar
	return &hostDeviceServiceGetResponse, nil
}

type HostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *HostDeviceServiceGetResponse) Device() *HostDevice {
	return p.device
}

//
// Retrieve information about a particular host's device.
// An example of getting a host device:
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/devices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
//   <name>usb_1_9_1_1_0</name>
//   <capability>usb</capability>
//   <host href="/ovirt-engine/api/hosts/123" id="123"/>
//   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
//     <name>usb_1_9_1</name>
//   </parent_device>
// </host_device>
// ----
//
func (op *HostDeviceService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*HostDevice,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var deviceVar HostDevice
	xml.Unmarshal([]byte(ovResp.Body), &deviceVar)
	return &deviceVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostDeviceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostDeviceService) String() string {
	return fmt.Sprintf("HostDeviceService:%s", op.Path)
}

//
// This service manages image transfers, for performing Image I/O API in oVirt.
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
//
type ImageTransfersService struct {
	BaseService
}

func NewImageTransfersService(connection *Connection, path string) *ImageTransfersService {
	var result ImageTransfersService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImageTransfersServiceAddRequest struct {
	imageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *ImageTransfersServiceAddRequest) Header(key, value string) *ImageTransfersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceAddRequest) Query(key, value string) *ImageTransfersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceAddRequest) ImageTransfer(imageTransfer *ImageTransfer) *ImageTransfersServiceAddRequest {
	p.imageTransfer = imageTransfer
	return p
}
func (p *ImageTransfersServiceAddRequest) Send() (*ImageTransfersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.Connection.URL(), p.imageTransfersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.imageTransfer)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransfersService.Connection.username, p.imageTransfersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var imageTransfersServiceAddResponse ImageTransfersServiceAddResponse
	var imageTransferVar ImageTransfer
	xml.Unmarshal(respBodyBytes, &imageTransferVar)
	imageTransfersServiceAddResponse.imageTransfer = &imageTransferVar
	return &imageTransfersServiceAddResponse, nil
}

type ImageTransfersServiceAddResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransfersServiceAddResponse) ImageTransfer() *ImageTransfer {
	return p.imageTransfer
}

//
// Add a new image transfer. An image needs to be specified in order to make
// a new transfer.
//
func (op *ImageTransfersService) Add(
	imageTransfer *ImageTransfer,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ImageTransfer,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(imageTransfer, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var imageTransferVar ImageTransfer
	xml.Unmarshal([]byte(ovResp.Body), &imageTransferVar)
	return &imageTransferVar, nil
}

type ImageTransfersServiceListRequest struct {
	imageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
}

func (p *ImageTransfersServiceListRequest) Header(key, value string) *ImageTransfersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceListRequest) Query(key, value string) *ImageTransfersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceListRequest) Send() (*ImageTransfersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.Connection.URL(), p.imageTransfersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransfersService.Connection.username, p.imageTransfersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var imageTransfersServiceListResponse ImageTransfersServiceListResponse
	var imageTransferVar ImageTransfers
	xml.Unmarshal(respBodyBytes, &imageTransferVar)
	imageTransfersServiceListResponse.imageTransfer = imageTransferVar.ImageTransfers
	return &imageTransfersServiceListResponse, nil
}

type ImageTransfersServiceListResponse struct {
	imageTransfer []ImageTransfer
}

func (p *ImageTransfersServiceListResponse) ImageTransfer() []ImageTransfer {
	return p.imageTransfer
}

//
// Retrieves the list of image transfers that are currently
// being performed.
//
func (op *ImageTransfersService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ImageTransfer,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var imageTransferVar ImageTransfers
	xml.Unmarshal([]byte(ovResp.Body), &imageTransferVar)
	return imageTransferVar.ImageTransfers, nil
}

//
// Returns a reference to the service that manages an
// specific image transfer.
//
func (op *ImageTransfersService) ImageTransferService(id string) *ImageTransferService {
	return NewImageTransferService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageTransfersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ImageTransferService(path)), nil
	}
	return op.ImageTransferService(path[:index]).Service(path[index+1:])
}

func (op *ImageTransfersService) String() string {
	return fmt.Sprintf("ImageTransfersService:%s", op.Path)
}

//
//
type ExternalProviderService struct {
	BaseService
}

func NewExternalProviderService(connection *Connection, path string) *ExternalProviderService {
	var result ExternalProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalProviderServiceImportCertificatesRequest struct {
	externalProviderService *ExternalProviderService
	header                  map[string]string
	query                   map[string]string
	certificates            []Certificate
}

func (p *ExternalProviderServiceImportCertificatesRequest) Header(key, value string) *ExternalProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) Query(key, value string) *ExternalProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *ExternalProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *ExternalProviderServiceImportCertificatesRequest) Send() (*ExternalProviderServiceImportCertificatesResponse, error) {
}

type ExternalProviderServiceImportCertificatesResponse struct {
}

//
//
func (op *ExternalProviderService) ImportCertificates(
	certificates []Certificate,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Certificates: certificates,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "importcertificates", headers, query, wait)
	return err
}

type ExternalProviderServiceTestConnectivityRequest struct {
	externalProviderService *ExternalProviderService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *ExternalProviderServiceTestConnectivityRequest) Header(key, value string) *ExternalProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderServiceTestConnectivityRequest) Query(key, value string) *ExternalProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderServiceTestConnectivityRequest) Async(async bool) *ExternalProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *ExternalProviderServiceTestConnectivityRequest) Send() (*ExternalProviderServiceTestConnectivityResponse, error) {
}

type ExternalProviderServiceTestConnectivityResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the test should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalProviderService) TestConnectivity(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "testconnectivity", headers, query, wait)
	return err
}

//
//
func (op *ExternalProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalProviderService) String() string {
	return fmt.Sprintf("ExternalProviderService:%s", op.Path)
}

//
// A service to manage an event in the system.
//
type EventService struct {
	BaseService
}

func NewEventService(connection *Connection, path string) *EventService {
	var result EventService
	result.Connection = connection
	result.Path = path
	return &result
}

type EventServiceGetRequest struct {
	eventService *EventService
	header       map[string]string
	query        map[string]string
}

func (p *EventServiceGetRequest) Header(key, value string) *EventServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventServiceGetRequest) Query(key, value string) *EventServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventServiceGetRequest) Send() (*EventServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventService.Connection.URL(), p.eventService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.eventService.Connection.username, p.eventService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.eventService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var eventServiceGetResponse EventServiceGetResponse
	var eventVar Event
	xml.Unmarshal(respBodyBytes, &eventVar)
	eventServiceGetResponse.event = &eventVar
	return &eventServiceGetResponse, nil
}

type EventServiceGetResponse struct {
	event *Event
}

func (p *EventServiceGetResponse) Event() *Event {
	return p.event
}

//
// Get an event.
// An example of getting an event:
// [source]
// ----
// GET /ovirt-engine/api/events/123
// ----
// [source,xml]
// ----
// <event href="/ovirt-engine/api/events/123" id="123">
//   <description>Host example.com was added by admin@internal-authz.</description>
//   <code>42</code>
//   <correlation_id>135</correlation_id>
//   <custom_id>-1</custom_id>
//   <flood_rate>30</flood_rate>
//   <origin>oVirt</origin>
//   <severity>normal</severity>
//   <time>2016-12-11T11:13:44.654+02:00</time>
//   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
//   <host href="/ovirt-engine/api/hosts/789" id="789"/>
//   <user href="/ovirt-engine/api/users/987" id="987"/>
// </event>
// ----
// Note that the number of fields changes according to the information that resides on the event.
// For example, for storage domain related events you will get the storage domain reference,
// as well as the reference for the data center this storage domain resides in.
//
func (op *EventService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Event,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var eventVar Event
	xml.Unmarshal([]byte(ovResp.Body), &eventVar)
	return &eventVar, nil
}

type EventServiceRemoveRequest struct {
	eventService *EventService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *EventServiceRemoveRequest) Header(key, value string) *EventServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventServiceRemoveRequest) Query(key, value string) *EventServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventServiceRemoveRequest) Async(async bool) *EventServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *EventServiceRemoveRequest) Send() (*EventServiceRemoveResponse, error) {
}

type EventServiceRemoveResponse struct {
}

//
// Removes an event from internal audit log.
// An event can be removed by sending following request
// [source]
// ----
// DELETE /ovirt-engine/api/events/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *EventService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *EventService) String() string {
	return fmt.Sprintf("EventService:%s", op.Path)
}

//
// Represents a readonly network filters sub-collection.
// The network filter enables to filter packets send to/from the VM's nic according to defined rules.
// For more information please refer to <<services/network_filter,NetworkFilter>> service documentation
// Network filters are supported in different versions, starting from version 3.0.
// A network filter is defined for each vnic profile.
// A vnic profile is defined for a specific network.
// A network can be assigned to several different clusters. In the future, each network will be defined in
// cluster level.
// Currently, each network is being defined at data center level. Potential network filters for each network
// are determined by the network's data center compatibility version V.
// V must be >= the network filter version in order to configure this network filter for a specific network.
// Please note, that if a network is assigned to cluster with a version supporting a network filter, the filter
// may not be available due to the data center version being smaller then the network filter's version.
// Example of listing all of the supported network filters for a specific cluster:
// [source]
// ----
// GET http://localhost:8080/ovirt-engine/api/clusters/{cluster:id}/networkfilters
// ----
// Output:
// [source,xml]
// ----
// <network_filters>
//   <network_filter id="00000019-0019-0019-0019-00000000026c">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026b">
//     <name>example-network-filter-b</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026a">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>3</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
// </network_filters>
// ----
//
type NetworkFiltersService struct {
	BaseService
}

func NewNetworkFiltersService(connection *Connection, path string) *NetworkFiltersService {
	var result NetworkFiltersService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFiltersServiceListRequest struct {
	networkFiltersService *NetworkFiltersService
	header                map[string]string
	query                 map[string]string
}

func (p *NetworkFiltersServiceListRequest) Header(key, value string) *NetworkFiltersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFiltersServiceListRequest) Query(key, value string) *NetworkFiltersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFiltersServiceListRequest) Send() (*NetworkFiltersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFiltersService.Connection.URL(), p.networkFiltersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFiltersService.Connection.username, p.networkFiltersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFiltersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkFiltersServiceListResponse NetworkFiltersServiceListResponse
	var filtersVar NetworkFilters
	xml.Unmarshal(respBodyBytes, &filtersVar)
	networkFiltersServiceListResponse.filters = filtersVar.NetworkFilters
	return &networkFiltersServiceListResponse, nil
}

type NetworkFiltersServiceListResponse struct {
	filters []NetworkFilter
}

func (p *NetworkFiltersServiceListResponse) Filters() []NetworkFilter {
	return p.filters
}

//
// Retrieves the representations of the network filters.
//
func (op *NetworkFiltersService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]NetworkFilter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var filtersVar NetworkFilters
	xml.Unmarshal([]byte(ovResp.Body), &filtersVar)
	return filtersVar.NetworkFilters, nil
}

//
//
func (op *NetworkFiltersService) NetworkFilterService(id string) *NetworkFilterService {
	return NewNetworkFilterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFiltersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkFilterService(path)), nil
	}
	return op.NetworkFilterService(path[:index]).Service(path[index+1:])
}

func (op *NetworkFiltersService) String() string {
	return fmt.Sprintf("NetworkFiltersService:%s", op.Path)
}

//
//
type StatisticService struct {
	BaseService
}

func NewStatisticService(connection *Connection, path string) *StatisticService {
	var result StatisticService
	result.Connection = connection
	result.Path = path
	return &result
}

type StatisticServiceGetRequest struct {
	statisticService *StatisticService
	header           map[string]string
	query            map[string]string
	statistic        *Statistic
}

func (p *StatisticServiceGetRequest) Header(key, value string) *StatisticServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StatisticServiceGetRequest) Query(key, value string) *StatisticServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StatisticServiceGetRequest) Statistic(statistic *Statistic) *StatisticServiceGetRequest {
	p.statistic = statistic
	return p
}
func (p *StatisticServiceGetRequest) Send() (*StatisticServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.statisticService.Connection.URL(), p.statisticService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.statisticService.Connection.username, p.statisticService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.statisticService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var statisticServiceGetResponse StatisticServiceGetResponse
	var statisticVar Statistic
	xml.Unmarshal(respBodyBytes, &statisticVar)
	statisticServiceGetResponse.statistic = &statisticVar
	return &statisticServiceGetResponse, nil
}

type StatisticServiceGetResponse struct {
	statistic *Statistic
}

func (p *StatisticServiceGetResponse) Statistic() *Statistic {
	return p.statistic
}

//
//
func (op *StatisticService) Get(
	statistic *Statistic,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Statistic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["statistic"] = fmt.Sprintf("%v", statistic)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var statisticVar Statistic
	xml.Unmarshal([]byte(ovResp.Body), &statisticVar)
	return &statisticVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StatisticService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StatisticService) String() string {
	return fmt.Sprintf("StatisticService:%s", op.Path)
}

//
// Provides capability to import external virtual machines.
//
type ExternalVmImportsService struct {
	BaseService
}

func NewExternalVmImportsService(connection *Connection, path string) *ExternalVmImportsService {
	var result ExternalVmImportsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalVmImportsServiceAddRequest struct {
	externalVmImportsService *ExternalVmImportsService
	header                   map[string]string
	query                    map[string]string
	import_                  *ExternalVmImport
}

func (p *ExternalVmImportsServiceAddRequest) Header(key, value string) *ExternalVmImportsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalVmImportsServiceAddRequest) Query(key, value string) *ExternalVmImportsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalVmImportsServiceAddRequest) Import(import_ *ExternalVmImport) *ExternalVmImportsServiceAddRequest {
	p.import_ = import_
	return p
}
func (p *ExternalVmImportsServiceAddRequest) Send() (*ExternalVmImportsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalVmImportsService.Connection.URL(), p.externalVmImportsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.import_)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalVmImportsService.Connection.username, p.externalVmImportsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalVmImportsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalVmImportsServiceAddResponse ExternalVmImportsServiceAddResponse
	var import_Var ExternalVmImport
	xml.Unmarshal(respBodyBytes, &import_Var)
	externalVmImportsServiceAddResponse.import_ = &import_Var
	return &externalVmImportsServiceAddResponse, nil
}

type ExternalVmImportsServiceAddResponse struct {
	import_ *ExternalVmImport
}

func (p *ExternalVmImportsServiceAddResponse) Import_() *ExternalVmImport {
	return p.import_
}

//
// This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
// For example import of a virtual machine from VMware can be facilitated using the following request:
// [source]
// ----
// POST /externalvmimports
// ----
// With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
// [source,xml]
// ----
// <external_vm_import>
//   <vm>
//     <name>my_vm</name>
//   </vm>
//   <cluster id="360014051136c20574f743bdbd28177fd" />
//   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
//   <name>vm_name_as_is_in_vmware</name>
//   <sparse>true</sparse>
//   <username>vmware_user</username>
//   <password>123456</password>
//   <provider>VMWARE</provider>
//   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
//   <drivers_iso id="virtio-win-1.6.7.iso" />
// </external_vm_import>
// ----
//
func (op *ExternalVmImportsService) Add(
	import_ *ExternalVmImport,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalVmImport,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(import_, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var import_Var ExternalVmImport
	xml.Unmarshal([]byte(ovResp.Body), &import_Var)
	return &import_Var, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalVmImportsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalVmImportsService) String() string {
	return fmt.Sprintf("ExternalVmImportsService:%s", op.Path)
}

//
// Represents a roles sub-collection, for example scoped by user.
//
type AssignedRolesService struct {
	BaseService
}

func NewAssignedRolesService(connection *Connection, path string) *AssignedRolesService {
	var result AssignedRolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedRolesServiceListRequest struct {
	assignedRolesService *AssignedRolesService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *AssignedRolesServiceListRequest) Header(key, value string) *AssignedRolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedRolesServiceListRequest) Query(key, value string) *AssignedRolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedRolesServiceListRequest) Max(max int64) *AssignedRolesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedRolesServiceListRequest) Send() (*AssignedRolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedRolesService.Connection.URL(), p.assignedRolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedRolesService.Connection.username, p.assignedRolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedRolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedRolesServiceListResponse AssignedRolesServiceListResponse
	var rolesVar Roles
	xml.Unmarshal(respBodyBytes, &rolesVar)
	assignedRolesServiceListResponse.roles = rolesVar.Roles
	return &assignedRolesServiceListResponse, nil
}

type AssignedRolesServiceListResponse struct {
	roles []Role
}

func (p *AssignedRolesServiceListResponse) Roles() []Role {
	return p.roles
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of roles to return. If not specified all the roles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedRolesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Role,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var rolesVar Roles
	xml.Unmarshal([]byte(ovResp.Body), &rolesVar)
	return rolesVar.Roles, nil
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *AssignedRolesService) RoleService(id string) *RoleService {
	return NewRoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedRolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.RoleService(path)), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *AssignedRolesService) String() string {
	return fmt.Sprintf("AssignedRolesService:%s", op.Path)
}

//
// This service manages a parameter for a network filter.
//
type NetworkFilterParameterService struct {
	BaseService
}

func NewNetworkFilterParameterService(connection *Connection, path string) *NetworkFilterParameterService {
	var result NetworkFilterParameterService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFilterParameterServiceGetRequest struct {
	networkFilterParameterService *NetworkFilterParameterService
	header                        map[string]string
	query                         map[string]string
}

func (p *NetworkFilterParameterServiceGetRequest) Header(key, value string) *NetworkFilterParameterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParameterServiceGetRequest) Query(key, value string) *NetworkFilterParameterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParameterServiceGetRequest) Send() (*NetworkFilterParameterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParameterService.Connection.URL(), p.networkFilterParameterService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParameterService.Connection.username, p.networkFilterParameterService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParameterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkFilterParameterServiceGetResponse NetworkFilterParameterServiceGetResponse
	var parameterVar NetworkFilterParameter
	xml.Unmarshal(respBodyBytes, &parameterVar)
	networkFilterParameterServiceGetResponse.parameter = &parameterVar
	return &networkFilterParameterServiceGetResponse, nil
}

type NetworkFilterParameterServiceGetResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NetworkFilterParameterServiceGetResponse) Parameter() *NetworkFilterParameter {
	return p.parameter
}

//
// Retrieves a representation of the network filter parameter.
//
func (op *NetworkFilterParameterService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkFilterParameter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var parameterVar NetworkFilterParameter
	xml.Unmarshal([]byte(ovResp.Body), &parameterVar)
	return &parameterVar, nil
}

type NetworkFilterParameterServiceRemoveRequest struct {
	networkFilterParameterService *NetworkFilterParameterService
	header                        map[string]string
	query                         map[string]string
}

func (p *NetworkFilterParameterServiceRemoveRequest) Header(key, value string) *NetworkFilterParameterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParameterServiceRemoveRequest) Query(key, value string) *NetworkFilterParameterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParameterServiceRemoveRequest) Send() (*NetworkFilterParameterServiceRemoveResponse, error) {
}

type NetworkFilterParameterServiceRemoveResponse struct {
}

//
// Removes the filter parameter.
// For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
//
func (op *NetworkFilterParameterService) Remove(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type NetworkFilterParameterServiceUpdateRequest struct {
	networkFilterParameterService *NetworkFilterParameterService
	header                        map[string]string
	query                         map[string]string
	parameter                     *NetworkFilterParameter
}

func (p *NetworkFilterParameterServiceUpdateRequest) Header(key, value string) *NetworkFilterParameterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParameterServiceUpdateRequest) Query(key, value string) *NetworkFilterParameterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParameterServiceUpdateRequest) Parameter(parameter *NetworkFilterParameter) *NetworkFilterParameterServiceUpdateRequest {
	p.parameter = parameter
	return p
}
func (p *NetworkFilterParameterServiceUpdateRequest) Send() (*NetworkFilterParameterServiceUpdateResponse, error) {
}

type NetworkFilterParameterServiceUpdateResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NetworkFilterParameterServiceUpdateResponse) Parameter() *NetworkFilterParameter {
	return p.parameter
}

//
// Updates the network filter parameter.
// For example, to update the network filter parameter having with with id `123` on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>updatedName</name>
//   <value>updatedValue</value>
// </network_filter_parameter>
// ----
// This method supports the following parameters:
// `Parameter`:: The network filter parameter that is being updated.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworkFilterParameterService) Update(
	parameter *NetworkFilterParameter,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkFilterParameter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request
	ovResp, err := op.internalUpdate(parameter, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var parameterVar NetworkFilterParameter
	xml.Unmarshal([]byte(ovResp.Body), &parameterVar)
	return &parameterVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFilterParameterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkFilterParameterService) String() string {
	return fmt.Sprintf("NetworkFilterParameterService:%s", op.Path)
}

//
//
type OpenstackImageProviderService struct {
	BaseService
}

func NewOpenstackImageProviderService(connection *Connection, path string) *OpenstackImageProviderService {
	var result OpenstackImageProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImageProviderServiceGetRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
}

func (p *OpenstackImageProviderServiceGetRequest) Header(key, value string) *OpenstackImageProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceGetRequest) Query(key, value string) *OpenstackImageProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceGetRequest) Send() (*OpenstackImageProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.Connection.URL(), p.openstackImageProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProviderService.Connection.username, p.openstackImageProviderService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackImageProviderServiceGetResponse OpenstackImageProviderServiceGetResponse
	var providerVar OpenStackImageProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackImageProviderServiceGetResponse.provider = &providerVar
	return &openstackImageProviderServiceGetResponse, nil
}

type OpenstackImageProviderServiceGetResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceGetResponse) Provider() *OpenStackImageProvider {
	return p.provider
}

//
//
func (op *OpenstackImageProviderService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackImageProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackImageProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type OpenstackImageProviderServiceImportCertificatesRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	certificates                  []Certificate
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackImageProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackImageProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *OpenstackImageProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *OpenstackImageProviderServiceImportCertificatesRequest) Send() (*OpenstackImageProviderServiceImportCertificatesResponse, error) {
}

type OpenstackImageProviderServiceImportCertificatesResponse struct {
}

//
//
func (op *OpenstackImageProviderService) ImportCertificates(
	certificates []Certificate,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Certificates: certificates,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "importcertificates", headers, query, wait)
	return err
}

type OpenstackImageProviderServiceRemoveRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *OpenstackImageProviderServiceRemoveRequest) Header(key, value string) *OpenstackImageProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceRemoveRequest) Query(key, value string) *OpenstackImageProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceRemoveRequest) Async(async bool) *OpenstackImageProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageProviderServiceRemoveRequest) Send() (*OpenstackImageProviderServiceRemoveResponse, error) {
}

type OpenstackImageProviderServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackImageProviderService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type OpenstackImageProviderServiceTestConnectivityRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackImageProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackImageProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackImageProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageProviderServiceTestConnectivityRequest) Send() (*OpenstackImageProviderServiceTestConnectivityResponse, error) {
}

type OpenstackImageProviderServiceTestConnectivityResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the test should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackImageProviderService) TestConnectivity(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "testconnectivity", headers, query, wait)
	return err
}

type OpenstackImageProviderServiceUpdateRequest struct {
	openstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	provider                      *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceUpdateRequest) Header(key, value string) *OpenstackImageProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Query(key, value string) *OpenstackImageProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Async(async bool) *OpenstackImageProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageProviderServiceUpdateRequest) Provider(provider *OpenStackImageProvider) *OpenstackImageProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *OpenstackImageProviderServiceUpdateRequest) Send() (*OpenstackImageProviderServiceUpdateResponse, error) {
}

type OpenstackImageProviderServiceUpdateResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceUpdateResponse) Provider() *OpenStackImageProvider {
	return p.provider
}

//
//
func (op *OpenstackImageProviderService) Update(
	provider *OpenStackImageProvider,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackImageProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackImageProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

//
//
func (op *OpenstackImageProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
//
func (op *OpenstackImageProviderService) ImagesService() *OpenstackImagesService {
	return NewOpenstackImagesService(op.Connection, fmt.Sprintf("%s/images", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackImageProviderService) String() string {
	return fmt.Sprintf("OpenstackImageProviderService:%s", op.Path)
}

//
//
type OpenstackNetworkService struct {
	BaseService
}

func NewOpenstackNetworkService(connection *Connection, path string) *OpenstackNetworkService {
	var result OpenstackNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworkServiceGetRequest struct {
	openstackNetworkService *OpenstackNetworkService
	header                  map[string]string
	query                   map[string]string
}

func (p *OpenstackNetworkServiceGetRequest) Header(key, value string) *OpenstackNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkServiceGetRequest) Query(key, value string) *OpenstackNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkServiceGetRequest) Send() (*OpenstackNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkService.Connection.URL(), p.openstackNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkService.Connection.username, p.openstackNetworkService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackNetworkServiceGetResponse OpenstackNetworkServiceGetResponse
	var networkVar OpenStackNetwork
	xml.Unmarshal(respBodyBytes, &networkVar)
	openstackNetworkServiceGetResponse.network = &networkVar
	return &openstackNetworkServiceGetResponse, nil
}

type OpenstackNetworkServiceGetResponse struct {
	network *OpenStackNetwork
}

func (p *OpenstackNetworkServiceGetResponse) Network() *OpenStackNetwork {
	return p.network
}

//
//
func (op *OpenstackNetworkService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackNetwork,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar OpenStackNetwork
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type OpenstackNetworkServiceImportRequest struct {
	openstackNetworkService *OpenstackNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	dataCenter              *DataCenter
}

func (p *OpenstackNetworkServiceImportRequest) Header(key, value string) *OpenstackNetworkServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkServiceImportRequest) Query(key, value string) *OpenstackNetworkServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkServiceImportRequest) Async(async bool) *OpenstackNetworkServiceImportRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkServiceImportRequest) DataCenter(dataCenter *DataCenter) *OpenstackNetworkServiceImportRequest {
	p.dataCenter = dataCenter
	return p
}
func (p *OpenstackNetworkServiceImportRequest) Send() (*OpenstackNetworkServiceImportResponse, error) {
}

type OpenstackNetworkServiceImportResponse struct {
}

//
// This operation imports an external network into oVirt.
// The network will be added to the data center specified.
// This method supports the following parameters:
// `DataCenter`:: The data center into which the network is to be imported.
// Data center is mandatory, and can be specified
// using the `id` or `name` attributes, the rest of
// the attributes will be ignored.
// `Async`:: Indicates if the import should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackNetworkService) Import(
	async bool,
	dataCenter *DataCenter,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:      &async,
		DataCenter: dataCenter,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "import", headers, query, wait)
	return err
}

//
//
func (op *OpenstackNetworkService) SubnetsService() *OpenstackSubnetsService {
	return NewOpenstackSubnetsService(op.Connection, fmt.Sprintf("%s/subnets", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "subnets" {
		return op.SubnetsService(), nil
	}
	if strings.HasPrefix(path, "subnets/") {
		return op.SubnetsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackNetworkService) String() string {
	return fmt.Sprintf("OpenstackNetworkService:%s", op.Path)
}

//
//
type OpenstackImageProvidersService struct {
	BaseService
}

func NewOpenstackImageProvidersService(connection *Connection, path string) *OpenstackImageProvidersService {
	var result OpenstackImageProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImageProvidersServiceAddRequest struct {
	openstackImageProvidersService *OpenstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	provider                       *OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceAddRequest) Header(key, value string) *OpenstackImageProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceAddRequest) Query(key, value string) *OpenstackImageProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceAddRequest) Provider(provider *OpenStackImageProvider) *OpenstackImageProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *OpenstackImageProvidersServiceAddRequest) Send() (*OpenstackImageProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.Connection.URL(), p.openstackImageProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProvidersService.Connection.username, p.openstackImageProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackImageProvidersServiceAddResponse OpenstackImageProvidersServiceAddResponse
	var providerVar OpenStackImageProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackImageProvidersServiceAddResponse.provider = &providerVar
	return &openstackImageProvidersServiceAddResponse, nil
}

type OpenstackImageProvidersServiceAddResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceAddResponse) Provider() *OpenStackImageProvider {
	return p.provider
}

//
//
func (op *OpenstackImageProvidersService) Add(
	provider *OpenStackImageProvider,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackImageProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackImageProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type OpenstackImageProvidersServiceListRequest struct {
	openstackImageProvidersService *OpenstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	max                            *int64
}

func (p *OpenstackImageProvidersServiceListRequest) Header(key, value string) *OpenstackImageProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Query(key, value string) *OpenstackImageProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Max(max int64) *OpenstackImageProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackImageProvidersServiceListRequest) Send() (*OpenstackImageProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.Connection.URL(), p.openstackImageProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageProvidersService.Connection.username, p.openstackImageProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackImageProvidersServiceListResponse OpenstackImageProvidersServiceListResponse
	var providersVar OpenStackImageProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	openstackImageProvidersServiceListResponse.providers = providersVar.OpenStackImageProviders
	return &openstackImageProvidersServiceListResponse, nil
}

type OpenstackImageProvidersServiceListResponse struct {
	providers []OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceListResponse) Providers() []OpenStackImageProvider {
	return p.providers
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of providers to return. If not specified all the providers are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackImageProvidersService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenStackImageProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providersVar OpenStackImageProviders
	xml.Unmarshal([]byte(ovResp.Body), &providersVar)
	return providersVar.OpenStackImageProviders, nil
}

//
//
func (op *OpenstackImageProvidersService) ProviderService(id string) *OpenstackImageProviderService {
	return NewOpenstackImageProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackImageProvidersService) String() string {
	return fmt.Sprintf("OpenstackImageProvidersService:%s", op.Path)
}

//
//
type OpenstackVolumeAuthenticationKeyService struct {
	BaseService
}

func NewOpenstackVolumeAuthenticationKeyService(connection *Connection, path string) *OpenstackVolumeAuthenticationKeyService {
	var result OpenstackVolumeAuthenticationKeyService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeAuthenticationKeyServiceGetRequest struct {
	openstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.Connection.URL(), p.openstackVolumeAuthenticationKeyService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeyService.Connection.username, p.openstackVolumeAuthenticationKeyService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeAuthenticationKeyServiceGetResponse OpenstackVolumeAuthenticationKeyServiceGetResponse
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	openstackVolumeAuthenticationKeyServiceGetResponse.key = &keyVar
	return &openstackVolumeAuthenticationKeyServiceGetResponse, nil
}

type OpenstackVolumeAuthenticationKeyServiceGetResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetResponse) Key() *OpenstackVolumeAuthenticationKey {
	return p.key
}

//
//
func (op *OpenstackVolumeAuthenticationKeyService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenstackVolumeAuthenticationKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal([]byte(ovResp.Body), &keyVar)
	return &keyVar, nil
}

type OpenstackVolumeAuthenticationKeyServiceRemoveRequest struct {
	openstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Async(async bool) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceRemoveResponse, error) {
}

type OpenstackVolumeAuthenticationKeyServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackVolumeAuthenticationKeyService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type OpenstackVolumeAuthenticationKeyServiceUpdateRequest struct {
	openstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	key                                     *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Key(key *OpenstackVolumeAuthenticationKey) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	p.key = key
	return p
}
func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceUpdateResponse, error) {
}

type OpenstackVolumeAuthenticationKeyServiceUpdateResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateResponse) Key() *OpenstackVolumeAuthenticationKey {
	return p.key
}

//
//
func (op *OpenstackVolumeAuthenticationKeyService) Update(
	key *OpenstackVolumeAuthenticationKey,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenstackVolumeAuthenticationKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request
	ovResp, err := op.internalUpdate(key, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal([]byte(ovResp.Body), &keyVar)
	return &keyVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeAuthenticationKeyService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeAuthenticationKeyService) String() string {
	return fmt.Sprintf("OpenstackVolumeAuthenticationKeyService:%s", op.Path)
}

//
//
type OpenstackImagesService struct {
	BaseService
}

func NewOpenstackImagesService(connection *Connection, path string) *OpenstackImagesService {
	var result OpenstackImagesService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImagesServiceListRequest struct {
	openstackImagesService *OpenstackImagesService
	header                 map[string]string
	query                  map[string]string
	max                    *int64
}

func (p *OpenstackImagesServiceListRequest) Header(key, value string) *OpenstackImagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImagesServiceListRequest) Query(key, value string) *OpenstackImagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImagesServiceListRequest) Max(max int64) *OpenstackImagesServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackImagesServiceListRequest) Send() (*OpenstackImagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImagesService.Connection.URL(), p.openstackImagesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImagesService.Connection.username, p.openstackImagesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImagesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackImagesServiceListResponse OpenstackImagesServiceListResponse
	var imagesVar OpenStackImages
	xml.Unmarshal(respBodyBytes, &imagesVar)
	openstackImagesServiceListResponse.images = imagesVar.OpenStackImages
	return &openstackImagesServiceListResponse, nil
}

type OpenstackImagesServiceListResponse struct {
	images []OpenStackImage
}

func (p *OpenstackImagesServiceListResponse) Images() []OpenStackImage {
	return p.images
}

//
// Lists the images of a Glance image storage domain.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of images to return. If not specified all the images are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackImagesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenStackImage,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var imagesVar OpenStackImages
	xml.Unmarshal([]byte(ovResp.Body), &imagesVar)
	return imagesVar.OpenStackImages, nil
}

//
// Returns a reference to the service that manages a specific image.
//
func (op *OpenstackImagesService) ImageService(id string) *OpenstackImageService {
	return NewOpenstackImageService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImagesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ImageService(path)), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackImagesService) String() string {
	return fmt.Sprintf("OpenstackImagesService:%s", op.Path)
}

//
// This service manages OpenStack network providers.
//
type OpenstackNetworkProvidersService struct {
	BaseService
}

func NewOpenstackNetworkProvidersService(connection *Connection, path string) *OpenstackNetworkProvidersService {
	var result OpenstackNetworkProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworkProvidersServiceAddRequest struct {
	openstackNetworkProvidersService *OpenstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	provider                         *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Header(key, value string) *OpenstackNetworkProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Query(key, value string) *OpenstackNetworkProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Provider(provider *OpenStackNetworkProvider) *OpenstackNetworkProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *OpenstackNetworkProvidersServiceAddRequest) Send() (*OpenstackNetworkProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.Connection.URL(), p.openstackNetworkProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProvidersService.Connection.username, p.openstackNetworkProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackNetworkProvidersServiceAddResponse OpenstackNetworkProvidersServiceAddResponse
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackNetworkProvidersServiceAddResponse.provider = &providerVar
	return &openstackNetworkProvidersServiceAddResponse, nil
}

type OpenstackNetworkProvidersServiceAddResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceAddResponse) Provider() *OpenStackNetworkProvider {
	return p.provider
}

//
// The operation adds a new network provider to the system.
// If the `type` property is not present, a default value of `NEUTRON` will be used.
//
func (op *OpenstackNetworkProvidersService) Add(
	provider *OpenStackNetworkProvider,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackNetworkProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type OpenstackNetworkProvidersServiceListRequest struct {
	openstackNetworkProvidersService *OpenstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	max                              *int64
}

func (p *OpenstackNetworkProvidersServiceListRequest) Header(key, value string) *OpenstackNetworkProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Query(key, value string) *OpenstackNetworkProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Max(max int64) *OpenstackNetworkProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackNetworkProvidersServiceListRequest) Send() (*OpenstackNetworkProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.Connection.URL(), p.openstackNetworkProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProvidersService.Connection.username, p.openstackNetworkProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackNetworkProvidersServiceListResponse OpenstackNetworkProvidersServiceListResponse
	var providersVar OpenStackNetworkProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	openstackNetworkProvidersServiceListResponse.providers = providersVar.OpenStackNetworkProviders
	return &openstackNetworkProvidersServiceListResponse, nil
}

type OpenstackNetworkProvidersServiceListResponse struct {
	providers []OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceListResponse) Providers() []OpenStackNetworkProvider {
	return p.providers
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of providers to return. If not specified all the providers are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackNetworkProvidersService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenStackNetworkProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providersVar OpenStackNetworkProviders
	xml.Unmarshal([]byte(ovResp.Body), &providersVar)
	return providersVar.OpenStackNetworkProviders, nil
}

//
// Reference to OpenStack network provider service.
//
func (op *OpenstackNetworkProvidersService) ProviderService(id string) *OpenstackNetworkProviderService {
	return NewOpenstackNetworkProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackNetworkProvidersService) String() string {
	return fmt.Sprintf("OpenstackNetworkProvidersService:%s", op.Path)
}

//
//
type OpenstackVolumeProvidersService struct {
	BaseService
}

func NewOpenstackVolumeProvidersService(connection *Connection, path string) *OpenstackVolumeProvidersService {
	var result OpenstackVolumeProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeProvidersServiceAddRequest struct {
	openstackVolumeProvidersService *OpenstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	provider                        *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Header(key, value string) *OpenstackVolumeProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Query(key, value string) *OpenstackVolumeProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Provider(provider *OpenStackVolumeProvider) *OpenstackVolumeProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *OpenstackVolumeProvidersServiceAddRequest) Send() (*OpenstackVolumeProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.Connection.URL(), p.openstackVolumeProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProvidersService.Connection.username, p.openstackVolumeProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeProvidersServiceAddResponse OpenstackVolumeProvidersServiceAddResponse
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackVolumeProvidersServiceAddResponse.provider = &providerVar
	return &openstackVolumeProvidersServiceAddResponse, nil
}

type OpenstackVolumeProvidersServiceAddResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceAddResponse) Provider() *OpenStackVolumeProvider {
	return p.provider
}

//
// Adds a new volume provider.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/openstackvolumeproviders
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_volume_provider>
//   <name>mycinder</name>
//   <url>https://mycinder.example.com:8776</url>
//   <data_center>
//     <name>mydc</name>
//   </data_center>
//   <requires_authentication>true</requires_authentication>
//   <username>admin</username>
//   <password>mypassword</password>
//   <tenant_name>mytenant</tenant_name>
// </openstack_volume_provider>
// ----
//
func (op *OpenstackVolumeProvidersService) Add(
	provider *OpenStackVolumeProvider,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackVolumeProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type OpenstackVolumeProvidersServiceListRequest struct {
	openstackVolumeProvidersService *OpenstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *OpenstackVolumeProvidersServiceListRequest) Header(key, value string) *OpenstackVolumeProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Query(key, value string) *OpenstackVolumeProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Max(max int64) *OpenstackVolumeProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackVolumeProvidersServiceListRequest) Send() (*OpenstackVolumeProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.Connection.URL(), p.openstackVolumeProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProvidersService.Connection.username, p.openstackVolumeProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeProvidersServiceListResponse OpenstackVolumeProvidersServiceListResponse
	var providersVar OpenStackVolumeProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	openstackVolumeProvidersServiceListResponse.providers = providersVar.OpenStackVolumeProviders
	return &openstackVolumeProvidersServiceListResponse, nil
}

type OpenstackVolumeProvidersServiceListResponse struct {
	providers []OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceListResponse) Providers() []OpenStackVolumeProvider {
	return p.providers
}

//
// Retrieves the list of volume providers.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of providers to return. If not specified all the providers are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackVolumeProvidersService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenStackVolumeProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providersVar OpenStackVolumeProviders
	xml.Unmarshal([]byte(ovResp.Body), &providersVar)
	return providersVar.OpenStackVolumeProviders, nil
}

//
//
func (op *OpenstackVolumeProvidersService) ProviderService(id string) *OpenstackVolumeProviderService {
	return NewOpenstackVolumeProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeProvidersService) String() string {
	return fmt.Sprintf("OpenstackVolumeProvidersService:%s", op.Path)
}

//
//
type OpenstackNetworksService struct {
	BaseService
}

func NewOpenstackNetworksService(connection *Connection, path string) *OpenstackNetworksService {
	var result OpenstackNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworksServiceListRequest struct {
	openstackNetworksService *OpenstackNetworksService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *OpenstackNetworksServiceListRequest) Header(key, value string) *OpenstackNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworksServiceListRequest) Query(key, value string) *OpenstackNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworksServiceListRequest) Max(max int64) *OpenstackNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackNetworksServiceListRequest) Send() (*OpenstackNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworksService.Connection.URL(), p.openstackNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworksService.Connection.username, p.openstackNetworksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackNetworksServiceListResponse OpenstackNetworksServiceListResponse
	var networksVar OpenStackNetworks
	xml.Unmarshal(respBodyBytes, &networksVar)
	openstackNetworksServiceListResponse.networks = networksVar.OpenStackNetworks
	return &openstackNetworksServiceListResponse, nil
}

type OpenstackNetworksServiceListResponse struct {
	networks []OpenStackNetwork
}

func (p *OpenstackNetworksServiceListResponse) Networks() []OpenStackNetwork {
	return p.networks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of networks to return. If not specified all the networks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackNetworksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenStackNetwork,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networksVar OpenStackNetworks
	xml.Unmarshal([]byte(ovResp.Body), &networksVar)
	return networksVar.OpenStackNetworks, nil
}

//
//
func (op *OpenstackNetworksService) NetworkService(id string) *OpenstackNetworkService {
	return NewOpenstackNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackNetworksService) String() string {
	return fmt.Sprintf("OpenstackNetworksService:%s", op.Path)
}

//
//
type OpenstackVolumeProviderService struct {
	BaseService
}

func NewOpenstackVolumeProviderService(connection *Connection, path string) *OpenstackVolumeProviderService {
	var result OpenstackVolumeProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeProviderServiceGetRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
}

func (p *OpenstackVolumeProviderServiceGetRequest) Header(key, value string) *OpenstackVolumeProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceGetRequest) Query(key, value string) *OpenstackVolumeProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceGetRequest) Send() (*OpenstackVolumeProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.Connection.URL(), p.openstackVolumeProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeProviderService.Connection.username, p.openstackVolumeProviderService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeProviderServiceGetResponse OpenstackVolumeProviderServiceGetResponse
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackVolumeProviderServiceGetResponse.provider = &providerVar
	return &openstackVolumeProviderServiceGetResponse, nil
}

type OpenstackVolumeProviderServiceGetResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceGetResponse) Provider() *OpenStackVolumeProvider {
	return p.provider
}

//
//
func (op *OpenstackVolumeProviderService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackVolumeProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type OpenstackVolumeProviderServiceImportCertificatesRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	certificates                   []Certificate
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Send() (*OpenstackVolumeProviderServiceImportCertificatesResponse, error) {
}

type OpenstackVolumeProviderServiceImportCertificatesResponse struct {
}

//
//
func (op *OpenstackVolumeProviderService) ImportCertificates(
	certificates []Certificate,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Certificates: certificates,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "importcertificates", headers, query, wait)
	return err
}

type OpenstackVolumeProviderServiceRemoveRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Header(key, value string) *OpenstackVolumeProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Query(key, value string) *OpenstackVolumeProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Async(async bool) *OpenstackVolumeProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeProviderServiceRemoveRequest) Send() (*OpenstackVolumeProviderServiceRemoveResponse, error) {
}

type OpenstackVolumeProviderServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackVolumeProviderService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type OpenstackVolumeProviderServiceTestConnectivityRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Send() (*OpenstackVolumeProviderServiceTestConnectivityResponse, error) {
}

type OpenstackVolumeProviderServiceTestConnectivityResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the test should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackVolumeProviderService) TestConnectivity(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "testconnectivity", headers, query, wait)
	return err
}

type OpenstackVolumeProviderServiceUpdateRequest struct {
	openstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	provider                       *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Header(key, value string) *OpenstackVolumeProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Query(key, value string) *OpenstackVolumeProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Async(async bool) *OpenstackVolumeProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *OpenstackVolumeProviderServiceUpdateRequest) Provider(provider *OpenStackVolumeProvider) *OpenstackVolumeProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *OpenstackVolumeProviderServiceUpdateRequest) Send() (*OpenstackVolumeProviderServiceUpdateResponse, error) {
}

type OpenstackVolumeProviderServiceUpdateResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceUpdateResponse) Provider() *OpenStackVolumeProvider {
	return p.provider
}

//
//
func (op *OpenstackVolumeProviderService) Update(
	provider *OpenStackVolumeProvider,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackVolumeProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackVolumeProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

//
//
func (op *OpenstackVolumeProviderService) AuthenticationKeysService() *OpenstackVolumeAuthenticationKeysService {
	return NewOpenstackVolumeAuthenticationKeysService(op.Connection, fmt.Sprintf("%s/authenticationkeys", op.Path))
}

//
//
func (op *OpenstackVolumeProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
//
func (op *OpenstackVolumeProviderService) VolumeTypesService() *OpenstackVolumeTypesService {
	return NewOpenstackVolumeTypesService(op.Connection, fmt.Sprintf("%s/volumetypes", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "authenticationkeys" {
		return op.AuthenticationKeysService(), nil
	}
	if strings.HasPrefix(path, "authenticationkeys/") {
		return op.AuthenticationKeysService().Service(path[19:])
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "volumetypes" {
		return op.VolumeTypesService(), nil
	}
	if strings.HasPrefix(path, "volumetypes/") {
		return op.VolumeTypesService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeProviderService) String() string {
	return fmt.Sprintf("OpenstackVolumeProviderService:%s", op.Path)
}

//
//
type OpenstackVolumeTypesService struct {
	BaseService
}

func NewOpenstackVolumeTypesService(connection *Connection, path string) *OpenstackVolumeTypesService {
	var result OpenstackVolumeTypesService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeTypesServiceListRequest struct {
	openstackVolumeTypesService *OpenstackVolumeTypesService
	header                      map[string]string
	query                       map[string]string
	max                         *int64
}

func (p *OpenstackVolumeTypesServiceListRequest) Header(key, value string) *OpenstackVolumeTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Query(key, value string) *OpenstackVolumeTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Max(max int64) *OpenstackVolumeTypesServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackVolumeTypesServiceListRequest) Send() (*OpenstackVolumeTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypesService.Connection.URL(), p.openstackVolumeTypesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeTypesService.Connection.username, p.openstackVolumeTypesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeTypesServiceListResponse OpenstackVolumeTypesServiceListResponse
	var typesVar OpenStackVolumeTypes
	xml.Unmarshal(respBodyBytes, &typesVar)
	openstackVolumeTypesServiceListResponse.types = typesVar.OpenStackVolumeTypes
	return &openstackVolumeTypesServiceListResponse, nil
}

type OpenstackVolumeTypesServiceListResponse struct {
	types []OpenStackVolumeType
}

func (p *OpenstackVolumeTypesServiceListResponse) Types() []OpenStackVolumeType {
	return p.types
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of volume types to return. If not specified all the volume types are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackVolumeTypesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenStackVolumeType,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var typesVar OpenStackVolumeTypes
	xml.Unmarshal([]byte(ovResp.Body), &typesVar)
	return typesVar.OpenStackVolumeTypes, nil
}

//
//
func (op *OpenstackVolumeTypesService) TypeService(id string) *OpenstackVolumeTypeService {
	return NewOpenstackVolumeTypeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeTypesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TypeService(path)), nil
	}
	return op.TypeService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeTypesService) String() string {
	return fmt.Sprintf("OpenstackVolumeTypesService:%s", op.Path)
}

//
//
type OpenstackVolumeAuthenticationKeysService struct {
	BaseService
}

func NewOpenstackVolumeAuthenticationKeysService(connection *Connection, path string) *OpenstackVolumeAuthenticationKeysService {
	var result OpenstackVolumeAuthenticationKeysService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeAuthenticationKeysServiceAddRequest struct {
	openstackVolumeAuthenticationKeysService *OpenstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	key                                      *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Key(key *OpenstackVolumeAuthenticationKey) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	p.key = key
	return p
}
func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Send() (*OpenstackVolumeAuthenticationKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.Connection.URL(), p.openstackVolumeAuthenticationKeysService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.key)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeysService.Connection.username, p.openstackVolumeAuthenticationKeysService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeAuthenticationKeysServiceAddResponse OpenstackVolumeAuthenticationKeysServiceAddResponse
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	openstackVolumeAuthenticationKeysServiceAddResponse.key = &keyVar
	return &openstackVolumeAuthenticationKeysServiceAddResponse, nil
}

type OpenstackVolumeAuthenticationKeysServiceAddResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddResponse) Key() *OpenstackVolumeAuthenticationKey {
	return p.key
}

//
//
func (op *OpenstackVolumeAuthenticationKeysService) Add(
	key *OpenstackVolumeAuthenticationKey,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenstackVolumeAuthenticationKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(key, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keyVar OpenstackVolumeAuthenticationKey
	xml.Unmarshal([]byte(ovResp.Body), &keyVar)
	return &keyVar, nil
}

type OpenstackVolumeAuthenticationKeysServiceListRequest struct {
	openstackVolumeAuthenticationKeysService *OpenstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	max                                      *int64
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Max(max int64) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Send() (*OpenstackVolumeAuthenticationKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.Connection.URL(), p.openstackVolumeAuthenticationKeysService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeAuthenticationKeysService.Connection.username, p.openstackVolumeAuthenticationKeysService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeAuthenticationKeysServiceListResponse OpenstackVolumeAuthenticationKeysServiceListResponse
	var keysVar OpenstackVolumeAuthenticationKeys
	xml.Unmarshal(respBodyBytes, &keysVar)
	openstackVolumeAuthenticationKeysServiceListResponse.keys = keysVar.OpenstackVolumeAuthenticationKeys
	return &openstackVolumeAuthenticationKeysServiceListResponse, nil
}

type OpenstackVolumeAuthenticationKeysServiceListResponse struct {
	keys []OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceListResponse) Keys() []OpenstackVolumeAuthenticationKey {
	return p.keys
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of keys to return. If not specified all the keys are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackVolumeAuthenticationKeysService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenstackVolumeAuthenticationKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keysVar OpenstackVolumeAuthenticationKeys
	xml.Unmarshal([]byte(ovResp.Body), &keysVar)
	return keysVar.OpenstackVolumeAuthenticationKeys, nil
}

//
//
func (op *OpenstackVolumeAuthenticationKeysService) KeyService(id string) *OpenstackVolumeAuthenticationKeyService {
	return NewOpenstackVolumeAuthenticationKeyService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeAuthenticationKeysService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KeyService(path)), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeAuthenticationKeysService) String() string {
	return fmt.Sprintf("OpenstackVolumeAuthenticationKeysService:%s", op.Path)
}

//
//
type OpenstackImageService struct {
	BaseService
}

func NewOpenstackImageService(connection *Connection, path string) *OpenstackImageService {
	var result OpenstackImageService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackImageServiceGetRequest struct {
	openstackImageService *OpenstackImageService
	header                map[string]string
	query                 map[string]string
}

func (p *OpenstackImageServiceGetRequest) Header(key, value string) *OpenstackImageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageServiceGetRequest) Query(key, value string) *OpenstackImageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageServiceGetRequest) Send() (*OpenstackImageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageService.Connection.URL(), p.openstackImageService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackImageService.Connection.username, p.openstackImageService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackImageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackImageServiceGetResponse OpenstackImageServiceGetResponse
	var imageVar OpenStackImage
	xml.Unmarshal(respBodyBytes, &imageVar)
	openstackImageServiceGetResponse.image = &imageVar
	return &openstackImageServiceGetResponse, nil
}

type OpenstackImageServiceGetResponse struct {
	image *OpenStackImage
}

func (p *OpenstackImageServiceGetResponse) Image() *OpenStackImage {
	return p.image
}

//
//
func (op *OpenstackImageService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackImage,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var imageVar OpenStackImage
	xml.Unmarshal([]byte(ovResp.Body), &imageVar)
	return &imageVar, nil
}

type OpenstackImageServiceImportRequest struct {
	openstackImageService *OpenstackImageService
	header                map[string]string
	query                 map[string]string
	async                 *bool
	cluster               *Cluster
	disk                  *Disk
	importAsTemplate      *bool
	storageDomain         *StorageDomain
	template              *Template
}

func (p *OpenstackImageServiceImportRequest) Header(key, value string) *OpenstackImageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageServiceImportRequest) Query(key, value string) *OpenstackImageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageServiceImportRequest) Async(async bool) *OpenstackImageServiceImportRequest {
	p.async = &async
	return p
}
func (p *OpenstackImageServiceImportRequest) Cluster(cluster *Cluster) *OpenstackImageServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *OpenstackImageServiceImportRequest) Disk(disk *Disk) *OpenstackImageServiceImportRequest {
	p.disk = disk
	return p
}
func (p *OpenstackImageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *OpenstackImageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}
func (p *OpenstackImageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *OpenstackImageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *OpenstackImageServiceImportRequest) Template(template *Template) *OpenstackImageServiceImportRequest {
	p.template = template
	return p
}
func (p *OpenstackImageServiceImportRequest) Send() (*OpenstackImageServiceImportResponse, error) {
}

type OpenstackImageServiceImportResponse struct {
}

//
// Imports a virtual machine from a Glance image storage domain.
// For example, to import the image with identifier `456` from the
// storage domain with identifier `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>images0</name>
//   </storage_domain>
//   <cluster>
//     <name>images0</name>
//   </cluster>
// </action>
// ----
// This method supports the following parameters:
// `ImportAsTemplate`:: Indicates whether the image should be imported as a template.
// `Cluster`:: This parameter is mandatory in case of using `import_as_template` and indicates which cluster should be used
// for import glance image as template.
// `Async`:: Indicates if the import should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackImageService) Import(
	async bool,
	cluster *Cluster,
	disk *Disk,
	importAsTemplate bool,
	storageDomain *StorageDomain,
	template *Template,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:            &async,
		Cluster:          cluster,
		Disk:             disk,
		ImportAsTemplate: &importAsTemplate,
		StorageDomain:    storageDomain,
		Template:         template,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "import", headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackImageService) String() string {
	return fmt.Sprintf("OpenstackImageService:%s", op.Path)
}

//
//
type OpenstackVolumeTypeService struct {
	BaseService
}

func NewOpenstackVolumeTypeService(connection *Connection, path string) *OpenstackVolumeTypeService {
	var result OpenstackVolumeTypeService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackVolumeTypeServiceGetRequest struct {
	openstackVolumeTypeService *OpenstackVolumeTypeService
	header                     map[string]string
	query                      map[string]string
}

func (p *OpenstackVolumeTypeServiceGetRequest) Header(key, value string) *OpenstackVolumeTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeTypeServiceGetRequest) Query(key, value string) *OpenstackVolumeTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeTypeServiceGetRequest) Send() (*OpenstackVolumeTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypeService.Connection.URL(), p.openstackVolumeTypeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackVolumeTypeService.Connection.username, p.openstackVolumeTypeService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackVolumeTypeServiceGetResponse OpenstackVolumeTypeServiceGetResponse
	var type_Var OpenStackVolumeType
	xml.Unmarshal(respBodyBytes, &type_Var)
	openstackVolumeTypeServiceGetResponse.type_ = &type_Var
	return &openstackVolumeTypeServiceGetResponse, nil
}

type OpenstackVolumeTypeServiceGetResponse struct {
	type_ *OpenStackVolumeType
}

func (p *OpenstackVolumeTypeServiceGetResponse) Type_() *OpenStackVolumeType {
	return p.type_
}

//
//
func (op *OpenstackVolumeTypeService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackVolumeType,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var type_Var OpenStackVolumeType
	xml.Unmarshal([]byte(ovResp.Body), &type_Var)
	return &type_Var, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeTypeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeTypeService) String() string {
	return fmt.Sprintf("OpenstackVolumeTypeService:%s", op.Path)
}

//
//
type OpenstackSubnetService struct {
	BaseService
}

func NewOpenstackSubnetService(connection *Connection, path string) *OpenstackSubnetService {
	var result OpenstackSubnetService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackSubnetServiceGetRequest struct {
	openstackSubnetService *OpenstackSubnetService
	header                 map[string]string
	query                  map[string]string
}

func (p *OpenstackSubnetServiceGetRequest) Header(key, value string) *OpenstackSubnetServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetServiceGetRequest) Query(key, value string) *OpenstackSubnetServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetServiceGetRequest) Send() (*OpenstackSubnetServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetService.Connection.URL(), p.openstackSubnetService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackSubnetService.Connection.username, p.openstackSubnetService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackSubnetService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackSubnetServiceGetResponse OpenstackSubnetServiceGetResponse
	var subnetVar OpenStackSubnet
	xml.Unmarshal(respBodyBytes, &subnetVar)
	openstackSubnetServiceGetResponse.subnet = &subnetVar
	return &openstackSubnetServiceGetResponse, nil
}

type OpenstackSubnetServiceGetResponse struct {
	subnet *OpenStackSubnet
}

func (p *OpenstackSubnetServiceGetResponse) Subnet() *OpenStackSubnet {
	return p.subnet
}

//
//
func (op *OpenstackSubnetService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackSubnet,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var subnetVar OpenStackSubnet
	xml.Unmarshal([]byte(ovResp.Body), &subnetVar)
	return &subnetVar, nil
}

type OpenstackSubnetServiceRemoveRequest struct {
	openstackSubnetService *OpenstackSubnetService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *OpenstackSubnetServiceRemoveRequest) Header(key, value string) *OpenstackSubnetServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetServiceRemoveRequest) Query(key, value string) *OpenstackSubnetServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetServiceRemoveRequest) Async(async bool) *OpenstackSubnetServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackSubnetServiceRemoveRequest) Send() (*OpenstackSubnetServiceRemoveResponse, error) {
}

type OpenstackSubnetServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackSubnetService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackSubnetService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackSubnetService) String() string {
	return fmt.Sprintf("OpenstackSubnetService:%s", op.Path)
}

//
//
type OpenstackSubnetsService struct {
	BaseService
}

func NewOpenstackSubnetsService(connection *Connection, path string) *OpenstackSubnetsService {
	var result OpenstackSubnetsService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackSubnetsServiceAddRequest struct {
	openstackSubnetsService *OpenstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	subnet                  *OpenStackSubnet
}

func (p *OpenstackSubnetsServiceAddRequest) Header(key, value string) *OpenstackSubnetsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetsServiceAddRequest) Query(key, value string) *OpenstackSubnetsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetsServiceAddRequest) Subnet(subnet *OpenStackSubnet) *OpenstackSubnetsServiceAddRequest {
	p.subnet = subnet
	return p
}
func (p *OpenstackSubnetsServiceAddRequest) Send() (*OpenstackSubnetsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.Connection.URL(), p.openstackSubnetsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.subnet)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackSubnetsService.Connection.username, p.openstackSubnetsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackSubnetsServiceAddResponse OpenstackSubnetsServiceAddResponse
	var subnetVar OpenStackSubnet
	xml.Unmarshal(respBodyBytes, &subnetVar)
	openstackSubnetsServiceAddResponse.subnet = &subnetVar
	return &openstackSubnetsServiceAddResponse, nil
}

type OpenstackSubnetsServiceAddResponse struct {
	subnet *OpenStackSubnet
}

func (p *OpenstackSubnetsServiceAddResponse) Subnet() *OpenStackSubnet {
	return p.subnet
}

//
//
func (op *OpenstackSubnetsService) Add(
	subnet *OpenStackSubnet,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackSubnet,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(subnet, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var subnetVar OpenStackSubnet
	xml.Unmarshal([]byte(ovResp.Body), &subnetVar)
	return &subnetVar, nil
}

type OpenstackSubnetsServiceListRequest struct {
	openstackSubnetsService *OpenstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *OpenstackSubnetsServiceListRequest) Header(key, value string) *OpenstackSubnetsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Query(key, value string) *OpenstackSubnetsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Max(max int64) *OpenstackSubnetsServiceListRequest {
	p.max = &max
	return p
}
func (p *OpenstackSubnetsServiceListRequest) Send() (*OpenstackSubnetsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.Connection.URL(), p.openstackSubnetsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackSubnetsService.Connection.username, p.openstackSubnetsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackSubnetsServiceListResponse OpenstackSubnetsServiceListResponse
	var subnetsVar OpenStackSubnets
	xml.Unmarshal(respBodyBytes, &subnetsVar)
	openstackSubnetsServiceListResponse.subnets = subnetsVar.OpenStackSubnets
	return &openstackSubnetsServiceListResponse, nil
}

type OpenstackSubnetsServiceListResponse struct {
	subnets []OpenStackSubnet
}

func (p *OpenstackSubnetsServiceListResponse) Subnets() []OpenStackSubnet {
	return p.subnets
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of sub-networks to return. If not specified all the sub-networks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackSubnetsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OpenStackSubnet,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var subnetsVar OpenStackSubnets
	xml.Unmarshal([]byte(ovResp.Body), &subnetsVar)
	return subnetsVar.OpenStackSubnets, nil
}

//
//
func (op *OpenstackSubnetsService) SubnetService(id string) *OpenstackSubnetService {
	return NewOpenstackSubnetService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackSubnetsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SubnetService(path)), nil
	}
	return op.SubnetService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackSubnetsService) String() string {
	return fmt.Sprintf("OpenstackSubnetsService:%s", op.Path)
}

//
// This service manages OpenStack network provider.
//
type OpenstackNetworkProviderService struct {
	BaseService
}

func NewOpenstackNetworkProviderService(connection *Connection, path string) *OpenstackNetworkProviderService {
	var result OpenstackNetworkProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type OpenstackNetworkProviderServiceGetRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
}

func (p *OpenstackNetworkProviderServiceGetRequest) Header(key, value string) *OpenstackNetworkProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceGetRequest) Query(key, value string) *OpenstackNetworkProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceGetRequest) Send() (*OpenstackNetworkProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.Connection.URL(), p.openstackNetworkProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.openstackNetworkProviderService.Connection.username, p.openstackNetworkProviderService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var openstackNetworkProviderServiceGetResponse OpenstackNetworkProviderServiceGetResponse
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	openstackNetworkProviderServiceGetResponse.provider = &providerVar
	return &openstackNetworkProviderServiceGetResponse, nil
}

type OpenstackNetworkProviderServiceGetResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceGetResponse) Provider() *OpenStackNetworkProvider {
	return p.provider
}

//
// Returns the representation of the object managed by this service.
// For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
func (op *OpenstackNetworkProviderService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackNetworkProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type OpenstackNetworkProviderServiceImportCertificatesRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	certificates                    []Certificate
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Send() (*OpenstackNetworkProviderServiceImportCertificatesResponse, error) {
}

type OpenstackNetworkProviderServiceImportCertificatesResponse struct {
}

//
//
func (op *OpenstackNetworkProviderService) ImportCertificates(
	certificates []Certificate,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Certificates: certificates,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "importcertificates", headers, query, wait)
	return err
}

type OpenstackNetworkProviderServiceRemoveRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Header(key, value string) *OpenstackNetworkProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Query(key, value string) *OpenstackNetworkProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Async(async bool) *OpenstackNetworkProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkProviderServiceRemoveRequest) Send() (*OpenstackNetworkProviderServiceRemoveResponse, error) {
}

type OpenstackNetworkProviderServiceRemoveResponse struct {
}

//
// Removes the provider.
// For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackNetworkProviderService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type OpenstackNetworkProviderServiceTestConnectivityRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Send() (*OpenstackNetworkProviderServiceTestConnectivityResponse, error) {
}

type OpenstackNetworkProviderServiceTestConnectivityResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the test should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackNetworkProviderService) TestConnectivity(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "testconnectivity", headers, query, wait)
	return err
}

type OpenstackNetworkProviderServiceUpdateRequest struct {
	openstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
	provider                        *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Header(key, value string) *OpenstackNetworkProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Query(key, value string) *OpenstackNetworkProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Async(async bool) *OpenstackNetworkProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *OpenstackNetworkProviderServiceUpdateRequest) Provider(provider *OpenStackNetworkProvider) *OpenstackNetworkProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *OpenstackNetworkProviderServiceUpdateRequest) Send() (*OpenstackNetworkProviderServiceUpdateResponse, error) {
}

type OpenstackNetworkProviderServiceUpdateResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceUpdateResponse) Provider() *OpenStackNetworkProvider {
	return p.provider
}

//
// Updates the provider.
// For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
// for the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_network_provider>
//   <name>ovn-network-provider</name>
//   <requires_authentication>false</requires_authentication>
//   <url>http://some_server_url.domain.com:9696</url>
//   <tenant_name>oVirt</tenant_name>
//   <type>external</type>
// </openstack_network_provider>
// ----
// This method supports the following parameters:
// `Provider`:: The provider to update.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OpenstackNetworkProviderService) Update(
	provider *OpenStackNetworkProvider,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*OpenStackNetworkProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar OpenStackNetworkProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

//
//
func (op *OpenstackNetworkProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
// Reference to OpenStack networks service.
//
func (op *OpenstackNetworkProviderService) NetworksService() *OpenstackNetworksService {
	return NewOpenstackNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackNetworkProviderService) String() string {
	return fmt.Sprintf("OpenstackNetworkProviderService:%s", op.Path)
}

//
// Manages the virtual machine template and template versions.
//
type TemplateService struct {
	BaseService
}

func NewTemplateService(connection *Connection, path string) *TemplateService {
	var result TemplateService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateServiceExportRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	exclusive       *bool
	storageDomain   *StorageDomain
}

func (p *TemplateServiceExportRequest) Header(key, value string) *TemplateServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceExportRequest) Query(key, value string) *TemplateServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceExportRequest) Exclusive(exclusive bool) *TemplateServiceExportRequest {
	p.exclusive = &exclusive
	return p
}
func (p *TemplateServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *TemplateServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *TemplateServiceExportRequest) Send() (*TemplateServiceExportResponse, error) {
}

type TemplateServiceExportResponse struct {
}

//
// Exports a template to the data center export domain.
// For example, the operation can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/templates/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <exclusive>true<exclusive/>
// </action>
// ----
// This method supports the following parameters:
// `Exclusive`:: Indicates if the existing templates with the same name should be overwritten.
// The export action reports a failed action if a template of the same name exists in the destination domain.
// Set this parameter to `true` to change this behavior and overwrite any existing template.
// `StorageDomain`:: Specifies the destination export storage domain.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateService) Export(
	exclusive bool,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Exclusive:     &exclusive,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "export", headers, query, wait)
	return err
}

type TemplateServiceGetRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	filter          *bool
}

func (p *TemplateServiceGetRequest) Header(key, value string) *TemplateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceGetRequest) Query(key, value string) *TemplateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceGetRequest) Filter(filter bool) *TemplateServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *TemplateServiceGetRequest) Send() (*TemplateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateService.Connection.URL(), p.templateService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateService.Connection.username, p.templateService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateServiceGetResponse TemplateServiceGetResponse
	var templateVar Template
	xml.Unmarshal(respBodyBytes, &templateVar)
	templateServiceGetResponse.template = &templateVar
	return &templateServiceGetResponse, nil
}

type TemplateServiceGetResponse struct {
	template *Template
}

func (p *TemplateServiceGetResponse) Template() *Template {
	return p.template
}

//
// Returns the information about this template or template version.
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Template,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var templateVar Template
	xml.Unmarshal([]byte(ovResp.Body), &templateVar)
	return &templateVar, nil
}

type TemplateServiceRemoveRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *TemplateServiceRemoveRequest) Header(key, value string) *TemplateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceRemoveRequest) Query(key, value string) *TemplateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceRemoveRequest) Async(async bool) *TemplateServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateServiceRemoveRequest) Send() (*TemplateServiceRemoveResponse, error) {
}

type TemplateServiceRemoveResponse struct {
}

//
// Removes a virtual machine template.
// [source]
// ----
// DELETE /ovirt-engine/api/templates/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type TemplateServiceSealRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
}

func (p *TemplateServiceSealRequest) Header(key, value string) *TemplateServiceSealRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceSealRequest) Query(key, value string) *TemplateServiceSealRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceSealRequest) Send() (*TemplateServiceSealResponse, error) {
}

type TemplateServiceSealResponse struct {
}

//
// Seal the template.
// Sealing erases all host-specific configuration from the filesystem:
// SSH keys, UDEV rules, MAC addresses, system ID, hostname etc.,
// thus making easy to use the template to create multiple virtual
// machines without manual intervention.
// Currently sealing is supported only for Linux OS.
//
func (op *TemplateService) Seal(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "seal", headers, query, wait)
	return err
}

type TemplateServiceUpdateRequest struct {
	templateService *TemplateService
	header          map[string]string
	query           map[string]string
	async           *bool
	template        *Template
}

func (p *TemplateServiceUpdateRequest) Header(key, value string) *TemplateServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceUpdateRequest) Query(key, value string) *TemplateServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceUpdateRequest) Async(async bool) *TemplateServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TemplateServiceUpdateRequest) Template(template *Template) *TemplateServiceUpdateRequest {
	p.template = template
	return p
}
func (p *TemplateServiceUpdateRequest) Send() (*TemplateServiceUpdateResponse, error) {
}

type TemplateServiceUpdateResponse struct {
	template *Template
}

func (p *TemplateServiceUpdateResponse) Template() *Template {
	return p.template
}

//
// Updates the template.
// The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
// `stateless`, `usb` and `timezone` elements can be updated after a template has been created.
// For example, to update a template to so that it has 1 GiB of memory send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/templates/123
// ----
// With the following request body:
// [source,xml]
// ----
// <template>
//   <memory>1073741824</memory>
// </template>
// ----
// The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
// template versions:
// [source,xml]
// ----
// <template>
//   <version>
//     <version_name>mytemplate_2</version_name>
//   </version>
// </template>
// ----
//
func (op *TemplateService) Update(
	template *Template,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Template,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(template, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var templateVar Template
	xml.Unmarshal([]byte(ovResp.Body), &templateVar)
	return &templateVar, nil
}

//
// Returns a reference to the service that manages the CDROMs that are associated with the template.
//
func (op *TemplateService) CdromsService() *TemplateCdromsService {
	return NewTemplateCdromsService(op.Connection, fmt.Sprintf("%s/cdroms", op.Path))
}

//
// Reference to the service that manages a specific
// disk attachment of the template.
//
func (op *TemplateService) DiskAttachmentsService() *TemplateDiskAttachmentsService {
	return NewTemplateDiskAttachmentsService(op.Connection, fmt.Sprintf("%s/diskattachments", op.Path))
}

//
// Returns a reference to the service that manages the graphical consoles that are associated with the template.
//
func (op *TemplateService) GraphicsConsolesService() *TemplateGraphicsConsolesService {
	return NewTemplateGraphicsConsolesService(op.Connection, fmt.Sprintf("%s/graphicsconsoles", op.Path))
}

//
// Returns a reference to the service that manages the NICs that are associated with the template.
//
func (op *TemplateService) NicsService() *TemplateNicsService {
	return NewTemplateNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Returns a reference to the service that manages the permissions that are associated with the template.
//
func (op *TemplateService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Returns a reference to the service that manages the tags that are associated with the template.
//
func (op *TemplateService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Returns a reference to the service that manages the _watchdogs_ that are associated with the template.
//
func (op *TemplateService) WatchdogsService() *TemplateWatchdogsService {
	return NewTemplateWatchdogsService(op.Connection, fmt.Sprintf("%s/watchdogs", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateService) String() string {
	return fmt.Sprintf("TemplateService:%s", op.Path)
}

//
// Lists the watchdogs of a virtual machine.
//
type VmWatchdogsService struct {
	BaseService
}

func NewVmWatchdogsService(connection *Connection, path string) *VmWatchdogsService {
	var result VmWatchdogsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmWatchdogsServiceAddRequest struct {
	vmWatchdogsService *VmWatchdogsService
	header             map[string]string
	query              map[string]string
	watchdog           *Watchdog
}

func (p *VmWatchdogsServiceAddRequest) Header(key, value string) *VmWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogsServiceAddRequest) Query(key, value string) *VmWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *VmWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}
func (p *VmWatchdogsServiceAddRequest) Send() (*VmWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.Connection.URL(), p.vmWatchdogsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogsService.Connection.username, p.vmWatchdogsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmWatchdogsServiceAddResponse VmWatchdogsServiceAddResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	vmWatchdogsServiceAddResponse.watchdog = &watchdogVar
	return &vmWatchdogsServiceAddResponse, nil
}

type VmWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogsServiceAddResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
// Adds new watchdog to the virtual machine.
// For example, to add a watchdog to a virtual machine, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// This method supports the following parameters:
// `Watchdog`:: The information about the watchdog.
// The request data must contain `model` element (such as `i6300esb`) and `action` element
// (one of `none`, `reset`, `poweroff`, `dump`, `pause`). The response data additionally
// contains references to the added watchdog and to the virtual machine.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmWatchdogsService) Add(
	watchdog *Watchdog,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(watchdog, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

type VmWatchdogsServiceListRequest struct {
	vmWatchdogsService *VmWatchdogsService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *VmWatchdogsServiceListRequest) Header(key, value string) *VmWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogsServiceListRequest) Query(key, value string) *VmWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogsServiceListRequest) Max(max int64) *VmWatchdogsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmWatchdogsServiceListRequest) Send() (*VmWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.Connection.URL(), p.vmWatchdogsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmWatchdogsService.Connection.username, p.vmWatchdogsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmWatchdogsServiceListResponse VmWatchdogsServiceListResponse
	var watchdogsVar Watchdogs
	xml.Unmarshal(respBodyBytes, &watchdogsVar)
	vmWatchdogsServiceListResponse.watchdogs = watchdogsVar.Watchdogs
	return &vmWatchdogsServiceListResponse, nil
}

type VmWatchdogsServiceListResponse struct {
	watchdogs []Watchdog
}

func (p *VmWatchdogsServiceListResponse) Watchdogs() []Watchdog {
	return p.watchdogs
}

//
// The list of watchdogs of the virtual machine.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of watchdogs to return. If not specified all the watchdogs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmWatchdogsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogsVar Watchdogs
	xml.Unmarshal([]byte(ovResp.Body), &watchdogsVar)
	return watchdogsVar.Watchdogs, nil
}

//
// Returns a reference to the service that manages a specific watchdog.
//
func (op *VmWatchdogsService) WatchdogService(id string) *VmWatchdogService {
	return NewVmWatchdogService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmWatchdogsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WatchdogService(path)), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *VmWatchdogsService) String() string {
	return fmt.Sprintf("VmWatchdogsService:%s", op.Path)
}

//
// This service represents a vm that has a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type AffinityLabelVmService struct {
	BaseService
}

func NewAffinityLabelVmService(connection *Connection, path string) *AffinityLabelVmService {
	var result AffinityLabelVmService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelVmServiceGetRequest struct {
	affinityLabelVmService *AffinityLabelVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *AffinityLabelVmServiceGetRequest) Header(key, value string) *AffinityLabelVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmServiceGetRequest) Query(key, value string) *AffinityLabelVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmServiceGetRequest) Send() (*AffinityLabelVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmService.Connection.URL(), p.affinityLabelVmService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelVmService.Connection.username, p.affinityLabelVmService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelVmServiceGetResponse AffinityLabelVmServiceGetResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	affinityLabelVmServiceGetResponse.vm = &vmVar
	return &affinityLabelVmServiceGetResponse, nil
}

type AffinityLabelVmServiceGetResponse struct {
	vm *Vm
}

func (p *AffinityLabelVmServiceGetResponse) Vm() *Vm {
	return p.vm
}

//
// Retrieves details about a vm that has this label assigned.
//
func (op *AffinityLabelVmService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vm
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return &vmVar, nil
}

type AffinityLabelVmServiceRemoveRequest struct {
	affinityLabelVmService *AffinityLabelVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *AffinityLabelVmServiceRemoveRequest) Header(key, value string) *AffinityLabelVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmServiceRemoveRequest) Query(key, value string) *AffinityLabelVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmServiceRemoveRequest) Send() (*AffinityLabelVmServiceRemoveResponse, error) {
}

type AffinityLabelVmServiceRemoveResponse struct {
}

//
// Remove a label from a vm.
//
func (op *AffinityLabelVmService) Remove(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelVmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelVmService) String() string {
	return fmt.Sprintf("AffinityLabelVmService:%s", op.Path)
}

//
//
type VmService struct {
	BaseService
}

func NewVmService(connection *Connection, path string) *VmService {
	var result VmService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmServiceCancelMigrationRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceCancelMigrationRequest) Header(key, value string) *VmServiceCancelMigrationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCancelMigrationRequest) Query(key, value string) *VmServiceCancelMigrationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCancelMigrationRequest) Async(async bool) *VmServiceCancelMigrationRequest {
	p.async = &async
	return p
}
func (p *VmServiceCancelMigrationRequest) Send() (*VmServiceCancelMigrationResponse, error) {
}

type VmServiceCancelMigrationResponse struct {
}

//
// This operation stops any migration of a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/cancelmigration
// ----
// The cancel migration action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the migration should cancelled asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) CancelMigration(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "cancelmigration", headers, query, wait)
	return err
}

type VmServiceCloneRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	vm        *Vm
}

func (p *VmServiceCloneRequest) Header(key, value string) *VmServiceCloneRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCloneRequest) Query(key, value string) *VmServiceCloneRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCloneRequest) Async(async bool) *VmServiceCloneRequest {
	p.async = &async
	return p
}
func (p *VmServiceCloneRequest) Vm(vm *Vm) *VmServiceCloneRequest {
	p.vm = vm
	return p
}
func (p *VmServiceCloneRequest) Send() (*VmServiceCloneResponse, error) {
}

type VmServiceCloneResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the clone should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Clone(
	async bool,
	vm *Vm,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
		Vm:    vm,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "clone", headers, query, wait)
	return err
}

type VmServiceCommitSnapshotRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceCommitSnapshotRequest) Header(key, value string) *VmServiceCommitSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCommitSnapshotRequest) Query(key, value string) *VmServiceCommitSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCommitSnapshotRequest) Async(async bool) *VmServiceCommitSnapshotRequest {
	p.async = &async
	return p
}
func (p *VmServiceCommitSnapshotRequest) Send() (*VmServiceCommitSnapshotResponse, error) {
}

type VmServiceCommitSnapshotResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the snapshots should be committed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) CommitSnapshot(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "commitsnapshot", headers, query, wait)
	return err
}

type VmServiceDetachRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceDetachRequest) Header(key, value string) *VmServiceDetachRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceDetachRequest) Query(key, value string) *VmServiceDetachRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceDetachRequest) Async(async bool) *VmServiceDetachRequest {
	p.async = &async
	return p
}
func (p *VmServiceDetachRequest) Send() (*VmServiceDetachResponse, error) {
}

type VmServiceDetachResponse struct {
}

//
// Detaches a virtual machine from a pool.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/detach
// ----
// The detach action does not take any action specific parameters, so the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the detach should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Detach(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "detach", headers, query, wait)
	return err
}

type VmServiceExportRequest struct {
	vmService        *VmService
	header           map[string]string
	query            map[string]string
	async            *bool
	discardSnapshots *bool
	exclusive        *bool
	storageDomain    *StorageDomain
}

func (p *VmServiceExportRequest) Header(key, value string) *VmServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceExportRequest) Query(key, value string) *VmServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceExportRequest) Async(async bool) *VmServiceExportRequest {
	p.async = &async
	return p
}
func (p *VmServiceExportRequest) DiscardSnapshots(discardSnapshots bool) *VmServiceExportRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}
func (p *VmServiceExportRequest) Exclusive(exclusive bool) *VmServiceExportRequest {
	p.exclusive = &exclusive
	return p
}
func (p *VmServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *VmServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *VmServiceExportRequest) Send() (*VmServiceExportResponse, error) {
}

type VmServiceExportResponse struct {
}

//
// Export a virtual machine to an export domain.
// For example to export virtual machine `123` to the export domain `myexport`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <exclusive>true</exclusive>
//   <discard_snapshots>true</discard_snapshots>
// </action>
// ----
// This method supports the following parameters:
// `DiscardSnapshots`:: The `discard_snapshots` parameter is to be used when the virtual machine should be exported with all its
// snapshots collapsed.
// `Exclusive`:: The `exclusive` parameter is to be used when the virtual machine should be exported even if another copy of
// it already exists in the export domain (override).
// `Async`:: Indicates if the export should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Export(
	async bool,
	discardSnapshots bool,
	exclusive bool,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:            &async,
		DiscardSnapshots: &discardSnapshots,
		Exclusive:        &exclusive,
		StorageDomain:    storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "export", headers, query, wait)
	return err
}

type VmServiceFreezeFilesystemsRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceFreezeFilesystemsRequest) Header(key, value string) *VmServiceFreezeFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceFreezeFilesystemsRequest) Query(key, value string) *VmServiceFreezeFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceFreezeFilesystemsRequest) Async(async bool) *VmServiceFreezeFilesystemsRequest {
	p.async = &async
	return p
}
func (p *VmServiceFreezeFilesystemsRequest) Send() (*VmServiceFreezeFilesystemsResponse, error) {
}

type VmServiceFreezeFilesystemsResponse struct {
}

//
// Freeze virtual machine file systems.
// This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
// a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
// manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/freezefilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the freeze should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) FreezeFilesystems(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "freezefilesystems", headers, query, wait)
	return err
}

type VmServiceGetRequest struct {
	vmService  *VmService
	header     map[string]string
	query      map[string]string
	allContent *bool
	filter     *bool
	nextRun    *bool
}

func (p *VmServiceGetRequest) Header(key, value string) *VmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceGetRequest) Query(key, value string) *VmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceGetRequest) AllContent(allContent bool) *VmServiceGetRequest {
	p.allContent = &allContent
	return p
}
func (p *VmServiceGetRequest) Filter(filter bool) *VmServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *VmServiceGetRequest) NextRun(nextRun bool) *VmServiceGetRequest {
	p.nextRun = &nextRun
	return p
}
func (p *VmServiceGetRequest) Send() (*VmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmService.Connection.URL(), p.vmService.Path)
	values := make(url.Values)
	if p.allContent != nil {
		values["allContent"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.nextRun != nil {
		values["nextRun"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmService.Connection.username, p.vmService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmServiceGetResponse VmServiceGetResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	vmServiceGetResponse.vm = &vmVar
	return &vmServiceGetResponse, nil
}

type VmServiceGetResponse struct {
	vm *Vm
}

func (p *VmServiceGetResponse) Vm() *Vm {
	return p.vm
}

//
// Retrieves the description of the virtual machine.
// This method supports the following parameters:
// `NextRun`:: Indicates if the returned result describes the virtual machine as it is currently running, or if describes
// it with the modifications that have already been performed but that will have effect only when it is
// restarted. By default the values is `false`.
// If the parameter is included in the request, but without a value, it is assumed that the value is `true`, so
// the following request:
// [source]
// ----
// GET /vms/{vm:id};next_run
// ----
// Is equivalent to using the value `true`:
// [source]
// ----
// GET /vms/{vm:id};next_run=true
// ----
// `AllContent`:: Indicates if all the attributes of the virtual machine should be included in the response.
// By default the following attributes are excluded:
// - `console`
// - `initialization.configuration.data` - The OVF document describing the virtual machine.
// - `rng_source`
// - `soundcard`
// - `virtio_scsi`
// For example, to retrieve the complete representation of the virtual machine '123' send a request like this:
// ....
// GET /ovirt-engine/api/vms/123?all_content=true
// ....
// NOTE: The reason for not including these attributes is performance: they are seldom used and they require
// additional queries to the database. So try to use the this parameter only when it is really needed.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Get(
	allContent bool,
	filter bool,
	nextRun bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["all_content"] = fmt.Sprintf("%v", allContent)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["next_run"] = fmt.Sprintf("%v", nextRun)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vm
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return &vmVar, nil
}

type VmServiceLogonRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceLogonRequest) Header(key, value string) *VmServiceLogonRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceLogonRequest) Query(key, value string) *VmServiceLogonRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceLogonRequest) Async(async bool) *VmServiceLogonRequest {
	p.async = &async
	return p
}
func (p *VmServiceLogonRequest) Send() (*VmServiceLogonResponse, error) {
}

type VmServiceLogonResponse struct {
}

//
// Initiates the automatic user logon to access a virtual machine from an external console.
// This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
// installed and the `ovirt-guest-agent` service to be running on the virtual machine.
// Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
// from an external console.
// This is how an example request would look like:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/logon
// ----
// Request body:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the logon should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Logon(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "logon", headers, query, wait)
	return err
}

type VmServiceMaintenanceRequest struct {
	vmService          *VmService
	header             map[string]string
	query              map[string]string
	async              *bool
	maintenanceEnabled *bool
}

func (p *VmServiceMaintenanceRequest) Header(key, value string) *VmServiceMaintenanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceMaintenanceRequest) Query(key, value string) *VmServiceMaintenanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceMaintenanceRequest) Async(async bool) *VmServiceMaintenanceRequest {
	p.async = &async
	return p
}
func (p *VmServiceMaintenanceRequest) MaintenanceEnabled(maintenanceEnabled bool) *VmServiceMaintenanceRequest {
	p.maintenanceEnabled = &maintenanceEnabled
	return p
}
func (p *VmServiceMaintenanceRequest) Send() (*VmServiceMaintenanceResponse, error) {
}

type VmServiceMaintenanceResponse struct {
}

//
// Sets the global maintenance mode on the hosted engine virtual machine.
// This action has no effect on other virtual machines.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/maintenance
// ----
// [source,xml]
// ----
// <action>
//   <maintenance_enabled>true<maintenance_enabled/>
// </action>
// ----
// This method supports the following parameters:
// `MaintenanceEnabled`:: Indicates if global maintenance should be enabled or disabled.
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Maintenance(
	async bool,
	maintenanceEnabled bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:              &async,
		MaintenanceEnabled: &maintenanceEnabled,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "maintenance", headers, query, wait)
	return err
}

type VmServiceMigrateRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	cluster   *Cluster
	force     *bool
	host      *Host
}

func (p *VmServiceMigrateRequest) Header(key, value string) *VmServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceMigrateRequest) Query(key, value string) *VmServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceMigrateRequest) Async(async bool) *VmServiceMigrateRequest {
	p.async = &async
	return p
}
func (p *VmServiceMigrateRequest) Cluster(cluster *Cluster) *VmServiceMigrateRequest {
	p.cluster = cluster
	return p
}
func (p *VmServiceMigrateRequest) Force(force bool) *VmServiceMigrateRequest {
	p.force = &force
	return p
}
func (p *VmServiceMigrateRequest) Host(host *Host) *VmServiceMigrateRequest {
	p.host = host
	return p
}
func (p *VmServiceMigrateRequest) Send() (*VmServiceMigrateResponse, error) {
}

type VmServiceMigrateResponse struct {
}

//
// This operation migrates a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/migrate
// ----
// One can specify a specific host to migrate the virtual machine to:
// [source,xml]
// ----
// <action>
//   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
// </action>
// ----
// This method supports the following parameters:
// `Cluster`:: Specifies the cluster the virtual machine should migrate to. This is an optional parameter. By default, the
// virtual machine is migrated to another host within the same cluster.
// `Force`:: Specifies the virtual machine should migrate although it might be defined as non migratable. This is an
// optional parameter. By default, it is set to `false`.
// `Host`:: Specifies a specific host the virtual machine should migrate to. This is an optional parameters. By default,
// the oVirt Engine automatically selects a default host for migration within the same cluster. If an API user
// requires a specific host, the user can specify the host with either an `id` or `name` parameter.
// `Async`:: Indicates if the migration should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Migrate(
	async bool,
	cluster *Cluster,
	force bool,
	host *Host,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:   &async,
		Cluster: cluster,
		Force:   &force,
		Host:    host,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "migrate", headers, query, wait)
	return err
}

type VmServicePreviewSnapshotRequest struct {
	vmService     *VmService
	header        map[string]string
	query         map[string]string
	async         *bool
	disks         []Disk
	restoreMemory *bool
	snapshot      *Snapshot
	vm            *Vm
}

func (p *VmServicePreviewSnapshotRequest) Header(key, value string) *VmServicePreviewSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServicePreviewSnapshotRequest) Query(key, value string) *VmServicePreviewSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServicePreviewSnapshotRequest) Async(async bool) *VmServicePreviewSnapshotRequest {
	p.async = &async
	return p
}
func (p *VmServicePreviewSnapshotRequest) Disks(disks []Disk) *VmServicePreviewSnapshotRequest {
	p.disks = disks
	return p
}
func (p *VmServicePreviewSnapshotRequest) RestoreMemory(restoreMemory bool) *VmServicePreviewSnapshotRequest {
	p.restoreMemory = &restoreMemory
	return p
}
func (p *VmServicePreviewSnapshotRequest) Snapshot(snapshot *Snapshot) *VmServicePreviewSnapshotRequest {
	p.snapshot = snapshot
	return p
}
func (p *VmServicePreviewSnapshotRequest) Vm(vm *Vm) *VmServicePreviewSnapshotRequest {
	p.vm = vm
	return p
}
func (p *VmServicePreviewSnapshotRequest) Send() (*VmServicePreviewSnapshotResponse, error) {
}

type VmServicePreviewSnapshotResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the preview should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) PreviewSnapshot(
	async bool,
	disks []Disk,
	restoreMemory bool,
	snapshot *Snapshot,
	vm *Vm,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Disks:         disks,
		RestoreMemory: &restoreMemory,
		Snapshot:      snapshot,
		Vm:            vm,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "previewsnapshot", headers, query, wait)
	return err
}

type VmServiceRebootRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceRebootRequest) Header(key, value string) *VmServiceRebootRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceRebootRequest) Query(key, value string) *VmServiceRebootRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceRebootRequest) Async(async bool) *VmServiceRebootRequest {
	p.async = &async
	return p
}
func (p *VmServiceRebootRequest) Send() (*VmServiceRebootResponse, error) {
}

type VmServiceRebootResponse struct {
}

//
// This operation sends a reboot request to a virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/reboot
// ----
// The reboot action does not take any action specific parameters, so the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the reboot should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Reboot(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "reboot", headers, query, wait)
	return err
}

type VmServiceRemoveRequest struct {
	vmService  *VmService
	header     map[string]string
	query      map[string]string
	async      *bool
	detachOnly *bool
	force      *bool
}

func (p *VmServiceRemoveRequest) Header(key, value string) *VmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceRemoveRequest) Query(key, value string) *VmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceRemoveRequest) Async(async bool) *VmServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmServiceRemoveRequest) DetachOnly(detachOnly bool) *VmServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}
func (p *VmServiceRemoveRequest) Force(force bool) *VmServiceRemoveRequest {
	p.force = &force
	return p
}
func (p *VmServiceRemoveRequest) Send() (*VmServiceRemoveResponse, error) {
}

type VmServiceRemoveResponse struct {
}

//
// Removes the virtual machine, including the virtual disks attached to it.
// For example, to remove the virtual machine with identifier `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `DetachOnly`:: Indicates if the attached virtual disks should be detached first and preserved instead of being removed.
// `Force`:: Indicates if the virtual machine should be forcibly removed.
// Locked virtual machines and virtual machines with locked disk images
// cannot be removed without this flag set to true.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Remove(
	async bool,
	detachOnly bool,
	force bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)
	query["detach_only"] = fmt.Sprintf("%v", detachOnly)
	query["force"] = fmt.Sprintf("%v", force)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VmServiceReorderMacAddressesRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceReorderMacAddressesRequest) Header(key, value string) *VmServiceReorderMacAddressesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceReorderMacAddressesRequest) Query(key, value string) *VmServiceReorderMacAddressesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceReorderMacAddressesRequest) Async(async bool) *VmServiceReorderMacAddressesRequest {
	p.async = &async
	return p
}
func (p *VmServiceReorderMacAddressesRequest) Send() (*VmServiceReorderMacAddressesResponse, error) {
}

type VmServiceReorderMacAddressesResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) ReorderMacAddresses(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "reordermacaddresses", headers, query, wait)
	return err
}

type VmServiceShutdownRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceShutdownRequest) Header(key, value string) *VmServiceShutdownRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceShutdownRequest) Query(key, value string) *VmServiceShutdownRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceShutdownRequest) Async(async bool) *VmServiceShutdownRequest {
	p.async = &async
	return p
}
func (p *VmServiceShutdownRequest) Send() (*VmServiceShutdownResponse, error) {
}

type VmServiceShutdownResponse struct {
}

//
// This operation sends a shutdown request to a virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/shutdown
// ----
// The shutdown action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the shutdown should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Shutdown(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "shutdown", headers, query, wait)
	return err
}

type VmServiceStartRequest struct {
	vmService    *VmService
	header       map[string]string
	query        map[string]string
	async        *bool
	filter       *bool
	pause        *bool
	useCloudInit *bool
	useSysprep   *bool
	vm           *Vm
}

func (p *VmServiceStartRequest) Header(key, value string) *VmServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceStartRequest) Query(key, value string) *VmServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceStartRequest) Async(async bool) *VmServiceStartRequest {
	p.async = &async
	return p
}
func (p *VmServiceStartRequest) Filter(filter bool) *VmServiceStartRequest {
	p.filter = &filter
	return p
}
func (p *VmServiceStartRequest) Pause(pause bool) *VmServiceStartRequest {
	p.pause = &pause
	return p
}
func (p *VmServiceStartRequest) UseCloudInit(useCloudInit bool) *VmServiceStartRequest {
	p.useCloudInit = &useCloudInit
	return p
}
func (p *VmServiceStartRequest) UseSysprep(useSysprep bool) *VmServiceStartRequest {
	p.useSysprep = &useSysprep
	return p
}
func (p *VmServiceStartRequest) Vm(vm *Vm) *VmServiceStartRequest {
	p.vm = vm
	return p
}
func (p *VmServiceStartRequest) Send() (*VmServiceStartResponse, error) {
}

type VmServiceStartResponse struct {
}

//
// Starts the virtual machine.
// If the virtual environment is complete and the virtual machine contains all necessary components to function,
// it can be started.
// This example starts the virtual machine:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/start
// ----
// With a request body:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Pause`:: If set to `true`, start the virtual machine in paused mode. Default is `false`.
// `Vm`:: The definition of the virtual machine for this specific run.
// For example:
// [source,xml]
// ----
// <action>
//   <vm>
//     <os>
//       <boot>
//         <devices>
//           <device>cdrom</device>
//         </devices>
//       </boot>
//     </os>
//   </vm>
// </action>
// ----
// This will set the boot device to the CDROM only for this specific start. After the virtual machine will be
// powered off, this definition will be reverted.
// `UseCloudInit`:: If set to `true`, the initialization type is set to _cloud-init_. The default value is `false`.
// See https://cloudinit.readthedocs.io/en/latest[this] for details.
// `UseSysprep`:: If set to `true`, the initialization type is set to _Sysprep_. The default value is `false`.
// See https://en.wikipedia.org/wiki/Sysprep[this] for details.
// `Async`:: Indicates if the action should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Start(
	async bool,
	filter bool,
	pause bool,
	useCloudInit bool,
	useSysprep bool,
	vm *Vm,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:        &async,
		Filter:       &filter,
		Pause:        &pause,
		UseCloudInit: &useCloudInit,
		UseSysprep:   &useSysprep,
		Vm:           vm,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "start", headers, query, wait)
	return err
}

type VmServiceStopRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceStopRequest) Header(key, value string) *VmServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceStopRequest) Query(key, value string) *VmServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceStopRequest) Async(async bool) *VmServiceStopRequest {
	p.async = &async
	return p
}
func (p *VmServiceStopRequest) Send() (*VmServiceStopResponse, error) {
}

type VmServiceStopResponse struct {
}

//
// This operation forces a virtual machine to power-off.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/stop
// ----
// The stop action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Stop(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "stop", headers, query, wait)
	return err
}

type VmServiceSuspendRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceSuspendRequest) Header(key, value string) *VmServiceSuspendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceSuspendRequest) Query(key, value string) *VmServiceSuspendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceSuspendRequest) Async(async bool) *VmServiceSuspendRequest {
	p.async = &async
	return p
}
func (p *VmServiceSuspendRequest) Send() (*VmServiceSuspendResponse, error) {
}

type VmServiceSuspendResponse struct {
}

//
// This operation saves the virtual machine state to disk and stops it.
// Start a suspended virtual machine and restore the virtual machine state with the start action.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/suspend
// ----
// The suspend action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Suspend(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "suspend", headers, query, wait)
	return err
}

type VmServiceThawFilesystemsRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceThawFilesystemsRequest) Header(key, value string) *VmServiceThawFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceThawFilesystemsRequest) Query(key, value string) *VmServiceThawFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceThawFilesystemsRequest) Async(async bool) *VmServiceThawFilesystemsRequest {
	p.async = &async
	return p
}
func (p *VmServiceThawFilesystemsRequest) Send() (*VmServiceThawFilesystemsResponse, error) {
}

type VmServiceThawFilesystemsResponse struct {
}

//
// Thaw virtual machine file systems.
// This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
// running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
// with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /api/vms/123/thawfilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) ThawFilesystems(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "thawfilesystems", headers, query, wait)
	return err
}

type VmServiceTicketRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	ticket    *Ticket
}

func (p *VmServiceTicketRequest) Header(key, value string) *VmServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceTicketRequest) Query(key, value string) *VmServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceTicketRequest) Async(async bool) *VmServiceTicketRequest {
	p.async = &async
	return p
}
func (p *VmServiceTicketRequest) Ticket(ticket *Ticket) *VmServiceTicketRequest {
	p.ticket = ticket
	return p
}
func (p *VmServiceTicketRequest) Send() (*VmServiceTicketResponse, error) {
}

type VmServiceTicketResponse struct {
	ticket *Ticket
}

func (p *VmServiceTicketResponse) Ticket() *Ticket {
	return p.ticket
}

//
// Generates a time-sensitive authentication token for accessing a virtual machine's display.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// [IMPORTANT]
// ====
// If the virtual machine is configured to support only one graphics protocol
// then the generated authentication token will be valid for that protocol.
// But if the virtual machine is configured to support multiple protocols,
// VNC and SPICE, then the authentication token will only be valid for
// the SPICE protocol.
// In order to obtain an authentication token for a specific protocol, for
// example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
// service>> that manages the graphics consoles of the virtual machine, sending
// a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// ====
// This method supports the following parameters:
// `Async`:: Indicates if the generation of the ticket should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) Ticket(
	async bool,
	ticket *Ticket,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Ticket,
	error) {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Ticket: ticket,
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "ticket", headers, query, wait)
	if err != nil {
		return nil, err
	}
	var ticketVar Ticket
	xml.Unmarshal([]byte(ovResp.Body), &ticketVar)
	return &ticketVar, nil
}

type VmServiceUndoSnapshotRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceUndoSnapshotRequest) Header(key, value string) *VmServiceUndoSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceUndoSnapshotRequest) Query(key, value string) *VmServiceUndoSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceUndoSnapshotRequest) Async(async bool) *VmServiceUndoSnapshotRequest {
	p.async = &async
	return p
}
func (p *VmServiceUndoSnapshotRequest) Send() (*VmServiceUndoSnapshotResponse, error) {
}

type VmServiceUndoSnapshotResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmService) UndoSnapshot(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "undosnapshot", headers, query, wait)
	return err
}

type VmServiceUpdateRequest struct {
	vmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	nextRun   *bool
	vm        *Vm
}

func (p *VmServiceUpdateRequest) Header(key, value string) *VmServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceUpdateRequest) Query(key, value string) *VmServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceUpdateRequest) Async(async bool) *VmServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmServiceUpdateRequest) NextRun(nextRun bool) *VmServiceUpdateRequest {
	p.nextRun = &nextRun
	return p
}
func (p *VmServiceUpdateRequest) Vm(vm *Vm) *VmServiceUpdateRequest {
	p.vm = vm
	return p
}
func (p *VmServiceUpdateRequest) Send() (*VmServiceUpdateResponse, error) {
}

type VmServiceUpdateResponse struct {
	vm *Vm
}

func (p *VmServiceUpdateResponse) Vm() *Vm {
	return p.vm
}

//
//
func (op *VmService) Update(
	vm *Vm,
	async bool,
	nextRun bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)
	query["next_run"] = fmt.Sprintf("%v", nextRun)

	// Send the request
	ovResp, err := op.internalUpdate(vm, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vm
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return &vmVar, nil
}

//
// List of scheduling labels assigned to this VM.
//
func (op *VmService) AffinityLabelsService() *AssignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.Connection, fmt.Sprintf("%s/affinitylabels", op.Path))
}

//
//
func (op *VmService) ApplicationsService() *VmApplicationsService {
	return NewVmApplicationsService(op.Connection, fmt.Sprintf("%s/applications", op.Path))
}

//
//
func (op *VmService) CdromsService() *VmCdromsService {
	return NewVmCdromsService(op.Connection, fmt.Sprintf("%s/cdroms", op.Path))
}

//
// List of disks attached to this virtual machine.
//
func (op *VmService) DiskAttachmentsService() *DiskAttachmentsService {
	return NewDiskAttachmentsService(op.Connection, fmt.Sprintf("%s/diskattachments", op.Path))
}

//
//
func (op *VmService) GraphicsConsolesService() *VmGraphicsConsolesService {
	return NewVmGraphicsConsolesService(op.Connection, fmt.Sprintf("%s/graphicsconsoles", op.Path))
}

//
//
func (op *VmService) HostDevicesService() *VmHostDevicesService {
	return NewVmHostDevicesService(op.Connection, fmt.Sprintf("%s/hostdevices", op.Path))
}

//
// Reference to the service that can show the applicable errata available on the virtual machine.
// This information is taken from Katello.
//
func (op *VmService) KatelloErrataService() *KatelloErrataService {
	return NewKatelloErrataService(op.Connection, fmt.Sprintf("%s/katelloerrata", op.Path))
}

//
//
func (op *VmService) NicsService() *VmNicsService {
	return NewVmNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
//
func (op *VmService) NumaNodesService() *VmNumaNodesService {
	return NewVmNumaNodesService(op.Connection, fmt.Sprintf("%s/numanodes", op.Path))
}

//
//
func (op *VmService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *VmService) ReportedDevicesService() *VmReportedDevicesService {
	return NewVmReportedDevicesService(op.Connection, fmt.Sprintf("%s/reporteddevices", op.Path))
}

//
// Reference to the service that provides information about virtual machine user sessions.
//
func (op *VmService) SessionsService() *VmSessionsService {
	return NewVmSessionsService(op.Connection, fmt.Sprintf("%s/sessions", op.Path))
}

//
//
func (op *VmService) SnapshotsService() *SnapshotsService {
	return NewSnapshotsService(op.Connection, fmt.Sprintf("%s/snapshots", op.Path))
}

//
//
func (op *VmService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
//
func (op *VmService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
//
func (op *VmService) WatchdogsService() *VmWatchdogsService {
	return NewVmWatchdogsService(op.Connection, fmt.Sprintf("%s/watchdogs", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "applications" {
		return op.ApplicationsService(), nil
	}
	if strings.HasPrefix(path, "applications/") {
		return op.ApplicationsService().Service(path[13:])
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "hostdevices" {
		return op.HostDevicesService(), nil
	}
	if strings.HasPrefix(path, "hostdevices/") {
		return op.HostDevicesService().Service(path[12:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "sessions" {
		return op.SessionsService(), nil
	}
	if strings.HasPrefix(path, "sessions/") {
		return op.SessionsService().Service(path[9:])
	}
	if path == "snapshots" {
		return op.SnapshotsService(), nil
	}
	if strings.HasPrefix(path, "snapshots/") {
		return op.SnapshotsService().Service(path[10:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmService) String() string {
	return fmt.Sprintf("VmService:%s", op.Path)
}

//
//
type InstanceTypeGraphicsConsolesService struct {
	BaseService
}

func NewInstanceTypeGraphicsConsolesService(connection *Connection, path string) *InstanceTypeGraphicsConsolesService {
	var result InstanceTypeGraphicsConsolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeGraphicsConsolesServiceAddRequest struct {
	instanceTypeGraphicsConsolesService *InstanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	console                             *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Header(key, value string) *InstanceTypeGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Query(key, value string) *InstanceTypeGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *InstanceTypeGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}
func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Send() (*InstanceTypeGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.Connection.URL(), p.instanceTypeGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.console)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeGraphicsConsolesService.Connection.username, p.instanceTypeGraphicsConsolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeGraphicsConsolesServiceAddResponse InstanceTypeGraphicsConsolesServiceAddResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	instanceTypeGraphicsConsolesServiceAddResponse.console = &consoleVar
	return &instanceTypeGraphicsConsolesServiceAddResponse, nil
}

type InstanceTypeGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceAddResponse) Console() *GraphicsConsole {
	return p.console
}

//
// Add new graphics console to the instance type.
//
func (op *InstanceTypeGraphicsConsolesService) Add(
	console *GraphicsConsole,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(console, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consoleVar GraphicsConsole
	xml.Unmarshal([]byte(ovResp.Body), &consoleVar)
	return &consoleVar, nil
}

type InstanceTypeGraphicsConsolesServiceListRequest struct {
	instanceTypeGraphicsConsolesService *InstanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	max                                 *int64
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Header(key, value string) *InstanceTypeGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Query(key, value string) *InstanceTypeGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Max(max int64) *InstanceTypeGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypeGraphicsConsolesServiceListRequest) Send() (*InstanceTypeGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.Connection.URL(), p.instanceTypeGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeGraphicsConsolesService.Connection.username, p.instanceTypeGraphicsConsolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeGraphicsConsolesServiceListResponse InstanceTypeGraphicsConsolesServiceListResponse
	var consolesVar GraphicsConsoles
	xml.Unmarshal(respBodyBytes, &consolesVar)
	instanceTypeGraphicsConsolesServiceListResponse.consoles = consolesVar.GraphicsConsoles
	return &instanceTypeGraphicsConsolesServiceListResponse, nil
}

type InstanceTypeGraphicsConsolesServiceListResponse struct {
	consoles []GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceListResponse) Consoles() []GraphicsConsole {
	return p.consoles
}

//
// Lists all the configured graphics consoles of the instance type.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of consoles to return. If not specified all the consoles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypeGraphicsConsolesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consolesVar GraphicsConsoles
	xml.Unmarshal([]byte(ovResp.Body), &consolesVar)
	return consolesVar.GraphicsConsoles, nil
}

//
// Returns a reference to the service that manages a specific instance type graphics console.
//
func (op *InstanceTypeGraphicsConsolesService) ConsoleService(id string) *InstanceTypeGraphicsConsoleService {
	return NewInstanceTypeGraphicsConsoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeGraphicsConsolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConsoleService(path)), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeGraphicsConsolesService) String() string {
	return fmt.Sprintf("InstanceTypeGraphicsConsolesService:%s", op.Path)
}

//
//
type StorageDomainVmService struct {
	BaseService
}

func NewStorageDomainVmService(connection *Connection, path string) *StorageDomainVmService {
	var result StorageDomainVmService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmServiceGetRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *StorageDomainVmServiceGetRequest) Header(key, value string) *StorageDomainVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceGetRequest) Query(key, value string) *StorageDomainVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceGetRequest) Send() (*StorageDomainVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmService.Connection.URL(), p.storageDomainVmService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmService.Connection.username, p.storageDomainVmService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainVmServiceGetResponse StorageDomainVmServiceGetResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	storageDomainVmServiceGetResponse.vm = &vmVar
	return &storageDomainVmServiceGetResponse, nil
}

type StorageDomainVmServiceGetResponse struct {
	vm *Vm
}

func (p *StorageDomainVmServiceGetResponse) Vm() *Vm {
	return p.vm
}

//
//
func (op *StorageDomainVmService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vm
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return &vmVar, nil
}

type StorageDomainVmServiceImportRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	clone                  *bool
	cluster                *Cluster
	collapseSnapshots      *bool
	storageDomain          *StorageDomain
	vm                     *Vm
}

func (p *StorageDomainVmServiceImportRequest) Header(key, value string) *StorageDomainVmServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceImportRequest) Query(key, value string) *StorageDomainVmServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceImportRequest) Async(async bool) *StorageDomainVmServiceImportRequest {
	p.async = &async
	return p
}
func (p *StorageDomainVmServiceImportRequest) Clone(clone bool) *StorageDomainVmServiceImportRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainVmServiceImportRequest) Cluster(cluster *Cluster) *StorageDomainVmServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainVmServiceImportRequest) CollapseSnapshots(collapseSnapshots bool) *StorageDomainVmServiceImportRequest {
	p.collapseSnapshots = &collapseSnapshots
	return p
}
func (p *StorageDomainVmServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainVmServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainVmServiceImportRequest) Vm(vm *Vm) *StorageDomainVmServiceImportRequest {
	p.vm = vm
	return p
}
func (p *StorageDomainVmServiceImportRequest) Send() (*StorageDomainVmServiceImportResponse, error) {
}

type StorageDomainVmServiceImportResponse struct {
}

//
// Imports a virtual machine from an export storage domain.
// For example, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/vms/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// To import a virtual machine as a new entity add the `clone` parameter:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <clone>true</clone>
//   <vm>
//     <name>myvm</name>
//   </vm>
// </action>
// ----
// Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
// of the template that have the identifiers `123` and `456` send the following request body:
// [source,xml]
// ----
// <action>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <vm>
//     <name>myvm</name>
//   </vm>
//   <disks>
//     <disk id="123"/>
//     <disk id="456"/>
//   </disks>
// </action>
// ----
// This method supports the following parameters:
// `Clone`:: Indicates if the identifiers of the imported virtual machine
// should be regenerated.
// By default when a virtual machine is imported the identifiers
// are preserved. This means that the same virtual machine can't
// be imported multiple times, as that identifiers needs to be
// unique. To allow importing the same machine multiple times set
// this parameter to `true`, as the default is `false`.
// `CollapseSnapshots`:: Indicates of the snapshots of the virtual machine that is imported
// should be collapsed, so that the result will be a virtual machine
// without snapshots.
// This parameter is optional, and if it isn't explicitly specified the
// default value is `false`.
// `Async`:: Indicates if the import should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainVmService) Import(
	async bool,
	clone bool,
	cluster *Cluster,
	collapseSnapshots bool,
	storageDomain *StorageDomain,
	vm *Vm,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:             &async,
		Clone:             &clone,
		Cluster:           cluster,
		CollapseSnapshots: &collapseSnapshots,
		StorageDomain:     storageDomain,
		Vm:                vm,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "import", headers, query, wait)
	return err
}

type StorageDomainVmServiceRegisterRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	allowPartialImport     *bool
	async                  *bool
	clone                  *bool
	cluster                *Cluster
	reassignBadMacs        *bool
	vm                     *Vm
	vnicProfileMappings    []VnicProfileMapping
}

func (p *StorageDomainVmServiceRegisterRequest) Header(key, value string) *StorageDomainVmServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Query(key, value string) *StorageDomainVmServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *StorageDomainVmServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Async(async bool) *StorageDomainVmServiceRegisterRequest {
	p.async = &async
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Clone(clone bool) *StorageDomainVmServiceRegisterRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Cluster(cluster *Cluster) *StorageDomainVmServiceRegisterRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) ReassignBadMacs(reassignBadMacs bool) *StorageDomainVmServiceRegisterRequest {
	p.reassignBadMacs = &reassignBadMacs
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Vm(vm *Vm) *StorageDomainVmServiceRegisterRequest {
	p.vm = vm
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) VnicProfileMappings(vnicProfileMappings []VnicProfileMapping) *StorageDomainVmServiceRegisterRequest {
	p.vnicProfileMappings = vnicProfileMappings
	return p
}
func (p *StorageDomainVmServiceRegisterRequest) Send() (*StorageDomainVmServiceRegisterResponse, error) {
}

type StorageDomainVmServiceRegisterResponse struct {
}

//
// This method supports the following parameters:
// `AllowPartialImport`:: Indicates whether a virtual machine is allowed to be registered with only some of its disks.
// If this flag is `true`, the engine will not fail in the validation process if an image is not found, but
// instead it will allow the virtual machine to be registered without the missing disks. This is mainly used
// during registration of a virtual machine when some of the storage domains are not available. The default
// value is `false`.
// `VnicProfileMappings`:: Mapping rules for virtual NIC profiles that will be applied during the import process.
// `ReassignBadMacs`:: Indicates if the problematic MAC addresses should be re-assigned during the import process by the engine.
// A MAC address would be considered as a problematic one if one of the following is true:
// - It conflicts with a MAC address that is already allocated to a virtual machine in the target environment.
// - It's out of the range of the target MAC address pool.
// `Async`:: Indicates if the registration should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainVmService) Register(
	allowPartialImport bool,
	async bool,
	clone bool,
	cluster *Cluster,
	reassignBadMacs bool,
	vm *Vm,
	vnicProfileMappings []VnicProfileMapping,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		AllowPartialImport:  &allowPartialImport,
		Async:               &async,
		Clone:               &clone,
		Cluster:             cluster,
		ReassignBadMacs:     &reassignBadMacs,
		Vm:                  vm,
		VnicProfileMappings: vnicProfileMappings,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "register", headers, query, wait)
	return err
}

type StorageDomainVmServiceRemoveRequest struct {
	storageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *StorageDomainVmServiceRemoveRequest) Header(key, value string) *StorageDomainVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceRemoveRequest) Query(key, value string) *StorageDomainVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceRemoveRequest) Async(async bool) *StorageDomainVmServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainVmServiceRemoveRequest) Send() (*StorageDomainVmServiceRemoveResponse, error) {
}

type StorageDomainVmServiceRemoveResponse struct {
}

//
// Deletes a virtual machine from an export storage domain.
// For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123/vms/456
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainVmService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Returns a reference to the service that manages the disk attachments of the virtual machine.
//
func (op *StorageDomainVmService) DiskAttachmentsService() *StorageDomainVmDiskAttachmentsService {
	return NewStorageDomainVmDiskAttachmentsService(op.Connection, fmt.Sprintf("%s/diskattachments", op.Path))
}

//
//
func (op *StorageDomainVmService) DisksService() *StorageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainVmService) String() string {
	return fmt.Sprintf("StorageDomainVmService:%s", op.Path)
}

//
// A service to manage specific cluster.
//
type ClusterService struct {
	BaseService
}

func NewClusterService(connection *Connection, path string) *ClusterService {
	var result ClusterService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClusterServiceGetRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	filter         *bool
}

func (p *ClusterServiceGetRequest) Header(key, value string) *ClusterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceGetRequest) Query(key, value string) *ClusterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceGetRequest) Filter(filter bool) *ClusterServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *ClusterServiceGetRequest) Send() (*ClusterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.Connection.URL(), p.clusterService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterService.Connection.username, p.clusterService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var clusterServiceGetResponse ClusterServiceGetResponse
	var clusterVar Cluster
	xml.Unmarshal(respBodyBytes, &clusterVar)
	clusterServiceGetResponse.cluster = &clusterVar
	return &clusterServiceGetResponse, nil
}

type ClusterServiceGetResponse struct {
	cluster *Cluster
}

func (p *ClusterServiceGetResponse) Cluster() *Cluster {
	return p.cluster
}

//
// Get information about the cluster.
// An example of getting a cluster:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123
// ----
// [source,xml]
// ----
// <cluster href="/ovirt-engine/api/clusters/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
//   </actions>
//   <name>Default</name>
//   <description>The default server cluster</description>
//   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
//   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
//   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
//   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
//   <ballooning_enabled>false</ballooning_enabled>
//   <cpu>
//     <architecture>x86_64</architecture>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <error_handling>
//     <on_error>migrate</on_error>
//   </error_handling>
//   <fencing_policy>
//     <enabled>true</enabled>
//     <skip_if_connectivity_broken>
//       <enabled>false</enabled>
//       <threshold>50</threshold>
//     </skip_if_connectivity_broken>
//     <skip_if_sd_active>
//       <enabled>false</enabled>
//     </skip_if_sd_active>
//   </fencing_policy>
//   <gluster_service>false</gluster_service>
//   <ha_reservation>false</ha_reservation>
//   <ksm>
//     <enabled>true</enabled>
//     <merge_across_nodes>true</merge_across_nodes>
//   </ksm>
//   <maintenance_reason_required>false</maintenance_reason_required>
//   <memory_policy>
//     <over_commit>
//       <percent>100</percent>
//     </over_commit>
//     <transparent_hugepages>
//       <enabled>true</enabled>
//     </transparent_hugepages>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <bandwidth>
//       <assignment_method>auto</assignment_method>
//     </bandwidth>
//     <compressed>inherit</compressed>
//   </migration>
//   <optional_reason>false</optional_reason>
//   <required_rng_sources>
//     <required_rng_source>random</required_rng_source>
//   </required_rng_sources>
//   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
//   <threads_as_cores>false</threads_as_cores>
//   <trusted_service>false</trusted_service>
//   <tunnel_migration>false</tunnel_migration>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <virt_service>true</virt_service>
//   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
// </cluster>
// ----
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ClusterService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Cluster,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var clusterVar Cluster
	xml.Unmarshal([]byte(ovResp.Body), &clusterVar)
	return &clusterVar, nil
}

type ClusterServiceRemoveRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *ClusterServiceRemoveRequest) Header(key, value string) *ClusterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceRemoveRequest) Query(key, value string) *ClusterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceRemoveRequest) Async(async bool) *ClusterServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *ClusterServiceRemoveRequest) Send() (*ClusterServiceRemoveResponse, error) {
}

type ClusterServiceRemoveResponse struct {
}

//
// Removes cluster from the system.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ClusterService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type ClusterServiceResetEmulatedMachineRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *ClusterServiceResetEmulatedMachineRequest) Header(key, value string) *ClusterServiceResetEmulatedMachineRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceResetEmulatedMachineRequest) Query(key, value string) *ClusterServiceResetEmulatedMachineRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceResetEmulatedMachineRequest) Async(async bool) *ClusterServiceResetEmulatedMachineRequest {
	p.async = &async
	return p
}
func (p *ClusterServiceResetEmulatedMachineRequest) Send() (*ClusterServiceResetEmulatedMachineResponse, error) {
}

type ClusterServiceResetEmulatedMachineResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the reset should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ClusterService) ResetEmulatedMachine(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "resetemulatedmachine", headers, query, wait)
	return err
}

type ClusterServiceUpdateRequest struct {
	clusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
	cluster        *Cluster
}

func (p *ClusterServiceUpdateRequest) Header(key, value string) *ClusterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceUpdateRequest) Query(key, value string) *ClusterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceUpdateRequest) Async(async bool) *ClusterServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *ClusterServiceUpdateRequest) Cluster(cluster *Cluster) *ClusterServiceUpdateRequest {
	p.cluster = cluster
	return p
}
func (p *ClusterServiceUpdateRequest) Send() (*ClusterServiceUpdateResponse, error) {
}

type ClusterServiceUpdateResponse struct {
	cluster *Cluster
}

func (p *ClusterServiceUpdateResponse) Cluster() *Cluster {
	return p.cluster
}

//
// Updates information about the cluster.
// Only specified fields are updated, others remain unchanged.
// E.g. update cluster's CPU:
// [source]
// ----
// PUT /ovirt-engine/api/clusters/123
// ----
// With request body like:
// [source,xml]
// ----
// <cluster>
//   <cpu>
//     <type>Intel Haswell-noTSX Family</type>
//   </cpu>
// </cluster>
// ----
//
func (op *ClusterService) Update(
	cluster *Cluster,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Cluster,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(cluster, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var clusterVar Cluster
	xml.Unmarshal([]byte(ovResp.Body), &clusterVar)
	return &clusterVar, nil
}

//
// Reference to the service that manages affinity groups.
//
func (op *ClusterService) AffinityGroupsService() *AffinityGroupsService {
	return NewAffinityGroupsService(op.Connection, fmt.Sprintf("%s/affinitygroups", op.Path))
}

//
// Reference to the service that manages assigned CPU profiles for cluster.
//
func (op *ClusterService) CpuProfilesService() *AssignedCpuProfilesService {
	return NewAssignedCpuProfilesService(op.Connection, fmt.Sprintf("%s/cpuprofiles", op.Path))
}

//
// Reference to the service that manages the Gluster hooks for cluster.
//
func (op *ClusterService) GlusterHooksService() *GlusterHooksService {
	return NewGlusterHooksService(op.Connection, fmt.Sprintf("%s/glusterhooks", op.Path))
}

//
// Reference to the service that manages Gluster volumes for cluster.
//
func (op *ClusterService) GlusterVolumesService() *GlusterVolumesService {
	return NewGlusterVolumesService(op.Connection, fmt.Sprintf("%s/glustervolumes", op.Path))
}

//
// A sub collection with all the supported network filters for this cluster.
//
func (op *ClusterService) NetworkFiltersService() *NetworkFiltersService {
	return NewNetworkFiltersService(op.Connection, fmt.Sprintf("%s/networkfilters", op.Path))
}

//
// Reference to the service that manages assigned networks for cluster.
//
func (op *ClusterService) NetworksService() *AssignedNetworksService {
	return NewAssignedNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
// Reference to permissions.
//
func (op *ClusterService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitygroups" {
		return op.AffinityGroupsService(), nil
	}
	if strings.HasPrefix(path, "affinitygroups/") {
		return op.AffinityGroupsService().Service(path[15:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "glusterhooks" {
		return op.GlusterHooksService(), nil
	}
	if strings.HasPrefix(path, "glusterhooks/") {
		return op.GlusterHooksService().Service(path[13:])
	}
	if path == "glustervolumes" {
		return op.GlusterVolumesService(), nil
	}
	if strings.HasPrefix(path, "glustervolumes/") {
		return op.GlusterVolumesService().Service(path[15:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterService) String() string {
	return fmt.Sprintf("ClusterService:%s", op.Path)
}

//
//
type SnapshotDisksService struct {
	BaseService
}

func NewSnapshotDisksService(connection *Connection, path string) *SnapshotDisksService {
	var result SnapshotDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotDisksServiceListRequest struct {
	snapshotDisksService *SnapshotDisksService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *SnapshotDisksServiceListRequest) Header(key, value string) *SnapshotDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotDisksServiceListRequest) Query(key, value string) *SnapshotDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotDisksServiceListRequest) Max(max int64) *SnapshotDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotDisksServiceListRequest) Send() (*SnapshotDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDisksService.Connection.URL(), p.snapshotDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotDisksService.Connection.username, p.snapshotDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotDisksServiceListResponse SnapshotDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	snapshotDisksServiceListResponse.disks = disksVar.Disks
	return &snapshotDisksServiceListResponse, nil
}

type SnapshotDisksServiceListResponse struct {
	disks []Disk
}

func (p *SnapshotDisksServiceListResponse) Disks() []Disk {
	return p.disks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of disks to return. If not specified all the disks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SnapshotDisksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var disksVar Disks
	xml.Unmarshal([]byte(ovResp.Body), &disksVar)
	return disksVar.Disks, nil
}

//
//
func (op *SnapshotDisksService) DiskService(id string) *SnapshotDiskService {
	return NewSnapshotDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotDisksService) String() string {
	return fmt.Sprintf("SnapshotDisksService:%s", op.Path)
}

//
//
type TemplateGraphicsConsolesService struct {
	BaseService
}

func NewTemplateGraphicsConsolesService(connection *Connection, path string) *TemplateGraphicsConsolesService {
	var result TemplateGraphicsConsolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateGraphicsConsolesServiceAddRequest struct {
	templateGraphicsConsolesService *TemplateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	console                         *GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Header(key, value string) *TemplateGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Query(key, value string) *TemplateGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *TemplateGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}
func (p *TemplateGraphicsConsolesServiceAddRequest) Send() (*TemplateGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.Connection.URL(), p.templateGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.console)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateGraphicsConsolesService.Connection.username, p.templateGraphicsConsolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateGraphicsConsolesServiceAddResponse TemplateGraphicsConsolesServiceAddResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	templateGraphicsConsolesServiceAddResponse.console = &consoleVar
	return &templateGraphicsConsolesServiceAddResponse, nil
}

type TemplateGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceAddResponse) Console() *GraphicsConsole {
	return p.console
}

//
// Add new graphics console to the template.
//
func (op *TemplateGraphicsConsolesService) Add(
	console *GraphicsConsole,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(console, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consoleVar GraphicsConsole
	xml.Unmarshal([]byte(ovResp.Body), &consoleVar)
	return &consoleVar, nil
}

type TemplateGraphicsConsolesServiceListRequest struct {
	templateGraphicsConsolesService *TemplateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *TemplateGraphicsConsolesServiceListRequest) Header(key, value string) *TemplateGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Query(key, value string) *TemplateGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Max(max int64) *TemplateGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateGraphicsConsolesServiceListRequest) Send() (*TemplateGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.Connection.URL(), p.templateGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateGraphicsConsolesService.Connection.username, p.templateGraphicsConsolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateGraphicsConsolesServiceListResponse TemplateGraphicsConsolesServiceListResponse
	var consolesVar GraphicsConsoles
	xml.Unmarshal(respBodyBytes, &consolesVar)
	templateGraphicsConsolesServiceListResponse.consoles = consolesVar.GraphicsConsoles
	return &templateGraphicsConsolesServiceListResponse, nil
}

type TemplateGraphicsConsolesServiceListResponse struct {
	consoles []GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceListResponse) Consoles() []GraphicsConsole {
	return p.consoles
}

//
// Lists all the configured graphics consoles of the template.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of consoles to return. If not specified all the consoles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateGraphicsConsolesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consolesVar GraphicsConsoles
	xml.Unmarshal([]byte(ovResp.Body), &consolesVar)
	return consolesVar.GraphicsConsoles, nil
}

//
// Returns a reference to the service that manages a specific template graphics console.
//
func (op *TemplateGraphicsConsolesService) ConsoleService(id string) *TemplateGraphicsConsoleService {
	return NewTemplateGraphicsConsoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateGraphicsConsolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConsoleService(path)), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *TemplateGraphicsConsolesService) String() string {
	return fmt.Sprintf("TemplateGraphicsConsolesService:%s", op.Path)
}

//
// A service to manage a virtual machines pool.
//
type VmPoolService struct {
	BaseService
}

func NewVmPoolService(connection *Connection, path string) *VmPoolService {
	var result VmPoolService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmPoolServiceAllocateVmRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmPoolServiceAllocateVmRequest) Header(key, value string) *VmPoolServiceAllocateVmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceAllocateVmRequest) Query(key, value string) *VmPoolServiceAllocateVmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceAllocateVmRequest) Async(async bool) *VmPoolServiceAllocateVmRequest {
	p.async = &async
	return p
}
func (p *VmPoolServiceAllocateVmRequest) Send() (*VmPoolServiceAllocateVmResponse, error) {
}

type VmPoolServiceAllocateVmResponse struct {
}

//
// This operation allocates a virtual machine in the virtual machine pool.
// [source]
// ----
// POST /ovirt-engine/api/vmpools/123/allocatevm
// ----
// The allocate virtual machine action does not take any action specific parameters, so the request body should
// contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the allocation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmPoolService) AllocateVm(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "allocatevm", headers, query, wait)
	return err
}

type VmPoolServiceGetRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	filter        *bool
}

func (p *VmPoolServiceGetRequest) Header(key, value string) *VmPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceGetRequest) Query(key, value string) *VmPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceGetRequest) Filter(filter bool) *VmPoolServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *VmPoolServiceGetRequest) Send() (*VmPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.Connection.URL(), p.vmPoolService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolService.Connection.username, p.vmPoolService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmPoolServiceGetResponse VmPoolServiceGetResponse
	var poolVar VmPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	vmPoolServiceGetResponse.pool = &poolVar
	return &vmPoolServiceGetResponse, nil
}

type VmPoolServiceGetResponse struct {
	pool *VmPool
}

func (p *VmPoolServiceGetResponse) Pool() *VmPool {
	return p.pool
}

//
// Get the virtual machine pool.
// [source]
// ----
// GET /ovirt-engine/api/vmpools/123
// ----
// You will get a XML response like that one:
// [source,xml]
// ----
// <vm_pool id="123">
//   <actions>...</actions>
//   <name>MyVmPool</name>
//   <description>MyVmPool description</description>
//   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
//   <max_user_vms>1</max_user_vms>
//   <prestarted_vms>0</prestarted_vms>
//   <size>100</size>
//   <stateful>false</stateful>
//   <type>automatic</type>
//   <use_latest_template_version>false</use_latest_template_version>
//   <cluster id="123"/>
//   <template id="123"/>
//   <vm id="123">...</vm>
//   ...
// </vm_pool>
// ----
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmPoolService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VmPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolVar VmPool
	xml.Unmarshal([]byte(ovResp.Body), &poolVar)
	return &poolVar, nil
}

type VmPoolServiceRemoveRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmPoolServiceRemoveRequest) Header(key, value string) *VmPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceRemoveRequest) Query(key, value string) *VmPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceRemoveRequest) Async(async bool) *VmPoolServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmPoolServiceRemoveRequest) Send() (*VmPoolServiceRemoveResponse, error) {
}

type VmPoolServiceRemoveResponse struct {
}

//
// Removes a virtual machine pool.
// [source]
// ----
// DELETE /ovirt-engine/api/vmpools/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmPoolService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VmPoolServiceUpdateRequest struct {
	vmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
	pool          *VmPool
}

func (p *VmPoolServiceUpdateRequest) Header(key, value string) *VmPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceUpdateRequest) Query(key, value string) *VmPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceUpdateRequest) Async(async bool) *VmPoolServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmPoolServiceUpdateRequest) Pool(pool *VmPool) *VmPoolServiceUpdateRequest {
	p.pool = pool
	return p
}
func (p *VmPoolServiceUpdateRequest) Send() (*VmPoolServiceUpdateResponse, error) {
}

type VmPoolServiceUpdateResponse struct {
	pool *VmPool
}

func (p *VmPoolServiceUpdateResponse) Pool() *VmPool {
	return p.pool
}

//
// Update the virtual machine pool.
// [source]
// ----
// PUT /ovirt-engine/api/vmpools/123
// ----
// The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
// attributes can be updated after the virtual machine pool has been
// created.
// [source,xml]
// ----
// <vmpool>
//   <name>VM_Pool_B</name>
//   <description>Virtual Machine Pool B</description>
//   <size>3</size>
//   <prestarted_vms>1</size>
//   <max_user_vms>2</size>
// </vmpool>
// ----
// This method supports the following parameters:
// `Pool`:: The virtual machine pool that is being updated.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmPoolService) Update(
	pool *VmPool,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VmPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(pool, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolVar VmPool
	xml.Unmarshal([]byte(ovResp.Body), &poolVar)
	return &poolVar, nil
}

//
// Reference to a service managing the virtual machine pool assigned permissions.
//
func (op *VmPoolService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmPoolService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmPoolService) String() string {
	return fmt.Sprintf("VmPoolService:%s", op.Path)
}

//
//
type QuotasService struct {
	BaseService
}

func NewQuotasService(connection *Connection, path string) *QuotasService {
	var result QuotasService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotasServiceAddRequest struct {
	quotasService *QuotasService
	header        map[string]string
	query         map[string]string
	quota         *Quota
}

func (p *QuotasServiceAddRequest) Header(key, value string) *QuotasServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotasServiceAddRequest) Query(key, value string) *QuotasServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotasServiceAddRequest) Quota(quota *Quota) *QuotasServiceAddRequest {
	p.quota = quota
	return p
}
func (p *QuotasServiceAddRequest) Send() (*QuotasServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.Connection.URL(), p.quotasService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.quota)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotasService.Connection.username, p.quotasService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotasService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotasServiceAddResponse QuotasServiceAddResponse
	var quotaVar Quota
	xml.Unmarshal(respBodyBytes, &quotaVar)
	quotasServiceAddResponse.quota = &quotaVar
	return &quotasServiceAddResponse, nil
}

type QuotasServiceAddResponse struct {
	quota *Quota
}

func (p *QuotasServiceAddResponse) Quota() *Quota {
	return p.quota
}

//
// Creates a new quota.
// An example of creating a new quota:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas
// ----
// [source,xml]
// ----
// <quota>
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
// </quota>
// ----
//
func (op *QuotasService) Add(
	quota *Quota,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Quota,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(quota, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var quotaVar Quota
	xml.Unmarshal([]byte(ovResp.Body), &quotaVar)
	return &quotaVar, nil
}

type QuotasServiceListRequest struct {
	quotasService *QuotasService
	header        map[string]string
	query         map[string]string
	max           *int64
}

func (p *QuotasServiceListRequest) Header(key, value string) *QuotasServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotasServiceListRequest) Query(key, value string) *QuotasServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotasServiceListRequest) Max(max int64) *QuotasServiceListRequest {
	p.max = &max
	return p
}
func (p *QuotasServiceListRequest) Send() (*QuotasServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.Connection.URL(), p.quotasService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotasService.Connection.username, p.quotasService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotasService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotasServiceListResponse QuotasServiceListResponse
	var quotasVar Quotas
	xml.Unmarshal(respBodyBytes, &quotasVar)
	quotasServiceListResponse.quotas = quotasVar.Quotas
	return &quotasServiceListResponse, nil
}

type QuotasServiceListResponse struct {
	quotas []Quota
}

func (p *QuotasServiceListResponse) Quotas() []Quota {
	return p.quotas
}

//
// Lists quotas of a data center
// This method supports the following parameters:
// `Max`:: Sets the maximum number of quota descriptors to return. If not specified all the descriptors are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QuotasService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Quota,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var quotasVar Quotas
	xml.Unmarshal([]byte(ovResp.Body), &quotasVar)
	return quotasVar.Quotas, nil
}

//
//
func (op *QuotasService) QuotaService(id string) *QuotaService {
	return NewQuotaService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotasService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.QuotaService(path)), nil
	}
	return op.QuotaService(path[:index]).Service(path[index+1:])
}

func (op *QuotasService) String() string {
	return fmt.Sprintf("QuotasService:%s", op.Path)
}

//
// Provides information about a specific cluster level. See the <<services/cluster_levels,ClusterLevels>> service for
// more information.
//
type ClusterLevelService struct {
	BaseService
}

func NewClusterLevelService(connection *Connection, path string) *ClusterLevelService {
	var result ClusterLevelService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClusterLevelServiceGetRequest struct {
	clusterLevelService *ClusterLevelService
	header              map[string]string
	query               map[string]string
}

func (p *ClusterLevelServiceGetRequest) Header(key, value string) *ClusterLevelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterLevelServiceGetRequest) Query(key, value string) *ClusterLevelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterLevelServiceGetRequest) Send() (*ClusterLevelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelService.Connection.URL(), p.clusterLevelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterLevelService.Connection.username, p.clusterLevelService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterLevelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var clusterLevelServiceGetResponse ClusterLevelServiceGetResponse
	var levelVar ClusterLevel
	xml.Unmarshal(respBodyBytes, &levelVar)
	clusterLevelServiceGetResponse.level = &levelVar
	return &clusterLevelServiceGetResponse, nil
}

type ClusterLevelServiceGetResponse struct {
	level *ClusterLevel
}

func (p *ClusterLevelServiceGetResponse) Level() *ClusterLevel {
	return p.level
}

//
// Provides the information about the capabilities of the specific cluster level managed by this service.
// For example, to find what CPU types are supported by level 3.6 you can send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/3.6
// ----
// That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
// information which describes the cluster level:
// [source,xml]
// ----
// <cluster_level id="3.6">
//   <cpu_types>
//     <cpu_type>
//       <name>Intel Conroe Family</name>
//       <level>3</level>
//       <architecture>x86_64</architecture>
//     </cpu_type>
//     ...
//   </cpu_types>
//   <permits>
//     <permit id="1">
//       <name>create_vm</name>
//       <administrative>false</administrative>
//     </permit>
//     ...
//   </permits>
// </cluster_level>
// ----
//
func (op *ClusterLevelService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ClusterLevel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var levelVar ClusterLevel
	xml.Unmarshal([]byte(ovResp.Body), &levelVar)
	return &levelVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterLevelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterLevelService) String() string {
	return fmt.Sprintf("ClusterLevelService:%s", op.Path)
}

//
//
type StorageDomainContentDiskService struct {
	BaseService
}

func NewStorageDomainContentDiskService(connection *Connection, path string) *StorageDomainContentDiskService {
	var result StorageDomainContentDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainContentDiskServiceGetRequest struct {
	storageDomainContentDiskService *StorageDomainContentDiskService
	header                          map[string]string
	query                           map[string]string
	filter                          *bool
}

func (p *StorageDomainContentDiskServiceGetRequest) Header(key, value string) *StorageDomainContentDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Query(key, value string) *StorageDomainContentDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Filter(filter bool) *StorageDomainContentDiskServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainContentDiskServiceGetRequest) Send() (*StorageDomainContentDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDiskService.Connection.URL(), p.storageDomainContentDiskService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainContentDiskService.Connection.username, p.storageDomainContentDiskService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainContentDiskServiceGetResponse StorageDomainContentDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	storageDomainContentDiskServiceGetResponse.disk = &diskVar
	return &storageDomainContentDiskServiceGetResponse, nil
}

type StorageDomainContentDiskServiceGetResponse struct {
	disk *Disk
}

func (p *StorageDomainContentDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}

//
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainContentDiskService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainContentDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainContentDiskService) String() string {
	return fmt.Sprintf("StorageDomainContentDiskService:%s", op.Path)
}

//
// A service that provides information about applications installed in a virtual machine.
//
type VmApplicationsService struct {
	BaseService
}

func NewVmApplicationsService(connection *Connection, path string) *VmApplicationsService {
	var result VmApplicationsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmApplicationsServiceListRequest struct {
	vmApplicationsService *VmApplicationsService
	header                map[string]string
	query                 map[string]string
	filter                *bool
	max                   *int64
}

func (p *VmApplicationsServiceListRequest) Header(key, value string) *VmApplicationsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmApplicationsServiceListRequest) Query(key, value string) *VmApplicationsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmApplicationsServiceListRequest) Filter(filter bool) *VmApplicationsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *VmApplicationsServiceListRequest) Max(max int64) *VmApplicationsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmApplicationsServiceListRequest) Send() (*VmApplicationsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationsService.Connection.URL(), p.vmApplicationsService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmApplicationsService.Connection.username, p.vmApplicationsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmApplicationsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmApplicationsServiceListResponse VmApplicationsServiceListResponse
	var applicationsVar Applications
	xml.Unmarshal(respBodyBytes, &applicationsVar)
	vmApplicationsServiceListResponse.applications = applicationsVar.Applications
	return &vmApplicationsServiceListResponse, nil
}

type VmApplicationsServiceListResponse struct {
	applications []Application
}

func (p *VmApplicationsServiceListResponse) Applications() []Application {
	return p.applications
}

//
// Returns a list of applications installed in the virtual machine.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of applications to return. If not specified all the applications are returned.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmApplicationsService) List(
	filter bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Application,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var applicationsVar Applications
	xml.Unmarshal([]byte(ovResp.Body), &applicationsVar)
	return applicationsVar.Applications, nil
}

//
// Returns a reference to the service that provides information about a specific application.
//
func (op *VmApplicationsService) ApplicationService(id string) *VmApplicationService {
	return NewVmApplicationService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmApplicationsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ApplicationService(path)), nil
	}
	return op.ApplicationService(path[:index]).Service(path[index+1:])
}

func (op *VmApplicationsService) String() string {
	return fmt.Sprintf("VmApplicationsService:%s", op.Path)
}

//
// Provides a way for clients to list available files.
// This services is specifically targeted to ISO storage domains, which contain ISO images and virtual floppy disks
// (VFDs) that an administrator uploads.
// The addition of a CDROM device to a virtual machine requires an ISO image from the files of an ISO storage domain.
//
type FilesService struct {
	BaseService
}

func NewFilesService(connection *Connection, path string) *FilesService {
	var result FilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type FilesServiceListRequest struct {
	filesService  *FilesService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *FilesServiceListRequest) Header(key, value string) *FilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilesServiceListRequest) Query(key, value string) *FilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilesServiceListRequest) CaseSensitive(caseSensitive bool) *FilesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *FilesServiceListRequest) Max(max int64) *FilesServiceListRequest {
	p.max = &max
	return p
}
func (p *FilesServiceListRequest) Search(search string) *FilesServiceListRequest {
	p.search = &search
	return p
}
func (p *FilesServiceListRequest) Send() (*FilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filesService.Connection.URL(), p.filesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filesService.Connection.username, p.filesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var filesServiceListResponse FilesServiceListResponse
	var fileVar Files
	xml.Unmarshal(respBodyBytes, &fileVar)
	filesServiceListResponse.file = fileVar.Files
	return &filesServiceListResponse, nil
}

type FilesServiceListResponse struct {
	file []File
}

func (p *FilesServiceListResponse) File() []File {
	return p.file
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of files to return. If not specified all the files are returned.
// `Search`:: A query string used to restrict the returned files.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *FilesService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]File,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var fileVar Files
	xml.Unmarshal([]byte(ovResp.Body), &fileVar)
	return fileVar.Files, nil
}

//
//
func (op *FilesService) FileService(id string) *FileService {
	return NewFileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.FileService(path)), nil
	}
	return op.FileService(path[:index]).Service(path[index+1:])
}

func (op *FilesService) String() string {
	return fmt.Sprintf("FilesService:%s", op.Path)
}

//
// This service manages a single virtual machine to affinity group assignment.
//
type AffinityGroupVmService struct {
	BaseService
}

func NewAffinityGroupVmService(connection *Connection, path string) *AffinityGroupVmService {
	var result AffinityGroupVmService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupVmServiceRemoveRequest struct {
	affinityGroupVmService *AffinityGroupVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *AffinityGroupVmServiceRemoveRequest) Header(key, value string) *AffinityGroupVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmServiceRemoveRequest) Query(key, value string) *AffinityGroupVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmServiceRemoveRequest) Async(async bool) *AffinityGroupVmServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AffinityGroupVmServiceRemoveRequest) Send() (*AffinityGroupVmServiceRemoveResponse, error) {
}

type AffinityGroupVmServiceRemoveResponse struct {
}

//
// Remove this virtual machine from the affinity group.
// This method supports the following parameters:
// `Async`:: Indicates if the removal should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AffinityGroupVmService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupVmService) String() string {
	return fmt.Sprintf("AffinityGroupVmService:%s", op.Path)
}

//
// Manages a CDROM device of a virtual machine.
// Changing and ejecting the disk is done using always the `update` method, to change the value of the `file`
// attribute.
//
type VmCdromService struct {
	BaseService
}

func NewVmCdromService(connection *Connection, path string) *VmCdromService {
	var result VmCdromService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmCdromServiceGetRequest struct {
	vmCdromService *VmCdromService
	header         map[string]string
	query          map[string]string
	current        *bool
}

func (p *VmCdromServiceGetRequest) Header(key, value string) *VmCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromServiceGetRequest) Query(key, value string) *VmCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromServiceGetRequest) Current(current bool) *VmCdromServiceGetRequest {
	p.current = &current
	return p
}
func (p *VmCdromServiceGetRequest) Send() (*VmCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromService.Connection.URL(), p.vmCdromService.Path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmCdromService.Connection.username, p.vmCdromService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmCdromService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmCdromServiceGetResponse VmCdromServiceGetResponse
	var cdromVar Cdrom
	xml.Unmarshal(respBodyBytes, &cdromVar)
	vmCdromServiceGetResponse.cdrom = &cdromVar
	return &vmCdromServiceGetResponse, nil
}

type VmCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *VmCdromServiceGetResponse) Cdrom() *Cdrom {
	return p.cdrom
}

//
// Returns the information about this CDROM device.
// The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
// and optionally the inserted disk.
// If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <file id="mycd.iso"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// If there is no disk inserted then the `file` attribute won't be reported:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// This method supports the following parameters:
// `Current`:: Indicates if the operation should return the information for the currently running virtual machine. This
// parameter is optional, and the default value is `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmCdromService) Get(
	current bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Cdrom,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["current"] = fmt.Sprintf("%v", current)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var cdromVar Cdrom
	xml.Unmarshal([]byte(ovResp.Body), &cdromVar)
	return &cdromVar, nil
}

type VmCdromServiceUpdateRequest struct {
	vmCdromService *VmCdromService
	header         map[string]string
	query          map[string]string
	cdrom          *Cdrom
	current        *bool
}

func (p *VmCdromServiceUpdateRequest) Header(key, value string) *VmCdromServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromServiceUpdateRequest) Query(key, value string) *VmCdromServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromServiceUpdateRequest) Cdrom(cdrom *Cdrom) *VmCdromServiceUpdateRequest {
	p.cdrom = cdrom
	return p
}
func (p *VmCdromServiceUpdateRequest) Current(current bool) *VmCdromServiceUpdateRequest {
	p.current = &current
	return p
}
func (p *VmCdromServiceUpdateRequest) Send() (*VmCdromServiceUpdateResponse, error) {
}

type VmCdromServiceUpdateResponse struct {
	cdrom *Cdrom
}

func (p *VmCdromServiceUpdateResponse) Cdrom() *Cdrom {
	return p.cdrom
}

//
// Updates the information about this CDROM device.
// It allows to change or eject the disk by changing the value of the `file` attribute.
// For example, to insert or change the disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
// ----
// The body should contain the new value for the `file` attribute:
// [source,xml]
// ----
// <cdrom>
//   <file id="mycd.iso"/>
// </cdrom>
// ----
// The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
// attached ISO storage domain.
// To eject the disk use a `file` with an empty `id`:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// By default the above operations change permanently the disk that will be visible to the virtual machine
// after the next boot, but they don't have any effect on the currently running virtual machine. If you want
// to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
// For example, to eject the current disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
// ----
// With a request body like this:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
// effect after the virtual machine is rebooted.
// This method supports the following parameters:
// `Cdrom`:: The information about the CDROM device.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmCdromService) Update(
	cdrom *Cdrom,
	current bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Cdrom,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["current"] = fmt.Sprintf("%v", current)

	// Send the request
	ovResp, err := op.internalUpdate(cdrom, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var cdromVar Cdrom
	xml.Unmarshal([]byte(ovResp.Body), &cdromVar)
	return &cdromVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmCdromService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmCdromService) String() string {
	return fmt.Sprintf("VmCdromService:%s", op.Path)
}

//
//
type QuotaClusterLimitService struct {
	BaseService
}

func NewQuotaClusterLimitService(connection *Connection, path string) *QuotaClusterLimitService {
	var result QuotaClusterLimitService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaClusterLimitServiceGetRequest struct {
	quotaClusterLimitService *QuotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
}

func (p *QuotaClusterLimitServiceGetRequest) Header(key, value string) *QuotaClusterLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitServiceGetRequest) Query(key, value string) *QuotaClusterLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitServiceGetRequest) Send() (*QuotaClusterLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitService.Connection.URL(), p.quotaClusterLimitService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaClusterLimitService.Connection.username, p.quotaClusterLimitService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotaClusterLimitServiceGetResponse QuotaClusterLimitServiceGetResponse
	var limitVar QuotaClusterLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaClusterLimitServiceGetResponse.limit = &limitVar
	return &quotaClusterLimitServiceGetResponse, nil
}

type QuotaClusterLimitServiceGetResponse struct {
	limit *QuotaClusterLimit
}

func (p *QuotaClusterLimitServiceGetResponse) Limit() *QuotaClusterLimit {
	return p.limit
}

//
//
func (op *QuotaClusterLimitService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*QuotaClusterLimit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var limitVar QuotaClusterLimit
	xml.Unmarshal([]byte(ovResp.Body), &limitVar)
	return &limitVar, nil
}

type QuotaClusterLimitServiceRemoveRequest struct {
	quotaClusterLimitService *QuotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *QuotaClusterLimitServiceRemoveRequest) Header(key, value string) *QuotaClusterLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitServiceRemoveRequest) Query(key, value string) *QuotaClusterLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitServiceRemoveRequest) Async(async bool) *QuotaClusterLimitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QuotaClusterLimitServiceRemoveRequest) Send() (*QuotaClusterLimitServiceRemoveResponse, error) {
}

type QuotaClusterLimitServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QuotaClusterLimitService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaClusterLimitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaClusterLimitService) String() string {
	return fmt.Sprintf("QuotaClusterLimitService:%s", op.Path)
}

//
// This service manages the attachment of a disk to a virtual machine.
//
type DiskAttachmentService struct {
	BaseService
}

func NewDiskAttachmentService(connection *Connection, path string) *DiskAttachmentService {
	var result DiskAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskAttachmentServiceGetRequest struct {
	diskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
}

func (p *DiskAttachmentServiceGetRequest) Header(key, value string) *DiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceGetRequest) Query(key, value string) *DiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceGetRequest) Send() (*DiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.Connection.URL(), p.diskAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentService.Connection.username, p.diskAttachmentService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskAttachmentServiceGetResponse DiskAttachmentServiceGetResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	diskAttachmentServiceGetResponse.attachment = &attachmentVar
	return &diskAttachmentServiceGetResponse, nil
}

type DiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentServiceGetResponse) Attachment() *DiskAttachment {
	return p.attachment
}

//
// Returns the details of the attachment, including the bootable flag and link to the disk.
// An example of getting a disk attachment:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/diskattachments/456
// ----
// [source,xml]
// ----
// <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
//   <active>true</active>
//   <bootable>true</bootable>
//   <interface>virtio</interface>
//   <disk href="/ovirt-engine/api/disks/456" id="456"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </disk_attachment>
// ----
//
func (op *DiskAttachmentService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentVar DiskAttachment
	xml.Unmarshal([]byte(ovResp.Body), &attachmentVar)
	return &attachmentVar, nil
}

type DiskAttachmentServiceRemoveRequest struct {
	diskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
	detachOnly            *bool
}

func (p *DiskAttachmentServiceRemoveRequest) Header(key, value string) *DiskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceRemoveRequest) Query(key, value string) *DiskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceRemoveRequest) DetachOnly(detachOnly bool) *DiskAttachmentServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}
func (p *DiskAttachmentServiceRemoveRequest) Send() (*DiskAttachmentServiceRemoveResponse, error) {
}

type DiskAttachmentServiceRemoveResponse struct {
}

//
// Removes the disk attachment.
// This will only detach the disk from the virtual machine, but won't remove it from
// the system, unless the `detach_only` parameter is `false`.
// An example of removing a disk attachment:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
// ----
// This method supports the following parameters:
// `DetachOnly`:: Indicates if the disk should only be detached from the virtual machine, but not removed from the system.
// The default value is `true`, which won't remove the disk from the system.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskAttachmentService) Remove(
	detachOnly bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["detach_only"] = fmt.Sprintf("%v", detachOnly)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type DiskAttachmentServiceUpdateRequest struct {
	diskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
	diskAttachment        *DiskAttachment
}

func (p *DiskAttachmentServiceUpdateRequest) Header(key, value string) *DiskAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceUpdateRequest) Query(key, value string) *DiskAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceUpdateRequest) DiskAttachment(diskAttachment *DiskAttachment) *DiskAttachmentServiceUpdateRequest {
	p.diskAttachment = diskAttachment
	return p
}
func (p *DiskAttachmentServiceUpdateRequest) Send() (*DiskAttachmentServiceUpdateResponse, error) {
}

type DiskAttachmentServiceUpdateResponse struct {
	diskAttachment *DiskAttachment
}

func (p *DiskAttachmentServiceUpdateResponse) DiskAttachment() *DiskAttachment {
	return p.diskAttachment
}

//
// Update the disk attachment and the disk properties within it.
// [source]
// ----
// PUT /vms/{vm:id}/disksattachments/{attachment:id}
// <disk_attachment>
//   <bootable>true</bootable>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
//
func (op *DiskAttachmentService) Update(
	diskAttachment *DiskAttachment,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request
	ovResp, err := op.internalUpdate(diskAttachment, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskAttachmentVar DiskAttachment
	xml.Unmarshal([]byte(ovResp.Body), &diskAttachmentVar)
	return &diskAttachmentVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskAttachmentService) String() string {
	return fmt.Sprintf("DiskAttachmentService:%s", op.Path)
}

//
// A service to manage a bookmark.
//
type BookmarkService struct {
	BaseService
}

func NewBookmarkService(connection *Connection, path string) *BookmarkService {
	var result BookmarkService
	result.Connection = connection
	result.Path = path
	return &result
}

type BookmarkServiceGetRequest struct {
	bookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
}

func (p *BookmarkServiceGetRequest) Header(key, value string) *BookmarkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceGetRequest) Query(key, value string) *BookmarkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceGetRequest) Send() (*BookmarkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.Connection.URL(), p.bookmarkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.bookmarkService.Connection.username, p.bookmarkService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.bookmarkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var bookmarkServiceGetResponse BookmarkServiceGetResponse
	var bookmarkVar Bookmark
	xml.Unmarshal(respBodyBytes, &bookmarkVar)
	bookmarkServiceGetResponse.bookmark = &bookmarkVar
	return &bookmarkServiceGetResponse, nil
}

type BookmarkServiceGetResponse struct {
	bookmark *Bookmark
}

func (p *BookmarkServiceGetResponse) Bookmark() *Bookmark {
	return p.bookmark
}

//
// Get a bookmark.
// An example for getting a bookmark:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks/123
// ----
// [source,xml]
// ----
// <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//   <name>example_vm</name>
//   <value>vm: name=example*</value>
// </bookmark>
// ----
//
func (op *BookmarkService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Bookmark,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bookmarkVar Bookmark
	xml.Unmarshal([]byte(ovResp.Body), &bookmarkVar)
	return &bookmarkVar, nil
}

type BookmarkServiceRemoveRequest struct {
	bookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *BookmarkServiceRemoveRequest) Header(key, value string) *BookmarkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceRemoveRequest) Query(key, value string) *BookmarkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceRemoveRequest) Async(async bool) *BookmarkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *BookmarkServiceRemoveRequest) Send() (*BookmarkServiceRemoveResponse, error) {
}

type BookmarkServiceRemoveResponse struct {
}

//
// Remove a bookmark.
// An example for removing a bookmark:
// [source]
// ----
// DELETE /ovirt-engine/api/bookmarks/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *BookmarkService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type BookmarkServiceUpdateRequest struct {
	bookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
	bookmark        *Bookmark
}

func (p *BookmarkServiceUpdateRequest) Header(key, value string) *BookmarkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceUpdateRequest) Query(key, value string) *BookmarkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceUpdateRequest) Async(async bool) *BookmarkServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *BookmarkServiceUpdateRequest) Bookmark(bookmark *Bookmark) *BookmarkServiceUpdateRequest {
	p.bookmark = bookmark
	return p
}
func (p *BookmarkServiceUpdateRequest) Send() (*BookmarkServiceUpdateResponse, error) {
}

type BookmarkServiceUpdateResponse struct {
	bookmark *Bookmark
}

func (p *BookmarkServiceUpdateResponse) Bookmark() *Bookmark {
	return p.bookmark
}

//
// Update a bookmark.
// An example for updating a bookmark:
// [source]
// ----
// PUT /ovirt-engine/api/bookmarks/123
// ----
// With the request body:
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
// This method supports the following parameters:
// `Bookmark`:: The updated bookmark.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *BookmarkService) Update(
	bookmark *Bookmark,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Bookmark,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(bookmark, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bookmarkVar Bookmark
	xml.Unmarshal([]byte(ovResp.Body), &bookmarkVar)
	return &bookmarkVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BookmarkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *BookmarkService) String() string {
	return fmt.Sprintf("BookmarkService:%s", op.Path)
}

//
//
type InstanceTypeNicService struct {
	BaseService
}

func NewInstanceTypeNicService(connection *Connection, path string) *InstanceTypeNicService {
	var result InstanceTypeNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeNicServiceGetRequest struct {
	instanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
}

func (p *InstanceTypeNicServiceGetRequest) Header(key, value string) *InstanceTypeNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceGetRequest) Query(key, value string) *InstanceTypeNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceGetRequest) Send() (*InstanceTypeNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.Connection.URL(), p.instanceTypeNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicService.Connection.username, p.instanceTypeNicService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeNicServiceGetResponse InstanceTypeNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	instanceTypeNicServiceGetResponse.nic = &nicVar
	return &instanceTypeNicServiceGetResponse, nil
}

type InstanceTypeNicServiceGetResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicServiceGetResponse) Nic() *Nic {
	return p.nic
}

//
// Gets network interface configuration of the instance type.
//
func (op *InstanceTypeNicService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

type InstanceTypeNicServiceRemoveRequest struct {
	instanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *InstanceTypeNicServiceRemoveRequest) Header(key, value string) *InstanceTypeNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceRemoveRequest) Query(key, value string) *InstanceTypeNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceRemoveRequest) Async(async bool) *InstanceTypeNicServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeNicServiceRemoveRequest) Send() (*InstanceTypeNicServiceRemoveResponse, error) {
}

type InstanceTypeNicServiceRemoveResponse struct {
}

//
// Remove the network interface from the instance type.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypeNicService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type InstanceTypeNicServiceUpdateRequest struct {
	instanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	nic                    *Nic
}

func (p *InstanceTypeNicServiceUpdateRequest) Header(key, value string) *InstanceTypeNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Query(key, value string) *InstanceTypeNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Async(async bool) *InstanceTypeNicServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeNicServiceUpdateRequest) Nic(nic *Nic) *InstanceTypeNicServiceUpdateRequest {
	p.nic = nic
	return p
}
func (p *InstanceTypeNicServiceUpdateRequest) Send() (*InstanceTypeNicServiceUpdateResponse, error) {
}

type InstanceTypeNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicServiceUpdateResponse) Nic() *Nic {
	return p.nic
}

//
// Updates the network interface configuration of the instance type.
//
func (op *InstanceTypeNicService) Update(
	nic *Nic,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(nic, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeNicService) String() string {
	return fmt.Sprintf("InstanceTypeNicService:%s", op.Path)
}

//
//
type AssignedDiskProfileService struct {
	BaseService
}

func NewAssignedDiskProfileService(connection *Connection, path string) *AssignedDiskProfileService {
	var result AssignedDiskProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedDiskProfileServiceGetRequest struct {
	assignedDiskProfileService *AssignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
}

func (p *AssignedDiskProfileServiceGetRequest) Header(key, value string) *AssignedDiskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfileServiceGetRequest) Query(key, value string) *AssignedDiskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfileServiceGetRequest) Send() (*AssignedDiskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfileService.Connection.URL(), p.assignedDiskProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedDiskProfileService.Connection.username, p.assignedDiskProfileService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedDiskProfileServiceGetResponse AssignedDiskProfileServiceGetResponse
	var diskProfileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &diskProfileVar)
	assignedDiskProfileServiceGetResponse.diskProfile = &diskProfileVar
	return &assignedDiskProfileServiceGetResponse, nil
}

type AssignedDiskProfileServiceGetResponse struct {
	diskProfile *DiskProfile
}

func (p *AssignedDiskProfileServiceGetResponse) DiskProfile() *DiskProfile {
	return p.diskProfile
}

//
//
func (op *AssignedDiskProfileService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskProfileVar DiskProfile
	xml.Unmarshal([]byte(ovResp.Body), &diskProfileVar)
	return &diskProfileVar, nil
}

type AssignedDiskProfileServiceRemoveRequest struct {
	assignedDiskProfileService *AssignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *AssignedDiskProfileServiceRemoveRequest) Header(key, value string) *AssignedDiskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfileServiceRemoveRequest) Query(key, value string) *AssignedDiskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfileServiceRemoveRequest) Async(async bool) *AssignedDiskProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedDiskProfileServiceRemoveRequest) Send() (*AssignedDiskProfileServiceRemoveResponse, error) {
}

type AssignedDiskProfileServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedDiskProfileService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedDiskProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedDiskProfileService) String() string {
	return fmt.Sprintf("AssignedDiskProfileService:%s", op.Path)
}

//
//
type NetworkLabelsService struct {
	BaseService
}

func NewNetworkLabelsService(connection *Connection, path string) *NetworkLabelsService {
	var result NetworkLabelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkLabelsServiceAddRequest struct {
	networkLabelsService *NetworkLabelsService
	header               map[string]string
	query                map[string]string
	label                *NetworkLabel
}

func (p *NetworkLabelsServiceAddRequest) Header(key, value string) *NetworkLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelsServiceAddRequest) Query(key, value string) *NetworkLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelsServiceAddRequest) Label(label *NetworkLabel) *NetworkLabelsServiceAddRequest {
	p.label = label
	return p
}
func (p *NetworkLabelsServiceAddRequest) Send() (*NetworkLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.Connection.URL(), p.networkLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.label)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkLabelsService.Connection.username, p.networkLabelsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkLabelsServiceAddResponse NetworkLabelsServiceAddResponse
	var labelVar NetworkLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	networkLabelsServiceAddResponse.label = &labelVar
	return &networkLabelsServiceAddResponse, nil
}

type NetworkLabelsServiceAddResponse struct {
	label *NetworkLabel
}

func (p *NetworkLabelsServiceAddResponse) Label() *NetworkLabel {
	return p.label
}

//
// Attaches label to logical network.
// You can attach labels to a logical network to automate the association of that logical network with physical host
// network interfaces to which the same label has been attached.
// For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks/123/labels
// ----
// With a request body like this:
// [source,xml]
// ----
// <label id="mylabel"/>
// ----
//
func (op *NetworkLabelsService) Add(
	label *NetworkLabel,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(label, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar NetworkLabel
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return &labelVar, nil
}

type NetworkLabelsServiceListRequest struct {
	networkLabelsService *NetworkLabelsService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *NetworkLabelsServiceListRequest) Header(key, value string) *NetworkLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelsServiceListRequest) Query(key, value string) *NetworkLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelsServiceListRequest) Max(max int64) *NetworkLabelsServiceListRequest {
	p.max = &max
	return p
}
func (p *NetworkLabelsServiceListRequest) Send() (*NetworkLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.Connection.URL(), p.networkLabelsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkLabelsService.Connection.username, p.networkLabelsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkLabelsServiceListResponse NetworkLabelsServiceListResponse
	var labelsVar NetworkLabels
	xml.Unmarshal(respBodyBytes, &labelsVar)
	networkLabelsServiceListResponse.labels = labelsVar.NetworkLabels
	return &networkLabelsServiceListResponse, nil
}

type NetworkLabelsServiceListResponse struct {
	labels []NetworkLabel
}

func (p *NetworkLabelsServiceListResponse) Labels() []NetworkLabel {
	return p.labels
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of labels to return. If not specified all the labels are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworkLabelsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]NetworkLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelsVar NetworkLabels
	xml.Unmarshal([]byte(ovResp.Body), &labelsVar)
	return labelsVar.NetworkLabels, nil
}

//
//
func (op *NetworkLabelsService) LabelService(id string) *NetworkLabelService {
	return NewNetworkLabelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkLabelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LabelService(path)), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *NetworkLabelsService) String() string {
	return fmt.Sprintf("NetworkLabelsService:%s", op.Path)
}

//
//
type StorageDomainService struct {
	BaseService
}

func NewStorageDomainService(connection *Connection, path string) *StorageDomainService {
	var result StorageDomainService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainServiceGetRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	filter               *bool
}

func (p *StorageDomainServiceGetRequest) Header(key, value string) *StorageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceGetRequest) Query(key, value string) *StorageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceGetRequest) Filter(filter bool) *StorageDomainServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainServiceGetRequest) Send() (*StorageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.Connection.URL(), p.storageDomainService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainService.Connection.username, p.storageDomainService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainServiceGetResponse StorageDomainServiceGetResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	storageDomainServiceGetResponse.storageDomain = &storageDomainVar
	return &storageDomainServiceGetResponse, nil
}

type StorageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainServiceGetResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}

//
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageDomain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainVar StorageDomain
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainVar)
	return &storageDomainVar, nil
}

type StorageDomainServiceIsAttachedRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	host                 *Host
}

func (p *StorageDomainServiceIsAttachedRequest) Header(key, value string) *StorageDomainServiceIsAttachedRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Query(key, value string) *StorageDomainServiceIsAttachedRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Async(async bool) *StorageDomainServiceIsAttachedRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceIsAttachedRequest) Host(host *Host) *StorageDomainServiceIsAttachedRequest {
	p.host = host
	return p
}
func (p *StorageDomainServiceIsAttachedRequest) Send() (*StorageDomainServiceIsAttachedResponse, error) {
}

type StorageDomainServiceIsAttachedResponse struct {
	isAttached bool
}

func (p *StorageDomainServiceIsAttachedResponse) IsAttached() bool {
	return p.isAttached
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainService) IsAttached(
	async bool,
	host *Host,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	bool,
	error) {
	// Populate the action:
	action := &Action{
		Async: &async,
		Host:  host,
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "isattached", headers, query, wait)
	if err != nil {
		return false, err
	}
	return strconv.ParseBool(ovResp.Body)
}

type StorageDomainServiceReduceLunsRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	logicalUnits         []LogicalUnit
}

func (p *StorageDomainServiceReduceLunsRequest) Header(key, value string) *StorageDomainServiceReduceLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) Query(key, value string) *StorageDomainServiceReduceLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) LogicalUnits(logicalUnits []LogicalUnit) *StorageDomainServiceReduceLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}
func (p *StorageDomainServiceReduceLunsRequest) Send() (*StorageDomainServiceReduceLunsResponse, error) {
}

type StorageDomainServiceReduceLunsResponse struct {
}

//
// This operation reduces logical units from the storage domain.
// In order to do so the data stored on the provided logical units will be moved to other logical units of the
// storage domain and only then they will be reduced from the storage domain.
// For example, in order to reduce two logical units from a storage domain send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/reduceluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
// This method supports the following parameters:
// `LogicalUnits`:: The logical units that needs to be reduced from the storage domain.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainService) ReduceLuns(
	logicalUnits []LogicalUnit,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		LogicalUnits: logicalUnits,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "reduceluns", headers, query, wait)
	return err
}

type StorageDomainServiceRefreshLunsRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	logicalUnits         []LogicalUnit
}

func (p *StorageDomainServiceRefreshLunsRequest) Header(key, value string) *StorageDomainServiceRefreshLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) Query(key, value string) *StorageDomainServiceRefreshLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) Async(async bool) *StorageDomainServiceRefreshLunsRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceRefreshLunsRequest) LogicalUnits(logicalUnits []LogicalUnit) *StorageDomainServiceRefreshLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}
func (p *StorageDomainServiceRefreshLunsRequest) Send() (*StorageDomainServiceRefreshLunsResponse, error) {
}

type StorageDomainServiceRefreshLunsResponse struct {
}

//
// This operation refreshes the LUN size.
// After increasing the size of the underlying LUN on the storage server,
// the user can refresh the LUN size.
// This action forces a rescan of the provided LUNs and
// updates the database with the new size if required.
// For example, in order to refresh the size of two LUNs send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
// This method supports the following parameters:
// `LogicalUnits`:: The LUNs that need to be refreshed.
// `Async`:: Indicates if the refresh should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainService) RefreshLuns(
	async bool,
	logicalUnits []LogicalUnit,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:        &async,
		LogicalUnits: logicalUnits,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "refreshluns", headers, query, wait)
	return err
}

type StorageDomainServiceRemoveRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	destroy              *bool
	format               *bool
	host                 *string
}

func (p *StorageDomainServiceRemoveRequest) Header(key, value string) *StorageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceRemoveRequest) Query(key, value string) *StorageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceRemoveRequest) Async(async bool) *StorageDomainServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceRemoveRequest) Destroy(destroy bool) *StorageDomainServiceRemoveRequest {
	p.destroy = &destroy
	return p
}
func (p *StorageDomainServiceRemoveRequest) Format(format bool) *StorageDomainServiceRemoveRequest {
	p.format = &format
	return p
}
func (p *StorageDomainServiceRemoveRequest) Host(host string) *StorageDomainServiceRemoveRequest {
	p.host = &host
	return p
}
func (p *StorageDomainServiceRemoveRequest) Send() (*StorageDomainServiceRemoveResponse, error) {
}

type StorageDomainServiceRemoveResponse struct {
}

//
// Removes the storage domain.
// Without any special parameters, the storage domain is detached from the system and removed from the database. The
// storage domain can then be imported to the same or different setup, with all the data on it. If the storage isn't
// accessible the operation will fail.
// If the `destroy` parameter is `true` then the operation will always succeed, even if the storage isn't
// accessible, the failure is just ignored and the storage domain is removed from the database anyway.
// If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
// LUN or directory, so it can no longer be imported to the same or a different setup.
// This method supports the following parameters:
// `Host`:: Indicates what host should be used to remove the storage domain.
// This parameter is mandatory, and it can contain the name or the identifier of the host. For example, to use
// the host named `myhost` to remove the storage domain with identifier `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123?host=myhost
// ----
// `Format`:: Indicates if the actual storage should be formatted, removing all the metadata from the underlying LUN or
// directory:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123?format=true
// ----
// This parameter is optional, and the default value is `false`.
// `Destroy`:: Indicates if the operation should succeed, and the storage domain removed from the database, even if the
// storage isn't accessible.
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123?destroy=true
// ----
// This parameter is optional, and the default value is `false`.
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainService) Remove(
	host string,
	format bool,
	destroy bool,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["host"] = fmt.Sprintf("%v", host)
	query["format"] = fmt.Sprintf("%v", format)
	query["destroy"] = fmt.Sprintf("%v", destroy)
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type StorageDomainServiceUpdateRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	storageDomain        *StorageDomain
}

func (p *StorageDomainServiceUpdateRequest) Header(key, value string) *StorageDomainServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceUpdateRequest) Query(key, value string) *StorageDomainServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceUpdateRequest) Async(async bool) *StorageDomainServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceUpdateRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainServiceUpdateRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainServiceUpdateRequest) Send() (*StorageDomainServiceUpdateResponse, error) {
}

type StorageDomainServiceUpdateResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainServiceUpdateResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}

//
// Updates a storage domain.
// Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable post-creation. Those that can be
// updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
// `wipe_after_delete` (note that changing the `wipe_after_delete` attribute will not change the wipe after delete
// property of disks that already exist).
// To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
// request as follows:
// [source]
// ----
// PUT /ovirt-engine/api/storagedomains/123
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>data2</name>
//   <wipe_after_delete>true</wipe_after_delete>
// </storage_domain>
// ----
//
func (op *StorageDomainService) Update(
	storageDomain *StorageDomain,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageDomain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(storageDomain, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainVar StorageDomain
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainVar)
	return &storageDomainVar, nil
}

type StorageDomainServiceUpdateOvfStoreRequest struct {
	storageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Header(key, value string) *StorageDomainServiceUpdateOvfStoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Query(key, value string) *StorageDomainServiceUpdateOvfStoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Async(async bool) *StorageDomainServiceUpdateOvfStoreRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServiceUpdateOvfStoreRequest) Send() (*StorageDomainServiceUpdateOvfStoreResponse, error) {
}

type StorageDomainServiceUpdateOvfStoreResponse struct {
}

//
// This operation forces the update of the `OVF_STORE`
// of this storage domain.
// The `OVF_STORE` is a disk image that contains the meta-data
// of virtual machines and disks that reside in the
// storage domain. This meta-data is used in case the
// domain is imported or exported to or from a different
// data center or a different installation.
// By default the `OVF_STORE` is updated periodically
// (set by default to 60 minutes) but users might want to force an
// update after an important change, or when the they believe the
// `OVF_STORE` is corrupt.
// When initiated by the user, `OVF_STORE` update will be performed whether
// an update is needed or not.
// This method supports the following parameters:
// `Async`:: Indicates if the `OVF_STORE` update should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainService) UpdateOvfStore(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "updateovfstore", headers, query, wait)
	return err
}

//
//
func (op *StorageDomainService) DiskProfilesService() *AssignedDiskProfilesService {
	return NewAssignedDiskProfilesService(op.Connection, fmt.Sprintf("%s/diskprofiles", op.Path))
}

//
//
func (op *StorageDomainService) DiskSnapshotsService() *DiskSnapshotsService {
	return NewDiskSnapshotsService(op.Connection, fmt.Sprintf("%s/disksnapshots", op.Path))
}

//
// Reference to the service that manages the disks available in the storage domain.
//
func (op *StorageDomainService) DisksService() *StorageDomainDisksService {
	return NewStorageDomainDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Returns a reference to the service that manages the files available in the storage domain.
//
func (op *StorageDomainService) FilesService() *FilesService {
	return NewFilesService(op.Connection, fmt.Sprintf("%s/files", op.Path))
}

//
//
func (op *StorageDomainService) ImagesService() *ImagesService {
	return NewImagesService(op.Connection, fmt.Sprintf("%s/images", op.Path))
}

//
//
func (op *StorageDomainService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Returns a reference to the service that manages the storage connections.
//
func (op *StorageDomainService) StorageConnectionsService() *StorageDomainServerConnectionsService {
	return NewStorageDomainServerConnectionsService(op.Connection, fmt.Sprintf("%s/storageconnections", op.Path))
}

//
//
func (op *StorageDomainService) TemplatesService() *StorageDomainTemplatesService {
	return NewStorageDomainTemplatesService(op.Connection, fmt.Sprintf("%s/templates", op.Path))
}

//
//
func (op *StorageDomainService) VmsService() *StorageDomainVmsService {
	return NewStorageDomainVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disksnapshots" {
		return op.DiskSnapshotsService(), nil
	}
	if strings.HasPrefix(path, "disksnapshots/") {
		return op.DiskSnapshotsService().Service(path[14:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "files" {
		return op.FilesService(), nil
	}
	if strings.HasPrefix(path, "files/") {
		return op.FilesService().Service(path[6:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainService) String() string {
	return fmt.Sprintf("StorageDomainService:%s", op.Path)
}

//
// A service to manage data centers.
//
type DataCentersService struct {
	BaseService
}

func NewDataCentersService(connection *Connection, path string) *DataCentersService {
	var result DataCentersService
	result.Connection = connection
	result.Path = path
	return &result
}

type DataCentersServiceAddRequest struct {
	dataCentersService *DataCentersService
	header             map[string]string
	query              map[string]string
	dataCenter         *DataCenter
}

func (p *DataCentersServiceAddRequest) Header(key, value string) *DataCentersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCentersServiceAddRequest) Query(key, value string) *DataCentersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCentersServiceAddRequest) DataCenter(dataCenter *DataCenter) *DataCentersServiceAddRequest {
	p.dataCenter = dataCenter
	return p
}
func (p *DataCentersServiceAddRequest) Send() (*DataCentersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.Connection.URL(), p.dataCentersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.dataCenter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCentersService.Connection.username, p.dataCentersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCentersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var dataCentersServiceAddResponse DataCentersServiceAddResponse
	var dataCenterVar DataCenter
	xml.Unmarshal(respBodyBytes, &dataCenterVar)
	dataCentersServiceAddResponse.dataCenter = &dataCenterVar
	return &dataCentersServiceAddResponse, nil
}

type DataCentersServiceAddResponse struct {
	dataCenter *DataCenter
}

func (p *DataCentersServiceAddResponse) DataCenter() *DataCenter {
	return p.dataCenter
}

//
// Creates a new data center.
// Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
// named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>mydc</name>
//   <local>false</local>
// </data_center>
// ----
// This method supports the following parameters:
// `DataCenter`:: The data center that is being added.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DataCentersService) Add(
	dataCenter *DataCenter,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DataCenter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(dataCenter, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var dataCenterVar DataCenter
	xml.Unmarshal([]byte(ovResp.Body), &dataCenterVar)
	return &dataCenterVar, nil
}

type DataCentersServiceListRequest struct {
	dataCentersService *DataCentersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	filter             *bool
	max                *int64
	search             *string
}

func (p *DataCentersServiceListRequest) Header(key, value string) *DataCentersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCentersServiceListRequest) Query(key, value string) *DataCentersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCentersServiceListRequest) CaseSensitive(caseSensitive bool) *DataCentersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DataCentersServiceListRequest) Filter(filter bool) *DataCentersServiceListRequest {
	p.filter = &filter
	return p
}
func (p *DataCentersServiceListRequest) Max(max int64) *DataCentersServiceListRequest {
	p.max = &max
	return p
}
func (p *DataCentersServiceListRequest) Search(search string) *DataCentersServiceListRequest {
	p.search = &search
	return p
}
func (p *DataCentersServiceListRequest) Send() (*DataCentersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.Connection.URL(), p.dataCentersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCentersService.Connection.username, p.dataCentersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCentersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var dataCentersServiceListResponse DataCentersServiceListResponse
	var dataCentersVar DataCenters
	xml.Unmarshal(respBodyBytes, &dataCentersVar)
	dataCentersServiceListResponse.dataCenters = dataCentersVar.DataCenters
	return &dataCentersServiceListResponse, nil
}

type DataCentersServiceListResponse struct {
	dataCenters []DataCenter
}

func (p *DataCentersServiceListResponse) DataCenters() []DataCenter {
	return p.dataCenters
}

//
// Lists the data centers.
// The following request retrieves a representation of the data centers:
// [source]
// ----
// GET /ovirt-engine/api/datacenters
// ----
// The above request performed with `curl`:
// [source,bash]
// ----
// curl \
// --request GET \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --header "Version: 4" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// https://myengine.example.com/ovirt-engine/api/datacenters
// ----
// This is what an example response could look like:
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//     </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
// </data_center>
// ----
// Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
// resources of your virtual environment.
// The data center also contains a link to the storage domains collection. The data center uses this collection to
// attach storage domains from the storage domains main collection.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of data centers to return. If not specified all the data centers are returned.
// `Search`:: A query string used to restrict the returned data centers.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DataCentersService) List(
	caseSensitive bool,
	filter bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]DataCenter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var dataCentersVar DataCenters
	xml.Unmarshal([]byte(ovResp.Body), &dataCentersVar)
	return dataCentersVar.DataCenters, nil
}

//
// Reference to the service that manages a specific data center.
//
func (op *DataCentersService) DataCenterService(id string) *DataCenterService {
	return NewDataCenterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCentersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DataCenterService(path)), nil
	}
	return op.DataCenterService(path[:index]).Service(path[index+1:])
}

func (op *DataCentersService) String() string {
	return fmt.Sprintf("DataCentersService:%s", op.Path)
}

//
// A service that provides information about an application installed in a virtual machine.
//
type VmApplicationService struct {
	BaseService
}

func NewVmApplicationService(connection *Connection, path string) *VmApplicationService {
	var result VmApplicationService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmApplicationServiceGetRequest struct {
	vmApplicationService *VmApplicationService
	header               map[string]string
	query                map[string]string
	filter               *bool
}

func (p *VmApplicationServiceGetRequest) Header(key, value string) *VmApplicationServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmApplicationServiceGetRequest) Query(key, value string) *VmApplicationServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmApplicationServiceGetRequest) Filter(filter bool) *VmApplicationServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *VmApplicationServiceGetRequest) Send() (*VmApplicationServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationService.Connection.URL(), p.vmApplicationService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmApplicationService.Connection.username, p.vmApplicationService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmApplicationService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmApplicationServiceGetResponse VmApplicationServiceGetResponse
	var applicationVar Application
	xml.Unmarshal(respBodyBytes, &applicationVar)
	vmApplicationServiceGetResponse.application = &applicationVar
	return &vmApplicationServiceGetResponse, nil
}

type VmApplicationServiceGetResponse struct {
	application *Application
}

func (p *VmApplicationServiceGetResponse) Application() *Application {
	return p.application
}

//
// Returns the information about the application.
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmApplicationService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Application,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var applicationVar Application
	xml.Unmarshal([]byte(ovResp.Body), &applicationVar)
	return &applicationVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmApplicationService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmApplicationService) String() string {
	return fmt.Sprintf("VmApplicationService:%s", op.Path)
}

//
//
type QuotaStorageLimitsService struct {
	BaseService
}

func NewQuotaStorageLimitsService(connection *Connection, path string) *QuotaStorageLimitsService {
	var result QuotaStorageLimitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaStorageLimitsServiceAddRequest struct {
	quotaStorageLimitsService *QuotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceAddRequest) Header(key, value string) *QuotaStorageLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceAddRequest) Query(key, value string) *QuotaStorageLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceAddRequest) Limit(limit *QuotaStorageLimit) *QuotaStorageLimitsServiceAddRequest {
	p.limit = limit
	return p
}
func (p *QuotaStorageLimitsServiceAddRequest) Send() (*QuotaStorageLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.Connection.URL(), p.quotaStorageLimitsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.limit)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaStorageLimitsService.Connection.username, p.quotaStorageLimitsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotaStorageLimitsServiceAddResponse QuotaStorageLimitsServiceAddResponse
	var limitVar QuotaStorageLimit
	xml.Unmarshal(respBodyBytes, &limitVar)
	quotaStorageLimitsServiceAddResponse.limit = &limitVar
	return &quotaStorageLimitsServiceAddResponse, nil
}

type QuotaStorageLimitsServiceAddResponse struct {
	limit *QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceAddResponse) Limit() *QuotaStorageLimit {
	return p.limit
}

//
//
func (op *QuotaStorageLimitsService) Add(
	limit *QuotaStorageLimit,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*QuotaStorageLimit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(limit, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var limitVar QuotaStorageLimit
	xml.Unmarshal([]byte(ovResp.Body), &limitVar)
	return &limitVar, nil
}

type QuotaStorageLimitsServiceListRequest struct {
	quotaStorageLimitsService *QuotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *QuotaStorageLimitsServiceListRequest) Header(key, value string) *QuotaStorageLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Query(key, value string) *QuotaStorageLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Max(max int64) *QuotaStorageLimitsServiceListRequest {
	p.max = &max
	return p
}
func (p *QuotaStorageLimitsServiceListRequest) Send() (*QuotaStorageLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.Connection.URL(), p.quotaStorageLimitsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaStorageLimitsService.Connection.username, p.quotaStorageLimitsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotaStorageLimitsServiceListResponse QuotaStorageLimitsServiceListResponse
	var limitsVar QuotaStorageLimits
	xml.Unmarshal(respBodyBytes, &limitsVar)
	quotaStorageLimitsServiceListResponse.limits = limitsVar.QuotaStorageLimits
	return &quotaStorageLimitsServiceListResponse, nil
}

type QuotaStorageLimitsServiceListResponse struct {
	limits []QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceListResponse) Limits() []QuotaStorageLimit {
	return p.limits
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of limits to return. If not specified all the limits are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QuotaStorageLimitsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]QuotaStorageLimit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var limitsVar QuotaStorageLimits
	xml.Unmarshal([]byte(ovResp.Body), &limitsVar)
	return limitsVar.QuotaStorageLimits, nil
}

//
//
func (op *QuotaStorageLimitsService) LimitService(id string) *QuotaStorageLimitService {
	return NewQuotaStorageLimitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaStorageLimitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LimitService(path)), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *QuotaStorageLimitsService) String() string {
	return fmt.Sprintf("QuotaStorageLimitsService:%s", op.Path)
}

//
//
type TemplateNicService struct {
	BaseService
}

func NewTemplateNicService(connection *Connection, path string) *TemplateNicService {
	var result TemplateNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateNicServiceGetRequest struct {
	templateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
}

func (p *TemplateNicServiceGetRequest) Header(key, value string) *TemplateNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceGetRequest) Query(key, value string) *TemplateNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceGetRequest) Send() (*TemplateNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.Connection.URL(), p.templateNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateNicService.Connection.username, p.templateNicService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateNicServiceGetResponse TemplateNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	templateNicServiceGetResponse.nic = &nicVar
	return &templateNicServiceGetResponse, nil
}

type TemplateNicServiceGetResponse struct {
	nic *Nic
}

func (p *TemplateNicServiceGetResponse) Nic() *Nic {
	return p.nic
}

//
//
func (op *TemplateNicService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

type TemplateNicServiceRemoveRequest struct {
	templateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *TemplateNicServiceRemoveRequest) Header(key, value string) *TemplateNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceRemoveRequest) Query(key, value string) *TemplateNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceRemoveRequest) Async(async bool) *TemplateNicServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateNicServiceRemoveRequest) Send() (*TemplateNicServiceRemoveResponse, error) {
}

type TemplateNicServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateNicService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type TemplateNicServiceUpdateRequest struct {
	templateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
	nic                *Nic
}

func (p *TemplateNicServiceUpdateRequest) Header(key, value string) *TemplateNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceUpdateRequest) Query(key, value string) *TemplateNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceUpdateRequest) Async(async bool) *TemplateNicServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TemplateNicServiceUpdateRequest) Nic(nic *Nic) *TemplateNicServiceUpdateRequest {
	p.nic = nic
	return p
}
func (p *TemplateNicServiceUpdateRequest) Send() (*TemplateNicServiceUpdateResponse, error) {
}

type TemplateNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *TemplateNicServiceUpdateResponse) Nic() *Nic {
	return p.nic
}

//
//
func (op *TemplateNicService) Update(
	nic *Nic,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(nic, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateNicService) String() string {
	return fmt.Sprintf("TemplateNicService:%s", op.Path)
}

//
// Manages the CDROM devices of a virtual machine.
// Currently virtual machines have exactly one CDROM device. No new devices can be added, and the existing one can't
// be removed, thus there are no `add` or `remove` methods. Changing and ejecting CDROM disks is done with the
// <<services/vm_cdrom/methods/update, update>> method of the <<services/vm_cdrom, service>> that manages the
// CDROM device.
//
type VmCdromsService struct {
	BaseService
}

func NewVmCdromsService(connection *Connection, path string) *VmCdromsService {
	var result VmCdromsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmCdromsServiceListRequest struct {
	vmCdromsService *VmCdromsService
	header          map[string]string
	query           map[string]string
	max             *int64
}

func (p *VmCdromsServiceListRequest) Header(key, value string) *VmCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromsServiceListRequest) Query(key, value string) *VmCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromsServiceListRequest) Max(max int64) *VmCdromsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmCdromsServiceListRequest) Send() (*VmCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromsService.Connection.URL(), p.vmCdromsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmCdromsService.Connection.username, p.vmCdromsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmCdromsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmCdromsServiceListResponse VmCdromsServiceListResponse
	var cdromsVar Cdroms
	xml.Unmarshal(respBodyBytes, &cdromsVar)
	vmCdromsServiceListResponse.cdroms = cdromsVar.Cdroms
	return &vmCdromsServiceListResponse, nil
}

type VmCdromsServiceListResponse struct {
	cdroms []Cdrom
}

func (p *VmCdromsServiceListResponse) Cdroms() []Cdrom {
	return p.cdroms
}

//
// Returns the list of CDROM devices of the virtual machine.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of CDROMs to return. If not specified all the CDROMs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmCdromsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Cdrom,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var cdromsVar Cdroms
	xml.Unmarshal([]byte(ovResp.Body), &cdromsVar)
	return cdromsVar.Cdroms, nil
}

//
// Returns a reference to the service that manages a specific CDROM device.
//
func (op *VmCdromsService) CdromService(id string) *VmCdromService {
	return NewVmCdromService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmCdromsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CdromService(path)), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *VmCdromsService) String() string {
	return fmt.Sprintf("VmCdromsService:%s", op.Path)
}

//
// Provides information about virtual machine user sessions.
//
type VmSessionsService struct {
	BaseService
}

func NewVmSessionsService(connection *Connection, path string) *VmSessionsService {
	var result VmSessionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmSessionsServiceListRequest struct {
	vmSessionsService *VmSessionsService
	header            map[string]string
	query             map[string]string
	max               *int64
}

func (p *VmSessionsServiceListRequest) Header(key, value string) *VmSessionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmSessionsServiceListRequest) Query(key, value string) *VmSessionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmSessionsServiceListRequest) Max(max int64) *VmSessionsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmSessionsServiceListRequest) Send() (*VmSessionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionsService.Connection.URL(), p.vmSessionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmSessionsService.Connection.username, p.vmSessionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmSessionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmSessionsServiceListResponse VmSessionsServiceListResponse
	var sessionsVar Sessions
	xml.Unmarshal(respBodyBytes, &sessionsVar)
	vmSessionsServiceListResponse.sessions = sessionsVar.Sessions
	return &vmSessionsServiceListResponse, nil
}

type VmSessionsServiceListResponse struct {
	sessions []Session
}

func (p *VmSessionsServiceListResponse) Sessions() []Session {
	return p.sessions
}

//
// Lists all user sessions for this virtual machine.
// For example, to retrieve the session information for virtual machine `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/sessions
// ----
// The response body will contain something like this:
// [source,xml]
// ----
// <sessions>
//   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
//     <console_user>true</console_user>
//     <ip>
//       <address>192.168.122.1</address>
//     </ip>
//     <user href="/ovirt-engine/api/users/789" id="789"/>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </session>
//   ...
// </sessions>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of sessions to return. If not specified all the sessions are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmSessionsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Session,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var sessionsVar Sessions
	xml.Unmarshal([]byte(ovResp.Body), &sessionsVar)
	return sessionsVar.Sessions, nil
}

//
// Reference to the service that manages a specific session.
//
func (op *VmSessionsService) SessionService(id string) *VmSessionService {
	return NewVmSessionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmSessionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SessionService(path)), nil
	}
	return op.SessionService(path[:index]).Service(path[index+1:])
}

func (op *VmSessionsService) String() string {
	return fmt.Sprintf("VmSessionsService:%s", op.Path)
}

//
//
type VmDiskService struct {
	BaseService
}

func NewVmDiskService(connection *Connection, path string) *VmDiskService {
	var result VmDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmDiskServiceActivateRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceActivateRequest) Header(key, value string) *VmDiskServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceActivateRequest) Query(key, value string) *VmDiskServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceActivateRequest) Async(async bool) *VmDiskServiceActivateRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceActivateRequest) Send() (*VmDiskServiceActivateResponse, error) {
}

type VmDiskServiceActivateResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the activation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmDiskService) Activate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "activate", headers, query, wait)
	return err
}

type VmDiskServiceDeactivateRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceDeactivateRequest) Header(key, value string) *VmDiskServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceDeactivateRequest) Query(key, value string) *VmDiskServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceDeactivateRequest) Async(async bool) *VmDiskServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceDeactivateRequest) Send() (*VmDiskServiceDeactivateResponse, error) {
}

type VmDiskServiceDeactivateResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the deactivation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmDiskService) Deactivate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "deactivate", headers, query, wait)
	return err
}

type VmDiskServiceExportRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *VmDiskServiceExportRequest) Header(key, value string) *VmDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceExportRequest) Query(key, value string) *VmDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceExportRequest) Async(async bool) *VmDiskServiceExportRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceExportRequest) Filter(filter bool) *VmDiskServiceExportRequest {
	p.filter = &filter
	return p
}
func (p *VmDiskServiceExportRequest) Send() (*VmDiskServiceExportResponse, error) {
}

type VmDiskServiceExportResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the export should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmDiskService) Export(
	async bool,
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Filter: &filter,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "export", headers, query, wait)
	return err
}

type VmDiskServiceGetRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
}

func (p *VmDiskServiceGetRequest) Header(key, value string) *VmDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceGetRequest) Query(key, value string) *VmDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceGetRequest) Send() (*VmDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.Connection.URL(), p.vmDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDiskService.Connection.username, p.vmDiskService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmDiskServiceGetResponse VmDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	vmDiskServiceGetResponse.disk = &diskVar
	return &vmDiskServiceGetResponse, nil
}

type VmDiskServiceGetResponse struct {
	disk *Disk
}

func (p *VmDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}

//
//
func (op *VmDiskService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type VmDiskServiceMoveRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *VmDiskServiceMoveRequest) Header(key, value string) *VmDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceMoveRequest) Query(key, value string) *VmDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceMoveRequest) Async(async bool) *VmDiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceMoveRequest) Filter(filter bool) *VmDiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *VmDiskServiceMoveRequest) Send() (*VmDiskServiceMoveResponse, error) {
}

type VmDiskServiceMoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the move should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmDiskService) Move(
	async bool,
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Filter: &filter,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "move", headers, query, wait)
	return err
}

type VmDiskServiceRemoveRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceRemoveRequest) Header(key, value string) *VmDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceRemoveRequest) Query(key, value string) *VmDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceRemoveRequest) Async(async bool) *VmDiskServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceRemoveRequest) Send() (*VmDiskServiceRemoveResponse, error) {
}

type VmDiskServiceRemoveResponse struct {
}

//
// Detach the disk from the virtual machine.
// NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
// version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
// method of the top level disk service>>.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmDiskService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VmDiskServiceUpdateRequest struct {
	vmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
}

func (p *VmDiskServiceUpdateRequest) Header(key, value string) *VmDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceUpdateRequest) Query(key, value string) *VmDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceUpdateRequest) Async(async bool) *VmDiskServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmDiskServiceUpdateRequest) Disk(disk *Disk) *VmDiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *VmDiskServiceUpdateRequest) Send() (*VmDiskServiceUpdateResponse, error) {
}

type VmDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *VmDiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}

//
//
func (op *VmDiskService) Update(
	disk *Disk,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

//
//
func (op *VmDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *VmDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmDiskService) String() string {
	return fmt.Sprintf("VmDiskService:%s", op.Path)
}

//
//
type StorageServerConnectionService struct {
	BaseService
}

func NewStorageServerConnectionService(connection *Connection, path string) *StorageServerConnectionService {
	var result StorageServerConnectionService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionServiceGetRequest struct {
	storageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
}

func (p *StorageServerConnectionServiceGetRequest) Header(key, value string) *StorageServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceGetRequest) Query(key, value string) *StorageServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceGetRequest) Send() (*StorageServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.Connection.URL(), p.storageServerConnectionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionService.Connection.username, p.storageServerConnectionService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageServerConnectionServiceGetResponse StorageServerConnectionServiceGetResponse
	var conectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &conectionVar)
	storageServerConnectionServiceGetResponse.conection = &conectionVar
	return &storageServerConnectionServiceGetResponse, nil
}

type StorageServerConnectionServiceGetResponse struct {
	conection *StorageConnection
}

func (p *StorageServerConnectionServiceGetResponse) Conection() *StorageConnection {
	return p.conection
}

//
//
func (op *StorageServerConnectionService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnection,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var conectionVar StorageConnection
	xml.Unmarshal([]byte(ovResp.Body), &conectionVar)
	return &conectionVar, nil
}

type StorageServerConnectionServiceRemoveRequest struct {
	storageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	host                           *string
}

func (p *StorageServerConnectionServiceRemoveRequest) Header(key, value string) *StorageServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Query(key, value string) *StorageServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Async(async bool) *StorageServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionServiceRemoveRequest) Host(host string) *StorageServerConnectionServiceRemoveRequest {
	p.host = &host
	return p
}
func (p *StorageServerConnectionServiceRemoveRequest) Send() (*StorageServerConnectionServiceRemoveResponse, error) {
}

type StorageServerConnectionServiceRemoveResponse struct {
}

//
// Removes a storage connection.
// A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
// id is optional; providing it disconnects (unmounts) the connection from that host.
// This method supports the following parameters:
// `Host`:: The name or identifier of the host from which the connection would be unmounted (disconnected). If not
// provided, no host will be disconnected.
// For example, to use the host with identifier `456` to delete the storage connection with identifier `123`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storageconnections/123?host=456
// ----
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageServerConnectionService) Remove(
	host string,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["host"] = fmt.Sprintf("%v", host)
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type StorageServerConnectionServiceUpdateRequest struct {
	storageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateRequest) Header(key, value string) *StorageServerConnectionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Query(key, value string) *StorageServerConnectionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Async(async bool) *StorageServerConnectionServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionServiceUpdateRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateRequest {
	p.connection = connection
	return p
}
func (p *StorageServerConnectionServiceUpdateRequest) Force(force bool) *StorageServerConnectionServiceUpdateRequest {
	p.force = &force
	return p
}
func (p *StorageServerConnectionServiceUpdateRequest) Send() (*StorageServerConnectionServiceUpdateResponse, error) {
}

type StorageServerConnectionServiceUpdateResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateResponse) Connection() *StorageConnection {
	return p.connection
}

//
// Updates the storage connection.
// For example, to change the address of the storage server send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <address>mynewnfs.example.com</address>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
func (op *StorageServerConnectionService) Update(
	connection *StorageConnection,
	async bool,
	force bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnection,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)
	query["force"] = fmt.Sprintf("%v", force)

	// Send the request
	ovResp, err := op.internalUpdate(connection, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var connectionVar StorageConnection
	xml.Unmarshal([]byte(ovResp.Body), &connectionVar)
	return &connectionVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageServerConnectionService) String() string {
	return fmt.Sprintf("StorageServerConnectionService:%s", op.Path)
}

//
// A service to manage a host.
//
type HostService struct {
	BaseService
}

func NewHostService(connection *Connection, path string) *HostService {
	var result HostService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostServiceActivateRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceActivateRequest) Header(key, value string) *HostServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceActivateRequest) Query(key, value string) *HostServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceActivateRequest) Async(async bool) *HostServiceActivateRequest {
	p.async = &async
	return p
}
func (p *HostServiceActivateRequest) Send() (*HostServiceActivateResponse, error) {
}

type HostServiceActivateResponse struct {
}

//
// Activate the host for use, such as running virtual machines.
// This method supports the following parameters:
// `Async`:: Indicates if the activation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Activate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "activate", headers, query, wait)
	return err
}

type HostServiceApproveRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	cluster     *Cluster
}

func (p *HostServiceApproveRequest) Header(key, value string) *HostServiceApproveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceApproveRequest) Query(key, value string) *HostServiceApproveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceApproveRequest) Async(async bool) *HostServiceApproveRequest {
	p.async = &async
	return p
}
func (p *HostServiceApproveRequest) Cluster(cluster *Cluster) *HostServiceApproveRequest {
	p.cluster = cluster
	return p
}
func (p *HostServiceApproveRequest) Send() (*HostServiceApproveResponse, error) {
}

type HostServiceApproveResponse struct {
}

//
// Approve a pre-installed Hypervisor host for usage in the virtualization environment.
// This action also accepts an optional cluster element to define the target cluster for this host.
// This method supports the following parameters:
// `Async`:: Indicates if the approval should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Approve(
	async bool,
	cluster *Cluster,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:   &async,
		Cluster: cluster,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "approve", headers, query, wait)
	return err
}

type HostServiceCommitNetConfigRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceCommitNetConfigRequest) Header(key, value string) *HostServiceCommitNetConfigRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceCommitNetConfigRequest) Query(key, value string) *HostServiceCommitNetConfigRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceCommitNetConfigRequest) Async(async bool) *HostServiceCommitNetConfigRequest {
	p.async = &async
	return p
}
func (p *HostServiceCommitNetConfigRequest) Send() (*HostServiceCommitNetConfigResponse, error) {
}

type HostServiceCommitNetConfigResponse struct {
}

//
// Marks the network configuration as good and persists it inside the host.
// An API user commits the network configuration to persist a host network interface attachment or detachment, or
// persist the creation and deletion of a bonded interface.
// IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
// not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
// automatically reverts to the previous networking configuration.
// For example, to commit the network configuration of host with id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/commitnetconfig
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) CommitNetConfig(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "commitnetconfig", headers, query, wait)
	return err
}

type HostServiceDeactivateRequest struct {
	hostService        *HostService
	header             map[string]string
	query              map[string]string
	async              *bool
	reason             *string
	stopGlusterService *bool
}

func (p *HostServiceDeactivateRequest) Header(key, value string) *HostServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceDeactivateRequest) Query(key, value string) *HostServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceDeactivateRequest) Async(async bool) *HostServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *HostServiceDeactivateRequest) Reason(reason string) *HostServiceDeactivateRequest {
	p.reason = &reason
	return p
}
func (p *HostServiceDeactivateRequest) StopGlusterService(stopGlusterService bool) *HostServiceDeactivateRequest {
	p.stopGlusterService = &stopGlusterService
	return p
}
func (p *HostServiceDeactivateRequest) Send() (*HostServiceDeactivateResponse, error) {
}

type HostServiceDeactivateResponse struct {
}

//
// Deactivate the host to perform maintenance tasks.
// This method supports the following parameters:
// `Async`:: Indicates if the deactivation should be performed asynchronously.
// `StopGlusterService`:: Indicates if the gluster service should be stopped as part of deactivating the host. It can be used while
// performing maintenance operations on the gluster host. Default value for this variable is `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Deactivate(
	async bool,
	reason string,
	stopGlusterService bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:              &async,
		Reason:             &reason,
		StopGlusterService: &stopGlusterService,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "deactivate", headers, query, wait)
	return err
}

type HostServiceEnrollCertificateRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceEnrollCertificateRequest) Header(key, value string) *HostServiceEnrollCertificateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceEnrollCertificateRequest) Query(key, value string) *HostServiceEnrollCertificateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceEnrollCertificateRequest) Async(async bool) *HostServiceEnrollCertificateRequest {
	p.async = &async
	return p
}
func (p *HostServiceEnrollCertificateRequest) Send() (*HostServiceEnrollCertificateResponse, error) {
}

type HostServiceEnrollCertificateResponse struct {
}

//
// Enroll certificate of the host. Useful in case you get a warning that it is about to, or already expired.
// This method supports the following parameters:
// `Async`:: Indicates if the enrollment should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) EnrollCertificate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "enrollcertificate", headers, query, wait)
	return err
}

type HostServiceFenceRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	fenceType   *string
}

func (p *HostServiceFenceRequest) Header(key, value string) *HostServiceFenceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceFenceRequest) Query(key, value string) *HostServiceFenceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceFenceRequest) Async(async bool) *HostServiceFenceRequest {
	p.async = &async
	return p
}
func (p *HostServiceFenceRequest) FenceType(fenceType string) *HostServiceFenceRequest {
	p.fenceType = &fenceType
	return p
}
func (p *HostServiceFenceRequest) Send() (*HostServiceFenceResponse, error) {
}

type HostServiceFenceResponse struct {
	powerManagement *PowerManagement
}

func (p *HostServiceFenceResponse) PowerManagement() *PowerManagement {
	return p.powerManagement
}

//
// Controls host's power management device.
// For example, let's assume you want to start the host. This can be done via:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <fence_type>start</fence_type>
// </action>
// ' \
// "${url}/hosts/123/fence"
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the fencing should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Fence(
	async bool,
	fenceType string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*PowerManagement,
	error) {
	// Populate the action:
	action := &Action{
		Async:     &async,
		FenceType: &fenceType,
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "fence", headers, query, wait)
	if err != nil {
		return nil, err
	}
	var powerManagementVar PowerManagement
	xml.Unmarshal([]byte(ovResp.Body), &powerManagementVar)
	return &powerManagementVar, nil
}

type HostServiceForceSelectSpmRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceForceSelectSpmRequest) Header(key, value string) *HostServiceForceSelectSpmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceForceSelectSpmRequest) Query(key, value string) *HostServiceForceSelectSpmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceForceSelectSpmRequest) Async(async bool) *HostServiceForceSelectSpmRequest {
	p.async = &async
	return p
}
func (p *HostServiceForceSelectSpmRequest) Send() (*HostServiceForceSelectSpmResponse, error) {
}

type HostServiceForceSelectSpmResponse struct {
}

//
// Manually set a host as the storage pool manager (SPM).
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/forceselectspm
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) ForceSelectSpm(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "forceselectspm", headers, query, wait)
	return err
}

type HostServiceGetRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	filter      *bool
}

func (p *HostServiceGetRequest) Header(key, value string) *HostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceGetRequest) Query(key, value string) *HostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceGetRequest) Filter(filter bool) *HostServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *HostServiceGetRequest) Send() (*HostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostService.Connection.URL(), p.hostService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostService.Connection.username, p.hostService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostServiceGetResponse HostServiceGetResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	hostServiceGetResponse.host = &hostVar
	return &hostServiceGetResponse, nil
}

type HostServiceGetResponse struct {
	host *Host
}

func (p *HostServiceGetResponse) Host() *Host {
	return p.host
}

//
// Get the host details.
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Host,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostVar Host
	xml.Unmarshal([]byte(ovResp.Body), &hostVar)
	return &hostVar, nil
}

type HostServiceInstallRequest struct {
	hostService          *HostService
	header               map[string]string
	query                map[string]string
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *HostServiceInstallRequest) Header(key, value string) *HostServiceInstallRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceInstallRequest) Query(key, value string) *HostServiceInstallRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceInstallRequest) Async(async bool) *HostServiceInstallRequest {
	p.async = &async
	return p
}
func (p *HostServiceInstallRequest) DeployHostedEngine(deployHostedEngine bool) *HostServiceInstallRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}
func (p *HostServiceInstallRequest) Host(host *Host) *HostServiceInstallRequest {
	p.host = host
	return p
}
func (p *HostServiceInstallRequest) Image(image string) *HostServiceInstallRequest {
	p.image = &image
	return p
}
func (p *HostServiceInstallRequest) RootPassword(rootPassword string) *HostServiceInstallRequest {
	p.rootPassword = &rootPassword
	return p
}
func (p *HostServiceInstallRequest) Ssh(ssh *Ssh) *HostServiceInstallRequest {
	p.ssh = ssh
	return p
}
func (p *HostServiceInstallRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostServiceInstallRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}
func (p *HostServiceInstallRequest) Send() (*HostServiceInstallResponse, error) {
}

type HostServiceInstallResponse struct {
}

//
// Install VDSM and related software on the host. The host type defines additional parameters for the action.
// Example of installing a host, using `curl` and JSON, plain:
// [source,bash]
// ----
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123"
// ----
// Example of installing a host, using `curl` and JSON, with hosted engine components:
// [source,bash]
// ----
// curl \
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123?deploy_hosted_engine=true"
// ----
// This method supports the following parameters:
// `RootPassword`:: The password of of the `root` user, used to connect to the host via SSH.
// `Ssh`:: The SSH details used to connect to the host.
// `Host`:: This `override_iptables` property is used to indicate if the firewall configuration should be
// replaced by the default one.
// `Image`:: When installing an oVirt node a image ISO file is needed.
// `Async`:: Indicates if the installation should be performed asynchronously.
// `DeployHostedEngine`:: When set to `true` it means this host should deploy also hosted
// engine components. Missing value is treated as `true` i.e deploy.
// Omitting this parameter means `false` and will perform no operation
// in hosted engine area.
// `UndeployHostedEngine`:: When set to `true` it means this host should un-deploy hosted engine
// components and this host will not function as part of the High
// Availability cluster. Missing value is treated as `true` i.e un-deploy
// Omitting this parameter means `false` and will perform no operation
// in hosted engine area.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Install(
	async bool,
	deployHostedEngine bool,
	host *Host,
	image string,
	rootPassword string,
	ssh *Ssh,
	undeployHostedEngine bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:                &async,
		DeployHostedEngine:   &deployHostedEngine,
		Host:                 host,
		Image:                &image,
		RootPassword:         &rootPassword,
		Ssh:                  ssh,
		UndeployHostedEngine: &undeployHostedEngine,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "install", headers, query, wait)
	return err
}

type HostServiceIscsiDiscoverRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceIscsiDiscoverRequest) Header(key, value string) *HostServiceIscsiDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Query(key, value string) *HostServiceIscsiDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Async(async bool) *HostServiceIscsiDiscoverRequest {
	p.async = &async
	return p
}
func (p *HostServiceIscsiDiscoverRequest) Iscsi(iscsi *IscsiDetails) *HostServiceIscsiDiscoverRequest {
	p.iscsi = iscsi
	return p
}
func (p *HostServiceIscsiDiscoverRequest) Send() (*HostServiceIscsiDiscoverResponse, error) {
}

type HostServiceIscsiDiscoverResponse struct {
	iscsiTargets []string
}

func (p *HostServiceIscsiDiscoverResponse) IscsiTargets() []string {
	return p.iscsiTargets
}

//
// Discover iSCSI targets on the host, using the initiator details.
// This method supports the following parameters:
// `Iscsi`:: The target iSCSI device.
// `Async`:: Indicates if the discovery should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) IscsiDiscover(
	async bool,
	iscsi *IscsiDetails,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]string,
	error) {
	// Populate the action:
	action := &Action{
		Async: &async,
		Iscsi: iscsi,
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "iscsidiscover", headers, query, wait)
	if err != nil {
		return nil, err
	}
	return []string{ovResp.Body}, nil
}

type HostServiceIscsiLoginRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceIscsiLoginRequest) Header(key, value string) *HostServiceIscsiLoginRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceIscsiLoginRequest) Query(key, value string) *HostServiceIscsiLoginRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceIscsiLoginRequest) Async(async bool) *HostServiceIscsiLoginRequest {
	p.async = &async
	return p
}
func (p *HostServiceIscsiLoginRequest) Iscsi(iscsi *IscsiDetails) *HostServiceIscsiLoginRequest {
	p.iscsi = iscsi
	return p
}
func (p *HostServiceIscsiLoginRequest) Send() (*HostServiceIscsiLoginResponse, error) {
}

type HostServiceIscsiLoginResponse struct {
}

//
// Login to iSCSI targets on the host, using the target details.
// This method supports the following parameters:
// `Iscsi`:: The target iSCSI device.
// `Async`:: Indicates if the login should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) IscsiLogin(
	async bool,
	iscsi *IscsiDetails,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
		Iscsi: iscsi,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "iscsilogin", headers, query, wait)
	return err
}

type HostServiceRefreshRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceRefreshRequest) Header(key, value string) *HostServiceRefreshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceRefreshRequest) Query(key, value string) *HostServiceRefreshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceRefreshRequest) Async(async bool) *HostServiceRefreshRequest {
	p.async = &async
	return p
}
func (p *HostServiceRefreshRequest) Send() (*HostServiceRefreshResponse, error) {
}

type HostServiceRefreshResponse struct {
}

//
// Refresh the host devices and capabilities.
// This method supports the following parameters:
// `Async`:: Indicates if the refresh should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Refresh(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "refresh", headers, query, wait)
	return err
}

type HostServiceRemoveRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceRemoveRequest) Header(key, value string) *HostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceRemoveRequest) Query(key, value string) *HostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceRemoveRequest) Async(async bool) *HostServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *HostServiceRemoveRequest) Send() (*HostServiceRemoveResponse, error) {
}

type HostServiceRemoveResponse struct {
}

//
// Remove the host from the system.
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request DELETE \
// --header "Version: 4" \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type HostServiceSetupNetworksRequest struct {
	hostService                    *HostService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	checkConnectivity              *bool
	connectivityTimeout            *int64
	modifiedBonds                  []HostNic
	modifiedLabels                 []NetworkLabel
	modifiedNetworkAttachments     []NetworkAttachment
	removedBonds                   []HostNic
	removedLabels                  []NetworkLabel
	removedNetworkAttachments      []NetworkAttachment
	synchronizedNetworkAttachments []NetworkAttachment
}

func (p *HostServiceSetupNetworksRequest) Header(key, value string) *HostServiceSetupNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceSetupNetworksRequest) Query(key, value string) *HostServiceSetupNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceSetupNetworksRequest) Async(async bool) *HostServiceSetupNetworksRequest {
	p.async = &async
	return p
}
func (p *HostServiceSetupNetworksRequest) CheckConnectivity(checkConnectivity bool) *HostServiceSetupNetworksRequest {
	p.checkConnectivity = &checkConnectivity
	return p
}
func (p *HostServiceSetupNetworksRequest) ConnectivityTimeout(connectivityTimeout int64) *HostServiceSetupNetworksRequest {
	p.connectivityTimeout = &connectivityTimeout
	return p
}
func (p *HostServiceSetupNetworksRequest) ModifiedBonds(modifiedBonds []HostNic) *HostServiceSetupNetworksRequest {
	p.modifiedBonds = modifiedBonds
	return p
}
func (p *HostServiceSetupNetworksRequest) ModifiedLabels(modifiedLabels []NetworkLabel) *HostServiceSetupNetworksRequest {
	p.modifiedLabels = modifiedLabels
	return p
}
func (p *HostServiceSetupNetworksRequest) ModifiedNetworkAttachments(modifiedNetworkAttachments []NetworkAttachment) *HostServiceSetupNetworksRequest {
	p.modifiedNetworkAttachments = modifiedNetworkAttachments
	return p
}
func (p *HostServiceSetupNetworksRequest) RemovedBonds(removedBonds []HostNic) *HostServiceSetupNetworksRequest {
	p.removedBonds = removedBonds
	return p
}
func (p *HostServiceSetupNetworksRequest) RemovedLabels(removedLabels []NetworkLabel) *HostServiceSetupNetworksRequest {
	p.removedLabels = removedLabels
	return p
}
func (p *HostServiceSetupNetworksRequest) RemovedNetworkAttachments(removedNetworkAttachments []NetworkAttachment) *HostServiceSetupNetworksRequest {
	p.removedNetworkAttachments = removedNetworkAttachments
	return p
}
func (p *HostServiceSetupNetworksRequest) SynchronizedNetworkAttachments(synchronizedNetworkAttachments []NetworkAttachment) *HostServiceSetupNetworksRequest {
	p.synchronizedNetworkAttachments = synchronizedNetworkAttachments
	return p
}
func (p *HostServiceSetupNetworksRequest) Send() (*HostServiceSetupNetworksResponse, error) {
}

type HostServiceSetupNetworksResponse struct {
}

//
// This method is used to change the configuration of the network interfaces of a host.
// For example, lets assume that you have a host with three network interfaces `eth0`, `eth1` and `eth2` and that
// you want to configure a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell
// script and the `curl` command line HTTP client that can be done as follows:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <modified_bonds>
//     <host_nic>
//       <name>bond0</name>
//       <bonding>
//         <options>
//           <option>
//             <name>mode</name>
//             <value>4</value>
//           </option>
//           <option>
//             <name>miimon</name>
//             <value>100</value>
//           </option>
//         </options>
//         <slaves>
//           <host_nic>
//             <name>eth1</name>
//           </host_nic>
//           <host_nic>
//             <name>eth2</name>
//           </host_nic>
//         </slaves>
//       </bonding>
//     </host_nic>
//   </modified_bonds>
//   <modified_network_attachments>
//     <network_attachment>
//       <network>
//         <name>myvlan</name>
//       </network>
//       <host_nic>
//         <name>bond0</name>
//       </host_nic>
//       <ip_address_assignments>
//         <assignment_method>static</assignment_method>
//         <ip_address_assignment>
//           <ip>
//             <address>192.168.122.10</address>
//             <netmask>255.255.255.0</netmask>
//           </ip>
//         </ip_address_assignment>
//       </ip_address_assignments>
//       <dns_resolver_configuration>
//         <name_servers>
//           <name_server>1.1.1.1</name_server>
//           <name_server>2.2.2.2</name_server>
//         </name_servers>
//       </dns_resolver_configuration>
//     </network_attachment>
//   </modified_network_attachments>
//  </action>
// ' \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
// ----
// Note that this is valid for version 4 of the API. In previous versions some elements were represented as XML
// attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
// [source,xml]
// ----
// <options name="mode" value="4"/>
// <options name="miimon" value="100"/>
// <ip address="192.168.122.10" netmask="255.255.255.0"/>
// ----
// Using the Python SDK the same can be done with the following code:
// [source,python]
// ----
// # Find the service that manages the collection of hosts:
// hosts_service = connection.system_service().hosts_service()
// # Find the host:
// host = hosts_service.list(search='name=myhost')[0]
// # Find the service that manages the host:
// host_service = hosts_service.host_service(host.id)
// # Configure the network adding a bond with two slaves and attaching it to a
// # network with an static IP address:
// host_service.setup_networks(
//     modified_bonds=[
//         types.HostNic(
//             name='bond0',
//             bonding=types.Bonding(
//                 options=[
//                     types.Option(
//                         name='mode',
//                         value='4',
//                     ),
//                     types.Option(
//                         name='miimon',
//                         value='100',
//                     ),
//                 ],
//                 slaves=[
//                     types.HostNic(
//                         name='eth1',
//                     ),
//                     types.HostNic(
//                         name='eth2',
//                     ),
//                 ],
//             ),
//         ),
//     ],
//     modified_network_attachments=[
//         types.NetworkAttachment(
//             network=types.Network(
//                 name='myvlan',
//             ),
//             host_nic=types.HostNic(
//                 name='bond0',
//             ),
//             ip_address_assignments=[
//                 types.IpAddressAssignment(
//                     assignment_method=types.BootProtocol.STATIC,
//                     ip=types.Ip(
//                         address='192.168.122.10',
//                         netmask='255.255.255.0',
//                     ),
//                 ),
//             ],
//             dns_resolver_configuration=types.DnsResolverConfiguration(
//                 name_servers=[
//                     '1.1.1.1',
//                     '2.2.2.2',
//                 ],
//             ),
//         ),
//     ],
// )
// # After modifying the network configuration it is very important to make it
// # persistent:
// host_service.commit_net_config()
// ----
// IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
// when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) SetupNetworks(
	async bool,
	checkConnectivity bool,
	connectivityTimeout int64,
	modifiedBonds []HostNic,
	modifiedLabels []NetworkLabel,
	modifiedNetworkAttachments []NetworkAttachment,
	removedBonds []HostNic,
	removedLabels []NetworkLabel,
	removedNetworkAttachments []NetworkAttachment,
	synchronizedNetworkAttachments []NetworkAttachment,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:                          &async,
		CheckConnectivity:              &checkConnectivity,
		ConnectivityTimeout:            &connectivityTimeout,
		ModifiedBonds:                  modifiedBonds,
		ModifiedLabels:                 modifiedLabels,
		ModifiedNetworkAttachments:     modifiedNetworkAttachments,
		RemovedBonds:                   removedBonds,
		RemovedLabels:                  removedLabels,
		RemovedNetworkAttachments:      removedNetworkAttachments,
		SynchronizedNetworkAttachments: synchronizedNetworkAttachments,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "setupnetworks", headers, query, wait)
	return err
}

type HostServiceUnregisteredStorageDomainsDiscoverRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Header(key, value string) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Query(key, value string) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Async(async bool) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.async = &async
	return p
}
func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Iscsi(iscsi *IscsiDetails) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.iscsi = iscsi
	return p
}
func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Send() (*HostServiceUnregisteredStorageDomainsDiscoverResponse, error) {
}

type HostServiceUnregisteredStorageDomainsDiscoverResponse struct {
	storageDomains []StorageDomain
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverResponse) StorageDomains() []StorageDomain {
	return p.storageDomains
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the discovery should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) UnregisteredStorageDomainsDiscover(
	async bool,
	iscsi *IscsiDetails,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]StorageDomain,
	error) {
	// Populate the action:
	action := &Action{
		Async: &async,
		Iscsi: iscsi,
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "unregisteredstoragedomainsdiscover", headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainsVar StorageDomains
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainsVar)
	return storageDomainsVar.StorageDomains, nil
}

type HostServiceUpdateRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *HostServiceUpdateRequest) Header(key, value string) *HostServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpdateRequest) Query(key, value string) *HostServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpdateRequest) Async(async bool) *HostServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *HostServiceUpdateRequest) Host(host *Host) *HostServiceUpdateRequest {
	p.host = host
	return p
}
func (p *HostServiceUpdateRequest) Send() (*HostServiceUpdateResponse, error) {
}

type HostServiceUpdateResponse struct {
	host *Host
}

func (p *HostServiceUpdateResponse) Host() *Host {
	return p.host
}

//
// Update the host properties.
// For example, to update a the kernel command line of a host send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123
// ----
// With request body like this:
// [source, xml]
// ----
// <host>
//   <os>
//     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
//   </os>
// </host>
// ----
//
func (op *HostService) Update(
	host *Host,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Host,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(host, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostVar Host
	xml.Unmarshal([]byte(ovResp.Body), &hostVar)
	return &hostVar, nil
}

type HostServiceUpgradeRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceUpgradeRequest) Header(key, value string) *HostServiceUpgradeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpgradeRequest) Query(key, value string) *HostServiceUpgradeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpgradeRequest) Async(async bool) *HostServiceUpgradeRequest {
	p.async = &async
	return p
}
func (p *HostServiceUpgradeRequest) Send() (*HostServiceUpgradeResponse, error) {
}

type HostServiceUpgradeResponse struct {
}

//
// Upgrade VDSM and selected software on the host.
// This method supports the following parameters:
// `Async`:: Indicates if the upgrade should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostService) Upgrade(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "upgrade", headers, query, wait)
	return err
}

type HostServiceUpgradeCheckRequest struct {
	hostService *HostService
	header      map[string]string
	query       map[string]string
}

func (p *HostServiceUpgradeCheckRequest) Header(key, value string) *HostServiceUpgradeCheckRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpgradeCheckRequest) Query(key, value string) *HostServiceUpgradeCheckRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpgradeCheckRequest) Send() (*HostServiceUpgradeCheckResponse, error) {
}

type HostServiceUpgradeCheckResponse struct {
}

//
// Check if there are upgrades available for the host. If there are upgrades
// available an icon will be displayed next to host status icon in the webadmin.
// Audit log messages are also added to indicate the availability of upgrades.
// The upgrade can be started from the webadmin or by using the
// <<services/host/methods/upgrade, upgrade>> host action.
//
func (op *HostService) UpgradeCheck(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "upgradecheck", headers, query, wait)
	return err
}

//
// List of scheduling labels assigned to this host.
//
func (op *HostService) AffinityLabelsService() *AssignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.Connection, fmt.Sprintf("%s/affinitylabels", op.Path))
}

//
// Reference to the host devices service.
// Use this service to view the devices of the host object.
//
func (op *HostService) DevicesService() *HostDevicesService {
	return NewHostDevicesService(op.Connection, fmt.Sprintf("%s/devices", op.Path))
}

//
// Reference to the fence agents service.
// Use this service to manage fence and power management agents on the host object.
//
func (op *HostService) FenceAgentsService() *FenceAgentsService {
	return NewFenceAgentsService(op.Connection, fmt.Sprintf("%s/fenceagents", op.Path))
}

//
// Reference to the host hooks service.
// Use this service to view the hooks available in the host object.
//
func (op *HostService) HooksService() *HostHooksService {
	return NewHostHooksService(op.Connection, fmt.Sprintf("%s/hooks", op.Path))
}

//
// Reference to the service that can show the applicable errata available on the host.
// This information is taken from Katello.
//
func (op *HostService) KatelloErrataService() *KatelloErrataService {
	return NewKatelloErrataService(op.Connection, fmt.Sprintf("%s/katelloerrata", op.Path))
}

//
// Reference to the network attachments service. You can use this service to attach
// Logical networks to host interfaces.
//
func (op *HostService) NetworkAttachmentsService() *NetworkAttachmentsService {
	return NewNetworkAttachmentsService(op.Connection, fmt.Sprintf("%s/networkattachments", op.Path))
}

//
// Reference to the service that manages the network interface devices on the host.
//
func (op *HostService) NicsService() *HostNicsService {
	return NewHostNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Reference to the service that manage NUMA nodes for the host.
//
func (op *HostService) NumaNodesService() *HostNumaNodesService {
	return NewHostNumaNodesService(op.Connection, fmt.Sprintf("%s/numanodes", op.Path))
}

//
// Reference to the host permission service.
// Use this service to manage permissions on the host object.
//
func (op *HostService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *HostService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Reference to the service that manage hosts storage.
//
func (op *HostService) StorageService() *HostStorageService {
	return NewHostStorageService(op.Connection, fmt.Sprintf("%s/storage", op.Path))
}

//
// Reference to storage connection extensions.
//
func (op *HostService) StorageConnectionExtensionsService() *StorageServerConnectionExtensionsService {
	return NewStorageServerConnectionExtensionsService(op.Connection, fmt.Sprintf("%s/storageconnectionextensions", op.Path))
}

//
// Reference to the host tags service.
// Use this service to manage tags on the host object.
//
func (op *HostService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Reference to unmanaged networks.
//
func (op *HostService) UnmanagedNetworksService() *UnmanagedNetworksService {
	return NewUnmanagedNetworksService(op.Connection, fmt.Sprintf("%s/unmanagednetworks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "devices" {
		return op.DevicesService(), nil
	}
	if strings.HasPrefix(path, "devices/") {
		return op.DevicesService().Service(path[8:])
	}
	if path == "fenceagents" {
		return op.FenceAgentsService(), nil
	}
	if strings.HasPrefix(path, "fenceagents/") {
		return op.FenceAgentsService().Service(path[12:])
	}
	if path == "hooks" {
		return op.HooksService(), nil
	}
	if strings.HasPrefix(path, "hooks/") {
		return op.HooksService().Service(path[6:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "storage" {
		return op.StorageService(), nil
	}
	if strings.HasPrefix(path, "storage/") {
		return op.StorageService().Service(path[8:])
	}
	if path == "storageconnectionextensions" {
		return op.StorageConnectionExtensionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnectionextensions/") {
		return op.StorageConnectionExtensionsService().Service(path[28:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "unmanagednetworks" {
		return op.UnmanagedNetworksService(), nil
	}
	if strings.HasPrefix(path, "unmanagednetworks/") {
		return op.UnmanagedNetworksService().Service(path[18:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostService) String() string {
	return fmt.Sprintf("HostService:%s", op.Path)
}

//
//
type ExternalProviderCertificatesService struct {
	BaseService
}

func NewExternalProviderCertificatesService(connection *Connection, path string) *ExternalProviderCertificatesService {
	var result ExternalProviderCertificatesService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalProviderCertificatesServiceListRequest struct {
	externalProviderCertificatesService *ExternalProviderCertificatesService
	header                              map[string]string
	query                               map[string]string
	max                                 *int64
}

func (p *ExternalProviderCertificatesServiceListRequest) Header(key, value string) *ExternalProviderCertificatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Query(key, value string) *ExternalProviderCertificatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Max(max int64) *ExternalProviderCertificatesServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalProviderCertificatesServiceListRequest) Send() (*ExternalProviderCertificatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificatesService.Connection.URL(), p.externalProviderCertificatesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalProviderCertificatesService.Connection.username, p.externalProviderCertificatesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalProviderCertificatesServiceListResponse ExternalProviderCertificatesServiceListResponse
	var certificatesVar Certificates
	xml.Unmarshal(respBodyBytes, &certificatesVar)
	externalProviderCertificatesServiceListResponse.certificates = certificatesVar.Certificates
	return &externalProviderCertificatesServiceListResponse, nil
}

type ExternalProviderCertificatesServiceListResponse struct {
	certificates []Certificate
}

func (p *ExternalProviderCertificatesServiceListResponse) Certificates() []Certificate {
	return p.certificates
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of certificates to return. If not specified all the certificates are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalProviderCertificatesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Certificate,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var certificatesVar Certificates
	xml.Unmarshal([]byte(ovResp.Body), &certificatesVar)
	return certificatesVar.Certificates, nil
}

//
//
func (op *ExternalProviderCertificatesService) CertificateService(id string) *ExternalProviderCertificateService {
	return NewExternalProviderCertificateService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderCertificatesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CertificateService(path)), nil
	}
	return op.CertificateService(path[:index]).Service(path[index+1:])
}

func (op *ExternalProviderCertificatesService) String() string {
	return fmt.Sprintf("ExternalProviderCertificatesService:%s", op.Path)
}

//
// A service to manage individual host device attached to a virtual machine.
//
type VmHostDeviceService struct {
	BaseService
}

func NewVmHostDeviceService(connection *Connection, path string) *VmHostDeviceService {
	var result VmHostDeviceService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmHostDeviceServiceGetRequest struct {
	vmHostDeviceService *VmHostDeviceService
	header              map[string]string
	query               map[string]string
}

func (p *VmHostDeviceServiceGetRequest) Header(key, value string) *VmHostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDeviceServiceGetRequest) Query(key, value string) *VmHostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDeviceServiceGetRequest) Send() (*VmHostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDeviceService.Connection.URL(), p.vmHostDeviceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmHostDeviceService.Connection.username, p.vmHostDeviceService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmHostDeviceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmHostDeviceServiceGetResponse VmHostDeviceServiceGetResponse
	var deviceVar HostDevice
	xml.Unmarshal(respBodyBytes, &deviceVar)
	vmHostDeviceServiceGetResponse.device = &deviceVar
	return &vmHostDeviceServiceGetResponse, nil
}

type VmHostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *VmHostDeviceServiceGetResponse) Device() *HostDevice {
	return p.device
}

//
// Retrieve information about particular host device attached to given virtual machine.
// Example:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/hostdevices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//   <name>pci_0000_04_00_0</name>
//   <capability>pci</capability>
//   <iommu_group>30</iommu_group>
//   <placeholder>true</placeholder>
//   <product id="0x13ba">
//     <name>GM107GL [Quadro K2200]</name>
//   </product>
//   <vendor id="0x10de">
//     <name>NVIDIA Corporation</name>
//   </vendor>
//   <host href="/ovirt-engine/api/hosts/543" id="543"/>
//   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//     <name>pci_0000_00_03_0</name>
//   </parent_device>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </host_device>
// ----
//
func (op *VmHostDeviceService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*HostDevice,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var deviceVar HostDevice
	xml.Unmarshal([]byte(ovResp.Body), &deviceVar)
	return &deviceVar, nil
}

type VmHostDeviceServiceRemoveRequest struct {
	vmHostDeviceService *VmHostDeviceService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *VmHostDeviceServiceRemoveRequest) Header(key, value string) *VmHostDeviceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDeviceServiceRemoveRequest) Query(key, value string) *VmHostDeviceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDeviceServiceRemoveRequest) Async(async bool) *VmHostDeviceServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmHostDeviceServiceRemoveRequest) Send() (*VmHostDeviceServiceRemoveResponse, error) {
}

type VmHostDeviceServiceRemoveResponse struct {
}

//
// Remove the attachment of this host device from given virtual machine.
// NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
// in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
// automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
// group are detached).
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/hostdevices/456
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmHostDeviceService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmHostDeviceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmHostDeviceService) String() string {
	return fmt.Sprintf("VmHostDeviceService:%s", op.Path)
}

//
// A service to manage a specific tag in the system.
//
type TagService struct {
	BaseService
}

func NewTagService(connection *Connection, path string) *TagService {
	var result TagService
	result.Connection = connection
	result.Path = path
	return &result
}

type TagServiceGetRequest struct {
	tagService *TagService
	header     map[string]string
	query      map[string]string
}

func (p *TagServiceGetRequest) Header(key, value string) *TagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceGetRequest) Query(key, value string) *TagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceGetRequest) Send() (*TagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagService.Connection.URL(), p.tagService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.tagService.Connection.username, p.tagService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.tagService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var tagServiceGetResponse TagServiceGetResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	tagServiceGetResponse.tag = &tagVar
	return &tagServiceGetResponse, nil
}

type TagServiceGetResponse struct {
	tag *Tag
}

func (p *TagServiceGetResponse) Tag() *Tag {
	return p.tag
}

//
// Gets the information about the tag.
// For example to retrieve the information about the tag with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/tags/123
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/123" id="123">
//   <name>root</name>
//   <description>root</description>
// </tag>
// ----
//
func (op *TagService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Tag,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var tagVar Tag
	xml.Unmarshal([]byte(ovResp.Body), &tagVar)
	return &tagVar, nil
}

type TagServiceRemoveRequest struct {
	tagService *TagService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *TagServiceRemoveRequest) Header(key, value string) *TagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceRemoveRequest) Query(key, value string) *TagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceRemoveRequest) Async(async bool) *TagServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TagServiceRemoveRequest) Send() (*TagServiceRemoveResponse, error) {
}

type TagServiceRemoveResponse struct {
}

//
// Removes the tag from the system.
// For example to remove the tag with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/tags/123
// ....
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TagService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type TagServiceUpdateRequest struct {
	tagService *TagService
	header     map[string]string
	query      map[string]string
	async      *bool
	tag        *Tag
}

func (p *TagServiceUpdateRequest) Header(key, value string) *TagServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceUpdateRequest) Query(key, value string) *TagServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceUpdateRequest) Async(async bool) *TagServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TagServiceUpdateRequest) Tag(tag *Tag) *TagServiceUpdateRequest {
	p.tag = tag
	return p
}
func (p *TagServiceUpdateRequest) Send() (*TagServiceUpdateResponse, error) {
}

type TagServiceUpdateResponse struct {
	tag *Tag
}

func (p *TagServiceUpdateResponse) Tag() *Tag {
	return p.tag
}

//
// Updates the tag entity.
// For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
// ....
// PUT /ovirt-engine/api/tags/123
// ....
// With request body like:
// [source,xml]
// ----
// <tag>
//   <parent id="456"/>
// </tag>
// ----
// You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
// of the tag with id `123` send a request like this:
// [source,xml]
// ----
// <tag>
//   <parent>
//     <name>mytag</name>
//   </parent>
// </tag>
// ----
// This method supports the following parameters:
// `Tag`:: The updated tag.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TagService) Update(
	tag *Tag,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Tag,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(tag, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var tagVar Tag
	xml.Unmarshal([]byte(ovResp.Body), &tagVar)
	return &tagVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TagService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TagService) String() string {
	return fmt.Sprintf("TagService:%s", op.Path)
}

//
//
type HostNumaNodesService struct {
	BaseService
}

func NewHostNumaNodesService(connection *Connection, path string) *HostNumaNodesService {
	var result HostNumaNodesService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNumaNodesServiceListRequest struct {
	hostNumaNodesService *HostNumaNodesService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *HostNumaNodesServiceListRequest) Header(key, value string) *HostNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNumaNodesServiceListRequest) Query(key, value string) *HostNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNumaNodesServiceListRequest) Max(max int64) *HostNumaNodesServiceListRequest {
	p.max = &max
	return p
}
func (p *HostNumaNodesServiceListRequest) Send() (*HostNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodesService.Connection.URL(), p.hostNumaNodesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNumaNodesService.Connection.username, p.hostNumaNodesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNumaNodesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostNumaNodesServiceListResponse HostNumaNodesServiceListResponse
	var nodesVar NumaNodes
	xml.Unmarshal(respBodyBytes, &nodesVar)
	hostNumaNodesServiceListResponse.nodes = nodesVar.NumaNodes
	return &hostNumaNodesServiceListResponse, nil
}

type HostNumaNodesServiceListResponse struct {
	nodes []NumaNode
}

func (p *HostNumaNodesServiceListResponse) Nodes() []NumaNode {
	return p.nodes
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of nodes to return. If not specified all the nodes are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostNumaNodesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]NumaNode,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nodesVar NumaNodes
	xml.Unmarshal([]byte(ovResp.Body), &nodesVar)
	return nodesVar.NumaNodes, nil
}

//
//
func (op *HostNumaNodesService) NodeService(id string) *HostNumaNodeService {
	return NewHostNumaNodeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNumaNodesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NodeService(path)), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *HostNumaNodesService) String() string {
	return fmt.Sprintf("HostNumaNodesService:%s", op.Path)
}

//
// A service to manage collection of assignment of tags to specific entities in system.
//
type AssignedTagsService struct {
	BaseService
}

func NewAssignedTagsService(connection *Connection, path string) *AssignedTagsService {
	var result AssignedTagsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedTagsServiceAddRequest struct {
	assignedTagsService *AssignedTagsService
	header              map[string]string
	query               map[string]string
	tag                 *Tag
}

func (p *AssignedTagsServiceAddRequest) Header(key, value string) *AssignedTagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagsServiceAddRequest) Query(key, value string) *AssignedTagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagsServiceAddRequest) Tag(tag *Tag) *AssignedTagsServiceAddRequest {
	p.tag = tag
	return p
}
func (p *AssignedTagsServiceAddRequest) Send() (*AssignedTagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.Connection.URL(), p.assignedTagsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.tag)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedTagsService.Connection.username, p.assignedTagsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedTagsServiceAddResponse AssignedTagsServiceAddResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	assignedTagsServiceAddResponse.tag = &tagVar
	return &assignedTagsServiceAddResponse, nil
}

type AssignedTagsServiceAddResponse struct {
	tag *Tag
}

func (p *AssignedTagsServiceAddResponse) Tag() *Tag {
	return p.tag
}

//
// Assign tag to specific entity in the system.
// For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// This method supports the following parameters:
// `Tag`:: The assigned tag.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedTagsService) Add(
	tag *Tag,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Tag,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(tag, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var tagVar Tag
	xml.Unmarshal([]byte(ovResp.Body), &tagVar)
	return &tagVar, nil
}

type AssignedTagsServiceListRequest struct {
	assignedTagsService *AssignedTagsService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *AssignedTagsServiceListRequest) Header(key, value string) *AssignedTagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagsServiceListRequest) Query(key, value string) *AssignedTagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagsServiceListRequest) Max(max int64) *AssignedTagsServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedTagsServiceListRequest) Send() (*AssignedTagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.Connection.URL(), p.assignedTagsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedTagsService.Connection.username, p.assignedTagsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedTagsServiceListResponse AssignedTagsServiceListResponse
	var tagsVar Tags
	xml.Unmarshal(respBodyBytes, &tagsVar)
	assignedTagsServiceListResponse.tags = tagsVar.Tags
	return &assignedTagsServiceListResponse, nil
}

type AssignedTagsServiceListResponse struct {
	tags []Tag
}

func (p *AssignedTagsServiceListResponse) Tags() []Tag {
	return p.tags
}

//
// List all tags assigned to the specific entity.
// For example to list all the tags of the virtual machine with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>mytag</name>
//     <description>mytag</description>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </tag>
// </tags>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of tags to return. If not specified all the tags are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedTagsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Tag,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var tagsVar Tags
	xml.Unmarshal([]byte(ovResp.Body), &tagsVar)
	return tagsVar.Tags, nil
}

//
// Reference to the service that manages assignment of specific tag.
//
func (op *AssignedTagsService) TagService(id string) *AssignedTagService {
	return NewAssignedTagService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedTagsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TagService(path)), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *AssignedTagsService) String() string {
	return fmt.Sprintf("AssignedTagsService:%s", op.Path)
}

//
// A service to manage a job.
//
type JobService struct {
	BaseService
}

func NewJobService(connection *Connection, path string) *JobService {
	var result JobService
	result.Connection = connection
	result.Path = path
	return &result
}

type JobServiceClearRequest struct {
	jobService *JobService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *JobServiceClearRequest) Header(key, value string) *JobServiceClearRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceClearRequest) Query(key, value string) *JobServiceClearRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceClearRequest) Async(async bool) *JobServiceClearRequest {
	p.async = &async
	return p
}
func (p *JobServiceClearRequest) Send() (*JobServiceClearResponse, error) {
}

type JobServiceClearResponse struct {
}

//
// Set an external job execution to be cleared by the system.
// For example, to set a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/clear
// ----
// With the following request body:
// [source,xml]
// ----
// <action/>
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *JobService) Clear(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "clear", headers, query, wait)
	return err
}

type JobServiceEndRequest struct {
	jobService *JobService
	header     map[string]string
	query      map[string]string
	async      *bool
	force      *bool
	succeeded  *bool
}

func (p *JobServiceEndRequest) Header(key, value string) *JobServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceEndRequest) Query(key, value string) *JobServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceEndRequest) Async(async bool) *JobServiceEndRequest {
	p.async = &async
	return p
}
func (p *JobServiceEndRequest) Force(force bool) *JobServiceEndRequest {
	p.force = &force
	return p
}
func (p *JobServiceEndRequest) Succeeded(succeeded bool) *JobServiceEndRequest {
	p.succeeded = &succeeded
	return p
}
func (p *JobServiceEndRequest) Send() (*JobServiceEndResponse, error) {
}

type JobServiceEndResponse struct {
}

//
// Marks an external job execution as ended.
// For example, to terminate a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <status>finished</status>
// </action>
// ----
// This method supports the following parameters:
// `Force`:: Indicates if the job should be forcibly terminated.
// `Succeeded`:: Indicates if the job should be marked as successfully finished or as failed.
// This parameter is optional, and the default value is `true`.
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *JobService) End(
	async bool,
	force bool,
	succeeded bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:     &async,
		Force:     &force,
		Succeeded: &succeeded,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "end", headers, query, wait)
	return err
}

type JobServiceGetRequest struct {
	jobService *JobService
	header     map[string]string
	query      map[string]string
}

func (p *JobServiceGetRequest) Header(key, value string) *JobServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceGetRequest) Query(key, value string) *JobServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceGetRequest) Send() (*JobServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobService.Connection.URL(), p.jobService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobService.Connection.username, p.jobService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var jobServiceGetResponse JobServiceGetResponse
	var jobVar Job
	xml.Unmarshal(respBodyBytes, &jobVar)
	jobServiceGetResponse.job = &jobVar
	return &jobServiceGetResponse, nil
}

type JobServiceGetResponse struct {
	job *Job
}

func (p *JobServiceGetResponse) Job() *Job {
	return p.job
}

//
// Retrieves a job.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Adding Disk</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//   <external>false</external>
//   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//   <status>failed</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
func (op *JobService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Job,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var jobVar Job
	xml.Unmarshal([]byte(ovResp.Body), &jobVar)
	return &jobVar, nil
}

//
// List all the steps of the job.
//
func (op *JobService) StepsService() *StepsService {
	return NewStepsService(op.Connection, fmt.Sprintf("%s/steps", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *JobService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "steps" {
		return op.StepsService(), nil
	}
	if strings.HasPrefix(path, "steps/") {
		return op.StepsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *JobService) String() string {
	return fmt.Sprintf("JobService:%s", op.Path)
}

//
//
type FileService struct {
	BaseService
}

func NewFileService(connection *Connection, path string) *FileService {
	var result FileService
	result.Connection = connection
	result.Path = path
	return &result
}

type FileServiceGetRequest struct {
	fileService *FileService
	header      map[string]string
	query       map[string]string
}

func (p *FileServiceGetRequest) Header(key, value string) *FileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FileServiceGetRequest) Query(key, value string) *FileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FileServiceGetRequest) Send() (*FileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fileService.Connection.URL(), p.fileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fileService.Connection.username, p.fileService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var fileServiceGetResponse FileServiceGetResponse
	var fileVar File
	xml.Unmarshal(respBodyBytes, &fileVar)
	fileServiceGetResponse.file = &fileVar
	return &fileServiceGetResponse, nil
}

type FileServiceGetResponse struct {
	file *File
}

func (p *FileServiceGetResponse) File() *File {
	return p.file
}

//
//
func (op *FileService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*File,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var fileVar File
	xml.Unmarshal([]byte(ovResp.Body), &fileVar)
	return &fileVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FileService) String() string {
	return fmt.Sprintf("FileService:%s", op.Path)
}

//
// A service to manage steps.
//
type StepsService struct {
	BaseService
}

func NewStepsService(connection *Connection, path string) *StepsService {
	var result StepsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StepsServiceAddRequest struct {
	stepsService *StepsService
	header       map[string]string
	query        map[string]string
	step         *Step
}

func (p *StepsServiceAddRequest) Header(key, value string) *StepsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepsServiceAddRequest) Query(key, value string) *StepsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepsServiceAddRequest) Step(step *Step) *StepsServiceAddRequest {
	p.step = step
	return p
}
func (p *StepsServiceAddRequest) Send() (*StepsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.Connection.URL(), p.stepsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.step)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.stepsService.Connection.username, p.stepsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.stepsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var stepsServiceAddResponse StepsServiceAddResponse
	var stepVar Step
	xml.Unmarshal(respBodyBytes, &stepVar)
	stepsServiceAddResponse.step = &stepVar
	return &stepsServiceAddResponse, nil
}

type StepsServiceAddResponse struct {
	step *Step
}

func (p *StepsServiceAddResponse) Step() *Step {
	return p.step
}

//
// Add an external step to an existing job or to an existing step.
// For example, to add a step to `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps
// ----
// With the following request body:
// [source,xml]
// ----
// <step>
//   <description>Validating</description>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
// </step>
// ----
// The response should look like:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//   <external>true</external>
//   <number>2</number>
//   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
// This method supports the following parameters:
// `Step`:: Step that will be added.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StepsService) Add(
	step *Step,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Step,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(step, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var stepVar Step
	xml.Unmarshal([]byte(ovResp.Body), &stepVar)
	return &stepVar, nil
}

type StepsServiceListRequest struct {
	stepsService *StepsService
	header       map[string]string
	query        map[string]string
	max          *int64
}

func (p *StepsServiceListRequest) Header(key, value string) *StepsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepsServiceListRequest) Query(key, value string) *StepsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepsServiceListRequest) Max(max int64) *StepsServiceListRequest {
	p.max = &max
	return p
}
func (p *StepsServiceListRequest) Send() (*StepsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.Connection.URL(), p.stepsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.stepsService.Connection.username, p.stepsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.stepsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var stepsServiceListResponse StepsServiceListResponse
	var stepsVar Steps
	xml.Unmarshal(respBodyBytes, &stepsVar)
	stepsServiceListResponse.steps = stepsVar.Steps
	return &stepsServiceListResponse, nil
}

type StepsServiceListResponse struct {
	steps []Step
}

func (p *StepsServiceListResponse) Steps() []Step {
	return p.steps
}

//
// Retrieves the representation of the steps.
// [source]
// ----
// GET /ovirt-engine/api/job/123/steps
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <steps>
//   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//     </actions>
//     <description>Validating</description>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//     <external>true</external>
//     <number>2</number>
//     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//     <status>started</status>
//     <type>validating</type>
//     <job href="/ovirt-engine/api/jobs/123" id="123"/>
//   </step>
//   ...
// </steps>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of steps to return. If not specified all the steps are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StepsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Step,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var stepsVar Steps
	xml.Unmarshal([]byte(ovResp.Body), &stepsVar)
	return stepsVar.Steps, nil
}

//
// Reference to the step service.
//
func (op *StepsService) StepService(id string) *StepService {
	return NewStepService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StepsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StepService(path)), nil
	}
	return op.StepService(path[:index]).Service(path[index+1:])
}

func (op *StepsService) String() string {
	return fmt.Sprintf("StepsService:%s", op.Path)
}

//
//
type StorageDomainServerConnectionService struct {
	BaseService
}

func NewStorageDomainServerConnectionService(connection *Connection, path string) *StorageDomainServerConnectionService {
	var result StorageDomainServerConnectionService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainServerConnectionServiceGetRequest struct {
	storageDomainServerConnectionService *StorageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
}

func (p *StorageDomainServerConnectionServiceGetRequest) Header(key, value string) *StorageDomainServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceGetRequest) Query(key, value string) *StorageDomainServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceGetRequest) Send() (*StorageDomainServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionService.Connection.URL(), p.storageDomainServerConnectionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainServerConnectionService.Connection.username, p.storageDomainServerConnectionService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainServerConnectionServiceGetResponse StorageDomainServerConnectionServiceGetResponse
	var connectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &connectionVar)
	storageDomainServerConnectionServiceGetResponse.connection = &connectionVar
	return &storageDomainServerConnectionServiceGetResponse, nil
}

type StorageDomainServerConnectionServiceGetResponse struct {
	connection *StorageConnection
}

func (p *StorageDomainServerConnectionServiceGetResponse) Connection() *StorageConnection {
	return p.connection
}

//
//
func (op *StorageDomainServerConnectionService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnection,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var connectionVar StorageConnection
	xml.Unmarshal([]byte(ovResp.Body), &connectionVar)
	return &connectionVar, nil
}

type StorageDomainServerConnectionServiceRemoveRequest struct {
	storageDomainServerConnectionService *StorageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Header(key, value string) *StorageDomainServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Query(key, value string) *StorageDomainServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Async(async bool) *StorageDomainServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainServerConnectionServiceRemoveRequest) Send() (*StorageDomainServerConnectionServiceRemoveResponse, error) {
}

type StorageDomainServerConnectionServiceRemoveResponse struct {
}

//
// Detaches a storage connection from storage.
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainServerConnectionService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainServerConnectionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainServerConnectionService) String() string {
	return fmt.Sprintf("StorageDomainServerConnectionService:%s", op.Path)
}

//
// Provides read-only access to the global set of roles
//
type RolesService struct {
	BaseService
}

func NewRolesService(connection *Connection, path string) *RolesService {
	var result RolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type RolesServiceAddRequest struct {
	rolesService *RolesService
	header       map[string]string
	query        map[string]string
	role         *Role
}

func (p *RolesServiceAddRequest) Header(key, value string) *RolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RolesServiceAddRequest) Query(key, value string) *RolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RolesServiceAddRequest) Role(role *Role) *RolesServiceAddRequest {
	p.role = role
	return p
}
func (p *RolesServiceAddRequest) Send() (*RolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.Connection.URL(), p.rolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.role)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.rolesService.Connection.username, p.rolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.rolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var rolesServiceAddResponse RolesServiceAddResponse
	var roleVar Role
	xml.Unmarshal(respBodyBytes, &roleVar)
	rolesServiceAddResponse.role = &roleVar
	return &rolesServiceAddResponse, nil
}

type RolesServiceAddResponse struct {
	role *Role
}

func (p *RolesServiceAddResponse) Role() *Role {
	return p.role
}

//
// Create a new role. The role can be administrative or non-administrative and can have different permits.
// For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
// send a request like this (note that you have to pass permit id):
// [source]
// ----
// POST /ovirt-engine/api/roles
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyRole</name>
//   <description>My custom role to create virtual machines</description>
//   <administrative>false</administrative>
//   <permits>
//     <permit id="1"/>
//     <permit id="1300"/>
//   </permits>
// </group>
// ----
// This method supports the following parameters:
// `Role`:: Role that will be added.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *RolesService) Add(
	role *Role,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Role,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(role, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var roleVar Role
	xml.Unmarshal([]byte(ovResp.Body), &roleVar)
	return &roleVar, nil
}

type RolesServiceListRequest struct {
	rolesService *RolesService
	header       map[string]string
	query        map[string]string
	max          *int64
}

func (p *RolesServiceListRequest) Header(key, value string) *RolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RolesServiceListRequest) Query(key, value string) *RolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RolesServiceListRequest) Max(max int64) *RolesServiceListRequest {
	p.max = &max
	return p
}
func (p *RolesServiceListRequest) Send() (*RolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.Connection.URL(), p.rolesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.rolesService.Connection.username, p.rolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.rolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var rolesServiceListResponse RolesServiceListResponse
	var rolesVar Roles
	xml.Unmarshal(respBodyBytes, &rolesVar)
	rolesServiceListResponse.roles = rolesVar.Roles
	return &rolesServiceListResponse, nil
}

type RolesServiceListResponse struct {
	roles []Role
}

func (p *RolesServiceListResponse) Roles() []Role {
	return p.roles
}

//
// List roles.
// [source]
// ----
// GET /ovirt-engine/api/roles
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <roles>
//   <role id="123">
//      <name>SuperUser</name>
//      <description>Roles management administrator</description>
//      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//      <administrative>true</administrative>
//      <mutable>false</mutable>
//   </role>
//   ...
// </roles>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of roles to return. If not specified all the roles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *RolesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Role,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var rolesVar Roles
	xml.Unmarshal([]byte(ovResp.Body), &rolesVar)
	return rolesVar.Roles, nil
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *RolesService) RoleService(id string) *RoleService {
	return NewRoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *RolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.RoleService(path)), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *RolesService) String() string {
	return fmt.Sprintf("RolesService:%s", op.Path)
}

//
// This service provides a mechanism to control an image transfer. The client will have
// to create a transfer by using <<services/image_transfers/methods/add, add>>
// of the <<services/image_transfers>> service, stating the image to transfer
// data to/from.
// After doing that, the transfer is managed by this service.
// E.g., for uploading to the disk image with id `52cb593f-837c-4633-a444-35a0a0383706`,
// the client can use oVirt's Python's SDK as follows:
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       image=types.Image(
//          id='52cb593f-837c-4633-a444-35a0a0383706'
//       )
//    )
// )
// ----
// If the user wishes to download a disk rather than upload, he/she should specify
// `download` as the <<types/image_transfer_direction, direction>> attribute of the transfer.
// This will grant a read permission from the image, instead of a write permission.
// E.g:
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       image=types.Image(
//          id='52cb593f-837c-4633-a444-35a0a0383706'
//       ),
//       direction=types.ImageTransferDirection.DOWNLOAD
//    )
// )
// ----
// Transfers have phases, which govern the flow of the upload/download.
// A client implementing such a flow should poll/check the transfer's phase and
// act accordingly. All the possible phases can be found in
// <<types/image_transfer_phase, ImageTransferPhase>>.
// After adding a new transfer, its phase will be <<types/image_transfer_phase, initializing>>.
// The client will have to poll on the transfer's phase until it changes.
// When the phase becomes <<types/image_transfer_phase, transferring>>,
// the session is ready to start the transfer.
// For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// while transfer.phase == types.ImageTransferPhase.INITIALIZING:
//    time.sleep(3)
//    transfer = transfer_service.get()
// ----
// At that stage, if the transfer's phase is <<types/image_transfer_phase, paused_system>>, then the session was
// not successfully established. One possible reason for that is that the ovirt-imageio-daemon is not running
// in the host that was selected for transfer.
// The transfer can be resumed by calling <<services/image_transfer/methods/resume, resume>>
// of the service that manages it.
// If the session was successfully established - the returned transfer entity will
// contain the <<types/image_transfer, proxy_url>> and <<types/image_transfer, signed_ticket>> attributes,
// which the client needs to use in order to transfer the required data. The client can choose whatever
// technique and tool for sending the HTTPS request with the image's data.
// - `proxy_url` is the address of a proxy server to the image, to do I/O to.
// - `signed_ticket` is the content that needs to be added to the `Authentication`
//    header in the HTTPS request, in order to perform a trusted communication.
// For example, Python's HTTPSConnection can be used in order to perform a transfer,
// so an `transfer_headers` dict is set for the upcoming transfer:
// [source,python]
// ----
// transfer_headers = {
//    'Authorization' :  transfer.signed_ticket,
// }
// ----
// Using Python's `HTTPSConnection`, a new connection is established:
// [source,python]
// ----
// # Extract the URI, port, and path from the transfer's proxy_url.
// url = urlparse.urlparse(transfer.proxy_url)
// # Create a new instance of the connection.
// proxy_connection = HTTPSConnection(
//    url.hostname,
//    url.port,
//    context=ssl.SSLContext(ssl.PROTOCOL_SSLv23)
// )
// ----
// For upload, the specific content range being sent must be noted in the `Content-Range` HTTPS
// header. This can be used in order to split the transfer into several requests for
// a more flexible process.
// For doing that, the client will have to repeatedly extend the transfer session
// to keep the channel open. Otherwise, the session will terminate and the transfer will
// get into `paused_system` phase, and HTTPS requests to the server will be rejected.
// E.g., the client can iterate on chunks of the file, and send them to the
// proxy server while asking the service to extend the session:
// [source,python]
// ----
// path = "/path/to/image"
// MB_per_request = 32
// with open(path, "rb") as disk:
//    size = os.path.getsize(path)
//    chunk_size = 1024*1024*MB_per_request
//    pos = 0
//    while (pos < size):
//       transfer_service.extend()
//       transfer_headers['Content-Range'] = "bytes %d-%d/%d" % (pos, min(pos + chunk_size, size)-1, size)
//       proxy_connection.request(
//          'PUT',
//          url.path,
//          disk.read(chunk_size),
//          headers=transfer_headers
//       )
//       r = proxy_connection.getresponse()
//       print r.status, r.reason, "Completed", "{:.0%}".format(pos/ float(size))
//       pos += chunk_size
// ----
// Similarly, for a download transfer, a `Range` header must be sent, making the download process
// more easily managed by downloading the disk in chunks.
// E.g., the client will again iterate on chunks of the disk image, but this time he/she will download
// it to a local file, rather than uploading its own file to the image:
// [source,python]
// ----
// output_file = "/home/user/downloaded_image"
// MiB_per_request = 32
// chunk_size = 1024*1024*MiB_per_request
// total = disk_size
// with open(output_file, "wb") as disk:
//    pos = 0
//    while pos < total:
//       transfer_service.extend()
//       transfer_headers['Range'] = "bytes=%d-%d" %  (pos, min(total, pos + chunk_size) - 1)
//       proxy_connection.request('GET', proxy_url.path, headers=transfer_headers)
//       r = proxy_connection.getresponse()
//       disk.write(r.read())
//       print "Completed", "{:.0%}".format(pos/ float(total))
//       pos += chunk_size
// ----
// When finishing the transfer, the user should call
// <<services/image_transfer/methods/finalize, finalize>>. This will make the
// final adjustments and verifications for finishing the transfer process.
// For example:
// [source,python]
// ----
// transfer_service.finalize()
// ----
// In case of an error, the transfer's phase will be changed to
// <<types/image_transfer_phase, finished_failure>>, and
// the disk's status will be changed to `Illegal`. Otherwise it will be changed to
// <<types/image_transfer_phase, finished_success>>, and the disk will be ready
// to be used. In both cases, the transfer entity will be removed shortly after.
//
type ImageTransferService struct {
	BaseService
}

func NewImageTransferService(connection *Connection, path string) *ImageTransferService {
	var result ImageTransferService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImageTransferServiceExtendRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceExtendRequest) Header(key, value string) *ImageTransferServiceExtendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceExtendRequest) Query(key, value string) *ImageTransferServiceExtendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceExtendRequest) Send() (*ImageTransferServiceExtendResponse, error) {
}

type ImageTransferServiceExtendResponse struct {
}

//
// Extend the image transfer session.
//
func (op *ImageTransferService) Extend(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "extend", headers, query, wait)
	return err
}

type ImageTransferServiceFinalizeRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceFinalizeRequest) Header(key, value string) *ImageTransferServiceFinalizeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceFinalizeRequest) Query(key, value string) *ImageTransferServiceFinalizeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceFinalizeRequest) Send() (*ImageTransferServiceFinalizeResponse, error) {
}

type ImageTransferServiceFinalizeResponse struct {
}

//
// After finishing to transfer the data, finalize the transfer.
// This will make sure that the data being transferred is valid and fits the
// image entity that was targeted in the transfer. Specifically, will verify that
// if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
// and that the image doesn't have a backing file.
//
func (op *ImageTransferService) Finalize(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "finalize", headers, query, wait)
	return err
}

type ImageTransferServiceGetRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceGetRequest) Header(key, value string) *ImageTransferServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceGetRequest) Query(key, value string) *ImageTransferServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceGetRequest) Send() (*ImageTransferServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransferService.Connection.URL(), p.imageTransferService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageTransferService.Connection.username, p.imageTransferService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageTransferService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var imageTransferServiceGetResponse ImageTransferServiceGetResponse
	var imageTransferVar ImageTransfer
	xml.Unmarshal(respBodyBytes, &imageTransferVar)
	imageTransferServiceGetResponse.imageTransfer = &imageTransferVar
	return &imageTransferServiceGetResponse, nil
}

type ImageTransferServiceGetResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransferServiceGetResponse) ImageTransfer() *ImageTransfer {
	return p.imageTransfer
}

//
// Get the image transfer entity.
//
func (op *ImageTransferService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ImageTransfer,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var imageTransferVar ImageTransfer
	xml.Unmarshal([]byte(ovResp.Body), &imageTransferVar)
	return &imageTransferVar, nil
}

type ImageTransferServicePauseRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServicePauseRequest) Header(key, value string) *ImageTransferServicePauseRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServicePauseRequest) Query(key, value string) *ImageTransferServicePauseRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServicePauseRequest) Send() (*ImageTransferServicePauseResponse, error) {
}

type ImageTransferServicePauseResponse struct {
}

//
// Pause the image transfer session.
//
func (op *ImageTransferService) Pause(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "pause", headers, query, wait)
	return err
}

type ImageTransferServiceResumeRequest struct {
	imageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceResumeRequest) Header(key, value string) *ImageTransferServiceResumeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceResumeRequest) Query(key, value string) *ImageTransferServiceResumeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceResumeRequest) Send() (*ImageTransferServiceResumeResponse, error) {
}

type ImageTransferServiceResumeResponse struct {
}

//
// Resume the image transfer session. The client will need to poll the transfer's phase until
// it is different than `resuming`. For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// transfer_service.resume()
// transfer = transfer_service.get()
// while transfer.phase == types.ImageTransferPhase.RESUMING:
//    time.sleep(1)
//    transfer = transfer_service.get()
// ----
//
func (op *ImageTransferService) Resume(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "resume", headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageTransferService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ImageTransferService) String() string {
	return fmt.Sprintf("ImageTransferService:%s", op.Path)
}

//
//
type AssignedVnicProfileService struct {
	BaseService
}

func NewAssignedVnicProfileService(connection *Connection, path string) *AssignedVnicProfileService {
	var result AssignedVnicProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedVnicProfileServiceGetRequest struct {
	assignedVnicProfileService *AssignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
}

func (p *AssignedVnicProfileServiceGetRequest) Header(key, value string) *AssignedVnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfileServiceGetRequest) Query(key, value string) *AssignedVnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfileServiceGetRequest) Send() (*AssignedVnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfileService.Connection.URL(), p.assignedVnicProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedVnicProfileService.Connection.username, p.assignedVnicProfileService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedVnicProfileServiceGetResponse AssignedVnicProfileServiceGetResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedVnicProfileServiceGetResponse.profile = &profileVar
	return &assignedVnicProfileServiceGetResponse, nil
}

type AssignedVnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *AssignedVnicProfileServiceGetResponse) Profile() *VnicProfile {
	return p.profile
}

//
//
func (op *AssignedVnicProfileService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VnicProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar VnicProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type AssignedVnicProfileServiceRemoveRequest struct {
	assignedVnicProfileService *AssignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *AssignedVnicProfileServiceRemoveRequest) Header(key, value string) *AssignedVnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfileServiceRemoveRequest) Query(key, value string) *AssignedVnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfileServiceRemoveRequest) Async(async bool) *AssignedVnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedVnicProfileServiceRemoveRequest) Send() (*AssignedVnicProfileServiceRemoveResponse, error) {
}

type AssignedVnicProfileServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedVnicProfileService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
//
func (op *AssignedVnicProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedVnicProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedVnicProfileService) String() string {
	return fmt.Sprintf("AssignedVnicProfileService:%s", op.Path)
}

//
//
type TemplateWatchdogService struct {
	BaseService
}

func NewTemplateWatchdogService(connection *Connection, path string) *TemplateWatchdogService {
	var result TemplateWatchdogService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateWatchdogServiceGetRequest struct {
	templateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
}

func (p *TemplateWatchdogServiceGetRequest) Header(key, value string) *TemplateWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceGetRequest) Query(key, value string) *TemplateWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceGetRequest) Send() (*TemplateWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.Connection.URL(), p.templateWatchdogService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogService.Connection.username, p.templateWatchdogService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateWatchdogServiceGetResponse TemplateWatchdogServiceGetResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	templateWatchdogServiceGetResponse.watchdog = &watchdogVar
	return &templateWatchdogServiceGetResponse, nil
}

type TemplateWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogServiceGetResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
//
func (op *TemplateWatchdogService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

type TemplateWatchdogServiceRemoveRequest struct {
	templateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *TemplateWatchdogServiceRemoveRequest) Header(key, value string) *TemplateWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceRemoveRequest) Query(key, value string) *TemplateWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceRemoveRequest) Async(async bool) *TemplateWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateWatchdogServiceRemoveRequest) Send() (*TemplateWatchdogServiceRemoveResponse, error) {
}

type TemplateWatchdogServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateWatchdogService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type TemplateWatchdogServiceUpdateRequest struct {
	templateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	watchdog                *Watchdog
}

func (p *TemplateWatchdogServiceUpdateRequest) Header(key, value string) *TemplateWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Query(key, value string) *TemplateWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Async(async bool) *TemplateWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *TemplateWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *TemplateWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}
func (p *TemplateWatchdogServiceUpdateRequest) Send() (*TemplateWatchdogServiceUpdateResponse, error) {
}

type TemplateWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogServiceUpdateResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
//
func (op *TemplateWatchdogService) Update(
	watchdog *Watchdog,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(watchdog, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateWatchdogService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateWatchdogService) String() string {
	return fmt.Sprintf("TemplateWatchdogService:%s", op.Path)
}

//
//
type VmSessionService struct {
	BaseService
}

func NewVmSessionService(connection *Connection, path string) *VmSessionService {
	var result VmSessionService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmSessionServiceGetRequest struct {
	vmSessionService *VmSessionService
	header           map[string]string
	query            map[string]string
}

func (p *VmSessionServiceGetRequest) Header(key, value string) *VmSessionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmSessionServiceGetRequest) Query(key, value string) *VmSessionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmSessionServiceGetRequest) Send() (*VmSessionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionService.Connection.URL(), p.vmSessionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmSessionService.Connection.username, p.vmSessionService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmSessionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmSessionServiceGetResponse VmSessionServiceGetResponse
	var sessionVar Session
	xml.Unmarshal(respBodyBytes, &sessionVar)
	vmSessionServiceGetResponse.session = &sessionVar
	return &vmSessionServiceGetResponse, nil
}

type VmSessionServiceGetResponse struct {
	session *Session
}

func (p *VmSessionServiceGetResponse) Session() *Session {
	return p.session
}

//
//
func (op *VmSessionService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Session,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var sessionVar Session
	xml.Unmarshal([]byte(ovResp.Body), &sessionVar)
	return &sessionVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmSessionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmSessionService) String() string {
	return fmt.Sprintf("VmSessionService:%s", op.Path)
}

//
//
type VmNicService struct {
	BaseService
}

func NewVmNicService(connection *Connection, path string) *VmNicService {
	var result VmNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNicServiceActivateRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceActivateRequest) Header(key, value string) *VmNicServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceActivateRequest) Query(key, value string) *VmNicServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceActivateRequest) Async(async bool) *VmNicServiceActivateRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceActivateRequest) Send() (*VmNicServiceActivateResponse, error) {
}

type VmNicServiceActivateResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the activation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmNicService) Activate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "activate", headers, query, wait)
	return err
}

type VmNicServiceDeactivateRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceDeactivateRequest) Header(key, value string) *VmNicServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceDeactivateRequest) Query(key, value string) *VmNicServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceDeactivateRequest) Async(async bool) *VmNicServiceDeactivateRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceDeactivateRequest) Send() (*VmNicServiceDeactivateResponse, error) {
}

type VmNicServiceDeactivateResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the deactivation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmNicService) Deactivate(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "deactivate", headers, query, wait)
	return err
}

type VmNicServiceGetRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
}

func (p *VmNicServiceGetRequest) Header(key, value string) *VmNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceGetRequest) Query(key, value string) *VmNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceGetRequest) Send() (*VmNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.Connection.URL(), p.vmNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicService.Connection.username, p.vmNicService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmNicServiceGetResponse VmNicServiceGetResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	vmNicServiceGetResponse.nic = &nicVar
	return &vmNicServiceGetResponse, nil
}

type VmNicServiceGetResponse struct {
	nic *Nic
}

func (p *VmNicServiceGetResponse) Nic() *Nic {
	return p.nic
}

//
//
func (op *VmNicService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

type VmNicServiceRemoveRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceRemoveRequest) Header(key, value string) *VmNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceRemoveRequest) Query(key, value string) *VmNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceRemoveRequest) Async(async bool) *VmNicServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceRemoveRequest) Send() (*VmNicServiceRemoveResponse, error) {
}

type VmNicServiceRemoveResponse struct {
}

//
// Removes the NIC.
// For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/nics/456
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmNicService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VmNicServiceUpdateRequest struct {
	vmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
	nic          *Nic
}

func (p *VmNicServiceUpdateRequest) Header(key, value string) *VmNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceUpdateRequest) Query(key, value string) *VmNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceUpdateRequest) Async(async bool) *VmNicServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VmNicServiceUpdateRequest) Nic(nic *Nic) *VmNicServiceUpdateRequest {
	p.nic = nic
	return p
}
func (p *VmNicServiceUpdateRequest) Send() (*VmNicServiceUpdateResponse, error) {
}

type VmNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *VmNicServiceUpdateResponse) Nic() *Nic {
	return p.nic
}

//
// Updates the NIC.
// For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
// like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/nics/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>e1000</interface>
//   <vnic_profile id='789'/>
// </nic>
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (op *VmNicService) Update(
	nic *Nic,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(nic, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

//
// Reference to the service that manages the network filter parameters of the NIC.
// A single top-level network filter may assigned to the NIC by the NIC's <<types/vnic_profile,vNIC Profile>>.
//
func (op *VmNicService) NetworkFilterParametersService() *NetworkFilterParametersService {
	return NewNetworkFilterParametersService(op.Connection, fmt.Sprintf("%s/networkfilterparameters", op.Path))
}

//
//
func (op *VmNicService) ReportedDevicesService() *VmReportedDevicesService {
	return NewVmReportedDevicesService(op.Connection, fmt.Sprintf("%s/reporteddevices", op.Path))
}

//
//
func (op *VmNicService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networkfilterparameters" {
		return op.NetworkFilterParametersService(), nil
	}
	if strings.HasPrefix(path, "networkfilterparameters/") {
		return op.NetworkFilterParametersService().Service(path[24:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmNicService) String() string {
	return fmt.Sprintf("VmNicService:%s", op.Path)
}

//
//
type SnapshotsService struct {
	BaseService
}

func NewSnapshotsService(connection *Connection, path string) *SnapshotsService {
	var result SnapshotsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotsServiceAddRequest struct {
	snapshotsService *SnapshotsService
	header           map[string]string
	query            map[string]string
	snapshot         *Snapshot
}

func (p *SnapshotsServiceAddRequest) Header(key, value string) *SnapshotsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotsServiceAddRequest) Query(key, value string) *SnapshotsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotsServiceAddRequest) Snapshot(snapshot *Snapshot) *SnapshotsServiceAddRequest {
	p.snapshot = snapshot
	return p
}
func (p *SnapshotsServiceAddRequest) Send() (*SnapshotsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.Connection.URL(), p.snapshotsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.snapshot)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotsService.Connection.username, p.snapshotsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotsServiceAddResponse SnapshotsServiceAddResponse
	var snapshotVar Snapshot
	xml.Unmarshal(respBodyBytes, &snapshotVar)
	snapshotsServiceAddResponse.snapshot = &snapshotVar
	return &snapshotsServiceAddResponse, nil
}

type SnapshotsServiceAddResponse struct {
	snapshot *Snapshot
}

func (p *SnapshotsServiceAddResponse) Snapshot() *Snapshot {
	return p.snapshot
}

//
// Creates a virtual machine snapshot.
// For example, to create a new snapshot for virtual machine `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots
// ----
// With a request body like this:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
// </snapshot>
// ----
//
func (op *SnapshotsService) Add(
	snapshot *Snapshot,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Snapshot,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(snapshot, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var snapshotVar Snapshot
	xml.Unmarshal([]byte(ovResp.Body), &snapshotVar)
	return &snapshotVar, nil
}

type SnapshotsServiceListRequest struct {
	snapshotsService *SnapshotsService
	header           map[string]string
	query            map[string]string
	allContent       *bool
	max              *int64
}

func (p *SnapshotsServiceListRequest) Header(key, value string) *SnapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotsServiceListRequest) Query(key, value string) *SnapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotsServiceListRequest) AllContent(allContent bool) *SnapshotsServiceListRequest {
	p.allContent = &allContent
	return p
}
func (p *SnapshotsServiceListRequest) Max(max int64) *SnapshotsServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotsServiceListRequest) Send() (*SnapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.Connection.URL(), p.snapshotsService.Path)
	values := make(url.Values)
	if p.allContent != nil {
		values["allContent"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotsService.Connection.username, p.snapshotsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotsServiceListResponse SnapshotsServiceListResponse
	var snapshotsVar Snapshots
	xml.Unmarshal(respBodyBytes, &snapshotsVar)
	snapshotsServiceListResponse.snapshots = snapshotsVar.Snapshots
	return &snapshotsServiceListResponse, nil
}

type SnapshotsServiceListResponse struct {
	snapshots []Snapshot
}

func (p *SnapshotsServiceListResponse) Snapshots() []Snapshot {
	return p.snapshots
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of snapshots to return. If not specified all the snapshots are returned.
// `AllContent`:: Indicates if all the attributes of the virtual machine snapshot should be included in the response.
// By default the attribute `initialization.configuration.data` is excluded.
// For example, to retrieve the complete representation of the virtual machine with id `123` snapshots send a
// request like this:
// ....
// GET /ovirt-engine/api/vms/123/snapshots?all_content=true
// ....
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SnapshotsService) List(
	allContent bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Snapshot,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["all_content"] = fmt.Sprintf("%v", allContent)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var snapshotsVar Snapshots
	xml.Unmarshal([]byte(ovResp.Body), &snapshotsVar)
	return snapshotsVar.Snapshots, nil
}

//
//
func (op *SnapshotsService) SnapshotService(id string) *SnapshotService {
	return NewSnapshotService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SnapshotService(path)), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotsService) String() string {
	return fmt.Sprintf("SnapshotsService:%s", op.Path)
}

//
// Returns the details of a disk attached to a virtual machine in the export domain.
//
type StorageDomainVmDiskAttachmentsService struct {
	BaseService
}

func NewStorageDomainVmDiskAttachmentsService(connection *Connection, path string) *StorageDomainVmDiskAttachmentsService {
	var result StorageDomainVmDiskAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmDiskAttachmentsServiceListRequest struct {
	storageDomainVmDiskAttachmentsService *StorageDomainVmDiskAttachmentsService
	header                                map[string]string
	query                                 map[string]string
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Header(key, value string) *StorageDomainVmDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Query(key, value string) *StorageDomainVmDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Send() (*StorageDomainVmDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentsService.Connection.URL(), p.storageDomainVmDiskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmDiskAttachmentsService.Connection.username, p.storageDomainVmDiskAttachmentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainVmDiskAttachmentsServiceListResponse StorageDomainVmDiskAttachmentsServiceListResponse
	var attachmentsVar DiskAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	storageDomainVmDiskAttachmentsServiceListResponse.attachments = attachmentsVar.DiskAttachments
	return &storageDomainVmDiskAttachmentsServiceListResponse, nil
}

type StorageDomainVmDiskAttachmentsServiceListResponse struct {
	attachments []DiskAttachment
}

func (p *StorageDomainVmDiskAttachmentsServiceListResponse) Attachments() []DiskAttachment {
	return p.attachments
}

//
// List the disks that are attached to the virtual machine.
//
func (op *StorageDomainVmDiskAttachmentsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentsVar DiskAttachments
	xml.Unmarshal([]byte(ovResp.Body), &attachmentsVar)
	return attachmentsVar.DiskAttachments, nil
}

//
// Reference to the service that manages a specific attachment.
//
func (op *StorageDomainVmDiskAttachmentsService) AttachmentService(id string) *StorageDomainVmDiskAttachmentService {
	return NewStorageDomainVmDiskAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmDiskAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainVmDiskAttachmentsService) String() string {
	return fmt.Sprintf("StorageDomainVmDiskAttachmentsService:%s", op.Path)
}

//
//
type ImageService struct {
	BaseService
}

func NewImageService(connection *Connection, path string) *ImageService {
	var result ImageService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImageServiceGetRequest struct {
	imageService *ImageService
	header       map[string]string
	query        map[string]string
}

func (p *ImageServiceGetRequest) Header(key, value string) *ImageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageServiceGetRequest) Query(key, value string) *ImageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageServiceGetRequest) Send() (*ImageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageService.Connection.URL(), p.imageService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imageService.Connection.username, p.imageService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var imageServiceGetResponse ImageServiceGetResponse
	var imageVar Image
	xml.Unmarshal(respBodyBytes, &imageVar)
	imageServiceGetResponse.image = &imageVar
	return &imageServiceGetResponse, nil
}

type ImageServiceGetResponse struct {
	image *Image
}

func (p *ImageServiceGetResponse) Image() *Image {
	return p.image
}

//
//
func (op *ImageService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Image,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var imageVar Image
	xml.Unmarshal([]byte(ovResp.Body), &imageVar)
	return &imageVar, nil
}

type ImageServiceImportRequest struct {
	imageService     *ImageService
	header           map[string]string
	query            map[string]string
	async            *bool
	cluster          *Cluster
	disk             *Disk
	importAsTemplate *bool
	storageDomain    *StorageDomain
	template         *Template
}

func (p *ImageServiceImportRequest) Header(key, value string) *ImageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageServiceImportRequest) Query(key, value string) *ImageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageServiceImportRequest) Async(async bool) *ImageServiceImportRequest {
	p.async = &async
	return p
}
func (p *ImageServiceImportRequest) Cluster(cluster *Cluster) *ImageServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *ImageServiceImportRequest) Disk(disk *Disk) *ImageServiceImportRequest {
	p.disk = disk
	return p
}
func (p *ImageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *ImageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}
func (p *ImageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *ImageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *ImageServiceImportRequest) Template(template *Template) *ImageServiceImportRequest {
	p.template = template
	return p
}
func (p *ImageServiceImportRequest) Send() (*ImageServiceImportResponse, error) {
}

type ImageServiceImportResponse struct {
}

//
// This method supports the following parameters:
// `Cluster`:: Cluster where the image should be imported. Has effect only in case `import_as_template` parameter
// is set to `true`.
// `Disk`:: The disk which should be imported.
// `ImportAsTemplate`:: Specify if template should be created from the imported disk.
// `Template`:: Name of the template, which should be created. Has effect only in case `import_as_template` parameter
// is set to `true`.
// `StorageDomain`:: Storage domain where disk should be imported.
// `Async`:: Indicates if the import should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ImageService) Import(
	async bool,
	cluster *Cluster,
	disk *Disk,
	importAsTemplate bool,
	storageDomain *StorageDomain,
	template *Template,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:            &async,
		Cluster:          cluster,
		Disk:             disk,
		ImportAsTemplate: &importAsTemplate,
		StorageDomain:    storageDomain,
		Template:         template,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "import", headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ImageService) String() string {
	return fmt.Sprintf("ImageService:%s", op.Path)
}

//
//
type InstanceTypeNicsService struct {
	BaseService
}

func NewInstanceTypeNicsService(connection *Connection, path string) *InstanceTypeNicsService {
	var result InstanceTypeNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeNicsServiceAddRequest struct {
	instanceTypeNicsService *InstanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	nic                     *Nic
}

func (p *InstanceTypeNicsServiceAddRequest) Header(key, value string) *InstanceTypeNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicsServiceAddRequest) Query(key, value string) *InstanceTypeNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicsServiceAddRequest) Nic(nic *Nic) *InstanceTypeNicsServiceAddRequest {
	p.nic = nic
	return p
}
func (p *InstanceTypeNicsServiceAddRequest) Send() (*InstanceTypeNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.Connection.URL(), p.instanceTypeNicsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicsService.Connection.username, p.instanceTypeNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeNicsServiceAddResponse InstanceTypeNicsServiceAddResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	instanceTypeNicsServiceAddResponse.nic = &nicVar
	return &instanceTypeNicsServiceAddResponse, nil
}

type InstanceTypeNicsServiceAddResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicsServiceAddResponse) Nic() *Nic {
	return p.nic
}

//
// Add new network interface to the instance type.
//
func (op *InstanceTypeNicsService) Add(
	nic *Nic,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(nic, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

type InstanceTypeNicsServiceListRequest struct {
	instanceTypeNicsService *InstanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
	search                  *string
}

func (p *InstanceTypeNicsServiceListRequest) Header(key, value string) *InstanceTypeNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Query(key, value string) *InstanceTypeNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Max(max int64) *InstanceTypeNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypeNicsServiceListRequest) Search(search string) *InstanceTypeNicsServiceListRequest {
	p.search = &search
	return p
}
func (p *InstanceTypeNicsServiceListRequest) Send() (*InstanceTypeNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.Connection.URL(), p.instanceTypeNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeNicsService.Connection.username, p.instanceTypeNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeNicsServiceListResponse InstanceTypeNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	instanceTypeNicsServiceListResponse.nics = nicsVar.Nics
	return &instanceTypeNicsServiceListResponse, nil
}

type InstanceTypeNicsServiceListResponse struct {
	nics []Nic
}

func (p *InstanceTypeNicsServiceListResponse) Nics() []Nic {
	return p.nics
}

//
// Lists all the configured network interface of the instance type.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of NICs to return. If not specified all the NICs are returned.
// `Search`:: A query string used to restrict the returned templates.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypeNicsService) List(
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicsVar Nics
	xml.Unmarshal([]byte(ovResp.Body), &nicsVar)
	return nicsVar.Nics, nil
}

//
//
func (op *InstanceTypeNicsService) NicService(id string) *InstanceTypeNicService {
	return NewInstanceTypeNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeNicsService) String() string {
	return fmt.Sprintf("InstanceTypeNicsService:%s", op.Path)
}

//
//
type OperatingSystemsService struct {
	BaseService
}

func NewOperatingSystemsService(connection *Connection, path string) *OperatingSystemsService {
	var result OperatingSystemsService
	result.Connection = connection
	result.Path = path
	return &result
}

type OperatingSystemsServiceListRequest struct {
	operatingSystemsService *OperatingSystemsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *OperatingSystemsServiceListRequest) Header(key, value string) *OperatingSystemsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OperatingSystemsServiceListRequest) Query(key, value string) *OperatingSystemsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OperatingSystemsServiceListRequest) Max(max int64) *OperatingSystemsServiceListRequest {
	p.max = &max
	return p
}
func (p *OperatingSystemsServiceListRequest) Send() (*OperatingSystemsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemsService.Connection.URL(), p.operatingSystemsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.operatingSystemsService.Connection.username, p.operatingSystemsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.operatingSystemsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var operatingSystemsServiceListResponse OperatingSystemsServiceListResponse
	var operatingSystemVar OperatingSystemInfos
	xml.Unmarshal(respBodyBytes, &operatingSystemVar)
	operatingSystemsServiceListResponse.operatingSystem = operatingSystemVar.OperatingSystemInfos
	return &operatingSystemsServiceListResponse, nil
}

type OperatingSystemsServiceListResponse struct {
	operatingSystem []OperatingSystemInfo
}

func (p *OperatingSystemsServiceListResponse) OperatingSystem() []OperatingSystemInfo {
	return p.operatingSystem
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of networks to return. If not specified all the networks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *OperatingSystemsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]OperatingSystemInfo,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var operatingSystemVar OperatingSystemInfos
	xml.Unmarshal([]byte(ovResp.Body), &operatingSystemVar)
	return operatingSystemVar.OperatingSystemInfos, nil
}

//
//
func (op *OperatingSystemsService) OperatingSystemService(id string) *OperatingSystemService {
	return NewOperatingSystemService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OperatingSystemsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.OperatingSystemService(path)), nil
	}
	return op.OperatingSystemService(path[:index]).Service(path[index+1:])
}

func (op *OperatingSystemsService) String() string {
	return fmt.Sprintf("OperatingSystemsService:%s", op.Path)
}

//
// A service to manage a network interface of a host.
//
type HostNicService struct {
	BaseService
}

func NewHostNicService(connection *Connection, path string) *HostNicService {
	var result HostNicService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNicServiceGetRequest struct {
	hostNicService *HostNicService
	header         map[string]string
	query          map[string]string
}

func (p *HostNicServiceGetRequest) Header(key, value string) *HostNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicServiceGetRequest) Query(key, value string) *HostNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicServiceGetRequest) Send() (*HostNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNicService.Connection.URL(), p.hostNicService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNicService.Connection.username, p.hostNicService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNicService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostNicServiceGetResponse HostNicServiceGetResponse
	var nicVar HostNic
	xml.Unmarshal(respBodyBytes, &nicVar)
	hostNicServiceGetResponse.nic = &nicVar
	return &hostNicServiceGetResponse, nil
}

type HostNicServiceGetResponse struct {
	nic *HostNic
}

func (p *HostNicServiceGetResponse) Nic() *HostNic {
	return p.nic
}

//
//
func (op *HostNicService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*HostNic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar HostNic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

type HostNicServiceUpdateVirtualFunctionsConfigurationRequest struct {
	hostNicService                *HostNicService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Header(key, value string) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Query(key, value string) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Async(async bool) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.async = &async
	return p
}
func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) VirtualFunctionsConfiguration(virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.virtualFunctionsConfiguration = virtualFunctionsConfiguration
	return p
}
func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Send() (*HostNicServiceUpdateVirtualFunctionsConfigurationResponse, error) {
}

type HostNicServiceUpdateVirtualFunctionsConfigurationResponse struct {
}

//
// The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
// The input should be consisted of at least one of the following properties:
// - `allNetworksAllowed`
// - `numberOfVirtualFunctions`
// Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
// This method supports the following parameters:
// `Async`:: Indicates if the update should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostNicService) UpdateVirtualFunctionsConfiguration(
	async bool,
	virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
		VirtualFunctionsConfiguration: virtualFunctionsConfiguration,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "updatevirtualfunctionsconfiguration", headers, query, wait)
	return err
}

//
// Reference to the service that manages the network attachments assigned to this network interface.
//
func (op *HostNicService) NetworkAttachmentsService() *NetworkAttachmentsService {
	return NewNetworkAttachmentsService(op.Connection, fmt.Sprintf("%s/networkattachments", op.Path))
}

//
// Reference to the service that manages the network labels assigned to this network interface.
//
func (op *HostNicService) NetworkLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.Connection, fmt.Sprintf("%s/networklabels", op.Path))
}

//
//
func (op *HostNicService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Retrieves sub-collection resource of network labels that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *HostNicService) VirtualFunctionAllowedLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.Connection, fmt.Sprintf("%s/virtualfunctionallowedlabels", op.Path))
}

//
// Retrieves sub-collection resource of networks that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *HostNicService) VirtualFunctionAllowedNetworksService() *VirtualFunctionAllowedNetworksService {
	return NewVirtualFunctionAllowedNetworksService(op.Connection, fmt.Sprintf("%s/virtualfunctionallowednetworks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNicService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "virtualfunctionallowedlabels" {
		return op.VirtualFunctionAllowedLabelsService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowedlabels/") {
		return op.VirtualFunctionAllowedLabelsService().Service(path[29:])
	}
	if path == "virtualfunctionallowednetworks" {
		return op.VirtualFunctionAllowedNetworksService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowednetworks/") {
		return op.VirtualFunctionAllowedNetworksService().Service(path[31:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostNicService) String() string {
	return fmt.Sprintf("HostNicService:%s", op.Path)
}

//
//
type IscsiBondsService struct {
	BaseService
}

func NewIscsiBondsService(connection *Connection, path string) *IscsiBondsService {
	var result IscsiBondsService
	result.Connection = connection
	result.Path = path
	return &result
}

type IscsiBondsServiceAddRequest struct {
	iscsiBondsService *IscsiBondsService
	header            map[string]string
	query             map[string]string
	bond              *IscsiBond
}

func (p *IscsiBondsServiceAddRequest) Header(key, value string) *IscsiBondsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondsServiceAddRequest) Query(key, value string) *IscsiBondsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondsServiceAddRequest) Bond(bond *IscsiBond) *IscsiBondsServiceAddRequest {
	p.bond = bond
	return p
}
func (p *IscsiBondsServiceAddRequest) Send() (*IscsiBondsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.Connection.URL(), p.iscsiBondsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bond)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondsService.Connection.username, p.iscsiBondsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var iscsiBondsServiceAddResponse IscsiBondsServiceAddResponse
	var bondVar IscsiBond
	xml.Unmarshal(respBodyBytes, &bondVar)
	iscsiBondsServiceAddResponse.bond = &bondVar
	return &iscsiBondsServiceAddResponse, nil
}

type IscsiBondsServiceAddResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondsServiceAddResponse) Bond() *IscsiBond {
	return p.bond
}

//
// Create a new iSCSI bond on a data center.
// For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/iscsibonds
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//   <name>mybond</name>
//   <storage_connections>
//     <storage_connection id="456"/>
//     <storage_connection id="789"/>
//   </storage_connections>
//   <networks>
//     <network id="abc"/>
//   </networks>
// </iscsi_bond>
// ----
//
func (op *IscsiBondsService) Add(
	bond *IscsiBond,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*IscsiBond,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(bond, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bondVar IscsiBond
	xml.Unmarshal([]byte(ovResp.Body), &bondVar)
	return &bondVar, nil
}

type IscsiBondsServiceListRequest struct {
	iscsiBondsService *IscsiBondsService
	header            map[string]string
	query             map[string]string
	max               *int64
}

func (p *IscsiBondsServiceListRequest) Header(key, value string) *IscsiBondsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondsServiceListRequest) Query(key, value string) *IscsiBondsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondsServiceListRequest) Max(max int64) *IscsiBondsServiceListRequest {
	p.max = &max
	return p
}
func (p *IscsiBondsServiceListRequest) Send() (*IscsiBondsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.Connection.URL(), p.iscsiBondsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondsService.Connection.username, p.iscsiBondsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var iscsiBondsServiceListResponse IscsiBondsServiceListResponse
	var bondsVar IscsiBonds
	xml.Unmarshal(respBodyBytes, &bondsVar)
	iscsiBondsServiceListResponse.bonds = bondsVar.IscsiBonds
	return &iscsiBondsServiceListResponse, nil
}

type IscsiBondsServiceListResponse struct {
	bonds []IscsiBond
}

func (p *IscsiBondsServiceListResponse) Bonds() []IscsiBond {
	return p.bonds
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of bonds to return. If not specified all the bonds are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *IscsiBondsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]IscsiBond,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bondsVar IscsiBonds
	xml.Unmarshal([]byte(ovResp.Body), &bondsVar)
	return bondsVar.IscsiBonds, nil
}

//
//
func (op *IscsiBondsService) IscsiBondService(id string) *IscsiBondService {
	return NewIscsiBondService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IscsiBondsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.IscsiBondService(path)), nil
	}
	return op.IscsiBondService(path[:index]).Service(path[index+1:])
}

func (op *IscsiBondsService) String() string {
	return fmt.Sprintf("IscsiBondsService:%s", op.Path)
}

//
// A service to manage the users in the system.
//
type UsersService struct {
	BaseService
}

func NewUsersService(connection *Connection, path string) *UsersService {
	var result UsersService
	result.Connection = connection
	result.Path = path
	return &result
}

type UsersServiceAddRequest struct {
	usersService *UsersService
	header       map[string]string
	query        map[string]string
	user         *User
}

func (p *UsersServiceAddRequest) Header(key, value string) *UsersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UsersServiceAddRequest) Query(key, value string) *UsersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UsersServiceAddRequest) User(user *User) *UsersServiceAddRequest {
	p.user = user
	return p
}
func (p *UsersServiceAddRequest) Send() (*UsersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.usersService.Connection.URL(), p.usersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.user)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.usersService.Connection.username, p.usersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.usersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var usersServiceAddResponse UsersServiceAddResponse
	var userVar User
	xml.Unmarshal(respBodyBytes, &userVar)
	usersServiceAddResponse.user = &userVar
	return &usersServiceAddResponse, nil
}

type UsersServiceAddResponse struct {
	user *User
}

func (p *UsersServiceAddResponse) User() *User {
	return p.user
}

//
// Add user from a directory service.
// For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/users
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//   <user_name>myuser@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
// In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
// by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
// also `principal` parameter set to UPN of the user.
// For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
// authorization provider send a request body like this:
// [source,xml]
// ----
// <user>
//   <principal>myuser@mysubdomain.mydomain.com</principal>
//   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
//
func (op *UsersService) Add(
	user *User,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*User,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(user, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var userVar User
	xml.Unmarshal([]byte(ovResp.Body), &userVar)
	return &userVar, nil
}

type UsersServiceListRequest struct {
	usersService  *UsersService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *UsersServiceListRequest) Header(key, value string) *UsersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UsersServiceListRequest) Query(key, value string) *UsersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UsersServiceListRequest) CaseSensitive(caseSensitive bool) *UsersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *UsersServiceListRequest) Max(max int64) *UsersServiceListRequest {
	p.max = &max
	return p
}
func (p *UsersServiceListRequest) Search(search string) *UsersServiceListRequest {
	p.search = &search
	return p
}
func (p *UsersServiceListRequest) Send() (*UsersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.usersService.Connection.URL(), p.usersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.usersService.Connection.username, p.usersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.usersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var usersServiceListResponse UsersServiceListResponse
	var usersVar Users
	xml.Unmarshal(respBodyBytes, &usersVar)
	usersServiceListResponse.users = usersVar.Users
	return &usersServiceListResponse, nil
}

type UsersServiceListResponse struct {
	users []User
}

func (p *UsersServiceListResponse) Users() []User {
	return p.users
}

//
// List all the users in the system.
// Usage:
// ....
// GET /ovirt-engine/api/users
// ....
// Will return the list of users:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/users/1234" id="1234">
//     <name>admin</name>
//     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//     <domain_entry_id>23456</domain_entry_id>
//     <namespace>*</namespace>
//     <principal>user1</principal>
//     <user_name>user1@domain-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/45678" id="45678">
//       <name>domain-authz</name>
//     </domain>
//   </user>
// </users>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of users to return. If not specified all the users are returned.
// `Search`:: A query string used to restrict the returned users.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *UsersService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]User,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var usersVar Users
	xml.Unmarshal([]byte(ovResp.Body), &usersVar)
	return usersVar.Users, nil
}

//
//
func (op *UsersService) UserService(id string) *UserService {
	return NewUserService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UsersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UserService(path)), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *UsersService) String() string {
	return fmt.Sprintf("UsersService:%s", op.Path)
}

//
//
type GroupsService struct {
	BaseService
}

func NewGroupsService(connection *Connection, path string) *GroupsService {
	var result GroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type GroupsServiceAddRequest struct {
	groupsService *GroupsService
	header        map[string]string
	query         map[string]string
	group         *Group
}

func (p *GroupsServiceAddRequest) Header(key, value string) *GroupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupsServiceAddRequest) Query(key, value string) *GroupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupsServiceAddRequest) Group(group *Group) *GroupsServiceAddRequest {
	p.group = group
	return p
}
func (p *GroupsServiceAddRequest) Send() (*GroupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.Connection.URL(), p.groupsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.group)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.groupsService.Connection.username, p.groupsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.groupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var groupsServiceAddResponse GroupsServiceAddResponse
	var groupVar Group
	xml.Unmarshal(respBodyBytes, &groupVar)
	groupsServiceAddResponse.group = &groupVar
	return &groupsServiceAddResponse, nil
}

type GroupsServiceAddResponse struct {
	group *Group
}

func (p *GroupsServiceAddResponse) Group() *Group {
	return p.group
}

//
// Add group from a directory service. Please note that domain name is name of the authorization provider.
// For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/groups
// ----
// With a request body like this:
// [source,xml]
// ----
// <group>
//   <name>Developers</name>
//   <domain>
//     <name>internal-authz</name>
//   </domain>
// </group>
// ----
//
func (op *GroupsService) Add(
	group *Group,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Group,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(group, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupVar Group
	xml.Unmarshal([]byte(ovResp.Body), &groupVar)
	return &groupVar, nil
}

type GroupsServiceListRequest struct {
	groupsService *GroupsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *GroupsServiceListRequest) Header(key, value string) *GroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupsServiceListRequest) Query(key, value string) *GroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupsServiceListRequest) CaseSensitive(caseSensitive bool) *GroupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *GroupsServiceListRequest) Max(max int64) *GroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *GroupsServiceListRequest) Search(search string) *GroupsServiceListRequest {
	p.search = &search
	return p
}
func (p *GroupsServiceListRequest) Send() (*GroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.Connection.URL(), p.groupsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.groupsService.Connection.username, p.groupsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.groupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var groupsServiceListResponse GroupsServiceListResponse
	var groupsVar Groups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	groupsServiceListResponse.groups = groupsVar.Groups
	return &groupsServiceListResponse, nil
}

type GroupsServiceListResponse struct {
	groups []Group
}

func (p *GroupsServiceListResponse) Groups() []Group {
	return p.groups
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of groups to return. If not specified all the groups are returned.
// `Search`:: A query string used to restrict the returned groups.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GroupsService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Group,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupsVar Groups
	xml.Unmarshal([]byte(ovResp.Body), &groupsVar)
	return groupsVar.Groups, nil
}

//
//
func (op *GroupsService) GroupService(id string) *GroupService {
	return NewGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *GroupsService) String() string {
	return fmt.Sprintf("GroupsService:%s", op.Path)
}

//
// A service to view details of an authentication domain in the system.
//
type DomainService struct {
	BaseService
}

func NewDomainService(connection *Connection, path string) *DomainService {
	var result DomainService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainServiceGetRequest struct {
	domainService *DomainService
	header        map[string]string
	query         map[string]string
}

func (p *DomainServiceGetRequest) Header(key, value string) *DomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainServiceGetRequest) Query(key, value string) *DomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainServiceGetRequest) Send() (*DomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainService.Connection.URL(), p.domainService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainService.Connection.username, p.domainService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var domainServiceGetResponse DomainServiceGetResponse
	var domainVar Domain
	xml.Unmarshal(respBodyBytes, &domainVar)
	domainServiceGetResponse.domain = &domainVar
	return &domainServiceGetResponse, nil
}

type DomainServiceGetResponse struct {
	domain *Domain
}

func (p *DomainServiceGetResponse) Domain() *Domain {
	return p.domain
}

//
// Gets the authentication domain information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678
// ....
// Will return the domain information:
// [source,xml]
// ----
// <domain href="/ovirt-engine/api/domains/5678" id="5678">
//   <name>internal-authz</name>
//   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
// </domain>
// ----
//
func (op *DomainService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Domain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var domainVar Domain
	xml.Unmarshal([]byte(ovResp.Body), &domainVar)
	return &domainVar, nil
}

//
// Reference to a service to manage domain groups.
//
func (op *DomainService) GroupsService() *DomainGroupsService {
	return NewDomainGroupsService(op.Connection, fmt.Sprintf("%s/groups", op.Path))
}

//
// Reference to a service to manage domain users.
//
func (op *DomainService) UsersService() *DomainUsersService {
	return NewDomainUsersService(op.Connection, fmt.Sprintf("%s/users", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainService) String() string {
	return fmt.Sprintf("DomainService:%s", op.Path)
}

//
//
type SshPublicKeysService struct {
	BaseService
}

func NewSshPublicKeysService(connection *Connection, path string) *SshPublicKeysService {
	var result SshPublicKeysService
	result.Connection = connection
	result.Path = path
	return &result
}

type SshPublicKeysServiceAddRequest struct {
	sshPublicKeysService *SshPublicKeysService
	header               map[string]string
	query                map[string]string
	key                  *SshPublicKey
}

func (p *SshPublicKeysServiceAddRequest) Header(key, value string) *SshPublicKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeysServiceAddRequest) Query(key, value string) *SshPublicKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeysServiceAddRequest) Key(key *SshPublicKey) *SshPublicKeysServiceAddRequest {
	p.key = key
	return p
}
func (p *SshPublicKeysServiceAddRequest) Send() (*SshPublicKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.Connection.URL(), p.sshPublicKeysService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.key)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeysService.Connection.username, p.sshPublicKeysService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var sshPublicKeysServiceAddResponse SshPublicKeysServiceAddResponse
	var keyVar SshPublicKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	sshPublicKeysServiceAddResponse.key = &keyVar
	return &sshPublicKeysServiceAddResponse, nil
}

type SshPublicKeysServiceAddResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeysServiceAddResponse) Key() *SshPublicKey {
	return p.key
}

//
//
func (op *SshPublicKeysService) Add(
	key *SshPublicKey,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*SshPublicKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(key, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keyVar SshPublicKey
	xml.Unmarshal([]byte(ovResp.Body), &keyVar)
	return &keyVar, nil
}

type SshPublicKeysServiceListRequest struct {
	sshPublicKeysService *SshPublicKeysService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *SshPublicKeysServiceListRequest) Header(key, value string) *SshPublicKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeysServiceListRequest) Query(key, value string) *SshPublicKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeysServiceListRequest) Max(max int64) *SshPublicKeysServiceListRequest {
	p.max = &max
	return p
}
func (p *SshPublicKeysServiceListRequest) Send() (*SshPublicKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.Connection.URL(), p.sshPublicKeysService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeysService.Connection.username, p.sshPublicKeysService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var sshPublicKeysServiceListResponse SshPublicKeysServiceListResponse
	var keysVar SshPublicKeys
	xml.Unmarshal(respBodyBytes, &keysVar)
	sshPublicKeysServiceListResponse.keys = keysVar.SshPublicKeys
	return &sshPublicKeysServiceListResponse, nil
}

type SshPublicKeysServiceListResponse struct {
	keys []SshPublicKey
}

func (p *SshPublicKeysServiceListResponse) Keys() []SshPublicKey {
	return p.keys
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of keys to return. If not specified all the keys are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SshPublicKeysService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]SshPublicKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keysVar SshPublicKeys
	xml.Unmarshal([]byte(ovResp.Body), &keysVar)
	return keysVar.SshPublicKeys, nil
}

//
//
func (op *SshPublicKeysService) KeyService(id string) *SshPublicKeyService {
	return NewSshPublicKeyService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SshPublicKeysService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KeyService(path)), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *SshPublicKeysService) String() string {
	return fmt.Sprintf("SshPublicKeysService:%s", op.Path)
}

//
// A service to view a domain user in the system.
//
type DomainUserService struct {
	BaseService
}

func NewDomainUserService(connection *Connection, path string) *DomainUserService {
	var result DomainUserService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainUserServiceGetRequest struct {
	domainUserService *DomainUserService
	header            map[string]string
	query             map[string]string
}

func (p *DomainUserServiceGetRequest) Header(key, value string) *DomainUserServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainUserServiceGetRequest) Query(key, value string) *DomainUserServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainUserServiceGetRequest) Send() (*DomainUserServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainUserService.Connection.URL(), p.domainUserService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainUserService.Connection.username, p.domainUserService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainUserService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var domainUserServiceGetResponse DomainUserServiceGetResponse
	var userVar User
	xml.Unmarshal(respBodyBytes, &userVar)
	domainUserServiceGetResponse.user = &userVar
	return &domainUserServiceGetResponse, nil
}

type DomainUserServiceGetResponse struct {
	user *User
}

func (p *DomainUserServiceGetResponse) User() *User {
	return p.user
}

//
// Gets the domain user information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users/1234
// ....
// Will return the domain user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <namespace>*</namespace>
//   <principal>admin</principal>
//   <user_name>admin@internal-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//   </domain>
//   <groups/>
// </user>
// ----
//
func (op *DomainUserService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*User,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var userVar User
	xml.Unmarshal([]byte(ovResp.Body), &userVar)
	return &userVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainUserService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainUserService) String() string {
	return fmt.Sprintf("DomainUserService:%s", op.Path)
}

//
// A service to manage a user in the system.
// Use this service to either get users details or remove users.
// In order to add new users please use
// <<services/users>>.
//
type UserService struct {
	BaseService
}

func NewUserService(connection *Connection, path string) *UserService {
	var result UserService
	result.Connection = connection
	result.Path = path
	return &result
}

type UserServiceGetRequest struct {
	userService *UserService
	header      map[string]string
	query       map[string]string
}

func (p *UserServiceGetRequest) Header(key, value string) *UserServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UserServiceGetRequest) Query(key, value string) *UserServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UserServiceGetRequest) Send() (*UserServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.userService.Connection.URL(), p.userService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.userService.Connection.username, p.userService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.userService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var userServiceGetResponse UserServiceGetResponse
	var userVar User
	xml.Unmarshal(respBodyBytes, &userVar)
	userServiceGetResponse.user = &userVar
	return &userServiceGetResponse, nil
}

type UserServiceGetResponse struct {
	user *User
}

func (p *UserServiceGetResponse) User() *User {
	return p.user
}

//
// Gets the system user information.
// Usage:
// ....
// GET /ovirt-engine/api/users/1234
// ....
// Will return the user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//   <department></department>
//   <domain_entry_id>23456</domain_entry_id>
//   <email>user1@domain.com</email>
//   <last_name>Lastname</last_name>
//   <namespace>*</namespace>
//   <principal>user1</principal>
//   <user_name>user1@domain-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/45678" id="45678">
//     <name>domain-authz</name>
//   </domain>
// </user>
// ----
//
func (op *UserService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*User,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var userVar User
	xml.Unmarshal([]byte(ovResp.Body), &userVar)
	return &userVar, nil
}

type UserServiceRemoveRequest struct {
	userService *UserService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *UserServiceRemoveRequest) Header(key, value string) *UserServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UserServiceRemoveRequest) Query(key, value string) *UserServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UserServiceRemoveRequest) Async(async bool) *UserServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *UserServiceRemoveRequest) Send() (*UserServiceRemoveResponse, error) {
}

type UserServiceRemoveResponse struct {
}

//
// Removes the system user.
// Usage:
// ....
// DELETE /ovirt-engine/api/users/1234
// ....
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *UserService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
//
func (op *UserService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *UserService) RolesService() *AssignedRolesService {
	return NewAssignedRolesService(op.Connection, fmt.Sprintf("%s/roles", op.Path))
}

//
//
func (op *UserService) SshPublicKeysService() *SshPublicKeysService {
	return NewSshPublicKeysService(op.Connection, fmt.Sprintf("%s/sshpublickeys", op.Path))
}

//
//
func (op *UserService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UserService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "sshpublickeys" {
		return op.SshPublicKeysService(), nil
	}
	if strings.HasPrefix(path, "sshpublickeys/") {
		return op.SshPublicKeysService().Service(path[14:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *UserService) String() string {
	return fmt.Sprintf("UserService:%s", op.Path)
}

//
// A service to list all authentication domains in the system.
//
type DomainsService struct {
	BaseService
}

func NewDomainsService(connection *Connection, path string) *DomainsService {
	var result DomainsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainsServiceListRequest struct {
	domainsService *DomainsService
	header         map[string]string
	query          map[string]string
	max            *int64
}

func (p *DomainsServiceListRequest) Header(key, value string) *DomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainsServiceListRequest) Query(key, value string) *DomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainsServiceListRequest) Max(max int64) *DomainsServiceListRequest {
	p.max = &max
	return p
}
func (p *DomainsServiceListRequest) Send() (*DomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainsService.Connection.URL(), p.domainsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainsService.Connection.username, p.domainsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var domainsServiceListResponse DomainsServiceListResponse
	var domainsVar Domains
	xml.Unmarshal(respBodyBytes, &domainsVar)
	domainsServiceListResponse.domains = domainsVar.Domains
	return &domainsServiceListResponse, nil
}

type DomainsServiceListResponse struct {
	domains []Domain
}

func (p *DomainsServiceListResponse) Domains() []Domain {
	return p.domains
}

//
// List all the authentication domains in the system.
// Usage:
// ....
// GET /ovirt-engine/api/domains
// ....
// Will return the list of domains:
// [source,xml]
// ----
// <domains>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
//   </domain>
// </domains>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of domains to return. If not specified all the domains are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DomainsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Domain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var domainsVar Domains
	xml.Unmarshal([]byte(ovResp.Body), &domainsVar)
	return domainsVar.Domains, nil
}

//
// Reference to a service to view details of a domain.
//
func (op *DomainsService) DomainService(id string) *DomainService {
	return NewDomainService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DomainService(path)), nil
	}
	return op.DomainService(path[:index]).Service(path[index+1:])
}

func (op *DomainsService) String() string {
	return fmt.Sprintf("DomainsService:%s", op.Path)
}

//
// A service to list all domain users in the system.
//
type DomainUsersService struct {
	BaseService
}

func NewDomainUsersService(connection *Connection, path string) *DomainUsersService {
	var result DomainUsersService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainUsersServiceListRequest struct {
	domainUsersService *DomainUsersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	max                *int64
	search             *string
}

func (p *DomainUsersServiceListRequest) Header(key, value string) *DomainUsersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainUsersServiceListRequest) Query(key, value string) *DomainUsersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainUsersServiceListRequest) CaseSensitive(caseSensitive bool) *DomainUsersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DomainUsersServiceListRequest) Max(max int64) *DomainUsersServiceListRequest {
	p.max = &max
	return p
}
func (p *DomainUsersServiceListRequest) Search(search string) *DomainUsersServiceListRequest {
	p.search = &search
	return p
}
func (p *DomainUsersServiceListRequest) Send() (*DomainUsersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainUsersService.Connection.URL(), p.domainUsersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainUsersService.Connection.username, p.domainUsersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainUsersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var domainUsersServiceListResponse DomainUsersServiceListResponse
	var usersVar Users
	xml.Unmarshal(respBodyBytes, &usersVar)
	domainUsersServiceListResponse.users = usersVar.Users
	return &domainUsersServiceListResponse, nil
}

type DomainUsersServiceListResponse struct {
	users []User
}

func (p *DomainUsersServiceListResponse) Users() []User {
	return p.users
}

//
// List all the users in the domain.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users
// ....
// Will return the list of users in the domain:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
//     <name>admin</name>
//     <namespace>*</namespace>
//     <principal>admin</principal>
//     <user_name>admin@internal-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/5678" id="5678">
//       <name>internal-authz</name>
//     </domain>
//     <groups/>
//   </user>
// </users>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of users to return. If not specified all the users are returned.
// `Search`:: A query string used to restrict the returned users.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DomainUsersService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]User,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var usersVar Users
	xml.Unmarshal([]byte(ovResp.Body), &usersVar)
	return usersVar.Users, nil
}

//
// Reference to a service to view details of a domain user.
//
func (op *DomainUsersService) UserService(id string) *DomainUserService {
	return NewDomainUserService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainUsersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UserService(path)), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *DomainUsersService) String() string {
	return fmt.Sprintf("DomainUsersService:%s", op.Path)
}

//
//
type DomainGroupsService struct {
	BaseService
}

func NewDomainGroupsService(connection *Connection, path string) *DomainGroupsService {
	var result DomainGroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainGroupsServiceListRequest struct {
	domainGroupsService *DomainGroupsService
	header              map[string]string
	query               map[string]string
	caseSensitive       *bool
	max                 *int64
	search              *string
}

func (p *DomainGroupsServiceListRequest) Header(key, value string) *DomainGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainGroupsServiceListRequest) Query(key, value string) *DomainGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainGroupsServiceListRequest) CaseSensitive(caseSensitive bool) *DomainGroupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DomainGroupsServiceListRequest) Max(max int64) *DomainGroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *DomainGroupsServiceListRequest) Search(search string) *DomainGroupsServiceListRequest {
	p.search = &search
	return p
}
func (p *DomainGroupsServiceListRequest) Send() (*DomainGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupsService.Connection.URL(), p.domainGroupsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainGroupsService.Connection.username, p.domainGroupsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var domainGroupsServiceListResponse DomainGroupsServiceListResponse
	var groupsVar Groups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	domainGroupsServiceListResponse.groups = groupsVar.Groups
	return &domainGroupsServiceListResponse, nil
}

type DomainGroupsServiceListResponse struct {
	groups []Group
}

func (p *DomainGroupsServiceListResponse) Groups() []Group {
	return p.groups
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of groups to return. If not specified all the groups are returned.
// `Search`:: A query string used to restrict the returned groups.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DomainGroupsService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Group,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupsVar Groups
	xml.Unmarshal([]byte(ovResp.Body), &groupsVar)
	return groupsVar.Groups, nil
}

//
//
func (op *DomainGroupsService) GroupService(id string) *DomainGroupService {
	return NewDomainGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainGroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *DomainGroupsService) String() string {
	return fmt.Sprintf("DomainGroupsService:%s", op.Path)
}

//
//
type GroupService struct {
	BaseService
}

func NewGroupService(connection *Connection, path string) *GroupService {
	var result GroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type GroupServiceGetRequest struct {
	groupService *GroupService
	header       map[string]string
	query        map[string]string
}

func (p *GroupServiceGetRequest) Header(key, value string) *GroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupServiceGetRequest) Query(key, value string) *GroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupServiceGetRequest) Send() (*GroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupService.Connection.URL(), p.groupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.groupService.Connection.username, p.groupService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.groupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var groupServiceGetResponse GroupServiceGetResponse
	var getVar Group
	xml.Unmarshal(respBodyBytes, &getVar)
	groupServiceGetResponse.get = &getVar
	return &groupServiceGetResponse, nil
}

type GroupServiceGetResponse struct {
	get *Group
}

func (p *GroupServiceGetResponse) Get() *Group {
	return p.get
}

//
//
func (op *GroupService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Group,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var getVar Group
	xml.Unmarshal([]byte(ovResp.Body), &getVar)
	return &getVar, nil
}

type GroupServiceRemoveRequest struct {
	groupService *GroupService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *GroupServiceRemoveRequest) Header(key, value string) *GroupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupServiceRemoveRequest) Query(key, value string) *GroupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupServiceRemoveRequest) Async(async bool) *GroupServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GroupServiceRemoveRequest) Send() (*GroupServiceRemoveResponse, error) {
}

type GroupServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GroupService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
//
func (op *GroupService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *GroupService) RolesService() *AssignedRolesService {
	return NewAssignedRolesService(op.Connection, fmt.Sprintf("%s/roles", op.Path))
}

//
//
func (op *GroupService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GroupService) String() string {
	return fmt.Sprintf("GroupService:%s", op.Path)
}

//
//
type DomainGroupService struct {
	BaseService
}

func NewDomainGroupService(connection *Connection, path string) *DomainGroupService {
	var result DomainGroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type DomainGroupServiceGetRequest struct {
	domainGroupService *DomainGroupService
	header             map[string]string
	query              map[string]string
}

func (p *DomainGroupServiceGetRequest) Header(key, value string) *DomainGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainGroupServiceGetRequest) Query(key, value string) *DomainGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainGroupServiceGetRequest) Send() (*DomainGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupService.Connection.URL(), p.domainGroupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.domainGroupService.Connection.username, p.domainGroupService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.domainGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var domainGroupServiceGetResponse DomainGroupServiceGetResponse
	var getVar Group
	xml.Unmarshal(respBodyBytes, &getVar)
	domainGroupServiceGetResponse.get = &getVar
	return &domainGroupServiceGetResponse, nil
}

type DomainGroupServiceGetResponse struct {
	get *Group
}

func (p *DomainGroupServiceGetResponse) Get() *Group {
	return p.get
}

//
//
func (op *DomainGroupService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Group,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var getVar Group
	xml.Unmarshal([]byte(ovResp.Body), &getVar)
	return &getVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainGroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainGroupService) String() string {
	return fmt.Sprintf("DomainGroupService:%s", op.Path)
}

//
//
type SshPublicKeyService struct {
	BaseService
}

func NewSshPublicKeyService(connection *Connection, path string) *SshPublicKeyService {
	var result SshPublicKeyService
	result.Connection = connection
	result.Path = path
	return &result
}

type SshPublicKeyServiceGetRequest struct {
	sshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
}

func (p *SshPublicKeyServiceGetRequest) Header(key, value string) *SshPublicKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceGetRequest) Query(key, value string) *SshPublicKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceGetRequest) Send() (*SshPublicKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.Connection.URL(), p.sshPublicKeyService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.sshPublicKeyService.Connection.username, p.sshPublicKeyService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var sshPublicKeyServiceGetResponse SshPublicKeyServiceGetResponse
	var keyVar SshPublicKey
	xml.Unmarshal(respBodyBytes, &keyVar)
	sshPublicKeyServiceGetResponse.key = &keyVar
	return &sshPublicKeyServiceGetResponse, nil
}

type SshPublicKeyServiceGetResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeyServiceGetResponse) Key() *SshPublicKey {
	return p.key
}

//
//
func (op *SshPublicKeyService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*SshPublicKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keyVar SshPublicKey
	xml.Unmarshal([]byte(ovResp.Body), &keyVar)
	return &keyVar, nil
}

type SshPublicKeyServiceRemoveRequest struct {
	sshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *SshPublicKeyServiceRemoveRequest) Header(key, value string) *SshPublicKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceRemoveRequest) Query(key, value string) *SshPublicKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceRemoveRequest) Async(async bool) *SshPublicKeyServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *SshPublicKeyServiceRemoveRequest) Send() (*SshPublicKeyServiceRemoveResponse, error) {
}

type SshPublicKeyServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SshPublicKeyService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type SshPublicKeyServiceUpdateRequest struct {
	sshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
	key                 *SshPublicKey
}

func (p *SshPublicKeyServiceUpdateRequest) Header(key, value string) *SshPublicKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Query(key, value string) *SshPublicKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Async(async bool) *SshPublicKeyServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *SshPublicKeyServiceUpdateRequest) Key(key *SshPublicKey) *SshPublicKeyServiceUpdateRequest {
	p.key = key
	return p
}
func (p *SshPublicKeyServiceUpdateRequest) Send() (*SshPublicKeyServiceUpdateResponse, error) {
}

type SshPublicKeyServiceUpdateResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeyServiceUpdateResponse) Key() *SshPublicKey {
	return p.key
}

//
//
func (op *SshPublicKeyService) Update(
	key *SshPublicKey,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*SshPublicKey,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(key, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var keyVar SshPublicKey
	xml.Unmarshal([]byte(ovResp.Body), &keyVar)
	return &keyVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SshPublicKeyService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SshPublicKeyService) String() string {
	return fmt.Sprintf("SshPublicKeyService:%s", op.Path)
}

//
//
type FenceAgentService struct {
	BaseService
}

func NewFenceAgentService(connection *Connection, path string) *FenceAgentService {
	var result FenceAgentService
	result.Connection = connection
	result.Path = path
	return &result
}

type FenceAgentServiceGetRequest struct {
	fenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
}

func (p *FenceAgentServiceGetRequest) Header(key, value string) *FenceAgentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceGetRequest) Query(key, value string) *FenceAgentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceGetRequest) Send() (*FenceAgentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.Connection.URL(), p.fenceAgentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentService.Connection.username, p.fenceAgentService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var fenceAgentServiceGetResponse FenceAgentServiceGetResponse
	var agentVar Agent
	xml.Unmarshal(respBodyBytes, &agentVar)
	fenceAgentServiceGetResponse.agent = &agentVar
	return &fenceAgentServiceGetResponse, nil
}

type FenceAgentServiceGetResponse struct {
	agent *Agent
}

func (p *FenceAgentServiceGetResponse) Agent() *Agent {
	return p.agent
}

//
//
func (op *FenceAgentService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Agent,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var agentVar Agent
	xml.Unmarshal([]byte(ovResp.Body), &agentVar)
	return &agentVar, nil
}

type FenceAgentServiceRemoveRequest struct {
	fenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *FenceAgentServiceRemoveRequest) Header(key, value string) *FenceAgentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceRemoveRequest) Query(key, value string) *FenceAgentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceRemoveRequest) Async(async bool) *FenceAgentServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *FenceAgentServiceRemoveRequest) Send() (*FenceAgentServiceRemoveResponse, error) {
}

type FenceAgentServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *FenceAgentService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type FenceAgentServiceUpdateRequest struct {
	fenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
	agent             *Agent
	async             *bool
}

func (p *FenceAgentServiceUpdateRequest) Header(key, value string) *FenceAgentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceUpdateRequest) Query(key, value string) *FenceAgentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceUpdateRequest) Agent(agent *Agent) *FenceAgentServiceUpdateRequest {
	p.agent = agent
	return p
}
func (p *FenceAgentServiceUpdateRequest) Async(async bool) *FenceAgentServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *FenceAgentServiceUpdateRequest) Send() (*FenceAgentServiceUpdateResponse, error) {
}

type FenceAgentServiceUpdateResponse struct {
	agent *Agent
}

func (p *FenceAgentServiceUpdateResponse) Agent() *Agent {
	return p.agent
}

//
//
func (op *FenceAgentService) Update(
	agent *Agent,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Agent,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(agent, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var agentVar Agent
	xml.Unmarshal([]byte(ovResp.Body), &agentVar)
	return &agentVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FenceAgentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FenceAgentService) String() string {
	return fmt.Sprintf("FenceAgentService:%s", op.Path)
}

//
//
type MacPoolService struct {
	BaseService
}

func NewMacPoolService(connection *Connection, path string) *MacPoolService {
	var result MacPoolService
	result.Connection = connection
	result.Path = path
	return &result
}

type MacPoolServiceGetRequest struct {
	macPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
}

func (p *MacPoolServiceGetRequest) Header(key, value string) *MacPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceGetRequest) Query(key, value string) *MacPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceGetRequest) Send() (*MacPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.Connection.URL(), p.macPoolService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.macPoolService.Connection.username, p.macPoolService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.macPoolService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var macPoolServiceGetResponse MacPoolServiceGetResponse
	var poolVar MacPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	macPoolServiceGetResponse.pool = &poolVar
	return &macPoolServiceGetResponse, nil
}

type MacPoolServiceGetResponse struct {
	pool *MacPool
}

func (p *MacPoolServiceGetResponse) Pool() *MacPool {
	return p.pool
}

//
//
func (op *MacPoolService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*MacPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolVar MacPool
	xml.Unmarshal([]byte(ovResp.Body), &poolVar)
	return &poolVar, nil
}

type MacPoolServiceRemoveRequest struct {
	macPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *MacPoolServiceRemoveRequest) Header(key, value string) *MacPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceRemoveRequest) Query(key, value string) *MacPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceRemoveRequest) Async(async bool) *MacPoolServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *MacPoolServiceRemoveRequest) Send() (*MacPoolServiceRemoveResponse, error) {
}

type MacPoolServiceRemoveResponse struct {
}

//
// Removes a MAC address pool.
// For example, to remove the MAC address pool having id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/macpools/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *MacPoolService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type MacPoolServiceUpdateRequest struct {
	macPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
	pool           *MacPool
}

func (p *MacPoolServiceUpdateRequest) Header(key, value string) *MacPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceUpdateRequest) Query(key, value string) *MacPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceUpdateRequest) Async(async bool) *MacPoolServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *MacPoolServiceUpdateRequest) Pool(pool *MacPool) *MacPoolServiceUpdateRequest {
	p.pool = pool
	return p
}
func (p *MacPoolServiceUpdateRequest) Send() (*MacPoolServiceUpdateResponse, error) {
}

type MacPoolServiceUpdateResponse struct {
	pool *MacPool
}

func (p *MacPoolServiceUpdateResponse) Pool() *MacPool {
	return p.pool
}

//
// Updates a MAC address pool.
// The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
// For example, to update the MAC address pool of id `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/macpools/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>UpdatedMACPool</name>
//   <description>An updated MAC address pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//     <range>
//       <from>02:1A:4A:01:00:00</from>
//       <to>02:1A:4A:FF:FF:FF</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
func (op *MacPoolService) Update(
	pool *MacPool,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*MacPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(pool, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolVar MacPool
	xml.Unmarshal([]byte(ovResp.Body), &poolVar)
	return &poolVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MacPoolService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MacPoolService) String() string {
	return fmt.Sprintf("MacPoolService:%s", op.Path)
}

//
//
type AssignedCpuProfilesService struct {
	BaseService
}

func NewAssignedCpuProfilesService(connection *Connection, path string) *AssignedCpuProfilesService {
	var result AssignedCpuProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedCpuProfilesServiceAddRequest struct {
	assignedCpuProfilesService *AssignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	profile                    *CpuProfile
}

func (p *AssignedCpuProfilesServiceAddRequest) Header(key, value string) *AssignedCpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceAddRequest) Query(key, value string) *AssignedCpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *AssignedCpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *AssignedCpuProfilesServiceAddRequest) Send() (*AssignedCpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.Connection.URL(), p.assignedCpuProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedCpuProfilesService.Connection.username, p.assignedCpuProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedCpuProfilesServiceAddResponse AssignedCpuProfilesServiceAddResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedCpuProfilesServiceAddResponse.profile = &profileVar
	return &assignedCpuProfilesServiceAddResponse, nil
}

type AssignedCpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *AssignedCpuProfilesServiceAddResponse) Profile() *CpuProfile {
	return p.profile
}

//
//
func (op *AssignedCpuProfilesService) Add(
	profile *CpuProfile,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*CpuProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar CpuProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type AssignedCpuProfilesServiceListRequest struct {
	assignedCpuProfilesService *AssignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	max                        *int64
}

func (p *AssignedCpuProfilesServiceListRequest) Header(key, value string) *AssignedCpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Query(key, value string) *AssignedCpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Max(max int64) *AssignedCpuProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedCpuProfilesServiceListRequest) Send() (*AssignedCpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.Connection.URL(), p.assignedCpuProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedCpuProfilesService.Connection.username, p.assignedCpuProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedCpuProfilesServiceListResponse AssignedCpuProfilesServiceListResponse
	var profilesVar CpuProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	assignedCpuProfilesServiceListResponse.profiles = profilesVar.CpuProfiles
	return &assignedCpuProfilesServiceListResponse, nil
}

type AssignedCpuProfilesServiceListResponse struct {
	profiles []CpuProfile
}

func (p *AssignedCpuProfilesServiceListResponse) Profiles() []CpuProfile {
	return p.profiles
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of profiles to return. If not specified all the profiles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedCpuProfilesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]CpuProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profilesVar CpuProfiles
	xml.Unmarshal([]byte(ovResp.Body), &profilesVar)
	return profilesVar.CpuProfiles, nil
}

//
//
func (op *AssignedCpuProfilesService) ProfileService(id string) *AssignedCpuProfileService {
	return NewAssignedCpuProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedCpuProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedCpuProfilesService) String() string {
	return fmt.Sprintf("AssignedCpuProfilesService:%s", op.Path)
}

//
//
type StorageServerConnectionExtensionsService struct {
	BaseService
}

func NewStorageServerConnectionExtensionsService(connection *Connection, path string) *StorageServerConnectionExtensionsService {
	var result StorageServerConnectionExtensionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionExtensionsServiceAddRequest struct {
	storageServerConnectionExtensionsService *StorageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	extension                                *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Header(key, value string) *StorageServerConnectionExtensionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Query(key, value string) *StorageServerConnectionExtensionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Extension(extension *StorageConnectionExtension) *StorageServerConnectionExtensionsServiceAddRequest {
	p.extension = extension
	return p
}
func (p *StorageServerConnectionExtensionsServiceAddRequest) Send() (*StorageServerConnectionExtensionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.Connection.URL(), p.storageServerConnectionExtensionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.extension)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionsService.Connection.username, p.storageServerConnectionExtensionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageServerConnectionExtensionsServiceAddResponse StorageServerConnectionExtensionsServiceAddResponse
	var extensionVar StorageConnectionExtension
	xml.Unmarshal(respBodyBytes, &extensionVar)
	storageServerConnectionExtensionsServiceAddResponse.extension = &extensionVar
	return &storageServerConnectionExtensionsServiceAddResponse, nil
}

type StorageServerConnectionExtensionsServiceAddResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceAddResponse) Extension() *StorageConnectionExtension {
	return p.extension
}

//
// Creates a new storage server connection extension for the given host.
// The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
// `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/storageconnectionextensions
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
func (op *StorageServerConnectionExtensionsService) Add(
	extension *StorageConnectionExtension,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnectionExtension,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(extension, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var extensionVar StorageConnectionExtension
	xml.Unmarshal([]byte(ovResp.Body), &extensionVar)
	return &extensionVar, nil
}

type StorageServerConnectionExtensionsServiceListRequest struct {
	storageServerConnectionExtensionsService *StorageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	max                                      *int64
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Header(key, value string) *StorageServerConnectionExtensionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Query(key, value string) *StorageServerConnectionExtensionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Max(max int64) *StorageServerConnectionExtensionsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageServerConnectionExtensionsServiceListRequest) Send() (*StorageServerConnectionExtensionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.Connection.URL(), p.storageServerConnectionExtensionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionsService.Connection.username, p.storageServerConnectionExtensionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageServerConnectionExtensionsServiceListResponse StorageServerConnectionExtensionsServiceListResponse
	var extensionsVar StorageConnectionExtensions
	xml.Unmarshal(respBodyBytes, &extensionsVar)
	storageServerConnectionExtensionsServiceListResponse.extensions = extensionsVar.StorageConnectionExtensions
	return &storageServerConnectionExtensionsServiceListResponse, nil
}

type StorageServerConnectionExtensionsServiceListResponse struct {
	extensions []StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceListResponse) Extensions() []StorageConnectionExtension {
	return p.extensions
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of extensions to return. If not specified all the extensions are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageServerConnectionExtensionsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]StorageConnectionExtension,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var extensionsVar StorageConnectionExtensions
	xml.Unmarshal([]byte(ovResp.Body), &extensionsVar)
	return extensionsVar.StorageConnectionExtensions, nil
}

//
//
func (op *StorageServerConnectionExtensionsService) StorageConnectionExtensionService(id string) *StorageServerConnectionExtensionService {
	return NewStorageServerConnectionExtensionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionExtensionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageConnectionExtensionService(path)), nil
	}
	return op.StorageConnectionExtensionService(path[:index]).Service(path[index+1:])
}

func (op *StorageServerConnectionExtensionsService) String() string {
	return fmt.Sprintf("StorageServerConnectionExtensionsService:%s", op.Path)
}

//
//
type PermissionService struct {
	BaseService
}

func NewPermissionService(connection *Connection, path string) *PermissionService {
	var result PermissionService
	result.Connection = connection
	result.Path = path
	return &result
}

type PermissionServiceGetRequest struct {
	permissionService *PermissionService
	header            map[string]string
	query             map[string]string
}

func (p *PermissionServiceGetRequest) Header(key, value string) *PermissionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermissionServiceGetRequest) Query(key, value string) *PermissionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermissionServiceGetRequest) Send() (*PermissionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permissionService.Connection.URL(), p.permissionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permissionService.Connection.username, p.permissionService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permissionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var permissionServiceGetResponse PermissionServiceGetResponse
	var permissionVar Permission
	xml.Unmarshal(respBodyBytes, &permissionVar)
	permissionServiceGetResponse.permission = &permissionVar
	return &permissionServiceGetResponse, nil
}

type PermissionServiceGetResponse struct {
	permission *Permission
}

func (p *PermissionServiceGetResponse) Permission() *Permission {
	return p.permission
}

//
//
func (op *PermissionService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Permission,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permissionVar Permission
	xml.Unmarshal([]byte(ovResp.Body), &permissionVar)
	return &permissionVar, nil
}

type PermissionServiceRemoveRequest struct {
	permissionService *PermissionService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *PermissionServiceRemoveRequest) Header(key, value string) *PermissionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermissionServiceRemoveRequest) Query(key, value string) *PermissionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermissionServiceRemoveRequest) Async(async bool) *PermissionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *PermissionServiceRemoveRequest) Send() (*PermissionServiceRemoveResponse, error) {
}

type PermissionServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *PermissionService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermissionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *PermissionService) String() string {
	return fmt.Sprintf("PermissionService:%s", op.Path)
}

//
//
type DiskProfileService struct {
	BaseService
}

func NewDiskProfileService(connection *Connection, path string) *DiskProfileService {
	var result DiskProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskProfileServiceGetRequest struct {
	diskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
}

func (p *DiskProfileServiceGetRequest) Header(key, value string) *DiskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceGetRequest) Query(key, value string) *DiskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceGetRequest) Send() (*DiskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.Connection.URL(), p.diskProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskProfileService.Connection.username, p.diskProfileService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskProfileServiceGetResponse DiskProfileServiceGetResponse
	var profileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	diskProfileServiceGetResponse.profile = &profileVar
	return &diskProfileServiceGetResponse, nil
}

type DiskProfileServiceGetResponse struct {
	profile *DiskProfile
}

func (p *DiskProfileServiceGetResponse) Profile() *DiskProfile {
	return p.profile
}

//
//
func (op *DiskProfileService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar DiskProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type DiskProfileServiceRemoveRequest struct {
	diskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *DiskProfileServiceRemoveRequest) Header(key, value string) *DiskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceRemoveRequest) Query(key, value string) *DiskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceRemoveRequest) Async(async bool) *DiskProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DiskProfileServiceRemoveRequest) Send() (*DiskProfileServiceRemoveResponse, error) {
}

type DiskProfileServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskProfileService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type DiskProfileServiceUpdateRequest struct {
	diskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *DiskProfile
}

func (p *DiskProfileServiceUpdateRequest) Header(key, value string) *DiskProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceUpdateRequest) Query(key, value string) *DiskProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceUpdateRequest) Async(async bool) *DiskProfileServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *DiskProfileServiceUpdateRequest) Profile(profile *DiskProfile) *DiskProfileServiceUpdateRequest {
	p.profile = profile
	return p
}
func (p *DiskProfileServiceUpdateRequest) Send() (*DiskProfileServiceUpdateResponse, error) {
}

type DiskProfileServiceUpdateResponse struct {
	profile *DiskProfile
}

func (p *DiskProfileServiceUpdateResponse) Profile() *DiskProfile {
	return p.profile
}

//
//
func (op *DiskProfileService) Update(
	profile *DiskProfile,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar DiskProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

//
//
func (op *DiskProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskProfileService) String() string {
	return fmt.Sprintf("DiskProfileService:%s", op.Path)
}

//
// This service manages a single affinity group.
//
type AffinityGroupService struct {
	BaseService
}

func NewAffinityGroupService(connection *Connection, path string) *AffinityGroupService {
	var result AffinityGroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityGroupServiceGetRequest struct {
	affinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
}

func (p *AffinityGroupServiceGetRequest) Header(key, value string) *AffinityGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceGetRequest) Query(key, value string) *AffinityGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceGetRequest) Send() (*AffinityGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.Connection.URL(), p.affinityGroupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityGroupService.Connection.username, p.affinityGroupService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityGroupServiceGetResponse AffinityGroupServiceGetResponse
	var groupVar AffinityGroup
	xml.Unmarshal(respBodyBytes, &groupVar)
	affinityGroupServiceGetResponse.group = &groupVar
	return &affinityGroupServiceGetResponse, nil
}

type AffinityGroupServiceGetResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupServiceGetResponse) Group() *AffinityGroup {
	return p.group
}

//
// Retrieve the affinity group details.
// [source,xml]
// ----
// <affinity_group id="00000000-0000-0000-0000-000000000000">
//   <name>AF_GROUP_001</name>
//   <cluster id="00000000-0000-0000-0000-000000000000"/>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
//
func (op *AffinityGroupService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityGroup,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupVar AffinityGroup
	xml.Unmarshal([]byte(ovResp.Body), &groupVar)
	return &groupVar, nil
}

type AffinityGroupServiceRemoveRequest struct {
	affinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *AffinityGroupServiceRemoveRequest) Header(key, value string) *AffinityGroupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceRemoveRequest) Query(key, value string) *AffinityGroupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceRemoveRequest) Async(async bool) *AffinityGroupServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AffinityGroupServiceRemoveRequest) Send() (*AffinityGroupServiceRemoveResponse, error) {
}

type AffinityGroupServiceRemoveResponse struct {
}

//
// Remove the affinity group.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the removal should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AffinityGroupService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type AffinityGroupServiceUpdateRequest struct {
	affinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
	group                *AffinityGroup
}

func (p *AffinityGroupServiceUpdateRequest) Header(key, value string) *AffinityGroupServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Query(key, value string) *AffinityGroupServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Async(async bool) *AffinityGroupServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *AffinityGroupServiceUpdateRequest) Group(group *AffinityGroup) *AffinityGroupServiceUpdateRequest {
	p.group = group
	return p
}
func (p *AffinityGroupServiceUpdateRequest) Send() (*AffinityGroupServiceUpdateResponse, error) {
}

type AffinityGroupServiceUpdateResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupServiceUpdateResponse) Group() *AffinityGroup {
	return p.group
}

//
// Update the affinity group.
// This method supports the following parameters:
// `Group`:: The affinity group.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AffinityGroupService) Update(
	group *AffinityGroup,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityGroup,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(group, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupVar AffinityGroup
	xml.Unmarshal([]byte(ovResp.Body), &groupVar)
	return &groupVar, nil
}

//
// Returns a reference to the service that manages the
// list of all virtual machines attached to this affinity
// group.
//
func (op *AffinityGroupService) VmsService() *AffinityGroupVmsService {
	return NewAffinityGroupVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupService) String() string {
	return fmt.Sprintf("AffinityGroupService:%s", op.Path)
}

//
//
type UnmanagedNetworksService struct {
	BaseService
}

func NewUnmanagedNetworksService(connection *Connection, path string) *UnmanagedNetworksService {
	var result UnmanagedNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type UnmanagedNetworksServiceListRequest struct {
	unmanagedNetworksService *UnmanagedNetworksService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *UnmanagedNetworksServiceListRequest) Header(key, value string) *UnmanagedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Query(key, value string) *UnmanagedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Max(max int64) *UnmanagedNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *UnmanagedNetworksServiceListRequest) Send() (*UnmanagedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworksService.Connection.URL(), p.unmanagedNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.unmanagedNetworksService.Connection.username, p.unmanagedNetworksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var unmanagedNetworksServiceListResponse UnmanagedNetworksServiceListResponse
	var networksVar UnmanagedNetworks
	xml.Unmarshal(respBodyBytes, &networksVar)
	unmanagedNetworksServiceListResponse.networks = networksVar.UnmanagedNetworks
	return &unmanagedNetworksServiceListResponse, nil
}

type UnmanagedNetworksServiceListResponse struct {
	networks []UnmanagedNetwork
}

func (p *UnmanagedNetworksServiceListResponse) Networks() []UnmanagedNetwork {
	return p.networks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of networks to return. If not specified all the networks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *UnmanagedNetworksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]UnmanagedNetwork,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networksVar UnmanagedNetworks
	xml.Unmarshal([]byte(ovResp.Body), &networksVar)
	return networksVar.UnmanagedNetworks, nil
}

//
//
func (op *UnmanagedNetworksService) UnmanagedNetworkService(id string) *UnmanagedNetworkService {
	return NewUnmanagedNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UnmanagedNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UnmanagedNetworkService(path)), nil
	}
	return op.UnmanagedNetworkService(path[:index]).Service(path[index+1:])
}

func (op *UnmanagedNetworksService) String() string {
	return fmt.Sprintf("UnmanagedNetworksService:%s", op.Path)
}

//
//
type VmsService struct {
	BaseService
}

func NewVmsService(connection *Connection, path string) *VmsService {
	var result VmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmsServiceAddRequest struct {
	vmsService       *VmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	vm               *Vm
}

func (p *VmsServiceAddRequest) Header(key, value string) *VmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceAddRequest) Query(key, value string) *VmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceAddRequest) Clone(clone bool) *VmsServiceAddRequest {
	p.clone = &clone
	return p
}
func (p *VmsServiceAddRequest) ClonePermissions(clonePermissions bool) *VmsServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}
func (p *VmsServiceAddRequest) Vm(vm *Vm) *VmsServiceAddRequest {
	p.vm = vm
	return p
}
func (p *VmsServiceAddRequest) Send() (*VmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.Connection.URL(), p.vmsService.Path)
	values := make(url.Values)
	if p.clone != nil {
		values["clone"] = []string{fmt.Sprintf("%v", *p.clone)}
	}
	if p.clonePermissions != nil {
		values["clonePermissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.vm)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmsService.Connection.username, p.vmsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmsServiceAddResponse VmsServiceAddResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	vmsServiceAddResponse.vm = &vmVar
	return &vmsServiceAddResponse, nil
}

type VmsServiceAddResponse struct {
	vm *Vm
}

func (p *VmsServiceAddResponse) Vm() *Vm {
	return p.vm
}

//
// Creates a new virtual machine.
// The virtual machine can be created in different ways:
// - From a template. In this case the identifier or name of the template must be provided. For example, using a
//   plain shell script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <template>
//     <name>Blank</name>
//   </template>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
//   shel script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <snapshots>
//     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
//   </snapshots>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
// in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
// a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
// `image_id` attribute instead of `id`.
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk>
//         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
// of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
// following:
// [source,xml]
// ----
// <vm>
//   <name>myvm</name>
//   <description>My Desktop Virtual Machine</description>
//   <type>desktop</type>
//   <memory>2147483648</memory>
//   ...
// </vm>
// ----
// A bootable CDROM device can be set like this:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot dev="cdrom"/>
//   </os>
// </vm>
// ----
// In order to boot from CDROM, you first need to insert a disk, as described in the
// <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
// attribute:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot>
//       <devices>
//         <device>cdrom</device>
//       </devices>
//     </boot>
//   </os>
// </vm>
// ----
// In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
//
func (op *VmsService) Add(
	vm *Vm,
	clone bool,
	clonePermissions bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["clone"] = fmt.Sprintf("%v", clone)
	query["clone_permissions"] = fmt.Sprintf("%v", clonePermissions)

	// Send the request and get the response
	ovResp, err := op.internalAdd(vm, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vm
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return &vmVar, nil
}

type VmsServiceListRequest struct {
	vmsService    *VmsService
	header        map[string]string
	query         map[string]string
	allContent    *bool
	caseSensitive *bool
	filter        *bool
	max           *int64
	search        *string
}

func (p *VmsServiceListRequest) Header(key, value string) *VmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceListRequest) Query(key, value string) *VmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceListRequest) AllContent(allContent bool) *VmsServiceListRequest {
	p.allContent = &allContent
	return p
}
func (p *VmsServiceListRequest) CaseSensitive(caseSensitive bool) *VmsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *VmsServiceListRequest) Filter(filter bool) *VmsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *VmsServiceListRequest) Max(max int64) *VmsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmsServiceListRequest) Search(search string) *VmsServiceListRequest {
	p.search = &search
	return p
}
func (p *VmsServiceListRequest) Send() (*VmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.Connection.URL(), p.vmsService.Path)
	values := make(url.Values)
	if p.allContent != nil {
		values["allContent"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmsService.Connection.username, p.vmsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmsServiceListResponse VmsServiceListResponse
	var vmsVar Vms
	xml.Unmarshal(respBodyBytes, &vmsVar)
	vmsServiceListResponse.vms = vmsVar.Vms
	return &vmsServiceListResponse, nil
}

type VmsServiceListResponse struct {
	vms []Vm
}

func (p *VmsServiceListResponse) Vms() []Vm {
	return p.vms
}

//
// This method supports the following parameters:
// `Search`:: A query string used to restrict the returned virtual machines.
// `Max`:: The maximum number of results to return.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `AllContent`:: Indicates if all the attributes of the virtual machines should be included in the response.
// By default the following attributes are excluded:
// - `console`
// - `initialization.configuration.data` - The OVF document describing the virtual machine.
// - `rng_source`
// - `soundcard`
// - `virtio_scsi`
// For example, to retrieve the complete representation of the virtual machines send a request like this:
// ....
// GET /ovirt-engine/api/vms?all_content=true
// ....
// NOTE: The reason for not including these attributes is performance: they are seldom used and they require
// additional queries to the database. So try to use the this parameter only when it is really needed.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmsService) List(
	allContent bool,
	caseSensitive bool,
	filter bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["all_content"] = fmt.Sprintf("%v", allContent)
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmsVar Vms
	xml.Unmarshal([]byte(ovResp.Body), &vmsVar)
	return vmsVar.Vms, nil
}

//
//
func (op *VmsService) VmService(id string) *VmService {
	return NewVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *VmsService) String() string {
	return fmt.Sprintf("VmsService:%s", op.Path)
}

//
//
type StorageDomainTemplateService struct {
	BaseService
}

func NewStorageDomainTemplateService(connection *Connection, path string) *StorageDomainTemplateService {
	var result StorageDomainTemplateService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainTemplateServiceGetRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
}

func (p *StorageDomainTemplateServiceGetRequest) Header(key, value string) *StorageDomainTemplateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceGetRequest) Query(key, value string) *StorageDomainTemplateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceGetRequest) Send() (*StorageDomainTemplateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplateService.Connection.URL(), p.storageDomainTemplateService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainTemplateService.Connection.username, p.storageDomainTemplateService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainTemplateServiceGetResponse StorageDomainTemplateServiceGetResponse
	var templateVar Template
	xml.Unmarshal(respBodyBytes, &templateVar)
	storageDomainTemplateServiceGetResponse.template = &templateVar
	return &storageDomainTemplateServiceGetResponse, nil
}

type StorageDomainTemplateServiceGetResponse struct {
	template *Template
}

func (p *StorageDomainTemplateServiceGetResponse) Template() *Template {
	return p.template
}

//
//
func (op *StorageDomainTemplateService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Template,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var templateVar Template
	xml.Unmarshal([]byte(ovResp.Body), &templateVar)
	return &templateVar, nil
}

type StorageDomainTemplateServiceImportRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	storageDomain                *StorageDomain
	template                     *Template
	vm                           *Vm
}

func (p *StorageDomainTemplateServiceImportRequest) Header(key, value string) *StorageDomainTemplateServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Query(key, value string) *StorageDomainTemplateServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Async(async bool) *StorageDomainTemplateServiceImportRequest {
	p.async = &async
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Clone(clone bool) *StorageDomainTemplateServiceImportRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Cluster(cluster *Cluster) *StorageDomainTemplateServiceImportRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Exclusive(exclusive bool) *StorageDomainTemplateServiceImportRequest {
	p.exclusive = &exclusive
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainTemplateServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Template(template *Template) *StorageDomainTemplateServiceImportRequest {
	p.template = template
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Vm(vm *Vm) *StorageDomainTemplateServiceImportRequest {
	p.vm = vm
	return p
}
func (p *StorageDomainTemplateServiceImportRequest) Send() (*StorageDomainTemplateServiceImportResponse, error) {
}

type StorageDomainTemplateServiceImportResponse struct {
}

//
// Action to import a template from an export storage domain.
// For example, to import the template `456` from the storage domain `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/templates/456/import
// ----
// With the following request body:
// [source, xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// This method supports the following parameters:
// `Clone`:: Use the optional `clone` parameter to generate new UUIDs for the imported template and its entities.
// The user might want to import a template with the `clone` parameter set to `false` when importing a template
// from an export domain, with templates that was exported by a different {product-name} environment.
// `Async`:: Indicates if the import should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainTemplateService) Import(
	async bool,
	clone bool,
	cluster *Cluster,
	exclusive bool,
	storageDomain *StorageDomain,
	template *Template,
	vm *Vm,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Clone:         &clone,
		Cluster:       cluster,
		Exclusive:     &exclusive,
		StorageDomain: storageDomain,
		Template:      template,
		Vm:            vm,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "import", headers, query, wait)
	return err
}

type StorageDomainTemplateServiceRegisterRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	allowPartialImport           *bool
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	template                     *Template
}

func (p *StorageDomainTemplateServiceRegisterRequest) Header(key, value string) *StorageDomainTemplateServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Query(key, value string) *StorageDomainTemplateServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *StorageDomainTemplateServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Async(async bool) *StorageDomainTemplateServiceRegisterRequest {
	p.async = &async
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Clone(clone bool) *StorageDomainTemplateServiceRegisterRequest {
	p.clone = &clone
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Cluster(cluster *Cluster) *StorageDomainTemplateServiceRegisterRequest {
	p.cluster = cluster
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Exclusive(exclusive bool) *StorageDomainTemplateServiceRegisterRequest {
	p.exclusive = &exclusive
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Template(template *Template) *StorageDomainTemplateServiceRegisterRequest {
	p.template = template
	return p
}
func (p *StorageDomainTemplateServiceRegisterRequest) Send() (*StorageDomainTemplateServiceRegisterResponse, error) {
}

type StorageDomainTemplateServiceRegisterResponse struct {
}

//
// This method supports the following parameters:
// `AllowPartialImport`:: Indicates whether a template is allowed to be registered with only some of its disks.
// If this flag is `true`, the engine will not fail in the validation process if an image is not found, but
// instead it will allow the template to be registered without the missing disks. This is mainly used during
// registration of a template when some of the storage domains are not available. The default value is `false`.
// `Async`:: Indicates if the registration should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainTemplateService) Register(
	allowPartialImport bool,
	async bool,
	clone bool,
	cluster *Cluster,
	exclusive bool,
	template *Template,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		AllowPartialImport: &allowPartialImport,
		Async:              &async,
		Clone:              &clone,
		Cluster:            cluster,
		Exclusive:          &exclusive,
		Template:           template,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "register", headers, query, wait)
	return err
}

type StorageDomainTemplateServiceRemoveRequest struct {
	storageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *StorageDomainTemplateServiceRemoveRequest) Header(key, value string) *StorageDomainTemplateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRemoveRequest) Query(key, value string) *StorageDomainTemplateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRemoveRequest) Async(async bool) *StorageDomainTemplateServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainTemplateServiceRemoveRequest) Send() (*StorageDomainTemplateServiceRemoveResponse, error) {
}

type StorageDomainTemplateServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainTemplateService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
//
func (op *StorageDomainTemplateService) DisksService() *StorageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainTemplateService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainTemplateService) String() string {
	return fmt.Sprintf("StorageDomainTemplateService:%s", op.Path)
}

//
// Provides read-write access to virtual machines pools.
//
type VmPoolsService struct {
	BaseService
}

func NewVmPoolsService(connection *Connection, path string) *VmPoolsService {
	var result VmPoolsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmPoolsServiceAddRequest struct {
	vmPoolsService *VmPoolsService
	header         map[string]string
	query          map[string]string
	pool           *VmPool
}

func (p *VmPoolsServiceAddRequest) Header(key, value string) *VmPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolsServiceAddRequest) Query(key, value string) *VmPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolsServiceAddRequest) Pool(pool *VmPool) *VmPoolsServiceAddRequest {
	p.pool = pool
	return p
}
func (p *VmPoolsServiceAddRequest) Send() (*VmPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.Connection.URL(), p.vmPoolsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.pool)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolsService.Connection.username, p.vmPoolsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmPoolsServiceAddResponse VmPoolsServiceAddResponse
	var poolVar VmPool
	xml.Unmarshal(respBodyBytes, &poolVar)
	vmPoolsServiceAddResponse.pool = &poolVar
	return &vmPoolsServiceAddResponse, nil
}

type VmPoolsServiceAddResponse struct {
	pool *VmPool
}

func (p *VmPoolsServiceAddResponse) Pool() *VmPool {
	return p.pool
}

//
// Creates a new virtual machine pool.
// A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
// `id` or `name` nested attributes:
// [source]
// ----
// POST /ovirt-engine/api/vmpools
// ----
// With the following body:
// [source,xml]
// ----
// <vmpool>
//   <name>mypool</name>
//   <cluster id="123"/>
//   <template id="456"/>
// </vmpool>
// ----
// This method supports the following parameters:
// `Pool`:: Pool to add.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmPoolsService) Add(
	pool *VmPool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VmPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(pool, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolVar VmPool
	xml.Unmarshal([]byte(ovResp.Body), &poolVar)
	return &poolVar, nil
}

type VmPoolsServiceListRequest struct {
	vmPoolsService *VmPoolsService
	header         map[string]string
	query          map[string]string
	caseSensitive  *bool
	filter         *bool
	max            *int64
	search         *string
}

func (p *VmPoolsServiceListRequest) Header(key, value string) *VmPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolsServiceListRequest) Query(key, value string) *VmPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolsServiceListRequest) CaseSensitive(caseSensitive bool) *VmPoolsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *VmPoolsServiceListRequest) Filter(filter bool) *VmPoolsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *VmPoolsServiceListRequest) Max(max int64) *VmPoolsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmPoolsServiceListRequest) Search(search string) *VmPoolsServiceListRequest {
	p.search = &search
	return p
}
func (p *VmPoolsServiceListRequest) Send() (*VmPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.Connection.URL(), p.vmPoolsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmPoolsService.Connection.username, p.vmPoolsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmPoolsServiceListResponse VmPoolsServiceListResponse
	var poolsVar VmPools
	xml.Unmarshal(respBodyBytes, &poolsVar)
	vmPoolsServiceListResponse.pools = poolsVar.VmPools
	return &vmPoolsServiceListResponse, nil
}

type VmPoolsServiceListResponse struct {
	pools []VmPool
}

func (p *VmPoolsServiceListResponse) Pools() []VmPool {
	return p.pools
}

//
// Get a list of available virtual machines pools.
// [source]
// ----
// GET /ovirt-engine/api/vmpools
// ----
// You will receive the following response:
// [source,xml]
// ----
// <vm_pools>
//   <vm_pool id="123">
//     ...
//   </vm_pool>
//   ...
// </vm_pools>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of pools to return. If this value is not specified, all of the pools are returned.
// `Search`:: A query string used to restrict the returned pools.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmPoolsService) List(
	caseSensitive bool,
	filter bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]VmPool,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var poolsVar VmPools
	xml.Unmarshal([]byte(ovResp.Body), &poolsVar)
	return poolsVar.VmPools, nil
}

//
// Reference to the service that manages a specific virtual machine pool.
//
func (op *VmPoolsService) PoolService(id string) *VmPoolService {
	return NewVmPoolService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmPoolsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PoolService(path)), nil
	}
	return op.PoolService(path[:index]).Service(path[index+1:])
}

func (op *VmPoolsService) String() string {
	return fmt.Sprintf("VmPoolsService:%s", op.Path)
}

//
//
type AssignedDiskProfilesService struct {
	BaseService
}

func NewAssignedDiskProfilesService(connection *Connection, path string) *AssignedDiskProfilesService {
	var result AssignedDiskProfilesService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedDiskProfilesServiceAddRequest struct {
	assignedDiskProfilesService *AssignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *DiskProfile
}

func (p *AssignedDiskProfilesServiceAddRequest) Header(key, value string) *AssignedDiskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceAddRequest) Query(key, value string) *AssignedDiskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceAddRequest) Profile(profile *DiskProfile) *AssignedDiskProfilesServiceAddRequest {
	p.profile = profile
	return p
}
func (p *AssignedDiskProfilesServiceAddRequest) Send() (*AssignedDiskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.Connection.URL(), p.assignedDiskProfilesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.profile)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedDiskProfilesService.Connection.username, p.assignedDiskProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedDiskProfilesServiceAddResponse AssignedDiskProfilesServiceAddResponse
	var profileVar DiskProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	assignedDiskProfilesServiceAddResponse.profile = &profileVar
	return &assignedDiskProfilesServiceAddResponse, nil
}

type AssignedDiskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *AssignedDiskProfilesServiceAddResponse) Profile() *DiskProfile {
	return p.profile
}

//
//
func (op *AssignedDiskProfilesService) Add(
	profile *DiskProfile,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar DiskProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type AssignedDiskProfilesServiceListRequest struct {
	assignedDiskProfilesService *AssignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	max                         *int64
}

func (p *AssignedDiskProfilesServiceListRequest) Header(key, value string) *AssignedDiskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Query(key, value string) *AssignedDiskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Max(max int64) *AssignedDiskProfilesServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedDiskProfilesServiceListRequest) Send() (*AssignedDiskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.Connection.URL(), p.assignedDiskProfilesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedDiskProfilesService.Connection.username, p.assignedDiskProfilesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedDiskProfilesServiceListResponse AssignedDiskProfilesServiceListResponse
	var profilesVar DiskProfiles
	xml.Unmarshal(respBodyBytes, &profilesVar)
	assignedDiskProfilesServiceListResponse.profiles = profilesVar.DiskProfiles
	return &assignedDiskProfilesServiceListResponse, nil
}

type AssignedDiskProfilesServiceListResponse struct {
	profiles []DiskProfile
}

func (p *AssignedDiskProfilesServiceListResponse) Profiles() []DiskProfile {
	return p.profiles
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of profiles to return. If not specified all the profiles are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedDiskProfilesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]DiskProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profilesVar DiskProfiles
	xml.Unmarshal([]byte(ovResp.Body), &profilesVar)
	return profilesVar.DiskProfiles, nil
}

//
//
func (op *AssignedDiskProfilesService) ProfileService(id string) *AssignedDiskProfileService {
	return NewAssignedDiskProfileService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedDiskProfilesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProfileService(path)), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedDiskProfilesService) String() string {
	return fmt.Sprintf("AssignedDiskProfilesService:%s", op.Path)
}

//
// A service to manage a step.
//
type StepService struct {
	BaseService
}

func NewStepService(connection *Connection, path string) *StepService {
	var result StepService
	result.Connection = connection
	result.Path = path
	return &result
}

type StepServiceEndRequest struct {
	stepService *StepService
	header      map[string]string
	query       map[string]string
	async       *bool
	force       *bool
	succeeded   *bool
}

func (p *StepServiceEndRequest) Header(key, value string) *StepServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepServiceEndRequest) Query(key, value string) *StepServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepServiceEndRequest) Async(async bool) *StepServiceEndRequest {
	p.async = &async
	return p
}
func (p *StepServiceEndRequest) Force(force bool) *StepServiceEndRequest {
	p.force = &force
	return p
}
func (p *StepServiceEndRequest) Succeeded(succeeded bool) *StepServiceEndRequest {
	p.succeeded = &succeeded
	return p
}
func (p *StepServiceEndRequest) Send() (*StepServiceEndResponse, error) {
}

type StepServiceEndResponse struct {
}

//
// Marks an external step execution as ended.
// For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps/456/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <succeeded>true</succeeded>
// </action>
// ----
// This method supports the following parameters:
// `Force`:: Indicates if the step should be forcibly terminated.
// `Succeeded`:: Indicates if the step should be marked as successfully finished or as failed.
// This parameter is optional, and the default value is `true`.
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StepService) End(
	async bool,
	force bool,
	succeeded bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:     &async,
		Force:     &force,
		Succeeded: &succeeded,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "end", headers, query, wait)
	return err
}

type StepServiceGetRequest struct {
	stepService *StepService
	header      map[string]string
	query       map[string]string
}

func (p *StepServiceGetRequest) Header(key, value string) *StepServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepServiceGetRequest) Query(key, value string) *StepServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepServiceGetRequest) Send() (*StepServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepService.Connection.URL(), p.stepService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.stepService.Connection.username, p.stepService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.stepService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var stepServiceGetResponse StepServiceGetResponse
	var stepVar Step
	xml.Unmarshal(respBodyBytes, &stepVar)
	stepServiceGetResponse.step = &stepVar
	return &stepServiceGetResponse, nil
}

type StepServiceGetResponse struct {
	step *Step
}

func (p *StepServiceGetResponse) Step() *Step {
	return p.step
}

//
// Retrieves a step.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123/steps/456
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
//   <external>false</external>
//   <number>0</number>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>finished</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
func (op *StepService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Step,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var stepVar Step
	xml.Unmarshal([]byte(ovResp.Body), &stepVar)
	return &stepVar, nil
}

//
//
func (op *StepService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StepService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StepService) String() string {
	return fmt.Sprintf("StepService:%s", op.Path)
}

//
// Manages the collection of disks available inside an storage domain that is attached to a data center.
//
type AttachedStorageDomainDisksService struct {
	BaseService
}

func NewAttachedStorageDomainDisksService(connection *Connection, path string) *AttachedStorageDomainDisksService {
	var result AttachedStorageDomainDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainDisksServiceAddRequest struct {
	attachedStorageDomainDisksService *AttachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	disk                              *Disk
	unregistered                      *bool
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Header(key, value string) *AttachedStorageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Query(key, value string) *AttachedStorageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Disk(disk *Disk) *AttachedStorageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *AttachedStorageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *AttachedStorageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}
func (p *AttachedStorageDomainDisksServiceAddRequest) Send() (*AttachedStorageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.Connection.URL(), p.attachedStorageDomainDisksService.Path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDisksService.Connection.username, p.attachedStorageDomainDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var attachedStorageDomainDisksServiceAddResponse AttachedStorageDomainDisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	attachedStorageDomainDisksServiceAddResponse.disk = &diskVar
	return &attachedStorageDomainDisksServiceAddResponse, nil
}

type AttachedStorageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDisksServiceAddResponse) Disk() *Disk {
	return p.disk
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
// This method supports the following parameters:
// `Disk`:: The disk to add or register.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainDisksService) Add(
	disk *Disk,
	unregistered bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["unregistered"] = fmt.Sprintf("%v", unregistered)

	// Send the request and get the response
	ovResp, err := op.internalAdd(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type AttachedStorageDomainDisksServiceListRequest struct {
	attachedStorageDomainDisksService *AttachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	max                               *int64
}

func (p *AttachedStorageDomainDisksServiceListRequest) Header(key, value string) *AttachedStorageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Query(key, value string) *AttachedStorageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Max(max int64) *AttachedStorageDomainDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *AttachedStorageDomainDisksServiceListRequest) Send() (*AttachedStorageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.Connection.URL(), p.attachedStorageDomainDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDisksService.Connection.username, p.attachedStorageDomainDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var attachedStorageDomainDisksServiceListResponse AttachedStorageDomainDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	attachedStorageDomainDisksServiceListResponse.disks = disksVar.Disks
	return &attachedStorageDomainDisksServiceListResponse, nil
}

type AttachedStorageDomainDisksServiceListResponse struct {
	disks []Disk
}

func (p *AttachedStorageDomainDisksServiceListResponse) Disks() []Disk {
	return p.disks
}

//
// Retrieve the list of disks that are available in the storage domain.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of disks to return. If not specified all the disks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainDisksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var disksVar Disks
	xml.Unmarshal([]byte(ovResp.Body), &disksVar)
	return disksVar.Disks, nil
}

//
// Reference to the service that manages a specific disk.
//
func (op *AttachedStorageDomainDisksService) DiskService(id string) *AttachedStorageDomainDiskService {
	return NewAttachedStorageDomainDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *AttachedStorageDomainDisksService) String() string {
	return fmt.Sprintf("AttachedStorageDomainDisksService:%s", op.Path)
}

//
// Manages a network filter.
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026b">
//   <name>example-network-filter-b</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
// Please note that version is referring to the minimal support version for the specific filter.
//
type NetworkFilterService struct {
	BaseService
}

func NewNetworkFilterService(connection *Connection, path string) *NetworkFilterService {
	var result NetworkFilterService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFilterServiceGetRequest struct {
	networkFilterService *NetworkFilterService
	header               map[string]string
	query                map[string]string
}

func (p *NetworkFilterServiceGetRequest) Header(key, value string) *NetworkFilterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterServiceGetRequest) Query(key, value string) *NetworkFilterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterServiceGetRequest) Send() (*NetworkFilterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterService.Connection.URL(), p.networkFilterService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterService.Connection.username, p.networkFilterService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkFilterServiceGetResponse NetworkFilterServiceGetResponse
	var networkFilterVar NetworkFilter
	xml.Unmarshal(respBodyBytes, &networkFilterVar)
	networkFilterServiceGetResponse.networkFilter = &networkFilterVar
	return &networkFilterServiceGetResponse, nil
}

type NetworkFilterServiceGetResponse struct {
	networkFilter *NetworkFilter
}

func (p *NetworkFilterServiceGetResponse) NetworkFilter() *NetworkFilter {
	return p.networkFilter
}

//
// Retrieves a representation of the network filter.
//
func (op *NetworkFilterService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkFilter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkFilterVar NetworkFilter
	xml.Unmarshal([]byte(ovResp.Body), &networkFilterVar)
	return &networkFilterVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFilterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkFilterService) String() string {
	return fmt.Sprintf("NetworkFilterService:%s", op.Path)
}

//
//
type VmDisksService struct {
	BaseService
}

func NewVmDisksService(connection *Connection, path string) *VmDisksService {
	var result VmDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmDisksServiceAddRequest struct {
	vmDisksService *VmDisksService
	header         map[string]string
	query          map[string]string
	disk           *Disk
}

func (p *VmDisksServiceAddRequest) Header(key, value string) *VmDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDisksServiceAddRequest) Query(key, value string) *VmDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDisksServiceAddRequest) Disk(disk *Disk) *VmDisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *VmDisksServiceAddRequest) Send() (*VmDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.Connection.URL(), p.vmDisksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDisksService.Connection.username, p.vmDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmDisksServiceAddResponse VmDisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	vmDisksServiceAddResponse.disk = &diskVar
	return &vmDisksServiceAddResponse, nil
}

type VmDisksServiceAddResponse struct {
	disk *Disk
}

func (p *VmDisksServiceAddResponse) Disk() *Disk {
	return p.disk
}

//
//
func (op *VmDisksService) Add(
	disk *Disk,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type VmDisksServiceListRequest struct {
	vmDisksService *VmDisksService
	header         map[string]string
	query          map[string]string
	max            *int64
}

func (p *VmDisksServiceListRequest) Header(key, value string) *VmDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDisksServiceListRequest) Query(key, value string) *VmDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDisksServiceListRequest) Max(max int64) *VmDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *VmDisksServiceListRequest) Send() (*VmDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.Connection.URL(), p.vmDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmDisksService.Connection.username, p.vmDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmDisksServiceListResponse VmDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	vmDisksServiceListResponse.disks = disksVar.Disks
	return &vmDisksServiceListResponse, nil
}

type VmDisksServiceListResponse struct {
	disks []Disk
}

func (p *VmDisksServiceListResponse) Disks() []Disk {
	return p.disks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of disks to return. If not specified all the disks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmDisksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var disksVar Disks
	xml.Unmarshal([]byte(ovResp.Body), &disksVar)
	return disksVar.Disks, nil
}

//
//
func (op *VmDisksService) DiskService(id string) *VmDiskService {
	return NewVmDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *VmDisksService) String() string {
	return fmt.Sprintf("VmDisksService:%s", op.Path)
}

//
// This service manages the set of disks attached to a virtual machine. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>, containing the bootable flag, the disk interface and the reference to
// the disk.
//
type DiskAttachmentsService struct {
	BaseService
}

func NewDiskAttachmentsService(connection *Connection, path string) *DiskAttachmentsService {
	var result DiskAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskAttachmentsServiceAddRequest struct {
	diskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *DiskAttachmentsServiceAddRequest) Header(key, value string) *DiskAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddRequest) Query(key, value string) *DiskAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddRequest) Attachment(attachment *DiskAttachment) *DiskAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}
func (p *DiskAttachmentsServiceAddRequest) Send() (*DiskAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.Connection.URL(), p.diskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.attachment)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentsService.Connection.username, p.diskAttachmentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskAttachmentsServiceAddResponse DiskAttachmentsServiceAddResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	diskAttachmentsServiceAddResponse.attachment = &attachmentVar
	return &diskAttachmentsServiceAddResponse, nil
}

type DiskAttachmentsServiceAddResponse struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentsServiceAddResponse) Attachment() *DiskAttachment {
	return p.attachment
}

//
// Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
// the disk already exists:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk id="123"/>
// </disk_attachment>
// ----
// Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
// In this case the disk will be created and then attached to the virtual machine.
// In both cases, use the following URL for a virtual machine with an id `345`:
// [source]
// ----
// POST /ovirt-engine/api/vms/345/diskattachments
// ----
// IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
// undefined. In some cases the disk will be automatically activated and in other cases it won't. To
// avoid issues it is strongly recommended to always include the `active` attribute with the desired
// value.
//
func (op *DiskAttachmentsService) Add(
	attachment *DiskAttachment,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(attachment, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentVar DiskAttachment
	xml.Unmarshal([]byte(ovResp.Body), &attachmentVar)
	return &attachmentVar, nil
}

type DiskAttachmentsServiceListRequest struct {
	diskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
}

func (p *DiskAttachmentsServiceListRequest) Header(key, value string) *DiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceListRequest) Query(key, value string) *DiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceListRequest) Send() (*DiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.Connection.URL(), p.diskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskAttachmentsService.Connection.username, p.diskAttachmentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskAttachmentsServiceListResponse DiskAttachmentsServiceListResponse
	var attachmentsVar DiskAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	diskAttachmentsServiceListResponse.attachments = attachmentsVar.DiskAttachments
	return &diskAttachmentsServiceListResponse, nil
}

type DiskAttachmentsServiceListResponse struct {
	attachments []DiskAttachment
}

func (p *DiskAttachmentsServiceListResponse) Attachments() []DiskAttachment {
	return p.attachments
}

//
// List the disk that are attached to the virtual machine.
//
func (op *DiskAttachmentsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentsVar DiskAttachments
	xml.Unmarshal([]byte(ovResp.Body), &attachmentsVar)
	return attachmentsVar.DiskAttachments, nil
}

//
// Reference to the service that manages a specific attachment.
//
func (op *DiskAttachmentsService) AttachmentService(id string) *DiskAttachmentService {
	return NewDiskAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *DiskAttachmentsService) String() string {
	return fmt.Sprintf("DiskAttachmentsService:%s", op.Path)
}

//
// Manages a single disk available in a storage domain.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type StorageDomainDiskService struct {
	BaseService
}

func NewStorageDomainDiskService(connection *Connection, path string) *StorageDomainDiskService {
	var result StorageDomainDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainDiskServiceCopyRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceCopyRequest) Header(key, value string) *StorageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) Query(key, value string) *StorageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) Disk(disk *Disk) *StorageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}
func (p *StorageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainDiskServiceCopyRequest) Send() (*StorageDomainDiskServiceCopyResponse, error) {
}

type StorageDomainDiskServiceCopyResponse struct {
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
// This method supports the following parameters:
// `Disk`:: Description of the resulting disk.
// `StorageDomain`:: The storage domain where the new disk will be created.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainDiskService) Copy(
	disk *Disk,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Disk:          disk,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "copy", headers, query, wait)
	return err
}

type StorageDomainDiskServiceExportRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceExportRequest) Header(key, value string) *StorageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceExportRequest) Query(key, value string) *StorageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainDiskServiceExportRequest) Send() (*StorageDomainDiskServiceExportResponse, error) {
}

type StorageDomainDiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
// This method supports the following parameters:
// `StorageDomain`:: The export storage domain where the disk should be exported to.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainDiskService) Export(
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "export", headers, query, wait)
	return err
}

type StorageDomainDiskServiceGetRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceGetRequest) Header(key, value string) *StorageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceGetRequest) Query(key, value string) *StorageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceGetRequest) Send() (*StorageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.Connection.URL(), p.storageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDiskService.Connection.username, p.storageDomainDiskService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainDiskServiceGetResponse StorageDomainDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	storageDomainDiskServiceGetResponse.disk = &diskVar
	return &storageDomainDiskServiceGetResponse, nil
}

type StorageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *StorageDomainDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (op *StorageDomainDiskService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type StorageDomainDiskServiceMoveRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	filter                   *bool
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceMoveRequest) Header(key, value string) *StorageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Query(key, value string) *StorageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Async(async bool) *StorageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *StorageDomainDiskServiceMoveRequest) Filter(filter bool) *StorageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainDiskServiceMoveRequest) Send() (*StorageDomainDiskServiceMoveResponse, error) {
}

type StorageDomainDiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
// This method supports the following parameters:
// `StorageDomain`:: The storage domain where the disk will be moved to.
// `Async`:: Indicates if the move should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainDiskService) Move(
	async bool,
	filter bool,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Filter:        &filter,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "move", headers, query, wait)
	return err
}

type StorageDomainDiskServiceRemoveRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceRemoveRequest) Header(key, value string) *StorageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceRemoveRequest) Query(key, value string) *StorageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceRemoveRequest) Send() (*StorageDomainDiskServiceRemoveResponse, error) {
}

type StorageDomainDiskServiceRemoveResponse struct {
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (op *StorageDomainDiskService) Remove(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type StorageDomainDiskServiceSparsifyRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceSparsifyRequest) Header(key, value string) *StorageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceSparsifyRequest) Query(key, value string) *StorageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceSparsifyRequest) Send() (*StorageDomainDiskServiceSparsifyResponse, error) {
}

type StorageDomainDiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (op *StorageDomainDiskService) Sparsify(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "sparsify", headers, query, wait)
	return err
}

type StorageDomainDiskServiceUpdateRequest struct {
	storageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
}

func (p *StorageDomainDiskServiceUpdateRequest) Header(key, value string) *StorageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceUpdateRequest) Query(key, value string) *StorageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *StorageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *StorageDomainDiskServiceUpdateRequest) Send() (*StorageDomainDiskServiceUpdateResponse, error) {
}

type StorageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *StorageDomainDiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
// This method supports the following parameters:
// `Disk`:: The update to apply to the disk.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainDiskService) Update(
	disk *Disk,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request
	ovResp, err := op.internalUpdate(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *StorageDomainDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *StorageDomainDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainDiskService) String() string {
	return fmt.Sprintf("StorageDomainDiskService:%s", op.Path)
}

//
//
type HostHooksService struct {
	BaseService
}

func NewHostHooksService(connection *Connection, path string) *HostHooksService {
	var result HostHooksService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostHooksServiceListRequest struct {
	hostHooksService *HostHooksService
	header           map[string]string
	query            map[string]string
	max              *int64
}

func (p *HostHooksServiceListRequest) Header(key, value string) *HostHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostHooksServiceListRequest) Query(key, value string) *HostHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostHooksServiceListRequest) Max(max int64) *HostHooksServiceListRequest {
	p.max = &max
	return p
}
func (p *HostHooksServiceListRequest) Send() (*HostHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostHooksService.Connection.URL(), p.hostHooksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostHooksService.Connection.username, p.hostHooksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostHooksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostHooksServiceListResponse HostHooksServiceListResponse
	var hooksVar Hooks
	xml.Unmarshal(respBodyBytes, &hooksVar)
	hostHooksServiceListResponse.hooks = hooksVar.Hooks
	return &hostHooksServiceListResponse, nil
}

type HostHooksServiceListResponse struct {
	hooks []Hook
}

func (p *HostHooksServiceListResponse) Hooks() []Hook {
	return p.hooks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of hooks to return. If not specified all the hooks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostHooksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Hook,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hooksVar Hooks
	xml.Unmarshal([]byte(ovResp.Body), &hooksVar)
	return hooksVar.Hooks, nil
}

//
//
func (op *HostHooksService) HookService(id string) *HostHookService {
	return NewHostHookService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostHooksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HookService(path)), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *HostHooksService) String() string {
	return fmt.Sprintf("HostHooksService:%s", op.Path)
}

//
//
type StorageDomainsService struct {
	BaseService
}

func NewStorageDomainsService(connection *Connection, path string) *StorageDomainsService {
	var result StorageDomainsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainsServiceAddRequest struct {
	storageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddRequest) Header(key, value string) *StorageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddRequest) Query(key, value string) *StorageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *StorageDomainsServiceAddRequest) Send() (*StorageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.Connection.URL(), p.storageDomainsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.storageDomain)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainsService.Connection.username, p.storageDomainsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainsServiceAddResponse StorageDomainsServiceAddResponse
	var storageDomainVar StorageDomain
	xml.Unmarshal(respBodyBytes, &storageDomainVar)
	storageDomainsServiceAddResponse.storageDomain = &storageDomainVar
	return &storageDomainsServiceAddResponse, nil
}

type StorageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddResponse) StorageDomain() *StorageDomain {
	return p.storageDomain
}

//
// Adds a new storage domain.
// Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host` and `storage`
// attributes. Identify the `host` attribute with the `id` or `name` attributes. In oVirt 3.6 and later you can
// enable the wipe after delete option by default on the storage domain. To configure this, specify
// `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
// not change the wipe after delete property of disks that already exist.
// To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address` and `storage.path`
// and by using a host with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>mydata</name>
//   <type>data</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/exports/mydata</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new NFS ISO storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myisos</name>
//   <type>iso</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/export/myisos</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new iSCSI storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myiscsi</name>
//   <type>data</type>
//   <storage>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
//       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
//     </logical_units>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
//
func (op *StorageDomainsService) Add(
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageDomain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(storageDomain, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainVar StorageDomain
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainVar)
	return &storageDomainVar, nil
}

type StorageDomainsServiceListRequest struct {
	storageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	filter                *bool
	max                   *int64
	search                *string
}

func (p *StorageDomainsServiceListRequest) Header(key, value string) *StorageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceListRequest) Query(key, value string) *StorageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceListRequest) CaseSensitive(caseSensitive bool) *StorageDomainsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *StorageDomainsServiceListRequest) Filter(filter bool) *StorageDomainsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *StorageDomainsServiceListRequest) Max(max int64) *StorageDomainsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainsServiceListRequest) Search(search string) *StorageDomainsServiceListRequest {
	p.search = &search
	return p
}
func (p *StorageDomainsServiceListRequest) Send() (*StorageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.Connection.URL(), p.storageDomainsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainsService.Connection.username, p.storageDomainsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainsServiceListResponse StorageDomainsServiceListResponse
	var storageDomainsVar StorageDomains
	xml.Unmarshal(respBodyBytes, &storageDomainsVar)
	storageDomainsServiceListResponse.storageDomains = storageDomainsVar.StorageDomains
	return &storageDomainsServiceListResponse, nil
}

type StorageDomainsServiceListResponse struct {
	storageDomains []StorageDomain
}

func (p *StorageDomainsServiceListResponse) StorageDomains() []StorageDomain {
	return p.storageDomains
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of storage domains to return. If not specified all the storage domains are returned.
// `Search`:: A query string used to restrict the returned storage domains.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainsService) List(
	caseSensitive bool,
	filter bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]StorageDomain,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageDomainsVar StorageDomains
	xml.Unmarshal([]byte(ovResp.Body), &storageDomainsVar)
	return storageDomainsVar.StorageDomains, nil
}

//
//
func (op *StorageDomainsService) StorageDomainService(id string) *StorageDomainService {
	return NewStorageDomainService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageDomainService(path)), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainsService) String() string {
	return fmt.Sprintf("StorageDomainsService:%s", op.Path)
}

//
//
type NetworkLabelService struct {
	BaseService
}

func NewNetworkLabelService(connection *Connection, path string) *NetworkLabelService {
	var result NetworkLabelService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkLabelServiceGetRequest struct {
	networkLabelService *NetworkLabelService
	header              map[string]string
	query               map[string]string
}

func (p *NetworkLabelServiceGetRequest) Header(key, value string) *NetworkLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelServiceGetRequest) Query(key, value string) *NetworkLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelServiceGetRequest) Send() (*NetworkLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelService.Connection.URL(), p.networkLabelService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkLabelService.Connection.username, p.networkLabelService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkLabelService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkLabelServiceGetResponse NetworkLabelServiceGetResponse
	var labelVar NetworkLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	networkLabelServiceGetResponse.label = &labelVar
	return &networkLabelServiceGetResponse, nil
}

type NetworkLabelServiceGetResponse struct {
	label *NetworkLabel
}

func (p *NetworkLabelServiceGetResponse) Label() *NetworkLabel {
	return p.label
}

//
//
func (op *NetworkLabelService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar NetworkLabel
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return &labelVar, nil
}

type NetworkLabelServiceRemoveRequest struct {
	networkLabelService *NetworkLabelService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *NetworkLabelServiceRemoveRequest) Header(key, value string) *NetworkLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelServiceRemoveRequest) Query(key, value string) *NetworkLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelServiceRemoveRequest) Async(async bool) *NetworkLabelServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *NetworkLabelServiceRemoveRequest) Send() (*NetworkLabelServiceRemoveResponse, error) {
}

type NetworkLabelServiceRemoveResponse struct {
}

//
// Removes a label from a logical network.
// For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123/labels/exemplary
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworkLabelService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkLabelService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkLabelService) String() string {
	return fmt.Sprintf("NetworkLabelService:%s", op.Path)
}

//
//
type InstanceTypesService struct {
	BaseService
}

func NewInstanceTypesService(connection *Connection, path string) *InstanceTypesService {
	var result InstanceTypesService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypesServiceAddRequest struct {
	instanceTypesService *InstanceTypesService
	header               map[string]string
	query                map[string]string
	instanceType         *InstanceType
}

func (p *InstanceTypesServiceAddRequest) Header(key, value string) *InstanceTypesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypesServiceAddRequest) Query(key, value string) *InstanceTypesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypesServiceAddRequest) InstanceType(instanceType *InstanceType) *InstanceTypesServiceAddRequest {
	p.instanceType = instanceType
	return p
}
func (p *InstanceTypesServiceAddRequest) Send() (*InstanceTypesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.Connection.URL(), p.instanceTypesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.instanceType)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypesService.Connection.username, p.instanceTypesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypesServiceAddResponse InstanceTypesServiceAddResponse
	var instanceTypeVar InstanceType
	xml.Unmarshal(respBodyBytes, &instanceTypeVar)
	instanceTypesServiceAddResponse.instanceType = &instanceTypeVar
	return &instanceTypesServiceAddResponse, nil
}

type InstanceTypesServiceAddResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypesServiceAddResponse) InstanceType() *InstanceType {
	return p.instanceType
}

//
// Creates a new instance type.
// This requires only a name attribute and can include all hardware configurations of the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/instancetypes
// ----
// With a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
// </template>
// ----
// Creating an instance type with all hardware configurations with a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
//   <console>
//     <enabled>true</enabled>
//   </console>
//   <cpu>
//     <topology>
//       <cores>2</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
//   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
//   <custom_emulated_machine>q35</custom_emulated_machine>
//   <display>
//     <monitors>1</monitors>
//     <single_qxl_pci>true</single_qxl_pci>
//     <smartcard_enabled>true</smartcard_enabled>
//     <type>spice</type>
//   </display>
//   <high_availability>
//     <enabled>true</enabled>
//     <priority>1</priority>
//   </high_availability>
//   <io>
//     <threads>2</threads>
//   </io>
//   <memory>4294967296</memory>
//   <memory_policy>
//     <ballooning>true</ballooning>
//     <guaranteed>268435456</guaranteed>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <compressed>inherit</compressed>
//     <policy id="00000000-0000-0000-0000-000000000000"/>
//   </migration>
//   <migration_downtime>2</migration_downtime>
//   <os>
//     <boot>
//       <devices>
//         <device>hd</device>
//       </devices>
//     </boot>
//   </os>
//   <rng_device>
//     <rate>
//       <bytes>200</bytes>
//       <period>2</period>
//     </rate>
//     <source>urandom</source>
//   </rng_device>
//   <soundcard_enabled>true</soundcard_enabled>
//   <usb>
//     <enabled>true</enabled>
//     <type>native</type>
//   </usb>
//   <virtio_scsi>
//     <enabled>true</enabled>
//   </virtio_scsi>
// </instance_type>
// ----
//
func (op *InstanceTypesService) Add(
	instanceType *InstanceType,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*InstanceType,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(instanceType, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var instanceTypeVar InstanceType
	xml.Unmarshal([]byte(ovResp.Body), &instanceTypeVar)
	return &instanceTypeVar, nil
}

type InstanceTypesServiceListRequest struct {
	instanceTypesService *InstanceTypesService
	header               map[string]string
	query                map[string]string
	caseSensitive        *bool
	max                  *int64
	search               *string
}

func (p *InstanceTypesServiceListRequest) Header(key, value string) *InstanceTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypesServiceListRequest) Query(key, value string) *InstanceTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypesServiceListRequest) CaseSensitive(caseSensitive bool) *InstanceTypesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *InstanceTypesServiceListRequest) Max(max int64) *InstanceTypesServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypesServiceListRequest) Search(search string) *InstanceTypesServiceListRequest {
	p.search = &search
	return p
}
func (p *InstanceTypesServiceListRequest) Send() (*InstanceTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.Connection.URL(), p.instanceTypesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypesService.Connection.username, p.instanceTypesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypesServiceListResponse InstanceTypesServiceListResponse
	var instanceTypeVar InstanceTypes
	xml.Unmarshal(respBodyBytes, &instanceTypeVar)
	instanceTypesServiceListResponse.instanceType = instanceTypeVar.InstanceTypes
	return &instanceTypesServiceListResponse, nil
}

type InstanceTypesServiceListResponse struct {
	instanceType []InstanceType
}

func (p *InstanceTypesServiceListResponse) InstanceType() []InstanceType {
	return p.instanceType
}

//
// Lists all existing instance types in the system.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of instance types to return. If not specified all the instance
// types are returned.
// `Search`:: A query string used to restrict the returned templates.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed
// taking case into account. The default value is `true`, which means that case is taken
// into account. If you want to search ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypesService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]InstanceType,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var instanceTypeVar InstanceTypes
	xml.Unmarshal([]byte(ovResp.Body), &instanceTypeVar)
	return instanceTypeVar.InstanceTypes, nil
}

//
//
func (op *InstanceTypesService) InstanceTypeService(id string) *InstanceTypeService {
	return NewInstanceTypeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.InstanceTypeService(path)), nil
	}
	return op.InstanceTypeService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypesService) String() string {
	return fmt.Sprintf("InstanceTypesService:%s", op.Path)
}

//
//
type StorageDomainServerConnectionsService struct {
	BaseService
}

func NewStorageDomainServerConnectionsService(connection *Connection, path string) *StorageDomainServerConnectionsService {
	var result StorageDomainServerConnectionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainServerConnectionsServiceAddRequest struct {
	storageDomainServerConnectionsService *StorageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	connection                            *StorageConnection
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Header(key, value string) *StorageDomainServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Query(key, value string) *StorageDomainServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *StorageDomainServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}
func (p *StorageDomainServerConnectionsServiceAddRequest) Send() (*StorageDomainServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.Connection.URL(), p.storageDomainServerConnectionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.connection)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainServerConnectionsService.Connection.username, p.storageDomainServerConnectionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainServerConnectionsServiceAddResponse StorageDomainServerConnectionsServiceAddResponse
	var connectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &connectionVar)
	storageDomainServerConnectionsServiceAddResponse.connection = &connectionVar
	return &storageDomainServerConnectionsServiceAddResponse, nil
}

type StorageDomainServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *StorageDomainServerConnectionsServiceAddResponse) Connection() *StorageConnection {
	return p.connection
}

//
//
func (op *StorageDomainServerConnectionsService) Add(
	connection *StorageConnection,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnection,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(connection, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var connectionVar StorageConnection
	xml.Unmarshal([]byte(ovResp.Body), &connectionVar)
	return &connectionVar, nil
}

type StorageDomainServerConnectionsServiceListRequest struct {
	storageDomainServerConnectionsService *StorageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	max                                   *int64
}

func (p *StorageDomainServerConnectionsServiceListRequest) Header(key, value string) *StorageDomainServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Query(key, value string) *StorageDomainServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Max(max int64) *StorageDomainServerConnectionsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainServerConnectionsServiceListRequest) Send() (*StorageDomainServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.Connection.URL(), p.storageDomainServerConnectionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainServerConnectionsService.Connection.username, p.storageDomainServerConnectionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainServerConnectionsServiceListResponse StorageDomainServerConnectionsServiceListResponse
	var connectionsVar StorageConnections
	xml.Unmarshal(respBodyBytes, &connectionsVar)
	storageDomainServerConnectionsServiceListResponse.connections = connectionsVar.StorageConnections
	return &storageDomainServerConnectionsServiceListResponse, nil
}

type StorageDomainServerConnectionsServiceListResponse struct {
	connections []StorageConnection
}

func (p *StorageDomainServerConnectionsServiceListResponse) Connections() []StorageConnection {
	return p.connections
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of connections to return. If not specified all the connections are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainServerConnectionsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]StorageConnection,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var connectionsVar StorageConnections
	xml.Unmarshal([]byte(ovResp.Body), &connectionsVar)
	return connectionsVar.StorageConnections, nil
}

//
//
func (op *StorageDomainServerConnectionsService) ConnectionService(id string) *StorageDomainServerConnectionService {
	return NewStorageDomainServerConnectionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainServerConnectionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConnectionService(path)), nil
	}
	return op.ConnectionService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainServerConnectionsService) String() string {
	return fmt.Sprintf("StorageDomainServerConnectionsService:%s", op.Path)
}

//
//
type InstanceTypeGraphicsConsoleService struct {
	BaseService
}

func NewInstanceTypeGraphicsConsoleService(connection *Connection, path string) *InstanceTypeGraphicsConsoleService {
	var result InstanceTypeGraphicsConsoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeGraphicsConsoleServiceGetRequest struct {
	instanceTypeGraphicsConsoleService *InstanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Header(key, value string) *InstanceTypeGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Query(key, value string) *InstanceTypeGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Send() (*InstanceTypeGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsoleService.Connection.URL(), p.instanceTypeGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeGraphicsConsoleService.Connection.username, p.instanceTypeGraphicsConsoleService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeGraphicsConsoleServiceGetResponse InstanceTypeGraphicsConsoleServiceGetResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	instanceTypeGraphicsConsoleServiceGetResponse.console = &consoleVar
	return &instanceTypeGraphicsConsoleServiceGetResponse, nil
}

type InstanceTypeGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsoleServiceGetResponse) Console() *GraphicsConsole {
	return p.console
}

//
// Gets graphics console configuration of the instance type.
//
func (op *InstanceTypeGraphicsConsoleService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consoleVar GraphicsConsole
	xml.Unmarshal([]byte(ovResp.Body), &consoleVar)
	return &consoleVar, nil
}

type InstanceTypeGraphicsConsoleServiceRemoveRequest struct {
	instanceTypeGraphicsConsoleService *InstanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
	async                              *bool
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Header(key, value string) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Query(key, value string) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Async(async bool) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Send() (*InstanceTypeGraphicsConsoleServiceRemoveResponse, error) {
}

type InstanceTypeGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the instance type.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypeGraphicsConsoleService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeGraphicsConsoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeGraphicsConsoleService) String() string {
	return fmt.Sprintf("InstanceTypeGraphicsConsoleService:%s", op.Path)
}

//
//
type IscsiBondService struct {
	BaseService
}

func NewIscsiBondService(connection *Connection, path string) *IscsiBondService {
	var result IscsiBondService
	result.Connection = connection
	result.Path = path
	return &result
}

type IscsiBondServiceGetRequest struct {
	iscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
}

func (p *IscsiBondServiceGetRequest) Header(key, value string) *IscsiBondServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceGetRequest) Query(key, value string) *IscsiBondServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceGetRequest) Send() (*IscsiBondServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.Connection.URL(), p.iscsiBondService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iscsiBondService.Connection.username, p.iscsiBondService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var iscsiBondServiceGetResponse IscsiBondServiceGetResponse
	var bondVar IscsiBond
	xml.Unmarshal(respBodyBytes, &bondVar)
	iscsiBondServiceGetResponse.bond = &bondVar
	return &iscsiBondServiceGetResponse, nil
}

type IscsiBondServiceGetResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondServiceGetResponse) Bond() *IscsiBond {
	return p.bond
}

//
//
func (op *IscsiBondService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*IscsiBond,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bondVar IscsiBond
	xml.Unmarshal([]byte(ovResp.Body), &bondVar)
	return &bondVar, nil
}

type IscsiBondServiceRemoveRequest struct {
	iscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
}

func (p *IscsiBondServiceRemoveRequest) Header(key, value string) *IscsiBondServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceRemoveRequest) Query(key, value string) *IscsiBondServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceRemoveRequest) Async(async bool) *IscsiBondServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *IscsiBondServiceRemoveRequest) Send() (*IscsiBondServiceRemoveResponse, error) {
}

type IscsiBondServiceRemoveResponse struct {
}

//
// Removes of an existing iSCSI bond.
// For example, to remove the iSCSI bond `456` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *IscsiBondService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type IscsiBondServiceUpdateRequest struct {
	iscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
	bond             *IscsiBond
}

func (p *IscsiBondServiceUpdateRequest) Header(key, value string) *IscsiBondServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceUpdateRequest) Query(key, value string) *IscsiBondServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceUpdateRequest) Async(async bool) *IscsiBondServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *IscsiBondServiceUpdateRequest) Bond(bond *IscsiBond) *IscsiBondServiceUpdateRequest {
	p.bond = bond
	return p
}
func (p *IscsiBondServiceUpdateRequest) Send() (*IscsiBondServiceUpdateResponse, error) {
}

type IscsiBondServiceUpdateResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondServiceUpdateResponse) Bond() *IscsiBond {
	return p.bond
}

//
// Updates an iSCSI bond.
// Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
// update the iSCSI bond `456` of data center `123`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//    <name>mybond</name>
//    <description>My iSCSI bond</description>
// </iscsi_bond>
// ----
//
func (op *IscsiBondService) Update(
	bond *IscsiBond,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*IscsiBond,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(bond, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bondVar IscsiBond
	xml.Unmarshal([]byte(ovResp.Body), &bondVar)
	return &bondVar, nil
}

//
//
func (op *IscsiBondService) NetworksService() *NetworksService {
	return NewNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
//
func (op *IscsiBondService) StorageServerConnectionsService() *StorageServerConnectionsService {
	return NewStorageServerConnectionsService(op.Connection, fmt.Sprintf("%s/storageserverconnections", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IscsiBondService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "storageserverconnections" {
		return op.StorageServerConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageserverconnections/") {
		return op.StorageServerConnectionsService().Service(path[25:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *IscsiBondService) String() string {
	return fmt.Sprintf("IscsiBondService:%s", op.Path)
}

//
// This service manages the attachment of a disk to a template.
//
type TemplateDiskAttachmentService struct {
	BaseService
}

func NewTemplateDiskAttachmentService(connection *Connection, path string) *TemplateDiskAttachmentService {
	var result TemplateDiskAttachmentService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDiskAttachmentServiceGetRequest struct {
	templateDiskAttachmentService *TemplateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
}

func (p *TemplateDiskAttachmentServiceGetRequest) Header(key, value string) *TemplateDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceGetRequest) Query(key, value string) *TemplateDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceGetRequest) Send() (*TemplateDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentService.Connection.URL(), p.templateDiskAttachmentService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskAttachmentService.Connection.username, p.templateDiskAttachmentService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateDiskAttachmentServiceGetResponse TemplateDiskAttachmentServiceGetResponse
	var attachmentVar DiskAttachment
	xml.Unmarshal(respBodyBytes, &attachmentVar)
	templateDiskAttachmentServiceGetResponse.attachment = &attachmentVar
	return &templateDiskAttachmentServiceGetResponse, nil
}

type TemplateDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *TemplateDiskAttachmentServiceGetResponse) Attachment() *DiskAttachment {
	return p.attachment
}

//
// Returns the details of the attachment.
//
func (op *TemplateDiskAttachmentService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentVar DiskAttachment
	xml.Unmarshal([]byte(ovResp.Body), &attachmentVar)
	return &attachmentVar, nil
}

type TemplateDiskAttachmentServiceRemoveRequest struct {
	templateDiskAttachmentService *TemplateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
	force                         *bool
	storageDomain                 *string
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Header(key, value string) *TemplateDiskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Query(key, value string) *TemplateDiskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Force(force bool) *TemplateDiskAttachmentServiceRemoveRequest {
	p.force = &force
	return p
}
func (p *TemplateDiskAttachmentServiceRemoveRequest) StorageDomain(storageDomain string) *TemplateDiskAttachmentServiceRemoveRequest {
	p.storageDomain = &storageDomain
	return p
}
func (p *TemplateDiskAttachmentServiceRemoveRequest) Send() (*TemplateDiskAttachmentServiceRemoveResponse, error) {
}

type TemplateDiskAttachmentServiceRemoveResponse struct {
}

//
// Removes the disk from the template. The disk will only be removed if there are other existing copies of the
// disk on other storage domains.
// A storage domain has to be specified to determine which of the copies should be removed (template disks can
// have copies on multiple storage domains).
// [source]
// ----
// DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
// ----
// This method supports the following parameters:
// `StorageDomain`:: Specifies the identifier of the storage domain the image to be removed resides on.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateDiskAttachmentService) Remove(
	storageDomain string,
	force bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["storage_domain"] = fmt.Sprintf("%v", storageDomain)
	query["force"] = fmt.Sprintf("%v", force)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskAttachmentService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateDiskAttachmentService) String() string {
	return fmt.Sprintf("TemplateDiskAttachmentService:%s", op.Path)
}

//
// A service to manage host storages.
//
type HostStorageService struct {
	BaseService
}

func NewHostStorageService(connection *Connection, path string) *HostStorageService {
	var result HostStorageService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostStorageServiceListRequest struct {
	hostStorageService *HostStorageService
	header             map[string]string
	query              map[string]string
	reportStatus       *bool
}

func (p *HostStorageServiceListRequest) Header(key, value string) *HostStorageServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostStorageServiceListRequest) Query(key, value string) *HostStorageServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostStorageServiceListRequest) ReportStatus(reportStatus bool) *HostStorageServiceListRequest {
	p.reportStatus = &reportStatus
	return p
}
func (p *HostStorageServiceListRequest) Send() (*HostStorageServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostStorageService.Connection.URL(), p.hostStorageService.Path)
	values := make(url.Values)
	if p.reportStatus != nil {
		values["reportStatus"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostStorageService.Connection.username, p.hostStorageService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostStorageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostStorageServiceListResponse HostStorageServiceListResponse
	var storagesVar HostStorages
	xml.Unmarshal(respBodyBytes, &storagesVar)
	hostStorageServiceListResponse.storages = storagesVar.HostStorages
	return &hostStorageServiceListResponse, nil
}

type HostStorageServiceListResponse struct {
	storages []HostStorage
}

func (p *HostStorageServiceListResponse) Storages() []HostStorage {
	return p.storages
}

//
// Get list of storages.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/storage
// ----
// The XML response you get will be like this one:
// [source,xml]
// ----
// <host_storages>
//   <host_storage id="123">
//     ...
//   </host_storage>
//   ...
// </host_storages>
// ----
// This method supports the following parameters:
// `ReportStatus`:: Indicates if the status of the LUNs in the storage should be checked.
// Checking the status of the LUN is an heavy weight operation and
// this data is not always needed by the user.
// This parameter will give the option to not perform the status check of the LUNs.
// The default is `true` for backward compatibility.
// Here an example with the LUN status :
// [source,xml]
// ----
// <host_storage id="123">
//   <logical_units>
//     <logical_unit id="123">
//       <lun_mapping>0</lun_mapping>
//       <paths>1</paths>
//       <product_id>lun0</product_id>
//       <serial>123</serial>
//       <size>10737418240</size>
//       <status>used</status>
//       <vendor_id>LIO-ORG</vendor_id>
//       <volume_group_id>123</volume_group_id>
//     </logical_unit>
//   </logical_units>
//   <type>iscsi</type>
//   <host id="123"/>
// </host_storage>
// ----
// Here an example without the LUN status :
// [source,xml]
// ----
// <host_storage id="123">
//   <logical_units>
//     <logical_unit id="123">
//       <lun_mapping>0</lun_mapping>
//       <paths>1</paths>
//       <product_id>lun0</product_id>
//       <serial>123</serial>
//       <size>10737418240</size>
//       <vendor_id>LIO-ORG</vendor_id>
//       <volume_group_id>123</volume_group_id>
//     </logical_unit>
//   </logical_units>
//   <type>iscsi</type>
//   <host id="123"/>
// </host_storage>
// ----
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostStorageService) List(
	reportStatus bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]HostStorage,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["report_status"] = fmt.Sprintf("%v", reportStatus)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storagesVar HostStorages
	xml.Unmarshal([]byte(ovResp.Body), &storagesVar)
	return storagesVar.HostStorages, nil
}

//
// Reference to a service managing the storage.
//
func (op *HostStorageService) StorageService(id string) *StorageService {
	return NewStorageService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostStorageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageService(path)), nil
	}
	return op.StorageService(path[:index]).Service(path[index+1:])
}

func (op *HostStorageService) String() string {
	return fmt.Sprintf("HostStorageService:%s", op.Path)
}

//
//
type WeightService struct {
	BaseService
}

func NewWeightService(connection *Connection, path string) *WeightService {
	var result WeightService
	result.Connection = connection
	result.Path = path
	return &result
}

type WeightServiceGetRequest struct {
	weightService *WeightService
	header        map[string]string
	query         map[string]string
	filter        *bool
}

func (p *WeightServiceGetRequest) Header(key, value string) *WeightServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightServiceGetRequest) Query(key, value string) *WeightServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightServiceGetRequest) Filter(filter bool) *WeightServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *WeightServiceGetRequest) Send() (*WeightServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightService.Connection.URL(), p.weightService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.weightService.Connection.username, p.weightService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.weightService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var weightServiceGetResponse WeightServiceGetResponse
	var weightVar Weight
	xml.Unmarshal(respBodyBytes, &weightVar)
	weightServiceGetResponse.weight = &weightVar
	return &weightServiceGetResponse, nil
}

type WeightServiceGetResponse struct {
	weight *Weight
}

func (p *WeightServiceGetResponse) Weight() *Weight {
	return p.weight
}

//
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *WeightService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Weight,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var weightVar Weight
	xml.Unmarshal([]byte(ovResp.Body), &weightVar)
	return &weightVar, nil
}

type WeightServiceRemoveRequest struct {
	weightService *WeightService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *WeightServiceRemoveRequest) Header(key, value string) *WeightServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightServiceRemoveRequest) Query(key, value string) *WeightServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightServiceRemoveRequest) Async(async bool) *WeightServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *WeightServiceRemoveRequest) Send() (*WeightServiceRemoveResponse, error) {
}

type WeightServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *WeightService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *WeightService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *WeightService) String() string {
	return fmt.Sprintf("WeightService:%s", op.Path)
}

//
//
type VmNumaNodesService struct {
	BaseService
}

func NewVmNumaNodesService(connection *Connection, path string) *VmNumaNodesService {
	var result VmNumaNodesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNumaNodesServiceAddRequest struct {
	vmNumaNodesService *VmNumaNodesService
	header             map[string]string
	query              map[string]string
	node               *VirtualNumaNode
}

func (p *VmNumaNodesServiceAddRequest) Header(key, value string) *VmNumaNodesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodesServiceAddRequest) Query(key, value string) *VmNumaNodesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodesServiceAddRequest) Node(node *VirtualNumaNode) *VmNumaNodesServiceAddRequest {
	p.node = node
	return p
}
func (p *VmNumaNodesServiceAddRequest) Send() (*VmNumaNodesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.Connection.URL(), p.vmNumaNodesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.node)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodesService.Connection.username, p.vmNumaNodesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmNumaNodesServiceAddResponse VmNumaNodesServiceAddResponse
	var nodeVar VirtualNumaNode
	xml.Unmarshal(respBodyBytes, &nodeVar)
	vmNumaNodesServiceAddResponse.node = &nodeVar
	return &vmNumaNodesServiceAddResponse, nil
}

type VmNumaNodesServiceAddResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodesServiceAddResponse) Node() *VirtualNumaNode {
	return p.node
}

//
// Creates a new virtual NUMA node for the virtual machine.
// An example of creating a NUMA node:
// [source]
// ----
// POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
// Accept: application/xml
// Content-type: application/xml
// ----
// The request body can contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
// </vm_numa_node>
// ----
//
func (op *VmNumaNodesService) Add(
	node *VirtualNumaNode,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VirtualNumaNode,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(node, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nodeVar VirtualNumaNode
	xml.Unmarshal([]byte(ovResp.Body), &nodeVar)
	return &nodeVar, nil
}

type VmNumaNodesServiceListRequest struct {
	vmNumaNodesService *VmNumaNodesService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *VmNumaNodesServiceListRequest) Header(key, value string) *VmNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodesServiceListRequest) Query(key, value string) *VmNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodesServiceListRequest) Max(max int64) *VmNumaNodesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmNumaNodesServiceListRequest) Send() (*VmNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.Connection.URL(), p.vmNumaNodesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNumaNodesService.Connection.username, p.vmNumaNodesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmNumaNodesServiceListResponse VmNumaNodesServiceListResponse
	var nodesVar VirtualNumaNodes
	xml.Unmarshal(respBodyBytes, &nodesVar)
	vmNumaNodesServiceListResponse.nodes = nodesVar.VirtualNumaNodes
	return &vmNumaNodesServiceListResponse, nil
}

type VmNumaNodesServiceListResponse struct {
	nodes []VirtualNumaNode
}

func (p *VmNumaNodesServiceListResponse) Nodes() []VirtualNumaNode {
	return p.nodes
}

//
// Lists virtual NUMA nodes of a virtual machine.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of nodes to return. If not specified all the nodes are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmNumaNodesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]VirtualNumaNode,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nodesVar VirtualNumaNodes
	xml.Unmarshal([]byte(ovResp.Body), &nodesVar)
	return nodesVar.VirtualNumaNodes, nil
}

//
//
func (op *VmNumaNodesService) NodeService(id string) *VmNumaNodeService {
	return NewVmNumaNodeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNumaNodesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NodeService(path)), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *VmNumaNodesService) String() string {
	return fmt.Sprintf("VmNumaNodesService:%s", op.Path)
}

//
//
type TemplateWatchdogsService struct {
	BaseService
}

func NewTemplateWatchdogsService(connection *Connection, path string) *TemplateWatchdogsService {
	var result TemplateWatchdogsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateWatchdogsServiceAddRequest struct {
	templateWatchdogsService *TemplateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	watchdog                 *Watchdog
}

func (p *TemplateWatchdogsServiceAddRequest) Header(key, value string) *TemplateWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogsServiceAddRequest) Query(key, value string) *TemplateWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *TemplateWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}
func (p *TemplateWatchdogsServiceAddRequest) Send() (*TemplateWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.Connection.URL(), p.templateWatchdogsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogsService.Connection.username, p.templateWatchdogsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateWatchdogsServiceAddResponse TemplateWatchdogsServiceAddResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	templateWatchdogsServiceAddResponse.watchdog = &watchdogVar
	return &templateWatchdogsServiceAddResponse, nil
}

type TemplateWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogsServiceAddResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
//
func (op *TemplateWatchdogsService) Add(
	watchdog *Watchdog,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(watchdog, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

type TemplateWatchdogsServiceListRequest struct {
	templateWatchdogsService *TemplateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *TemplateWatchdogsServiceListRequest) Header(key, value string) *TemplateWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Query(key, value string) *TemplateWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Max(max int64) *TemplateWatchdogsServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplateWatchdogsServiceListRequest) Send() (*TemplateWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.Connection.URL(), p.templateWatchdogsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateWatchdogsService.Connection.username, p.templateWatchdogsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateWatchdogsServiceListResponse TemplateWatchdogsServiceListResponse
	var watchdogsVar Watchdogs
	xml.Unmarshal(respBodyBytes, &watchdogsVar)
	templateWatchdogsServiceListResponse.watchdogs = watchdogsVar.Watchdogs
	return &templateWatchdogsServiceListResponse, nil
}

type TemplateWatchdogsServiceListResponse struct {
	watchdogs []Watchdog
}

func (p *TemplateWatchdogsServiceListResponse) Watchdogs() []Watchdog {
	return p.watchdogs
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of watchdogs to return. If not specified all the watchdogs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateWatchdogsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogsVar Watchdogs
	xml.Unmarshal([]byte(ovResp.Body), &watchdogsVar)
	return watchdogsVar.Watchdogs, nil
}

//
//
func (op *TemplateWatchdogsService) WatchdogService(id string) *TemplateWatchdogService {
	return NewTemplateWatchdogService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateWatchdogsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WatchdogService(path)), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *TemplateWatchdogsService) String() string {
	return fmt.Sprintf("TemplateWatchdogsService:%s", op.Path)
}

//
// Manages a single disk available in a storage domain attached to a data center.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type AttachedStorageDomainDiskService struct {
	BaseService
}

func NewAttachedStorageDomainDiskService(connection *Connection, path string) *AttachedStorageDomainDiskService {
	var result AttachedStorageDomainDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type AttachedStorageDomainDiskServiceCopyRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Header(key, value string) *AttachedStorageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Query(key, value string) *AttachedStorageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Disk(disk *Disk) *AttachedStorageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}
func (p *AttachedStorageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainDiskServiceCopyRequest) Send() (*AttachedStorageDomainDiskServiceCopyResponse, error) {
}

type AttachedStorageDomainDiskServiceCopyResponse struct {
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
// This method supports the following parameters:
// `Disk`:: Description of the resulting disk.
// `StorageDomain`:: The storage domain where the new disk will be created.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainDiskService) Copy(
	disk *Disk,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Disk:          disk,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "copy", headers, query, wait)
	return err
}

type AttachedStorageDomainDiskServiceExportRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceExportRequest) Header(key, value string) *AttachedStorageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceExportRequest) Query(key, value string) *AttachedStorageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainDiskServiceExportRequest) Send() (*AttachedStorageDomainDiskServiceExportResponse, error) {
}

type AttachedStorageDomainDiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
// This method supports the following parameters:
// `StorageDomain`:: The export storage domain where the disk should be exported to.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainDiskService) Export(
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "export", headers, query, wait)
	return err
}

type AttachedStorageDomainDiskServiceGetRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Header(key, value string) *AttachedStorageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Query(key, value string) *AttachedStorageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Send() (*AttachedStorageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.Connection.URL(), p.attachedStorageDomainDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.attachedStorageDomainDiskService.Connection.username, p.attachedStorageDomainDiskService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var attachedStorageDomainDiskServiceGetResponse AttachedStorageDomainDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	attachedStorageDomainDiskServiceGetResponse.disk = &diskVar
	return &attachedStorageDomainDiskServiceGetResponse, nil
}

type AttachedStorageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (op *AttachedStorageDomainDiskService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type AttachedStorageDomainDiskServiceMoveRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	async                            *bool
	filter                           *bool
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Header(key, value string) *AttachedStorageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Query(key, value string) *AttachedStorageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Async(async bool) *AttachedStorageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *AttachedStorageDomainDiskServiceMoveRequest) Filter(filter bool) *AttachedStorageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *AttachedStorageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *AttachedStorageDomainDiskServiceMoveRequest) Send() (*AttachedStorageDomainDiskServiceMoveResponse, error) {
}

type AttachedStorageDomainDiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
// This method supports the following parameters:
// `StorageDomain`:: The storage domain where the disk will be moved to.
// `Async`:: Indicates if the move should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainDiskService) Move(
	async bool,
	filter bool,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Filter:        &filter,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "move", headers, query, wait)
	return err
}

type AttachedStorageDomainDiskServiceRegisterRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Header(key, value string) *AttachedStorageDomainDiskServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Query(key, value string) *AttachedStorageDomainDiskServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Send() (*AttachedStorageDomainDiskServiceRegisterResponse, error) {
}

type AttachedStorageDomainDiskServiceRegisterResponse struct {
}

//
// Registers an unregistered disk.
//
func (op *AttachedStorageDomainDiskService) Register(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "register", headers, query, wait)
	return err
}

type AttachedStorageDomainDiskServiceRemoveRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Header(key, value string) *AttachedStorageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Query(key, value string) *AttachedStorageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Send() (*AttachedStorageDomainDiskServiceRemoveResponse, error) {
}

type AttachedStorageDomainDiskServiceRemoveResponse struct {
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (op *AttachedStorageDomainDiskService) Remove(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type AttachedStorageDomainDiskServiceSparsifyRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Header(key, value string) *AttachedStorageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Query(key, value string) *AttachedStorageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Send() (*AttachedStorageDomainDiskServiceSparsifyResponse, error) {
}

type AttachedStorageDomainDiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (op *AttachedStorageDomainDiskService) Sparsify(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "sparsify", headers, query, wait)
	return err
}

type AttachedStorageDomainDiskServiceUpdateRequest struct {
	attachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Header(key, value string) *AttachedStorageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Query(key, value string) *AttachedStorageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *AttachedStorageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *AttachedStorageDomainDiskServiceUpdateRequest) Send() (*AttachedStorageDomainDiskServiceUpdateResponse, error) {
}

type AttachedStorageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
// This method supports the following parameters:
// `Disk`:: The update to apply to the disk.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AttachedStorageDomainDiskService) Update(
	disk *Disk,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request
	ovResp, err := op.internalUpdate(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *AttachedStorageDomainDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *AttachedStorageDomainDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AttachedStorageDomainDiskService) String() string {
	return fmt.Sprintf("AttachedStorageDomainDiskService:%s", op.Path)
}

//
// This service manages a vNIC profile.
//
type VnicProfileService struct {
	BaseService
}

func NewVnicProfileService(connection *Connection, path string) *VnicProfileService {
	var result VnicProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type VnicProfileServiceGetRequest struct {
	vnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
}

func (p *VnicProfileServiceGetRequest) Header(key, value string) *VnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceGetRequest) Query(key, value string) *VnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceGetRequest) Send() (*VnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.Connection.URL(), p.vnicProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vnicProfileService.Connection.username, p.vnicProfileService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vnicProfileServiceGetResponse VnicProfileServiceGetResponse
	var profileVar VnicProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	vnicProfileServiceGetResponse.profile = &profileVar
	return &vnicProfileServiceGetResponse, nil
}

type VnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *VnicProfileServiceGetResponse) Profile() *VnicProfile {
	return p.profile
}

//
// Retrieves details about a vNIC profile.
//
func (op *VnicProfileService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VnicProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar VnicProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type VnicProfileServiceRemoveRequest struct {
	vnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *VnicProfileServiceRemoveRequest) Header(key, value string) *VnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceRemoveRequest) Query(key, value string) *VnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceRemoveRequest) Async(async bool) *VnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VnicProfileServiceRemoveRequest) Send() (*VnicProfileServiceRemoveResponse, error) {
}

type VnicProfileServiceRemoveResponse struct {
}

//
// Removes the vNIC profile.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VnicProfileService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VnicProfileServiceUpdateRequest struct {
	vnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *VnicProfile
}

func (p *VnicProfileServiceUpdateRequest) Header(key, value string) *VnicProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceUpdateRequest) Query(key, value string) *VnicProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceUpdateRequest) Async(async bool) *VnicProfileServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *VnicProfileServiceUpdateRequest) Profile(profile *VnicProfile) *VnicProfileServiceUpdateRequest {
	p.profile = profile
	return p
}
func (p *VnicProfileServiceUpdateRequest) Send() (*VnicProfileServiceUpdateResponse, error) {
}

type VnicProfileServiceUpdateResponse struct {
	profile *VnicProfile
}

func (p *VnicProfileServiceUpdateResponse) Profile() *VnicProfile {
	return p.profile
}

//
// Updates details of a vNIC profile.
// This method supports the following parameters:
// `Profile`:: The vNIC profile that is being updated.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VnicProfileService) Update(
	profile *VnicProfile,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*VnicProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar VnicProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

//
//
func (op *VnicProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VnicProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VnicProfileService) String() string {
	return fmt.Sprintf("VnicProfileService:%s", op.Path)
}

//
//
type VmGraphicsConsolesService struct {
	BaseService
}

func NewVmGraphicsConsolesService(connection *Connection, path string) *VmGraphicsConsolesService {
	var result VmGraphicsConsolesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmGraphicsConsolesServiceAddRequest struct {
	vmGraphicsConsolesService *VmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	console                   *GraphicsConsole
}

func (p *VmGraphicsConsolesServiceAddRequest) Header(key, value string) *VmGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceAddRequest) Query(key, value string) *VmGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *VmGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}
func (p *VmGraphicsConsolesServiceAddRequest) Send() (*VmGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.Connection.URL(), p.vmGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.console)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsolesService.Connection.username, p.vmGraphicsConsolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmGraphicsConsolesServiceAddResponse VmGraphicsConsolesServiceAddResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	vmGraphicsConsolesServiceAddResponse.console = &consoleVar
	return &vmGraphicsConsolesServiceAddResponse, nil
}

type VmGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *VmGraphicsConsolesServiceAddResponse) Console() *GraphicsConsole {
	return p.console
}

//
// Add new graphics console to the virtual machine.
//
func (op *VmGraphicsConsolesService) Add(
	console *GraphicsConsole,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(console, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consoleVar GraphicsConsole
	xml.Unmarshal([]byte(ovResp.Body), &consoleVar)
	return &consoleVar, nil
}

type VmGraphicsConsolesServiceListRequest struct {
	vmGraphicsConsolesService *VmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	current                   *bool
	max                       *int64
}

func (p *VmGraphicsConsolesServiceListRequest) Header(key, value string) *VmGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Query(key, value string) *VmGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Current(current bool) *VmGraphicsConsolesServiceListRequest {
	p.current = &current
	return p
}
func (p *VmGraphicsConsolesServiceListRequest) Max(max int64) *VmGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmGraphicsConsolesServiceListRequest) Send() (*VmGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.Connection.URL(), p.vmGraphicsConsolesService.Path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsolesService.Connection.username, p.vmGraphicsConsolesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmGraphicsConsolesServiceListResponse VmGraphicsConsolesServiceListResponse
	var consolesVar GraphicsConsoles
	xml.Unmarshal(respBodyBytes, &consolesVar)
	vmGraphicsConsolesServiceListResponse.consoles = consolesVar.GraphicsConsoles
	return &vmGraphicsConsolesServiceListResponse, nil
}

type VmGraphicsConsolesServiceListResponse struct {
	consoles []GraphicsConsole
}

func (p *VmGraphicsConsolesServiceListResponse) Consoles() []GraphicsConsole {
	return p.consoles
}

//
// Lists all the configured graphics consoles of the virtual machine.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of consoles to return. If not specified all the consoles are returned.
// `Current`:: Use the following query to obtain the current run-time configuration of the graphics consoles.
// [source]
// ----
// GET /ovirt-engine/api/vms/123/graphicsconsoles?current=true
// ----
// The default value is `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmGraphicsConsolesService) List(
	current bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["current"] = fmt.Sprintf("%v", current)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consolesVar GraphicsConsoles
	xml.Unmarshal([]byte(ovResp.Body), &consolesVar)
	return consolesVar.GraphicsConsoles, nil
}

//
// Returns a reference to the service that manages a specific virtual machine graphics console.
//
func (op *VmGraphicsConsolesService) ConsoleService(id string) *VmGraphicsConsoleService {
	return NewVmGraphicsConsoleService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmGraphicsConsolesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ConsoleService(path)), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *VmGraphicsConsolesService) String() string {
	return fmt.Sprintf("VmGraphicsConsolesService:%s", op.Path)
}

//
// A service to manage a specific permit of the role.
//
type PermitService struct {
	BaseService
}

func NewPermitService(connection *Connection, path string) *PermitService {
	var result PermitService
	result.Connection = connection
	result.Path = path
	return &result
}

type PermitServiceGetRequest struct {
	permitService *PermitService
	header        map[string]string
	query         map[string]string
}

func (p *PermitServiceGetRequest) Header(key, value string) *PermitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitServiceGetRequest) Query(key, value string) *PermitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitServiceGetRequest) Send() (*PermitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitService.Connection.URL(), p.permitService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permitService.Connection.username, p.permitService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permitService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var permitServiceGetResponse PermitServiceGetResponse
	var permitVar Permit
	xml.Unmarshal(respBodyBytes, &permitVar)
	permitServiceGetResponse.permit = &permitVar
	return &permitServiceGetResponse, nil
}

type PermitServiceGetResponse struct {
	permit *Permit
}

func (p *PermitServiceGetResponse) Permit() *Permit {
	return p.permit
}

//
// Gets the information about the permit of the role.
// For example to retrieve the information about the permit with the id `456` of the role with the id `123`
// send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits/456
// ....
// [source,xml]
// ----
// <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
//   <name>change_vm_cd</name>
//   <administrative>false</administrative>
//   <role href="/ovirt-engine/api/roles/123" id="123"/>
// </permit>
// ----
//
func (op *PermitService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Permit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permitVar Permit
	xml.Unmarshal([]byte(ovResp.Body), &permitVar)
	return &permitVar, nil
}

type PermitServiceRemoveRequest struct {
	permitService *PermitService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *PermitServiceRemoveRequest) Header(key, value string) *PermitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitServiceRemoveRequest) Query(key, value string) *PermitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitServiceRemoveRequest) Async(async bool) *PermitServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *PermitServiceRemoveRequest) Send() (*PermitServiceRemoveResponse, error) {
}

type PermitServiceRemoveResponse struct {
}

//
// Removes the permit from the role.
// For example to remove the permit with id `456` from the role with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/roles/123/permits/456
// ....
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *PermitService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermitService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *PermitService) String() string {
	return fmt.Sprintf("PermitService:%s", op.Path)
}

//
// A service to manage a data center.
//
type DataCenterService struct {
	BaseService
}

func NewDataCenterService(connection *Connection, path string) *DataCenterService {
	var result DataCenterService
	result.Connection = connection
	result.Path = path
	return &result
}

type DataCenterServiceGetRequest struct {
	dataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	filter            *bool
}

func (p *DataCenterServiceGetRequest) Header(key, value string) *DataCenterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceGetRequest) Query(key, value string) *DataCenterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceGetRequest) Filter(filter bool) *DataCenterServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *DataCenterServiceGetRequest) Send() (*DataCenterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.Connection.URL(), p.dataCenterService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.dataCenterService.Connection.username, p.dataCenterService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.dataCenterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var dataCenterServiceGetResponse DataCenterServiceGetResponse
	var dataCenterVar DataCenter
	xml.Unmarshal(respBodyBytes, &dataCenterVar)
	dataCenterServiceGetResponse.dataCenter = &dataCenterVar
	return &dataCenterServiceGetResponse, nil
}

type DataCenterServiceGetResponse struct {
	dataCenter *DataCenter
}

func (p *DataCenterServiceGetResponse) DataCenter() *DataCenter {
	return p.dataCenter
}

//
// Get a data center.
// An example of getting a data center:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123
// ----
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <storage_format>v3</storage_format>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//    </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
// </data_center>
// ----
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DataCenterService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DataCenter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var dataCenterVar DataCenter
	xml.Unmarshal([]byte(ovResp.Body), &dataCenterVar)
	return &dataCenterVar, nil
}

type DataCenterServiceRemoveRequest struct {
	dataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	force             *bool
}

func (p *DataCenterServiceRemoveRequest) Header(key, value string) *DataCenterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceRemoveRequest) Query(key, value string) *DataCenterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceRemoveRequest) Async(async bool) *DataCenterServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DataCenterServiceRemoveRequest) Force(force bool) *DataCenterServiceRemoveRequest {
	p.force = &force
	return p
}
func (p *DataCenterServiceRemoveRequest) Send() (*DataCenterServiceRemoveResponse, error) {
}

type DataCenterServiceRemoveResponse struct {
}

//
// Removes the data center.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123
// ----
// Without any special parameters, the storage domains attached to the data center are detached and then removed
// from the storage. If something fails when performing this operation, for example if there is no host available to
// remove the storage domains from the storage, the complete operation will fail.
// If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
// one storage domain, for example. The failure is just ignored and the data center is removed from the database
// anyway.
// This method supports the following parameters:
// `Force`:: Indicates if the operation should succeed, and the storage domain removed from the database, even if
// something fails during the operation.
// This parameter is optional, and the default value is `false`.
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DataCenterService) Remove(
	force bool,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["force"] = fmt.Sprintf("%v", force)
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type DataCenterServiceUpdateRequest struct {
	dataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	dataCenter        *DataCenter
}

func (p *DataCenterServiceUpdateRequest) Header(key, value string) *DataCenterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceUpdateRequest) Query(key, value string) *DataCenterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceUpdateRequest) Async(async bool) *DataCenterServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *DataCenterServiceUpdateRequest) DataCenter(dataCenter *DataCenter) *DataCenterServiceUpdateRequest {
	p.dataCenter = dataCenter
	return p
}
func (p *DataCenterServiceUpdateRequest) Send() (*DataCenterServiceUpdateResponse, error) {
}

type DataCenterServiceUpdateResponse struct {
	dataCenter *DataCenter
}

func (p *DataCenterServiceUpdateResponse) DataCenter() *DataCenter {
	return p.dataCenter
}

//
// Updates the data center.
// The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
// post-creation. For example, to change the name and description of data center `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>myupdatedname</name>
//   <description>An updated description for the data center</description>
// </data_center>
// ----
// This method supports the following parameters:
// `DataCenter`:: The data center that is being updated.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DataCenterService) Update(
	dataCenter *DataCenter,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*DataCenter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(dataCenter, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var dataCenterVar DataCenter
	xml.Unmarshal([]byte(ovResp.Body), &dataCenterVar)
	return &dataCenterVar, nil
}

//
//
func (op *DataCenterService) ClustersService() *ClustersService {
	return NewClustersService(op.Connection, fmt.Sprintf("%s/clusters", op.Path))
}

//
// Reference to the iSCSI bonds service.
//
func (op *DataCenterService) IscsiBondsService() *IscsiBondsService {
	return NewIscsiBondsService(op.Connection, fmt.Sprintf("%s/iscsibonds", op.Path))
}

//
// Returns a reference to the service, that manages the networks, that are associated with the data center.
//
func (op *DataCenterService) NetworksService() *NetworksService {
	return NewNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
// Reference to the permissions service.
//
func (op *DataCenterService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Reference to the QOSs service.
//
func (op *DataCenterService) QossService() *QossService {
	return NewQossService(op.Connection, fmt.Sprintf("%s/qoss", op.Path))
}

//
// Reference to the quotas service.
//
func (op *DataCenterService) QuotasService() *QuotasService {
	return NewQuotasService(op.Connection, fmt.Sprintf("%s/quotas", op.Path))
}

//
// Attach and detach storage domains to and from a data center.
// For attaching a single storage domain we should use the following POST request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>data1</name>
// </storage_domain>
// ----
// For detaching a single storage domain we should use the following DELETE request:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/storagedomains/123
// ----
//
func (op *DataCenterService) StorageDomainsService() *AttachedStorageDomainsService {
	return NewAttachedStorageDomainsService(op.Connection, fmt.Sprintf("%s/storagedomains", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCenterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "iscsibonds" {
		return op.IscsiBondsService(), nil
	}
	if strings.HasPrefix(path, "iscsibonds/") {
		return op.IscsiBondsService().Service(path[11:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "qoss" {
		return op.QossService(), nil
	}
	if strings.HasPrefix(path, "qoss/") {
		return op.QossService().Service(path[5:])
	}
	if path == "quotas" {
		return op.QuotasService(), nil
	}
	if strings.HasPrefix(path, "quotas/") {
		return op.QuotasService().Service(path[7:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DataCenterService) String() string {
	return fmt.Sprintf("DataCenterService:%s", op.Path)
}

//
//
type StatisticsService struct {
	BaseService
}

func NewStatisticsService(connection *Connection, path string) *StatisticsService {
	var result StatisticsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StatisticsServiceListRequest struct {
	statisticsService *StatisticsService
	header            map[string]string
	query             map[string]string
	max               *int64
}

func (p *StatisticsServiceListRequest) Header(key, value string) *StatisticsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StatisticsServiceListRequest) Query(key, value string) *StatisticsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StatisticsServiceListRequest) Max(max int64) *StatisticsServiceListRequest {
	p.max = &max
	return p
}
func (p *StatisticsServiceListRequest) Send() (*StatisticsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.statisticsService.Connection.URL(), p.statisticsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.statisticsService.Connection.username, p.statisticsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.statisticsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var statisticsServiceListResponse StatisticsServiceListResponse
	var statisticsVar Statistics
	xml.Unmarshal(respBodyBytes, &statisticsVar)
	statisticsServiceListResponse.statistics = statisticsVar.Statistics
	return &statisticsServiceListResponse, nil
}

type StatisticsServiceListResponse struct {
	statistics []Statistic
}

func (p *StatisticsServiceListResponse) Statistics() []Statistic {
	return p.statistics
}

//
// Retrieves a list of statistics.
// For example, to retrieve the statistics for virtual machine `123` send a
// request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics
// ----
// The result will be like this:
// [source,xml]
// ----
// <statistics>
//   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//     <name>memory.installed</name>
//     <description>Total memory configured</description>
//     <kind>gauge</kind>
//     <type>integer</type>
//     <unit>bytes</unit>
//     <values>
//       <value>
//         <datum>1073741824</datum>
//       </value>
//     </values>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </statistic>
//   ...
// </statistics>
// ----
// Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics/456
// ----
// Outputs:
// [source,xml]
// ----
// <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//   <name>memory.installed</name>
//   <description>Total memory configured</description>
//   <kind>gauge</kind>
//   <type>integer</type>
//   <unit>bytes</unit>
//   <values>
//     <value>
//       <datum>1073741824</datum>
//     </value>
//   </values>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </statistic>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of statistics to return. If not specified all the statistics are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StatisticsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Statistic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var statisticsVar Statistics
	xml.Unmarshal([]byte(ovResp.Body), &statisticsVar)
	return statisticsVar.Statistics, nil
}

//
//
func (op *StatisticsService) StatisticService(id string) *StatisticService {
	return NewStatisticService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StatisticsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StatisticService(path)), nil
	}
	return op.StatisticService(path[:index]).Service(path[index+1:])
}

func (op *StatisticsService) String() string {
	return fmt.Sprintf("StatisticsService:%s", op.Path)
}

//
//
type SchedulingPolicyUnitsService struct {
	BaseService
}

func NewSchedulingPolicyUnitsService(connection *Connection, path string) *SchedulingPolicyUnitsService {
	var result SchedulingPolicyUnitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SchedulingPolicyUnitsServiceListRequest struct {
	schedulingPolicyUnitsService *SchedulingPolicyUnitsService
	header                       map[string]string
	query                        map[string]string
	filter                       *bool
	max                          *int64
}

func (p *SchedulingPolicyUnitsServiceListRequest) Header(key, value string) *SchedulingPolicyUnitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Query(key, value string) *SchedulingPolicyUnitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Filter(filter bool) *SchedulingPolicyUnitsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *SchedulingPolicyUnitsServiceListRequest) Max(max int64) *SchedulingPolicyUnitsServiceListRequest {
	p.max = &max
	return p
}
func (p *SchedulingPolicyUnitsServiceListRequest) Send() (*SchedulingPolicyUnitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitsService.Connection.URL(), p.schedulingPolicyUnitsService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.schedulingPolicyUnitsService.Connection.username, p.schedulingPolicyUnitsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var schedulingPolicyUnitsServiceListResponse SchedulingPolicyUnitsServiceListResponse
	var unitsVar SchedulingPolicyUnits
	xml.Unmarshal(respBodyBytes, &unitsVar)
	schedulingPolicyUnitsServiceListResponse.units = unitsVar.SchedulingPolicyUnits
	return &schedulingPolicyUnitsServiceListResponse, nil
}

type SchedulingPolicyUnitsServiceListResponse struct {
	units []SchedulingPolicyUnit
}

func (p *SchedulingPolicyUnitsServiceListResponse) Units() []SchedulingPolicyUnit {
	return p.units
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of policy units to return. If not specified all the policy units are returned.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SchedulingPolicyUnitsService) List(
	filter bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]SchedulingPolicyUnit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var unitsVar SchedulingPolicyUnits
	xml.Unmarshal([]byte(ovResp.Body), &unitsVar)
	return unitsVar.SchedulingPolicyUnits, nil
}

//
//
func (op *SchedulingPolicyUnitsService) UnitService(id string) *SchedulingPolicyUnitService {
	return NewSchedulingPolicyUnitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyUnitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.UnitService(path)), nil
	}
	return op.UnitService(path[:index]).Service(path[index+1:])
}

func (op *SchedulingPolicyUnitsService) String() string {
	return fmt.Sprintf("SchedulingPolicyUnitsService:%s", op.Path)
}

//
//
type TemplateDiskService struct {
	BaseService
}

func NewTemplateDiskService(connection *Connection, path string) *TemplateDiskService {
	var result TemplateDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDiskServiceCopyRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
}

func (p *TemplateDiskServiceCopyRequest) Header(key, value string) *TemplateDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceCopyRequest) Query(key, value string) *TemplateDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceCopyRequest) Async(async bool) *TemplateDiskServiceCopyRequest {
	p.async = &async
	return p
}
func (p *TemplateDiskServiceCopyRequest) Filter(filter bool) *TemplateDiskServiceCopyRequest {
	p.filter = &filter
	return p
}
func (p *TemplateDiskServiceCopyRequest) Send() (*TemplateDiskServiceCopyResponse, error) {
}

type TemplateDiskServiceCopyResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the copy should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateDiskService) Copy(
	async bool,
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Filter: &filter,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "copy", headers, query, wait)
	return err
}

type TemplateDiskServiceExportRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
}

func (p *TemplateDiskServiceExportRequest) Header(key, value string) *TemplateDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceExportRequest) Query(key, value string) *TemplateDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceExportRequest) Async(async bool) *TemplateDiskServiceExportRequest {
	p.async = &async
	return p
}
func (p *TemplateDiskServiceExportRequest) Filter(filter bool) *TemplateDiskServiceExportRequest {
	p.filter = &filter
	return p
}
func (p *TemplateDiskServiceExportRequest) Send() (*TemplateDiskServiceExportResponse, error) {
}

type TemplateDiskServiceExportResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the export should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateDiskService) Export(
	async bool,
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Filter: &filter,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "export", headers, query, wait)
	return err
}

type TemplateDiskServiceGetRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
}

func (p *TemplateDiskServiceGetRequest) Header(key, value string) *TemplateDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceGetRequest) Query(key, value string) *TemplateDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceGetRequest) Send() (*TemplateDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskService.Connection.URL(), p.templateDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskService.Connection.username, p.templateDiskService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateDiskServiceGetResponse TemplateDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	templateDiskServiceGetResponse.disk = &diskVar
	return &templateDiskServiceGetResponse, nil
}

type TemplateDiskServiceGetResponse struct {
	disk *Disk
}

func (p *TemplateDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}

//
//
func (op *TemplateDiskService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type TemplateDiskServiceRemoveRequest struct {
	templateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *TemplateDiskServiceRemoveRequest) Header(key, value string) *TemplateDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceRemoveRequest) Query(key, value string) *TemplateDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceRemoveRequest) Async(async bool) *TemplateDiskServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateDiskServiceRemoveRequest) Send() (*TemplateDiskServiceRemoveResponse, error) {
}

type TemplateDiskServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateDiskService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateDiskService) String() string {
	return fmt.Sprintf("TemplateDiskService:%s", op.Path)
}

//
// This service represents list of vms that have a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type AffinityLabelVmsService struct {
	BaseService
}

func NewAffinityLabelVmsService(connection *Connection, path string) *AffinityLabelVmsService {
	var result AffinityLabelVmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelVmsServiceAddRequest struct {
	affinityLabelVmsService *AffinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *AffinityLabelVmsServiceAddRequest) Header(key, value string) *AffinityLabelVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmsServiceAddRequest) Query(key, value string) *AffinityLabelVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmsServiceAddRequest) Vm(vm *Vm) *AffinityLabelVmsServiceAddRequest {
	p.vm = vm
	return p
}
func (p *AffinityLabelVmsServiceAddRequest) Send() (*AffinityLabelVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.Connection.URL(), p.affinityLabelVmsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.vm)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelVmsService.Connection.username, p.affinityLabelVmsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelVmsServiceAddResponse AffinityLabelVmsServiceAddResponse
	var vmVar Vm
	xml.Unmarshal(respBodyBytes, &vmVar)
	affinityLabelVmsServiceAddResponse.vm = &vmVar
	return &affinityLabelVmsServiceAddResponse, nil
}

type AffinityLabelVmsServiceAddResponse struct {
	vm *Vm
}

func (p *AffinityLabelVmsServiceAddResponse) Vm() *Vm {
	return p.vm
}

//
// Add a label to a vm.
//
func (op *AffinityLabelVmsService) Add(
	vm *Vm,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(vm, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vm
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return &vmVar, nil
}

type AffinityLabelVmsServiceListRequest struct {
	affinityLabelVmsService *AffinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
}

func (p *AffinityLabelVmsServiceListRequest) Header(key, value string) *AffinityLabelVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmsServiceListRequest) Query(key, value string) *AffinityLabelVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmsServiceListRequest) Send() (*AffinityLabelVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.Connection.URL(), p.affinityLabelVmsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelVmsService.Connection.username, p.affinityLabelVmsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelVmsServiceListResponse AffinityLabelVmsServiceListResponse
	var vmsVar Vms
	xml.Unmarshal(respBodyBytes, &vmsVar)
	affinityLabelVmsServiceListResponse.vms = vmsVar.Vms
	return &affinityLabelVmsServiceListResponse, nil
}

type AffinityLabelVmsServiceListResponse struct {
	vms []Vm
}

func (p *AffinityLabelVmsServiceListResponse) Vms() []Vm {
	return p.vms
}

//
// List all vms with the label.
//
func (op *AffinityLabelVmsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmsVar Vms
	xml.Unmarshal([]byte(ovResp.Body), &vmsVar)
	return vmsVar.Vms, nil
}

//
// A link to the specific label-vm assignment to
// allow label removal.
//
func (op *AffinityLabelVmsService) VmService(id string) *AffinityLabelVmService {
	return NewAffinityLabelVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelVmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelVmsService) String() string {
	return fmt.Sprintf("AffinityLabelVmsService:%s", op.Path)
}

//
//
type CopyableService struct {
	BaseService
}

func NewCopyableService(connection *Connection, path string) *CopyableService {
	var result CopyableService
	result.Connection = connection
	result.Path = path
	return &result
}

type CopyableServiceCopyRequest struct {
	copyableService *CopyableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *CopyableServiceCopyRequest) Header(key, value string) *CopyableServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CopyableServiceCopyRequest) Query(key, value string) *CopyableServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CopyableServiceCopyRequest) Async(async bool) *CopyableServiceCopyRequest {
	p.async = &async
	return p
}
func (p *CopyableServiceCopyRequest) Send() (*CopyableServiceCopyResponse, error) {
}

type CopyableServiceCopyResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the copy should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *CopyableService) Copy(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "copy", headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CopyableService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *CopyableService) String() string {
	return fmt.Sprintf("CopyableService:%s", op.Path)
}

//
// Manages the affinity labels available in the system.
//
type AffinityLabelsService struct {
	BaseService
}

func NewAffinityLabelsService(connection *Connection, path string) *AffinityLabelsService {
	var result AffinityLabelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelsServiceAddRequest struct {
	affinityLabelsService *AffinityLabelsService
	header                map[string]string
	query                 map[string]string
	label                 *AffinityLabel
}

func (p *AffinityLabelsServiceAddRequest) Header(key, value string) *AffinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelsServiceAddRequest) Query(key, value string) *AffinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelsServiceAddRequest) Label(label *AffinityLabel) *AffinityLabelsServiceAddRequest {
	p.label = label
	return p
}
func (p *AffinityLabelsServiceAddRequest) Send() (*AffinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.Connection.URL(), p.affinityLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.label)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelsService.Connection.username, p.affinityLabelsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelsServiceAddResponse AffinityLabelsServiceAddResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	affinityLabelsServiceAddResponse.label = &labelVar
	return &affinityLabelsServiceAddResponse, nil
}

type AffinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelsServiceAddResponse) Label() *AffinityLabel {
	return p.label
}

//
// Creates a new label. The label is automatically attached
// to all entities mentioned in the vms or hosts lists.
//
func (op *AffinityLabelsService) Add(
	label *AffinityLabel,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(label, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar AffinityLabel
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return &labelVar, nil
}

type AffinityLabelsServiceListRequest struct {
	affinityLabelsService *AffinityLabelsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *AffinityLabelsServiceListRequest) Header(key, value string) *AffinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelsServiceListRequest) Query(key, value string) *AffinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelsServiceListRequest) Max(max int64) *AffinityLabelsServiceListRequest {
	p.max = &max
	return p
}
func (p *AffinityLabelsServiceListRequest) Send() (*AffinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.Connection.URL(), p.affinityLabelsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelsService.Connection.username, p.affinityLabelsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelsServiceListResponse AffinityLabelsServiceListResponse
	var labelsVar AffinityLabels
	xml.Unmarshal(respBodyBytes, &labelsVar)
	affinityLabelsServiceListResponse.labels = labelsVar.AffinityLabels
	return &affinityLabelsServiceListResponse, nil
}

type AffinityLabelsServiceListResponse struct {
	labels []AffinityLabel
}

func (p *AffinityLabelsServiceListResponse) Labels() []AffinityLabel {
	return p.labels
}

//
// Lists all labels present in the system.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of labels to return. If not specified all the labels are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AffinityLabelsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]AffinityLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelsVar AffinityLabels
	xml.Unmarshal([]byte(ovResp.Body), &labelsVar)
	return labelsVar.AffinityLabels, nil
}

//
// Link to a single label details.
//
func (op *AffinityLabelsService) LabelService(id string) *AffinityLabelService {
	return NewAffinityLabelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LabelService(path)), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelsService) String() string {
	return fmt.Sprintf("AffinityLabelsService:%s", op.Path)
}

//
//
type VmGraphicsConsoleService struct {
	BaseService
}

func NewVmGraphicsConsoleService(connection *Connection, path string) *VmGraphicsConsoleService {
	var result VmGraphicsConsoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmGraphicsConsoleServiceGetRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	current                  *bool
}

func (p *VmGraphicsConsoleServiceGetRequest) Header(key, value string) *VmGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Query(key, value string) *VmGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Current(current bool) *VmGraphicsConsoleServiceGetRequest {
	p.current = &current
	return p
}
func (p *VmGraphicsConsoleServiceGetRequest) Send() (*VmGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsoleService.Connection.URL(), p.vmGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmGraphicsConsoleService.Connection.username, p.vmGraphicsConsoleService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmGraphicsConsoleServiceGetResponse VmGraphicsConsoleServiceGetResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	vmGraphicsConsoleServiceGetResponse.console = &consoleVar
	return &vmGraphicsConsoleServiceGetResponse, nil
}

type VmGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *VmGraphicsConsoleServiceGetResponse) Console() *GraphicsConsole {
	return p.console
}

//
// Gets graphics console configuration of the virtual machine.
// This method supports the following parameters:
// `Current`:: Use the following query to obtain the current run-time configuration of the graphics console.
// [source]
// ----
// GET /ovit-engine/api/vms/123/graphicsconsoles/456?current=true
// ----
// The default value is `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmGraphicsConsoleService) Get(
	current bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["current"] = fmt.Sprintf("%v", current)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consoleVar GraphicsConsole
	xml.Unmarshal([]byte(ovResp.Body), &consoleVar)
	return &consoleVar, nil
}

type VmGraphicsConsoleServiceProxyTicketRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Header(key, value string) *VmGraphicsConsoleServiceProxyTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Query(key, value string) *VmGraphicsConsoleServiceProxyTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Async(async bool) *VmGraphicsConsoleServiceProxyTicketRequest {
	p.async = &async
	return p
}
func (p *VmGraphicsConsoleServiceProxyTicketRequest) Send() (*VmGraphicsConsoleServiceProxyTicketResponse, error) {
}

type VmGraphicsConsoleServiceProxyTicketResponse struct {
	proxyTicket *ProxyTicket
}

func (p *VmGraphicsConsoleServiceProxyTicketResponse) ProxyTicket() *ProxyTicket {
	return p.proxyTicket
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the generation of the ticket should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmGraphicsConsoleService) ProxyTicket(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ProxyTicket,
	error) {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "proxyticket", headers, query, wait)
	if err != nil {
		return nil, err
	}
	var proxyTicketVar ProxyTicket
	xml.Unmarshal([]byte(ovResp.Body), &proxyTicketVar)
	return &proxyTicketVar, nil
}

type VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Header(key, value string) *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Query(key, value string) *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Send() (*VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse, error) {
}

type VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse struct {
	remoteViewerConnectionFile string
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse) RemoteViewerConnectionFile() string {
	return p.remoteViewerConnectionFile
}

//
// Generates the file which is compatible with `remote-viewer` client.
// Use the following request to generate remote viewer connection file of the graphics console.
// Note that this action generates the file only if virtual machine is running.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
// ----
// The `remoteviewerconnectionfile` action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// The response contains the file, which can be used with `remote-viewer` client.
// [source,xml]
// ----
// <action>
//   <remote_viewer_connection_file>
//     [virt-viewer]
//     type=spice
//     host=192.168.1.101
//     port=-1
//     password=123456789
//     delete-this-file=1
//     fullscreen=0
//     toggle-fullscreen=shift+f11
//     release-cursor=shift+f12
//     secure-attention=ctrl+alt+end
//     tls-port=5900
//     enable-smartcard=0
//     enable-usb-autoshare=0
//     usb-filter=null
//     tls-ciphers=DEFAULT
//     host-subject=O=local,CN=example.com
//     ca=...
//   </remote_viewer_connection_file>
// </action>
// ----
// E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
// oVirt Python SDK as follows:
// [source,python]
// ----
// # Find the virtual machine:
// vm = vms_service.list(search='name=myvm')[0]
// # Locate the service that manages the virtual machine, as that is where
// # the locators are defined:
// vm_service = vms_service.vm_service(vm.id)
// # Find the graphic console of the virtual machine:
// graphics_consoles_service = vm_service.graphics_consoles_service()
// graphics_console = graphics_consoles_service.list()[0]
// # Generate the remote viewer connection file:
// console_service = graphics_consoles_service.console_service(graphics_console.id)
// remote_viewer_connection_file = console_service.remote_viewer_connection_file()
// # Write the content to file "/tmp/remote_viewer_connection_file.vv"
// path = "/tmp/remote_viewer_connection_file.vv"
// with open(path, "w") as f:
//     f.write(remote_viewer_connection_file)
// ----
// When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
// as follows:
// [source,bash]
// ----
// #!/bin/sh -ex
// remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
// ----
//
func (op *VmGraphicsConsoleService) RemoteViewerConnectionFile(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	string,
	error) {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "remoteviewerconnectionfile", headers, query, wait)
	if err != nil {
		return "", err
	}
	return ovResp.Body, nil
}

type VmGraphicsConsoleServiceRemoveRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Header(key, value string) *VmGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Query(key, value string) *VmGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Async(async bool) *VmGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *VmGraphicsConsoleServiceRemoveRequest) Send() (*VmGraphicsConsoleServiceRemoveResponse, error) {
}

type VmGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the virtual machine.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmGraphicsConsoleService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type VmGraphicsConsoleServiceTicketRequest struct {
	vmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	ticket                   *Ticket
}

func (p *VmGraphicsConsoleServiceTicketRequest) Header(key, value string) *VmGraphicsConsoleServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceTicketRequest) Query(key, value string) *VmGraphicsConsoleServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceTicketRequest) Ticket(ticket *Ticket) *VmGraphicsConsoleServiceTicketRequest {
	p.ticket = ticket
	return p
}
func (p *VmGraphicsConsoleServiceTicketRequest) Send() (*VmGraphicsConsoleServiceTicketResponse, error) {
}

type VmGraphicsConsoleServiceTicketResponse struct {
	ticket *Ticket
}

func (p *VmGraphicsConsoleServiceTicketResponse) Ticket() *Ticket {
	return p.ticket
}

//
// Generates a time-sensitive authentication token for accessing this virtual machine's console.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// This method supports the following parameters:
// `Ticket`:: The generated ticket that can be used to access this console.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmGraphicsConsoleService) Ticket(
	ticket *Ticket,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Ticket,
	error) {
	// Populate the action:
	action := &Action{
		Ticket: ticket,
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "ticket", headers, query, wait)
	if err != nil {
		return nil, err
	}
	var ticketVar Ticket
	xml.Unmarshal([]byte(ovResp.Body), &ticketVar)
	return &ticketVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmGraphicsConsoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmGraphicsConsoleService) String() string {
	return fmt.Sprintf("VmGraphicsConsoleService:%s", op.Path)
}

//
// This service represents a host that has a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type AffinityLabelHostService struct {
	BaseService
}

func NewAffinityLabelHostService(connection *Connection, path string) *AffinityLabelHostService {
	var result AffinityLabelHostService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelHostServiceGetRequest struct {
	affinityLabelHostService *AffinityLabelHostService
	header                   map[string]string
	query                    map[string]string
}

func (p *AffinityLabelHostServiceGetRequest) Header(key, value string) *AffinityLabelHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostServiceGetRequest) Query(key, value string) *AffinityLabelHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostServiceGetRequest) Send() (*AffinityLabelHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostService.Connection.URL(), p.affinityLabelHostService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelHostService.Connection.username, p.affinityLabelHostService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelHostServiceGetResponse AffinityLabelHostServiceGetResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	affinityLabelHostServiceGetResponse.host = &hostVar
	return &affinityLabelHostServiceGetResponse, nil
}

type AffinityLabelHostServiceGetResponse struct {
	host *Host
}

func (p *AffinityLabelHostServiceGetResponse) Host() *Host {
	return p.host
}

//
// Retrieves details about a host that has this label assigned.
//
func (op *AffinityLabelHostService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Host,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostVar Host
	xml.Unmarshal([]byte(ovResp.Body), &hostVar)
	return &hostVar, nil
}

type AffinityLabelHostServiceRemoveRequest struct {
	affinityLabelHostService *AffinityLabelHostService
	header                   map[string]string
	query                    map[string]string
}

func (p *AffinityLabelHostServiceRemoveRequest) Header(key, value string) *AffinityLabelHostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostServiceRemoveRequest) Query(key, value string) *AffinityLabelHostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostServiceRemoveRequest) Send() (*AffinityLabelHostServiceRemoveResponse, error) {
}

type AffinityLabelHostServiceRemoveResponse struct {
}

//
// Remove a label from a host.
//
func (op *AffinityLabelHostService) Remove(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelHostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelHostService) String() string {
	return fmt.Sprintf("AffinityLabelHostService:%s", op.Path)
}

//
// A service to manage assignment of specific tag to specific entities in system.
//
type AssignedTagService struct {
	BaseService
}

func NewAssignedTagService(connection *Connection, path string) *AssignedTagService {
	var result AssignedTagService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedTagServiceGetRequest struct {
	assignedTagService *AssignedTagService
	header             map[string]string
	query              map[string]string
}

func (p *AssignedTagServiceGetRequest) Header(key, value string) *AssignedTagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagServiceGetRequest) Query(key, value string) *AssignedTagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagServiceGetRequest) Send() (*AssignedTagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagService.Connection.URL(), p.assignedTagService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedTagService.Connection.username, p.assignedTagService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedTagService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedTagServiceGetResponse AssignedTagServiceGetResponse
	var tagVar Tag
	xml.Unmarshal(respBodyBytes, &tagVar)
	assignedTagServiceGetResponse.tag = &tagVar
	return &assignedTagServiceGetResponse, nil
}

type AssignedTagServiceGetResponse struct {
	tag *Tag
}

func (p *AssignedTagServiceGetResponse) Tag() *Tag {
	return p.tag
}

//
// Gets the information about the assigned tag.
// For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags/456
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/456" id="456">
//   <name>root</name>
//   <description>root</description>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </tag>
// ----
//
func (op *AssignedTagService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Tag,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var tagVar Tag
	xml.Unmarshal([]byte(ovResp.Body), &tagVar)
	return &tagVar, nil
}

type AssignedTagServiceRemoveRequest struct {
	assignedTagService *AssignedTagService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *AssignedTagServiceRemoveRequest) Header(key, value string) *AssignedTagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagServiceRemoveRequest) Query(key, value string) *AssignedTagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagServiceRemoveRequest) Async(async bool) *AssignedTagServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *AssignedTagServiceRemoveRequest) Send() (*AssignedTagServiceRemoveResponse, error) {
}

type AssignedTagServiceRemoveResponse struct {
}

//
// Unassign tag from specific entity in the system.
// For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/vms/123/tags/456
// ....
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedTagService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedTagService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedTagService) String() string {
	return fmt.Sprintf("AssignedTagService:%s", op.Path)
}

//
// Manages a single disk.
//
type DiskService struct {
	BaseService
}

func NewDiskService(connection *Connection, path string) *DiskService {
	var result DiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskServiceCopyRequest struct {
	diskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
	filter        *bool
	storageDomain *StorageDomain
}

func (p *DiskServiceCopyRequest) Header(key, value string) *DiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceCopyRequest) Query(key, value string) *DiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceCopyRequest) Async(async bool) *DiskServiceCopyRequest {
	p.async = &async
	return p
}
func (p *DiskServiceCopyRequest) Disk(disk *Disk) *DiskServiceCopyRequest {
	p.disk = disk
	return p
}
func (p *DiskServiceCopyRequest) Filter(filter bool) *DiskServiceCopyRequest {
	p.filter = &filter
	return p
}
func (p *DiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *DiskServiceCopyRequest) Send() (*DiskServiceCopyResponse, error) {
}

type DiskServiceCopyResponse struct {
}

//
// This operation copies a disk to the specified storage domain.
// For example, copy of a disk can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/copy
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk>
//     <name>mydisk</name>
//   </disk>
// </action>
// ----
// This method supports the following parameters:
// `Disk`:: Description of the resulting disk. The only accepted value is the `name` attribute, which will be the name
// used for the new disk. For example, to copy disk `123` using `myname` as the name for the new disk, send
// a request like this:
// ....
// POST /ovirt-engine/disks/123
// ....
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <disk>
//     <name>mydisk<name>
//   </disk>
//   <storage_domain id="456"/>
// </action>
// ----
// `StorageDomain`:: The storage domain where the new disk will be created. Can be specified using the `id` or `name`
// attributes. For example, to copy a disk to the storage domain named `mydata` send a request like this:
// ....
// POST /ovirt-engine/api/storagedomains/123/disks/789
// ....
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
// </action>
// ----
// `Async`:: Indicates if the copy should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskService) Copy(
	async bool,
	disk *Disk,
	filter bool,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Disk:          disk,
		Filter:        &filter,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "copy", headers, query, wait)
	return err
}

type DiskServiceExportRequest struct {
	diskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
	storageDomain *StorageDomain
}

func (p *DiskServiceExportRequest) Header(key, value string) *DiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceExportRequest) Query(key, value string) *DiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceExportRequest) Async(async bool) *DiskServiceExportRequest {
	p.async = &async
	return p
}
func (p *DiskServiceExportRequest) Filter(filter bool) *DiskServiceExportRequest {
	p.filter = &filter
	return p
}
func (p *DiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *DiskServiceExportRequest) Send() (*DiskServiceExportResponse, error) {
}

type DiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
// This method supports the following parameters:
// `StorageDomain`:: The export storage domain where the disk should be exported to.
// `Async`:: Indicates if the export should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskService) Export(
	async bool,
	filter bool,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Filter:        &filter,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "export", headers, query, wait)
	return err
}

type DiskServiceGetRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
}

func (p *DiskServiceGetRequest) Header(key, value string) *DiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceGetRequest) Query(key, value string) *DiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceGetRequest) Send() (*DiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskService.Connection.URL(), p.diskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskService.Connection.username, p.diskService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskServiceGetResponse DiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	diskServiceGetResponse.disk = &diskVar
	return &diskServiceGetResponse, nil
}

type DiskServiceGetResponse struct {
	disk *Disk
}

func (p *DiskServiceGetResponse) Disk() *Disk {
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (op *DiskService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type DiskServiceMoveRequest struct {
	diskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
	storageDomain *StorageDomain
}

func (p *DiskServiceMoveRequest) Header(key, value string) *DiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceMoveRequest) Query(key, value string) *DiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceMoveRequest) Async(async bool) *DiskServiceMoveRequest {
	p.async = &async
	return p
}
func (p *DiskServiceMoveRequest) Filter(filter bool) *DiskServiceMoveRequest {
	p.filter = &filter
	return p
}
func (p *DiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}
func (p *DiskServiceMoveRequest) Send() (*DiskServiceMoveResponse, error) {
}

type DiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
// request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/move
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
// </action>
// ----
// This method supports the following parameters:
// `StorageDomain`:: The storage domain where the disk will be moved to.
// `Async`:: Indicates if the move should be performed asynchronously.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskService) Move(
	async bool,
	filter bool,
	storageDomain *StorageDomain,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:         &async,
		Filter:        &filter,
		StorageDomain: storageDomain,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "move", headers, query, wait)
	return err
}

type DiskServiceRemoveRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *DiskServiceRemoveRequest) Header(key, value string) *DiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceRemoveRequest) Query(key, value string) *DiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceRemoveRequest) Async(async bool) *DiskServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *DiskServiceRemoveRequest) Send() (*DiskServiceRemoveResponse, error) {
}

type DiskServiceRemoveResponse struct {
}

//
// Removes a disk.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type DiskServiceSparsifyRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
}

func (p *DiskServiceSparsifyRequest) Header(key, value string) *DiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceSparsifyRequest) Query(key, value string) *DiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceSparsifyRequest) Send() (*DiskServiceSparsifyResponse, error) {
}

type DiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// Sparsification frees space in the disk image that is not used by its
// filesystem. As a result, the image will occupy less space on the storage.
// Currently sparsification works only on disks without snapshots. Disks
// having derived disks are also not allowed.
//
func (op *DiskService) Sparsify(
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "sparsify", headers, query, wait)
	return err
}

type DiskServiceUpdateRequest struct {
	diskService *DiskService
	header      map[string]string
	query       map[string]string
	disk        *Disk
}

func (p *DiskServiceUpdateRequest) Header(key, value string) *DiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceUpdateRequest) Query(key, value string) *DiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceUpdateRequest) Disk(disk *Disk) *DiskServiceUpdateRequest {
	p.disk = disk
	return p
}
func (p *DiskServiceUpdateRequest) Send() (*DiskServiceUpdateResponse, error) {
}

type DiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *DiskServiceUpdateResponse) Disk() *Disk {
	return p.disk
}

//
// This operation updates the disk with the appropriate parameters.
// The only field that can be updated is `qcow_version`.
// For example, update disk can be facilitated using the following request:
// [source]
// ----
// PUT /ovirt-engine/api/disks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <disk>
//   <qcow_version>qcow2_v3</qcow_version>
// </disk>
// ----
// Since the backend operation is asynchronous the disk element which will be returned
// to the user might not be synced with the changed properties.
// This method supports the following parameters:
// `Disk`:: The update to apply to the disk.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskService) Update(
	disk *Disk,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request
	ovResp, err := op.internalUpdate(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *DiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *DiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskService) String() string {
	return fmt.Sprintf("DiskService:%s", op.Path)
}

//
// This service manages the set of disks attached to a template. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>.
//
type TemplateDiskAttachmentsService struct {
	BaseService
}

func NewTemplateDiskAttachmentsService(connection *Connection, path string) *TemplateDiskAttachmentsService {
	var result TemplateDiskAttachmentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateDiskAttachmentsServiceListRequest struct {
	templateDiskAttachmentsService *TemplateDiskAttachmentsService
	header                         map[string]string
	query                          map[string]string
}

func (p *TemplateDiskAttachmentsServiceListRequest) Header(key, value string) *TemplateDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentsServiceListRequest) Query(key, value string) *TemplateDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentsServiceListRequest) Send() (*TemplateDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentsService.Connection.URL(), p.templateDiskAttachmentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateDiskAttachmentsService.Connection.username, p.templateDiskAttachmentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateDiskAttachmentsServiceListResponse TemplateDiskAttachmentsServiceListResponse
	var attachmentsVar DiskAttachments
	xml.Unmarshal(respBodyBytes, &attachmentsVar)
	templateDiskAttachmentsServiceListResponse.attachments = attachmentsVar.DiskAttachments
	return &templateDiskAttachmentsServiceListResponse, nil
}

type TemplateDiskAttachmentsServiceListResponse struct {
	attachments []DiskAttachment
}

func (p *TemplateDiskAttachmentsServiceListResponse) Attachments() []DiskAttachment {
	return p.attachments
}

//
// List the disks that are attached to the template.
//
func (op *TemplateDiskAttachmentsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]DiskAttachment,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var attachmentsVar DiskAttachments
	xml.Unmarshal([]byte(ovResp.Body), &attachmentsVar)
	return attachmentsVar.DiskAttachments, nil
}

//
// Reference to the service that manages a specific attachment.
//
func (op *TemplateDiskAttachmentsService) AttachmentService(id string) *TemplateDiskAttachmentService {
	return NewTemplateDiskAttachmentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskAttachmentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AttachmentService(path)), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *TemplateDiskAttachmentsService) String() string {
	return fmt.Sprintf("TemplateDiskAttachmentsService:%s", op.Path)
}

//
//
type StorageDomainContentDisksService struct {
	BaseService
}

func NewStorageDomainContentDisksService(connection *Connection, path string) *StorageDomainContentDisksService {
	var result StorageDomainContentDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainContentDisksServiceListRequest struct {
	storageDomainContentDisksService *StorageDomainContentDisksService
	header                           map[string]string
	query                            map[string]string
	caseSensitive                    *bool
	max                              *int64
	search                           *string
}

func (p *StorageDomainContentDisksServiceListRequest) Header(key, value string) *StorageDomainContentDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) Query(key, value string) *StorageDomainContentDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) CaseSensitive(caseSensitive bool) *StorageDomainContentDisksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *StorageDomainContentDisksServiceListRequest) Max(max int64) *StorageDomainContentDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainContentDisksServiceListRequest) Search(search string) *StorageDomainContentDisksServiceListRequest {
	p.search = &search
	return p
}
func (p *StorageDomainContentDisksServiceListRequest) Send() (*StorageDomainContentDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDisksService.Connection.URL(), p.storageDomainContentDisksService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainContentDisksService.Connection.username, p.storageDomainContentDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainContentDisksServiceListResponse StorageDomainContentDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	storageDomainContentDisksServiceListResponse.disks = disksVar.Disks
	return &storageDomainContentDisksServiceListResponse, nil
}

type StorageDomainContentDisksServiceListResponse struct {
	disks []Disk
}

func (p *StorageDomainContentDisksServiceListResponse) Disks() []Disk {
	return p.disks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of disks to return. If not specified all the disks are returned.
// `Search`:: A query string used to restrict the returned disks.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainContentDisksService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var disksVar Disks
	xml.Unmarshal([]byte(ovResp.Body), &disksVar)
	return disksVar.Disks, nil
}

//
//
func (op *StorageDomainContentDisksService) DiskService(id string) *StorageDomainContentDiskService {
	return NewStorageDomainContentDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainContentDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainContentDisksService) String() string {
	return fmt.Sprintf("StorageDomainContentDisksService:%s", op.Path)
}

//
// A service to access host devices.
//
type HostDevicesService struct {
	BaseService
}

func NewHostDevicesService(connection *Connection, path string) *HostDevicesService {
	var result HostDevicesService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostDevicesServiceListRequest struct {
	hostDevicesService *HostDevicesService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *HostDevicesServiceListRequest) Header(key, value string) *HostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostDevicesServiceListRequest) Query(key, value string) *HostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostDevicesServiceListRequest) Max(max int64) *HostDevicesServiceListRequest {
	p.max = &max
	return p
}
func (p *HostDevicesServiceListRequest) Send() (*HostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostDevicesService.Connection.URL(), p.hostDevicesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostDevicesService.Connection.username, p.hostDevicesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostDevicesServiceListResponse HostDevicesServiceListResponse
	var devicesVar HostDevices
	xml.Unmarshal(respBodyBytes, &devicesVar)
	hostDevicesServiceListResponse.devices = devicesVar.HostDevices
	return &hostDevicesServiceListResponse, nil
}

type HostDevicesServiceListResponse struct {
	devices []HostDevice
}

func (p *HostDevicesServiceListResponse) Devices() []HostDevice {
	return p.devices
}

//
// List the devices of a host.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of devices to return. If not specified all the devices are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostDevicesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]HostDevice,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var devicesVar HostDevices
	xml.Unmarshal([]byte(ovResp.Body), &devicesVar)
	return devicesVar.HostDevices, nil
}

//
// Reference to the service that can be used to access a specific host device.
//
func (op *HostDevicesService) DeviceService(id string) *HostDeviceService {
	return NewHostDeviceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostDevicesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DeviceService(path)), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *HostDevicesService) String() string {
	return fmt.Sprintf("HostDevicesService:%s", op.Path)
}

//
//
type AssignedNetworksService struct {
	BaseService
}

func NewAssignedNetworksService(connection *Connection, path string) *AssignedNetworksService {
	var result AssignedNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedNetworksServiceAddRequest struct {
	assignedNetworksService *AssignedNetworksService
	header                  map[string]string
	query                   map[string]string
	network                 *Network
}

func (p *AssignedNetworksServiceAddRequest) Header(key, value string) *AssignedNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworksServiceAddRequest) Query(key, value string) *AssignedNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworksServiceAddRequest) Network(network *Network) *AssignedNetworksServiceAddRequest {
	p.network = network
	return p
}
func (p *AssignedNetworksServiceAddRequest) Send() (*AssignedNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworksService.Connection.URL(), p.assignedNetworksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworksService.Connection.username, p.assignedNetworksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedNetworksServiceAddResponse AssignedNetworksServiceAddResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	assignedNetworksServiceAddResponse.network = &networkVar
	return &assignedNetworksServiceAddResponse, nil
}

type AssignedNetworksServiceAddResponse struct {
	network *Network
}

func (p *AssignedNetworksServiceAddResponse) Network() *Network {
	return p.network
}

//
//
func (op *AssignedNetworksService) Add(
	network *Network,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(network, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type AssignedNetworksServiceListRequest struct {
	assignedNetworksService *AssignedNetworksService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *AssignedNetworksServiceListRequest) Header(key, value string) *AssignedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedNetworksServiceListRequest) Query(key, value string) *AssignedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedNetworksServiceListRequest) Max(max int64) *AssignedNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *AssignedNetworksServiceListRequest) Send() (*AssignedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedNetworksService.Connection.URL(), p.assignedNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedNetworksService.Connection.username, p.assignedNetworksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedNetworksServiceListResponse AssignedNetworksServiceListResponse
	var networksVar Networks
	xml.Unmarshal(respBodyBytes, &networksVar)
	assignedNetworksServiceListResponse.networks = networksVar.Networks
	return &assignedNetworksServiceListResponse, nil
}

type AssignedNetworksServiceListResponse struct {
	networks []Network
}

func (p *AssignedNetworksServiceListResponse) Networks() []Network {
	return p.networks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of networks to return. If not specified all the networks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedNetworksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networksVar Networks
	xml.Unmarshal([]byte(ovResp.Body), &networksVar)
	return networksVar.Networks, nil
}

//
//
func (op *AssignedNetworksService) NetworkService(id string) *AssignedNetworkService {
	return NewAssignedNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *AssignedNetworksService) String() string {
	return fmt.Sprintf("AssignedNetworksService:%s", op.Path)
}

//
//
type StorageService struct {
	BaseService
}

func NewStorageService(connection *Connection, path string) *StorageService {
	var result StorageService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServiceGetRequest struct {
	storageService *StorageService
	header         map[string]string
	query          map[string]string
	reportStatus   *bool
}

func (p *StorageServiceGetRequest) Header(key, value string) *StorageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServiceGetRequest) Query(key, value string) *StorageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServiceGetRequest) ReportStatus(reportStatus bool) *StorageServiceGetRequest {
	p.reportStatus = &reportStatus
	return p
}
func (p *StorageServiceGetRequest) Send() (*StorageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageService.Connection.URL(), p.storageService.Path)
	values := make(url.Values)
	if p.reportStatus != nil {
		values["reportStatus"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageService.Connection.username, p.storageService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageServiceGetResponse StorageServiceGetResponse
	var storageVar HostStorage
	xml.Unmarshal(respBodyBytes, &storageVar)
	storageServiceGetResponse.storage = &storageVar
	return &storageServiceGetResponse, nil
}

type StorageServiceGetResponse struct {
	storage *HostStorage
}

func (p *StorageServiceGetResponse) Storage() *HostStorage {
	return p.storage
}

//
// This method supports the following parameters:
// `ReportStatus`:: Indicates if the status of the LUNs in the storage should be checked.
// Checking the status of the LUN is an heavy weight operation and
// this data is not always needed by the user.
// This parameter will give the option to not perform the status check of the LUNs.
// The default is `true` for backward compatibility.
// Here an example with the LUN status :
// [source,xml]
// ----
// <host_storage id="360014051136c20574f743bdbd28177fd">
//   <logical_units>
//     <logical_unit id="360014051136c20574f743bdbd28177fd">
//       <lun_mapping>0</lun_mapping>
//       <paths>1</paths>
//       <product_id>lun0</product_id>
//       <serial>SLIO-ORG_lun0_1136c205-74f7-43bd-bd28-177fd5ce6993</serial>
//       <size>10737418240</size>
//       <status>used</status>
//       <vendor_id>LIO-ORG</vendor_id>
//       <volume_group_id>O9Du7I-RahN-ECe1-dZ1w-nh0b-64io-MNzIBZ</volume_group_id>
//     </logical_unit>
//   </logical_units>
//   <type>iscsi</type>
//   <host id="8bb5ade5-e988-4000-8b93-dbfc6717fe50"/>
// </host_storage>
// ----
// Here an example without the LUN status :
// [source,xml]
// ----
// <host_storage id="360014051136c20574f743bdbd28177fd">
//   <logical_units>
//     <logical_unit id="360014051136c20574f743bdbd28177fd">
//       <lun_mapping>0</lun_mapping>
//       <paths>1</paths>
//       <product_id>lun0</product_id>
//       <serial>SLIO-ORG_lun0_1136c205-74f7-43bd-bd28-177fd5ce6993</serial>
//       <size>10737418240</size>
//       <vendor_id>LIO-ORG</vendor_id>
//       <volume_group_id>O9Du7I-RahN-ECe1-dZ1w-nh0b-64io-MNzIBZ</volume_group_id>
//     </logical_unit>
//   </logical_units>
//   <type>iscsi</type>
//   <host id="8bb5ade5-e988-4000-8b93-dbfc6717fe50"/>
// </host_storage>
// ----
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageService) Get(
	reportStatus bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*HostStorage,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["report_status"] = fmt.Sprintf("%v", reportStatus)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var storageVar HostStorage
	xml.Unmarshal([]byte(ovResp.Body), &storageVar)
	return &storageVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageService) String() string {
	return fmt.Sprintf("StorageService:%s", op.Path)
}

//
//
type UnmanagedNetworkService struct {
	BaseService
}

func NewUnmanagedNetworkService(connection *Connection, path string) *UnmanagedNetworkService {
	var result UnmanagedNetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type UnmanagedNetworkServiceGetRequest struct {
	unmanagedNetworkService *UnmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
}

func (p *UnmanagedNetworkServiceGetRequest) Header(key, value string) *UnmanagedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworkServiceGetRequest) Query(key, value string) *UnmanagedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworkServiceGetRequest) Send() (*UnmanagedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworkService.Connection.URL(), p.unmanagedNetworkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.unmanagedNetworkService.Connection.username, p.unmanagedNetworkService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var unmanagedNetworkServiceGetResponse UnmanagedNetworkServiceGetResponse
	var networkVar UnmanagedNetwork
	xml.Unmarshal(respBodyBytes, &networkVar)
	unmanagedNetworkServiceGetResponse.network = &networkVar
	return &unmanagedNetworkServiceGetResponse, nil
}

type UnmanagedNetworkServiceGetResponse struct {
	network *UnmanagedNetwork
}

func (p *UnmanagedNetworkServiceGetResponse) Network() *UnmanagedNetwork {
	return p.network
}

//
//
func (op *UnmanagedNetworkService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*UnmanagedNetwork,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar UnmanagedNetwork
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type UnmanagedNetworkServiceRemoveRequest struct {
	unmanagedNetworkService *UnmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *UnmanagedNetworkServiceRemoveRequest) Header(key, value string) *UnmanagedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworkServiceRemoveRequest) Query(key, value string) *UnmanagedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworkServiceRemoveRequest) Async(async bool) *UnmanagedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *UnmanagedNetworkServiceRemoveRequest) Send() (*UnmanagedNetworkServiceRemoveResponse, error) {
}

type UnmanagedNetworkServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *UnmanagedNetworkService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UnmanagedNetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *UnmanagedNetworkService) String() string {
	return fmt.Sprintf("UnmanagedNetworkService:%s", op.Path)
}

//
//
type QuotaService struct {
	BaseService
}

func NewQuotaService(connection *Connection, path string) *QuotaService {
	var result QuotaService
	result.Connection = connection
	result.Path = path
	return &result
}

type QuotaServiceGetRequest struct {
	quotaService *QuotaService
	header       map[string]string
	query        map[string]string
}

func (p *QuotaServiceGetRequest) Header(key, value string) *QuotaServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceGetRequest) Query(key, value string) *QuotaServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceGetRequest) Send() (*QuotaServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.Connection.URL(), p.quotaService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.quotaService.Connection.username, p.quotaService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.quotaService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var quotaServiceGetResponse QuotaServiceGetResponse
	var quotaVar Quota
	xml.Unmarshal(respBodyBytes, &quotaVar)
	quotaServiceGetResponse.quota = &quotaVar
	return &quotaServiceGetResponse, nil
}

type QuotaServiceGetResponse struct {
	quota *Quota
}

func (p *QuotaServiceGetResponse) Quota() *Quota {
	return p.quota
}

//
// Retrieves a quota.
// An example of retrieving a quota:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota id="456">
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
//   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
func (op *QuotaService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Quota,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var quotaVar Quota
	xml.Unmarshal([]byte(ovResp.Body), &quotaVar)
	return &quotaVar, nil
}

type QuotaServiceRemoveRequest struct {
	quotaService *QuotaService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *QuotaServiceRemoveRequest) Header(key, value string) *QuotaServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceRemoveRequest) Query(key, value string) *QuotaServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceRemoveRequest) Async(async bool) *QuotaServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *QuotaServiceRemoveRequest) Send() (*QuotaServiceRemoveResponse, error) {
}

type QuotaServiceRemoveResponse struct {
}

//
// Delete a quota.
// An example of deleting a quota:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
// -0472718ab224 HTTP/1.1
// Accept: application/xml
// Content-type: application/xml
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QuotaService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type QuotaServiceUpdateRequest struct {
	quotaService *QuotaService
	header       map[string]string
	query        map[string]string
	async        *bool
	quota        *Quota
}

func (p *QuotaServiceUpdateRequest) Header(key, value string) *QuotaServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceUpdateRequest) Query(key, value string) *QuotaServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceUpdateRequest) Async(async bool) *QuotaServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *QuotaServiceUpdateRequest) Quota(quota *Quota) *QuotaServiceUpdateRequest {
	p.quota = quota
	return p
}
func (p *QuotaServiceUpdateRequest) Send() (*QuotaServiceUpdateResponse, error) {
}

type QuotaServiceUpdateResponse struct {
	quota *Quota
}

func (p *QuotaServiceUpdateResponse) Quota() *Quota {
	return p.quota
}

//
// Updates a quota.
// An example of updating a quota:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota>
//   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
func (op *QuotaService) Update(
	quota *Quota,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Quota,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(quota, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var quotaVar Quota
	xml.Unmarshal([]byte(ovResp.Body), &quotaVar)
	return &quotaVar, nil
}

//
//
func (op *QuotaService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *QuotaService) QuotaClusterLimitsService() *QuotaClusterLimitsService {
	return NewQuotaClusterLimitsService(op.Connection, fmt.Sprintf("%s/quotaclusterlimits", op.Path))
}

//
//
func (op *QuotaService) QuotaStorageLimitsService() *QuotaStorageLimitsService {
	return NewQuotaStorageLimitsService(op.Connection, fmt.Sprintf("%s/quotastoragelimits", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "quotaclusterlimits" {
		return op.QuotaClusterLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotaclusterlimits/") {
		return op.QuotaClusterLimitsService().Service(path[19:])
	}
	if path == "quotastoragelimits" {
		return op.QuotaStorageLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotastoragelimits/") {
		return op.QuotaStorageLimitsService().Service(path[19:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaService) String() string {
	return fmt.Sprintf("QuotaService:%s", op.Path)
}

//
//
type SnapshotDiskService struct {
	BaseService
}

func NewSnapshotDiskService(connection *Connection, path string) *SnapshotDiskService {
	var result SnapshotDiskService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotDiskServiceGetRequest struct {
	snapshotDiskService *SnapshotDiskService
	header              map[string]string
	query               map[string]string
}

func (p *SnapshotDiskServiceGetRequest) Header(key, value string) *SnapshotDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotDiskServiceGetRequest) Query(key, value string) *SnapshotDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotDiskServiceGetRequest) Send() (*SnapshotDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDiskService.Connection.URL(), p.snapshotDiskService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotDiskService.Connection.username, p.snapshotDiskService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotDiskService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotDiskServiceGetResponse SnapshotDiskServiceGetResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	snapshotDiskServiceGetResponse.disk = &diskVar
	return &snapshotDiskServiceGetResponse, nil
}

type SnapshotDiskServiceGetResponse struct {
	disk *Disk
}

func (p *SnapshotDiskServiceGetResponse) Disk() *Disk {
	return p.disk
}

//
//
func (op *SnapshotDiskService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotDiskService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotDiskService) String() string {
	return fmt.Sprintf("SnapshotDiskService:%s", op.Path)
}

//
//
type QossService struct {
	BaseService
}

func NewQossService(connection *Connection, path string) *QossService {
	var result QossService
	result.Connection = connection
	result.Path = path
	return &result
}

type QossServiceAddRequest struct {
	qossService *QossService
	header      map[string]string
	query       map[string]string
	qos         *Qos
}

func (p *QossServiceAddRequest) Header(key, value string) *QossServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QossServiceAddRequest) Query(key, value string) *QossServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QossServiceAddRequest) Qos(qos *Qos) *QossServiceAddRequest {
	p.qos = qos
	return p
}
func (p *QossServiceAddRequest) Send() (*QossServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qossService.Connection.URL(), p.qossService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.qos)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qossService.Connection.username, p.qossService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qossService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var qossServiceAddResponse QossServiceAddResponse
	var qosVar Qos
	xml.Unmarshal(respBodyBytes, &qosVar)
	qossServiceAddResponse.qos = &qosVar
	return &qossServiceAddResponse, nil
}

type QossServiceAddResponse struct {
	qos *Qos
}

func (p *QossServiceAddResponse) Qos() *Qos {
	return p.qos
}

//
//
func (op *QossService) Add(
	qos *Qos,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Qos,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(qos, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var qosVar Qos
	xml.Unmarshal([]byte(ovResp.Body), &qosVar)
	return &qosVar, nil
}

type QossServiceListRequest struct {
	qossService *QossService
	header      map[string]string
	query       map[string]string
	max         *int64
}

func (p *QossServiceListRequest) Header(key, value string) *QossServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QossServiceListRequest) Query(key, value string) *QossServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QossServiceListRequest) Max(max int64) *QossServiceListRequest {
	p.max = &max
	return p
}
func (p *QossServiceListRequest) Send() (*QossServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qossService.Connection.URL(), p.qossService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.qossService.Connection.username, p.qossService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.qossService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var qossServiceListResponse QossServiceListResponse
	var qossVar Qoss
	xml.Unmarshal(respBodyBytes, &qossVar)
	qossServiceListResponse.qoss = qossVar.Qoss
	return &qossServiceListResponse, nil
}

type QossServiceListResponse struct {
	qoss []Qos
}

func (p *QossServiceListResponse) Qoss() []Qos {
	return p.qoss
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of QoS descriptors to return. If not specified all the descriptors are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *QossService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Qos,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var qossVar Qoss
	xml.Unmarshal([]byte(ovResp.Body), &qossVar)
	return qossVar.Qoss, nil
}

//
//
func (op *QossService) QosService(id string) *QosService {
	return NewQosService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QossService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.QosService(path)), nil
	}
	return op.QosService(path[:index]).Service(path[index+1:])
}

func (op *QossService) String() string {
	return fmt.Sprintf("QossService:%s", op.Path)
}

//
// A service managing a network
//
type NetworkService struct {
	BaseService
}

func NewNetworkService(connection *Connection, path string) *NetworkService {
	var result NetworkService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkServiceGetRequest struct {
	networkService *NetworkService
	header         map[string]string
	query          map[string]string
}

func (p *NetworkServiceGetRequest) Header(key, value string) *NetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceGetRequest) Query(key, value string) *NetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceGetRequest) Send() (*NetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkService.Connection.URL(), p.networkService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkService.Connection.username, p.networkService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkServiceGetResponse NetworkServiceGetResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	networkServiceGetResponse.network = &networkVar
	return &networkServiceGetResponse, nil
}

type NetworkServiceGetResponse struct {
	network *Network
}

func (p *NetworkServiceGetResponse) Network() *Network {
	return p.network
}

//
// Gets a logical network.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks/123
// ----
// Will respond:
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/123" id="123">
//   <name>ovirtmgmt</name>
//   <description>Default Management Network</description>
//   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//   <mtu>0</mtu>
//   <stp>false</stp>
//   <usages>
//     <usage>vm</usage>
//   </usages>
//   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
// </network>
// ----
//
func (op *NetworkService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type NetworkServiceRemoveRequest struct {
	networkService *NetworkService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *NetworkServiceRemoveRequest) Header(key, value string) *NetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceRemoveRequest) Query(key, value string) *NetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceRemoveRequest) Async(async bool) *NetworkServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *NetworkServiceRemoveRequest) Send() (*NetworkServiceRemoveResponse, error) {
}

type NetworkServiceRemoveResponse struct {
}

//
// Removes a logical network, or the association of a logical network to a data center.
// For example, to remove the logical network `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123
// ----
// Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
// result as if we would just remove that network. However it might be more specific to say we're removing network
// `456` of data center `123`.
// For example, to remove the association of network `456` to data center `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/networks/456
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworkService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type NetworkServiceUpdateRequest struct {
	networkService *NetworkService
	header         map[string]string
	query          map[string]string
	async          *bool
	network        *Network
}

func (p *NetworkServiceUpdateRequest) Header(key, value string) *NetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceUpdateRequest) Query(key, value string) *NetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceUpdateRequest) Async(async bool) *NetworkServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *NetworkServiceUpdateRequest) Network(network *Network) *NetworkServiceUpdateRequest {
	p.network = network
	return p
}
func (p *NetworkServiceUpdateRequest) Send() (*NetworkServiceUpdateResponse, error) {
}

type NetworkServiceUpdateResponse struct {
	network *Network
}

func (p *NetworkServiceUpdateResponse) Network() *Network {
	return p.network
}

//
// Updates a logical network.
// The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
// For example, to update the description of the logical network `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/networks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <description>My updated description</description>
// </network>
// ----
// The maximum transmission unit of a network is set using a PUT request to
// specify the integer value of the `mtu` attribute.
// For example, to set the maximum transmission unit send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/networks/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <mtu>1500</mtu>
// </network>
// ----
//
func (op *NetworkService) Update(
	network *Network,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(network, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

//
// Reference to the service that manages the network labels assigned to this network.
//
func (op *NetworkService) NetworkLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.Connection, fmt.Sprintf("%s/networklabels", op.Path))
}

//
// Reference to the service that manages the permissions assigned to this network.
//
func (op *NetworkService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Reference to the service that manages the vNIC profiles assigned to this network.
//
func (op *NetworkService) VnicProfilesService() *AssignedVnicProfilesService {
	return NewAssignedVnicProfilesService(op.Connection, fmt.Sprintf("%s/vnicprofiles", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkService) String() string {
	return fmt.Sprintf("NetworkService:%s", op.Path)
}

//
//
type InstanceTypeService struct {
	BaseService
}

func NewInstanceTypeService(connection *Connection, path string) *InstanceTypeService {
	var result InstanceTypeService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeServiceGetRequest struct {
	instanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
}

func (p *InstanceTypeServiceGetRequest) Header(key, value string) *InstanceTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceGetRequest) Query(key, value string) *InstanceTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceGetRequest) Send() (*InstanceTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.Connection.URL(), p.instanceTypeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeService.Connection.username, p.instanceTypeService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeServiceGetResponse InstanceTypeServiceGetResponse
	var instanceTypeVar InstanceType
	xml.Unmarshal(respBodyBytes, &instanceTypeVar)
	instanceTypeServiceGetResponse.instanceType = &instanceTypeVar
	return &instanceTypeServiceGetResponse, nil
}

type InstanceTypeServiceGetResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypeServiceGetResponse) InstanceType() *InstanceType {
	return p.instanceType
}

//
// Get a specific instance type and it's attributes.
// [source]
// ----
// GET /ovirt-engine/api/instancetypes/123
// ----
//
func (op *InstanceTypeService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*InstanceType,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var instanceTypeVar InstanceType
	xml.Unmarshal([]byte(ovResp.Body), &instanceTypeVar)
	return &instanceTypeVar, nil
}

type InstanceTypeServiceRemoveRequest struct {
	instanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *InstanceTypeServiceRemoveRequest) Header(key, value string) *InstanceTypeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceRemoveRequest) Query(key, value string) *InstanceTypeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceRemoveRequest) Async(async bool) *InstanceTypeServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeServiceRemoveRequest) Send() (*InstanceTypeServiceRemoveResponse, error) {
}

type InstanceTypeServiceRemoveResponse struct {
}

//
// Removes a specific instance type from the system.
// If a virtual machine was created using an instance type X after removal of the instance type
// the virtual machine's instance type will be set to `custom`.
// [source]
// ----
// DELETE /ovirt-engine/api/instancetypes/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypeService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type InstanceTypeServiceUpdateRequest struct {
	instanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
	instanceType        *InstanceType
}

func (p *InstanceTypeServiceUpdateRequest) Header(key, value string) *InstanceTypeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceUpdateRequest) Query(key, value string) *InstanceTypeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceUpdateRequest) Async(async bool) *InstanceTypeServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *InstanceTypeServiceUpdateRequest) InstanceType(instanceType *InstanceType) *InstanceTypeServiceUpdateRequest {
	p.instanceType = instanceType
	return p
}
func (p *InstanceTypeServiceUpdateRequest) Send() (*InstanceTypeServiceUpdateResponse, error) {
}

type InstanceTypeServiceUpdateResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypeServiceUpdateResponse) InstanceType() *InstanceType {
	return p.instanceType
}

//
// Update a specific instance type and it's attributes.
// All the attributes are editable after creation.
// If a virtual machine was created using an instance type X and some configuration in instance
// type X was updated, the virtual machine's configuration will be updated automatically by the
// engine.
// [source]
// ----
// PUT /ovirt-engine/api/instancetypes/123
// ----
// For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
// to 2 sockets and 1 core, send a request like this:
// [source, xml]
// ----
// <instance_type>
//   <memory>1073741824</memory>
//   <cpu>
//     <topology>
//       <cores>1</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
// </instance_type>
// ----
//
func (op *InstanceTypeService) Update(
	instanceType *InstanceType,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*InstanceType,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(instanceType, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var instanceTypeVar InstanceType
	xml.Unmarshal([]byte(ovResp.Body), &instanceTypeVar)
	return &instanceTypeVar, nil
}

//
// Reference to the service that manages the graphic consoles that are attached to this
// instance type.
//
func (op *InstanceTypeService) GraphicsConsolesService() *InstanceTypeGraphicsConsolesService {
	return NewInstanceTypeGraphicsConsolesService(op.Connection, fmt.Sprintf("%s/graphicsconsoles", op.Path))
}

//
// Reference to the service that manages the NICs that are attached to this instance type.
//
func (op *InstanceTypeService) NicsService() *InstanceTypeNicsService {
	return NewInstanceTypeNicsService(op.Connection, fmt.Sprintf("%s/nics", op.Path))
}

//
// Reference to the service that manages the watchdogs that are attached to this instance type.
//
func (op *InstanceTypeService) WatchdogsService() *InstanceTypeWatchdogsService {
	return NewInstanceTypeWatchdogsService(op.Connection, fmt.Sprintf("%s/watchdogs", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeService) String() string {
	return fmt.Sprintf("InstanceTypeService:%s", op.Path)
}

//
//
type VirtualFunctionAllowedNetworksService struct {
	BaseService
}

func NewVirtualFunctionAllowedNetworksService(connection *Connection, path string) *VirtualFunctionAllowedNetworksService {
	var result VirtualFunctionAllowedNetworksService
	result.Connection = connection
	result.Path = path
	return &result
}

type VirtualFunctionAllowedNetworksServiceAddRequest struct {
	virtualFunctionAllowedNetworksService *VirtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	network                               *Network
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Header(key, value string) *VirtualFunctionAllowedNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Query(key, value string) *VirtualFunctionAllowedNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Network(network *Network) *VirtualFunctionAllowedNetworksServiceAddRequest {
	p.network = network
	return p
}
func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Send() (*VirtualFunctionAllowedNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.Connection.URL(), p.virtualFunctionAllowedNetworksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.network)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.virtualFunctionAllowedNetworksService.Connection.username, p.virtualFunctionAllowedNetworksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var virtualFunctionAllowedNetworksServiceAddResponse VirtualFunctionAllowedNetworksServiceAddResponse
	var networkVar Network
	xml.Unmarshal(respBodyBytes, &networkVar)
	virtualFunctionAllowedNetworksServiceAddResponse.network = &networkVar
	return &virtualFunctionAllowedNetworksServiceAddResponse, nil
}

type VirtualFunctionAllowedNetworksServiceAddResponse struct {
	network *Network
}

func (p *VirtualFunctionAllowedNetworksServiceAddResponse) Network() *Network {
	return p.network
}

//
//
func (op *VirtualFunctionAllowedNetworksService) Add(
	network *Network,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(network, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networkVar Network
	xml.Unmarshal([]byte(ovResp.Body), &networkVar)
	return &networkVar, nil
}

type VirtualFunctionAllowedNetworksServiceListRequest struct {
	virtualFunctionAllowedNetworksService *VirtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	max                                   *int64
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Header(key, value string) *VirtualFunctionAllowedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Query(key, value string) *VirtualFunctionAllowedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Max(max int64) *VirtualFunctionAllowedNetworksServiceListRequest {
	p.max = &max
	return p
}
func (p *VirtualFunctionAllowedNetworksServiceListRequest) Send() (*VirtualFunctionAllowedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.Connection.URL(), p.virtualFunctionAllowedNetworksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.virtualFunctionAllowedNetworksService.Connection.username, p.virtualFunctionAllowedNetworksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var virtualFunctionAllowedNetworksServiceListResponse VirtualFunctionAllowedNetworksServiceListResponse
	var networksVar Networks
	xml.Unmarshal(respBodyBytes, &networksVar)
	virtualFunctionAllowedNetworksServiceListResponse.networks = networksVar.Networks
	return &virtualFunctionAllowedNetworksServiceListResponse, nil
}

type VirtualFunctionAllowedNetworksServiceListResponse struct {
	networks []Network
}

func (p *VirtualFunctionAllowedNetworksServiceListResponse) Networks() []Network {
	return p.networks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of networks to return. If not specified all the networks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VirtualFunctionAllowedNetworksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Network,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var networksVar Networks
	xml.Unmarshal([]byte(ovResp.Body), &networksVar)
	return networksVar.Networks, nil
}

//
//
func (op *VirtualFunctionAllowedNetworksService) NetworkService(id string) *VirtualFunctionAllowedNetworkService {
	return NewVirtualFunctionAllowedNetworkService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VirtualFunctionAllowedNetworksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NetworkService(path)), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *VirtualFunctionAllowedNetworksService) String() string {
	return fmt.Sprintf("VirtualFunctionAllowedNetworksService:%s", op.Path)
}

//
//
type HostHookService struct {
	BaseService
}

func NewHostHookService(connection *Connection, path string) *HostHookService {
	var result HostHookService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostHookServiceGetRequest struct {
	hostHookService *HostHookService
	header          map[string]string
	query           map[string]string
}

func (p *HostHookServiceGetRequest) Header(key, value string) *HostHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostHookServiceGetRequest) Query(key, value string) *HostHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostHookServiceGetRequest) Send() (*HostHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostHookService.Connection.URL(), p.hostHookService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostHookService.Connection.username, p.hostHookService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostHookServiceGetResponse HostHookServiceGetResponse
	var hookVar Hook
	xml.Unmarshal(respBodyBytes, &hookVar)
	hostHookServiceGetResponse.hook = &hookVar
	return &hostHookServiceGetResponse, nil
}

type HostHookServiceGetResponse struct {
	hook *Hook
}

func (p *HostHookServiceGetResponse) Hook() *Hook {
	return p.hook
}

//
//
func (op *HostHookService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Hook,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hookVar Hook
	xml.Unmarshal([]byte(ovResp.Body), &hookVar)
	return &hookVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostHookService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostHookService) String() string {
	return fmt.Sprintf("HostHookService:%s", op.Path)
}

//
//
type ImagesService struct {
	BaseService
}

func NewImagesService(connection *Connection, path string) *ImagesService {
	var result ImagesService
	result.Connection = connection
	result.Path = path
	return &result
}

type ImagesServiceListRequest struct {
	imagesService *ImagesService
	header        map[string]string
	query         map[string]string
	max           *int64
}

func (p *ImagesServiceListRequest) Header(key, value string) *ImagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImagesServiceListRequest) Query(key, value string) *ImagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImagesServiceListRequest) Max(max int64) *ImagesServiceListRequest {
	p.max = &max
	return p
}
func (p *ImagesServiceListRequest) Send() (*ImagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imagesService.Connection.URL(), p.imagesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.imagesService.Connection.username, p.imagesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.imagesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var imagesServiceListResponse ImagesServiceListResponse
	var imagesVar Images
	xml.Unmarshal(respBodyBytes, &imagesVar)
	imagesServiceListResponse.images = imagesVar.Images
	return &imagesServiceListResponse, nil
}

type ImagesServiceListResponse struct {
	images []Image
}

func (p *ImagesServiceListResponse) Images() []Image {
	return p.images
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of images to return. If not specified all the images are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ImagesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Image,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var imagesVar Images
	xml.Unmarshal([]byte(ovResp.Body), &imagesVar)
	return imagesVar.Images, nil
}

//
//
func (op *ImagesService) ImageService(id string) *ImageService {
	return NewImageService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImagesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ImageService(path)), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *ImagesService) String() string {
	return fmt.Sprintf("ImagesService:%s", op.Path)
}

//
//
type SnapshotCdromsService struct {
	BaseService
}

func NewSnapshotCdromsService(connection *Connection, path string) *SnapshotCdromsService {
	var result SnapshotCdromsService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotCdromsServiceListRequest struct {
	snapshotCdromsService *SnapshotCdromsService
	header                map[string]string
	query                 map[string]string
	max                   *int64
}

func (p *SnapshotCdromsServiceListRequest) Header(key, value string) *SnapshotCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotCdromsServiceListRequest) Query(key, value string) *SnapshotCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotCdromsServiceListRequest) Max(max int64) *SnapshotCdromsServiceListRequest {
	p.max = &max
	return p
}
func (p *SnapshotCdromsServiceListRequest) Send() (*SnapshotCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromsService.Connection.URL(), p.snapshotCdromsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotCdromsService.Connection.username, p.snapshotCdromsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotCdromsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotCdromsServiceListResponse SnapshotCdromsServiceListResponse
	var cdromsVar Cdroms
	xml.Unmarshal(respBodyBytes, &cdromsVar)
	snapshotCdromsServiceListResponse.cdroms = cdromsVar.Cdroms
	return &snapshotCdromsServiceListResponse, nil
}

type SnapshotCdromsServiceListResponse struct {
	cdroms []Cdrom
}

func (p *SnapshotCdromsServiceListResponse) Cdroms() []Cdrom {
	return p.cdroms
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of CDROMS to return. If not specified all the CDROMS are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SnapshotCdromsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Cdrom,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var cdromsVar Cdroms
	xml.Unmarshal([]byte(ovResp.Body), &cdromsVar)
	return cdromsVar.Cdroms, nil
}

//
//
func (op *SnapshotCdromsService) CdromService(id string) *SnapshotCdromService {
	return NewSnapshotCdromService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotCdromsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.CdromService(path)), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotCdromsService) String() string {
	return fmt.Sprintf("SnapshotCdromsService:%s", op.Path)
}

//
//
type BalancesService struct {
	BaseService
}

func NewBalancesService(connection *Connection, path string) *BalancesService {
	var result BalancesService
	result.Connection = connection
	result.Path = path
	return &result
}

type BalancesServiceAddRequest struct {
	balancesService *BalancesService
	header          map[string]string
	query           map[string]string
	balance         *Balance
}

func (p *BalancesServiceAddRequest) Header(key, value string) *BalancesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalancesServiceAddRequest) Query(key, value string) *BalancesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalancesServiceAddRequest) Balance(balance *Balance) *BalancesServiceAddRequest {
	p.balance = balance
	return p
}
func (p *BalancesServiceAddRequest) Send() (*BalancesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.Connection.URL(), p.balancesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.balance)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.balancesService.Connection.username, p.balancesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.balancesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var balancesServiceAddResponse BalancesServiceAddResponse
	var balanceVar Balance
	xml.Unmarshal(respBodyBytes, &balanceVar)
	balancesServiceAddResponse.balance = &balanceVar
	return &balancesServiceAddResponse, nil
}

type BalancesServiceAddResponse struct {
	balance *Balance
}

func (p *BalancesServiceAddResponse) Balance() *Balance {
	return p.balance
}

//
//
func (op *BalancesService) Add(
	balance *Balance,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Balance,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(balance, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var balanceVar Balance
	xml.Unmarshal([]byte(ovResp.Body), &balanceVar)
	return &balanceVar, nil
}

type BalancesServiceListRequest struct {
	balancesService *BalancesService
	header          map[string]string
	query           map[string]string
	filter          *bool
	max             *int64
}

func (p *BalancesServiceListRequest) Header(key, value string) *BalancesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalancesServiceListRequest) Query(key, value string) *BalancesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalancesServiceListRequest) Filter(filter bool) *BalancesServiceListRequest {
	p.filter = &filter
	return p
}
func (p *BalancesServiceListRequest) Max(max int64) *BalancesServiceListRequest {
	p.max = &max
	return p
}
func (p *BalancesServiceListRequest) Send() (*BalancesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.Connection.URL(), p.balancesService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.balancesService.Connection.username, p.balancesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.balancesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var balancesServiceListResponse BalancesServiceListResponse
	var balancesVar Balances
	xml.Unmarshal(respBodyBytes, &balancesVar)
	balancesServiceListResponse.balances = balancesVar.Balances
	return &balancesServiceListResponse, nil
}

type BalancesServiceListResponse struct {
	balances []Balance
}

func (p *BalancesServiceListResponse) Balances() []Balance {
	return p.balances
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of balances to return. If not specified all the balances are returned.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *BalancesService) List(
	filter bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Balance,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var balancesVar Balances
	xml.Unmarshal([]byte(ovResp.Body), &balancesVar)
	return balancesVar.Balances, nil
}

//
//
func (op *BalancesService) BalanceService(id string) *BalanceService {
	return NewBalanceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BalancesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.BalanceService(path)), nil
	}
	return op.BalanceService(path[:index]).Service(path[index+1:])
}

func (op *BalancesService) String() string {
	return fmt.Sprintf("BalancesService:%s", op.Path)
}

//
// A service managing a CD-ROM device on templates.
//
type TemplateCdromService struct {
	BaseService
}

func NewTemplateCdromService(connection *Connection, path string) *TemplateCdromService {
	var result TemplateCdromService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateCdromServiceGetRequest struct {
	templateCdromService *TemplateCdromService
	header               map[string]string
	query                map[string]string
}

func (p *TemplateCdromServiceGetRequest) Header(key, value string) *TemplateCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateCdromServiceGetRequest) Query(key, value string) *TemplateCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateCdromServiceGetRequest) Send() (*TemplateCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromService.Connection.URL(), p.templateCdromService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateCdromService.Connection.username, p.templateCdromService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateCdromService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateCdromServiceGetResponse TemplateCdromServiceGetResponse
	var cdromVar Cdrom
	xml.Unmarshal(respBodyBytes, &cdromVar)
	templateCdromServiceGetResponse.cdrom = &cdromVar
	return &templateCdromServiceGetResponse, nil
}

type TemplateCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *TemplateCdromServiceGetResponse) Cdrom() *Cdrom {
	return p.cdrom
}

//
// Returns the information about this CD-ROM device.
// For example, to get information about the CD-ROM device of template `123` send a request like:
// [source]
// ----
// GET /ovirt-engine/api/templates/123/cdroms/
// ----
//
func (op *TemplateCdromService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Cdrom,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var cdromVar Cdrom
	xml.Unmarshal([]byte(ovResp.Body), &cdromVar)
	return &cdromVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateCdromService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateCdromService) String() string {
	return fmt.Sprintf("TemplateCdromService:%s", op.Path)
}

//
//
type MoveableService struct {
	BaseService
}

func NewMoveableService(connection *Connection, path string) *MoveableService {
	var result MoveableService
	result.Connection = connection
	result.Path = path
	return &result
}

type MoveableServiceMoveRequest struct {
	moveableService *MoveableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *MoveableServiceMoveRequest) Header(key, value string) *MoveableServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MoveableServiceMoveRequest) Query(key, value string) *MoveableServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MoveableServiceMoveRequest) Async(async bool) *MoveableServiceMoveRequest {
	p.async = &async
	return p
}
func (p *MoveableServiceMoveRequest) Send() (*MoveableServiceMoveResponse, error) {
}

type MoveableServiceMoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the move should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *MoveableService) Move(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "move", headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MoveableService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MoveableService) String() string {
	return fmt.Sprintf("MoveableService:%s", op.Path)
}

//
//
type CpuProfileService struct {
	BaseService
}

func NewCpuProfileService(connection *Connection, path string) *CpuProfileService {
	var result CpuProfileService
	result.Connection = connection
	result.Path = path
	return &result
}

type CpuProfileServiceGetRequest struct {
	cpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
}

func (p *CpuProfileServiceGetRequest) Header(key, value string) *CpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceGetRequest) Query(key, value string) *CpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceGetRequest) Send() (*CpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.Connection.URL(), p.cpuProfileService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.cpuProfileService.Connection.username, p.cpuProfileService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var cpuProfileServiceGetResponse CpuProfileServiceGetResponse
	var profileVar CpuProfile
	xml.Unmarshal(respBodyBytes, &profileVar)
	cpuProfileServiceGetResponse.profile = &profileVar
	return &cpuProfileServiceGetResponse, nil
}

type CpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *CpuProfileServiceGetResponse) Profile() *CpuProfile {
	return p.profile
}

//
//
func (op *CpuProfileService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*CpuProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar CpuProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

type CpuProfileServiceRemoveRequest struct {
	cpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *CpuProfileServiceRemoveRequest) Header(key, value string) *CpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceRemoveRequest) Query(key, value string) *CpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceRemoveRequest) Async(async bool) *CpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *CpuProfileServiceRemoveRequest) Send() (*CpuProfileServiceRemoveResponse, error) {
}

type CpuProfileServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *CpuProfileService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type CpuProfileServiceUpdateRequest struct {
	cpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
	profile           *CpuProfile
}

func (p *CpuProfileServiceUpdateRequest) Header(key, value string) *CpuProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceUpdateRequest) Query(key, value string) *CpuProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceUpdateRequest) Async(async bool) *CpuProfileServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *CpuProfileServiceUpdateRequest) Profile(profile *CpuProfile) *CpuProfileServiceUpdateRequest {
	p.profile = profile
	return p
}
func (p *CpuProfileServiceUpdateRequest) Send() (*CpuProfileServiceUpdateResponse, error) {
}

type CpuProfileServiceUpdateResponse struct {
	profile *CpuProfile
}

func (p *CpuProfileServiceUpdateResponse) Profile() *CpuProfile {
	return p.profile
}

//
//
func (op *CpuProfileService) Update(
	profile *CpuProfile,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*CpuProfile,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(profile, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var profileVar CpuProfile
	xml.Unmarshal([]byte(ovResp.Body), &profileVar)
	return &profileVar, nil
}

//
//
func (op *CpuProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CpuProfileService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *CpuProfileService) String() string {
	return fmt.Sprintf("CpuProfileService:%s", op.Path)
}

//
//
type MeasurableService struct {
	BaseService
}

func NewMeasurableService(connection *Connection, path string) *MeasurableService {
	var result MeasurableService
	result.Connection = connection
	result.Path = path
	return &result
}

//
//
func (op *MeasurableService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MeasurableService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MeasurableService) String() string {
	return fmt.Sprintf("MeasurableService:%s", op.Path)
}

//
//
type StorageServerConnectionExtensionService struct {
	BaseService
}

func NewStorageServerConnectionExtensionService(connection *Connection, path string) *StorageServerConnectionExtensionService {
	var result StorageServerConnectionExtensionService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionExtensionServiceGetRequest struct {
	storageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Header(key, value string) *StorageServerConnectionExtensionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Query(key, value string) *StorageServerConnectionExtensionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Send() (*StorageServerConnectionExtensionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.Connection.URL(), p.storageServerConnectionExtensionService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionExtensionService.Connection.username, p.storageServerConnectionExtensionService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageServerConnectionExtensionServiceGetResponse StorageServerConnectionExtensionServiceGetResponse
	var extensionVar StorageConnectionExtension
	xml.Unmarshal(respBodyBytes, &extensionVar)
	storageServerConnectionExtensionServiceGetResponse.extension = &extensionVar
	return &storageServerConnectionExtensionServiceGetResponse, nil
}

type StorageServerConnectionExtensionServiceGetResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceGetResponse) Extension() *StorageConnectionExtension {
	return p.extension
}

//
//
func (op *StorageServerConnectionExtensionService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnectionExtension,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var extensionVar StorageConnectionExtension
	xml.Unmarshal([]byte(ovResp.Body), &extensionVar)
	return &extensionVar, nil
}

type StorageServerConnectionExtensionServiceRemoveRequest struct {
	storageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Header(key, value string) *StorageServerConnectionExtensionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Query(key, value string) *StorageServerConnectionExtensionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Async(async bool) *StorageServerConnectionExtensionServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionExtensionServiceRemoveRequest) Send() (*StorageServerConnectionExtensionServiceRemoveResponse, error) {
}

type StorageServerConnectionExtensionServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageServerConnectionExtensionService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type StorageServerConnectionExtensionServiceUpdateRequest struct {
	storageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
	extension                               *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Header(key, value string) *StorageServerConnectionExtensionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Query(key, value string) *StorageServerConnectionExtensionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Async(async bool) *StorageServerConnectionExtensionServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *StorageServerConnectionExtensionServiceUpdateRequest) Extension(extension *StorageConnectionExtension) *StorageServerConnectionExtensionServiceUpdateRequest {
	p.extension = extension
	return p
}
func (p *StorageServerConnectionExtensionServiceUpdateRequest) Send() (*StorageServerConnectionExtensionServiceUpdateResponse, error) {
}

type StorageServerConnectionExtensionServiceUpdateResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceUpdateResponse) Extension() *StorageConnectionExtension {
	return p.extension
}

//
// Update a storage server connection extension for the given host.
// To update the storage connection `456` of host `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
func (op *StorageServerConnectionExtensionService) Update(
	extension *StorageConnectionExtension,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnectionExtension,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(extension, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var extensionVar StorageConnectionExtension
	xml.Unmarshal([]byte(ovResp.Body), &extensionVar)
	return &extensionVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionExtensionService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageServerConnectionExtensionService) String() string {
	return fmt.Sprintf("StorageServerConnectionExtensionService:%s", op.Path)
}

//
// Provides information about the capabilities of different cluster levels supported by the engine. Version 4.0 of the
// engine supports levels 4.0 and 3.6. Each of these levels support different sets of CPU types, for example. This
// service provides that information.
//
type ClusterLevelsService struct {
	BaseService
}

func NewClusterLevelsService(connection *Connection, path string) *ClusterLevelsService {
	var result ClusterLevelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClusterLevelsServiceListRequest struct {
	clusterLevelsService *ClusterLevelsService
	header               map[string]string
	query                map[string]string
}

func (p *ClusterLevelsServiceListRequest) Header(key, value string) *ClusterLevelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterLevelsServiceListRequest) Query(key, value string) *ClusterLevelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterLevelsServiceListRequest) Send() (*ClusterLevelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelsService.Connection.URL(), p.clusterLevelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clusterLevelsService.Connection.username, p.clusterLevelsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clusterLevelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var clusterLevelsServiceListResponse ClusterLevelsServiceListResponse
	var levelsVar ClusterLevels
	xml.Unmarshal(respBodyBytes, &levelsVar)
	clusterLevelsServiceListResponse.levels = levelsVar.ClusterLevels
	return &clusterLevelsServiceListResponse, nil
}

type ClusterLevelsServiceListResponse struct {
	levels []ClusterLevel
}

func (p *ClusterLevelsServiceListResponse) Levels() []ClusterLevel {
	return p.levels
}

//
// Lists the cluster levels supported by the system.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels
// ----
// This will return a list of available cluster levels.
// [source,xml]
// ----
// <cluster_levels>
//   <cluster_level id="4.0">
//      ...
//   </cluster_level>
//   ...
// </cluster_levels>
// ----
//
func (op *ClusterLevelsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ClusterLevel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var levelsVar ClusterLevels
	xml.Unmarshal([]byte(ovResp.Body), &levelsVar)
	return levelsVar.ClusterLevels, nil
}

//
// Reference to the service that provides information about an specific cluster level.
//
func (op *ClusterLevelsService) LevelService(id string) *ClusterLevelService {
	return NewClusterLevelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterLevelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LevelService(path)), nil
	}
	return op.LevelService(path[:index]).Service(path[index+1:])
}

func (op *ClusterLevelsService) String() string {
	return fmt.Sprintf("ClusterLevelsService:%s", op.Path)
}

//
// This service manages a collection of parameters for network filters.
//
type NetworkFilterParametersService struct {
	BaseService
}

func NewNetworkFilterParametersService(connection *Connection, path string) *NetworkFilterParametersService {
	var result NetworkFilterParametersService
	result.Connection = connection
	result.Path = path
	return &result
}

type NetworkFilterParametersServiceAddRequest struct {
	networkFilterParametersService *NetworkFilterParametersService
	header                         map[string]string
	query                          map[string]string
	parameter                      *NetworkFilterParameter
}

func (p *NetworkFilterParametersServiceAddRequest) Header(key, value string) *NetworkFilterParametersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParametersServiceAddRequest) Query(key, value string) *NetworkFilterParametersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParametersServiceAddRequest) Parameter(parameter *NetworkFilterParameter) *NetworkFilterParametersServiceAddRequest {
	p.parameter = parameter
	return p
}
func (p *NetworkFilterParametersServiceAddRequest) Send() (*NetworkFilterParametersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParametersService.Connection.URL(), p.networkFilterParametersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.parameter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParametersService.Connection.username, p.networkFilterParametersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParametersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkFilterParametersServiceAddResponse NetworkFilterParametersServiceAddResponse
	var parameterVar NetworkFilterParameter
	xml.Unmarshal(respBodyBytes, &parameterVar)
	networkFilterParametersServiceAddResponse.parameter = &parameterVar
	return &networkFilterParametersServiceAddResponse, nil
}

type NetworkFilterParametersServiceAddResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NetworkFilterParametersServiceAddResponse) Parameter() *NetworkFilterParameter {
	return p.parameter
}

//
// Add a network filter parameter.
// For example, to add the parameter for the network filter on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
// This method supports the following parameters:
// `Parameter`:: The network filter parameter that is being added.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *NetworkFilterParametersService) Add(
	parameter *NetworkFilterParameter,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NetworkFilterParameter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(parameter, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var parameterVar NetworkFilterParameter
	xml.Unmarshal([]byte(ovResp.Body), &parameterVar)
	return &parameterVar, nil
}

type NetworkFilterParametersServiceListRequest struct {
	networkFilterParametersService *NetworkFilterParametersService
	header                         map[string]string
	query                          map[string]string
}

func (p *NetworkFilterParametersServiceListRequest) Header(key, value string) *NetworkFilterParametersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterParametersServiceListRequest) Query(key, value string) *NetworkFilterParametersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterParametersServiceListRequest) Send() (*NetworkFilterParametersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterParametersService.Connection.URL(), p.networkFilterParametersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.networkFilterParametersService.Connection.username, p.networkFilterParametersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.networkFilterParametersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var networkFilterParametersServiceListResponse NetworkFilterParametersServiceListResponse
	var parametersVar NetworkFilterParameters
	xml.Unmarshal(respBodyBytes, &parametersVar)
	networkFilterParametersServiceListResponse.parameters = parametersVar.NetworkFilterParameters
	return &networkFilterParametersServiceListResponse, nil
}

type NetworkFilterParametersServiceListResponse struct {
	parameters []NetworkFilterParameter
}

func (p *NetworkFilterParametersServiceListResponse) Parameters() []NetworkFilterParameter {
	return p.parameters
}

//
// Retrieves the representations of the network filter parameters.
//
func (op *NetworkFilterParametersService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]NetworkFilterParameter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var parametersVar NetworkFilterParameters
	xml.Unmarshal([]byte(ovResp.Body), &parametersVar)
	return parametersVar.NetworkFilterParameters, nil
}

//
// Reference to the service that manages a specific network filter parameter.
//
func (op *NetworkFilterParametersService) ParameterService(id string) *NetworkFilterParameterService {
	return NewNetworkFilterParameterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFilterParametersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ParameterService(path)), nil
	}
	return op.ParameterService(path[:index]).Service(path[index+1:])
}

func (op *NetworkFilterParametersService) String() string {
	return fmt.Sprintf("NetworkFilterParametersService:%s", op.Path)
}

//
//
type VmNicsService struct {
	BaseService
}

func NewVmNicsService(connection *Connection, path string) *VmNicsService {
	var result VmNicsService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmNicsServiceAddRequest struct {
	vmNicsService *VmNicsService
	header        map[string]string
	query         map[string]string
	nic           *Nic
}

func (p *VmNicsServiceAddRequest) Header(key, value string) *VmNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicsServiceAddRequest) Query(key, value string) *VmNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicsServiceAddRequest) Nic(nic *Nic) *VmNicsServiceAddRequest {
	p.nic = nic
	return p
}
func (p *VmNicsServiceAddRequest) Send() (*VmNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.Connection.URL(), p.vmNicsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.nic)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicsService.Connection.username, p.vmNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmNicsServiceAddResponse VmNicsServiceAddResponse
	var nicVar Nic
	xml.Unmarshal(respBodyBytes, &nicVar)
	vmNicsServiceAddResponse.nic = &nicVar
	return &vmNicsServiceAddResponse, nil
}

type VmNicsServiceAddResponse struct {
	nic *Nic
}

func (p *VmNicsServiceAddResponse) Nic() *Nic {
	return p.nic
}

//
// Adds a NIC to the virtual machine.
// The following example adds a network interface named `mynic` using `virtio` and the `ovirtmgmt` network to the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/nics
// ----
// [source,xml]
// ----
// <nic>
//   <interface>virtio</interface>
//   <name>mynic</name>
//   <network>
//     <name>ovirtmgmt</name>
//   </network>
// </nic>
// ----
// The following example sends that request using `curl`:
// [source,bash]
// ----
// curl \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --data '
// <nic>
//   <name>mynic</name>
//   <network>
//     <name>ovirtmgmt</name>
//   </network>
// </nic>
// ' \
// https://myengine.example.com/ovirt-engine/api/vms/123/nics
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (op *VmNicsService) Add(
	nic *Nic,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(nic, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicVar Nic
	xml.Unmarshal([]byte(ovResp.Body), &nicVar)
	return &nicVar, nil
}

type VmNicsServiceListRequest struct {
	vmNicsService *VmNicsService
	header        map[string]string
	query         map[string]string
	max           *int64
}

func (p *VmNicsServiceListRequest) Header(key, value string) *VmNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicsServiceListRequest) Query(key, value string) *VmNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicsServiceListRequest) Max(max int64) *VmNicsServiceListRequest {
	p.max = &max
	return p
}
func (p *VmNicsServiceListRequest) Send() (*VmNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.Connection.URL(), p.vmNicsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmNicsService.Connection.username, p.vmNicsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmNicsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmNicsServiceListResponse VmNicsServiceListResponse
	var nicsVar Nics
	xml.Unmarshal(respBodyBytes, &nicsVar)
	vmNicsServiceListResponse.nics = nicsVar.Nics
	return &vmNicsServiceListResponse, nil
}

type VmNicsServiceListResponse struct {
	nics []Nic
}

func (p *VmNicsServiceListResponse) Nics() []Nic {
	return p.nics
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of NICs to return. If not specified all the NICs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmNicsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Nic,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nicsVar Nics
	xml.Unmarshal([]byte(ovResp.Body), &nicsVar)
	return nicsVar.Nics, nil
}

//
//
func (op *VmNicsService) NicService(id string) *VmNicService {
	return NewVmNicService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNicsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.NicService(path)), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *VmNicsService) String() string {
	return fmt.Sprintf("VmNicsService:%s", op.Path)
}

//
//
type VmReportedDevicesService struct {
	BaseService
}

func NewVmReportedDevicesService(connection *Connection, path string) *VmReportedDevicesService {
	var result VmReportedDevicesService
	result.Connection = connection
	result.Path = path
	return &result
}

type VmReportedDevicesServiceListRequest struct {
	vmReportedDevicesService *VmReportedDevicesService
	header                   map[string]string
	query                    map[string]string
	max                      *int64
}

func (p *VmReportedDevicesServiceListRequest) Header(key, value string) *VmReportedDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmReportedDevicesServiceListRequest) Query(key, value string) *VmReportedDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmReportedDevicesServiceListRequest) Max(max int64) *VmReportedDevicesServiceListRequest {
	p.max = &max
	return p
}
func (p *VmReportedDevicesServiceListRequest) Send() (*VmReportedDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDevicesService.Connection.URL(), p.vmReportedDevicesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.vmReportedDevicesService.Connection.username, p.vmReportedDevicesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.vmReportedDevicesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var vmReportedDevicesServiceListResponse VmReportedDevicesServiceListResponse
	var reportedDeviceVar ReportedDevices
	xml.Unmarshal(respBodyBytes, &reportedDeviceVar)
	vmReportedDevicesServiceListResponse.reportedDevice = reportedDeviceVar.ReportedDevices
	return &vmReportedDevicesServiceListResponse, nil
}

type VmReportedDevicesServiceListResponse struct {
	reportedDevice []ReportedDevice
}

func (p *VmReportedDevicesServiceListResponse) ReportedDevice() []ReportedDevice {
	return p.reportedDevice
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of devices to return. If not specified all the devices are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *VmReportedDevicesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ReportedDevice,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var reportedDeviceVar ReportedDevices
	xml.Unmarshal([]byte(ovResp.Body), &reportedDeviceVar)
	return reportedDeviceVar.ReportedDevices, nil
}

//
//
func (op *VmReportedDevicesService) ReportedDeviceService(id string) *VmReportedDeviceService {
	return NewVmReportedDeviceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmReportedDevicesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ReportedDeviceService(path)), nil
	}
	return op.ReportedDeviceService(path[:index]).Service(path[index+1:])
}

func (op *VmReportedDevicesService) String() string {
	return fmt.Sprintf("VmReportedDevicesService:%s", op.Path)
}

//
//
type BalanceService struct {
	BaseService
}

func NewBalanceService(connection *Connection, path string) *BalanceService {
	var result BalanceService
	result.Connection = connection
	result.Path = path
	return &result
}

type BalanceServiceGetRequest struct {
	balanceService *BalanceService
	header         map[string]string
	query          map[string]string
	filter         *bool
}

func (p *BalanceServiceGetRequest) Header(key, value string) *BalanceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalanceServiceGetRequest) Query(key, value string) *BalanceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalanceServiceGetRequest) Filter(filter bool) *BalanceServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *BalanceServiceGetRequest) Send() (*BalanceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balanceService.Connection.URL(), p.balanceService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.balanceService.Connection.username, p.balanceService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.balanceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var balanceServiceGetResponse BalanceServiceGetResponse
	var balanceVar Balance
	xml.Unmarshal(respBodyBytes, &balanceVar)
	balanceServiceGetResponse.balance = &balanceVar
	return &balanceServiceGetResponse, nil
}

type BalanceServiceGetResponse struct {
	balance *Balance
}

func (p *BalanceServiceGetResponse) Balance() *Balance {
	return p.balance
}

//
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *BalanceService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Balance,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var balanceVar Balance
	xml.Unmarshal([]byte(ovResp.Body), &balanceVar)
	return &balanceVar, nil
}

type BalanceServiceRemoveRequest struct {
	balanceService *BalanceService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *BalanceServiceRemoveRequest) Header(key, value string) *BalanceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalanceServiceRemoveRequest) Query(key, value string) *BalanceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalanceServiceRemoveRequest) Async(async bool) *BalanceServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *BalanceServiceRemoveRequest) Send() (*BalanceServiceRemoveResponse, error) {
}

type BalanceServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *BalanceService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BalanceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *BalanceService) String() string {
	return fmt.Sprintf("BalanceService:%s", op.Path)
}

//
// Represents a permits sub-collection of the specific role.
//
type PermitsService struct {
	BaseService
}

func NewPermitsService(connection *Connection, path string) *PermitsService {
	var result PermitsService
	result.Connection = connection
	result.Path = path
	return &result
}

type PermitsServiceAddRequest struct {
	permitsService *PermitsService
	header         map[string]string
	query          map[string]string
	permit         *Permit
}

func (p *PermitsServiceAddRequest) Header(key, value string) *PermitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitsServiceAddRequest) Query(key, value string) *PermitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitsServiceAddRequest) Permit(permit *Permit) *PermitsServiceAddRequest {
	p.permit = permit
	return p
}
func (p *PermitsServiceAddRequest) Send() (*PermitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.Connection.URL(), p.permitsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.permit)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permitsService.Connection.username, p.permitsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var permitsServiceAddResponse PermitsServiceAddResponse
	var permitVar Permit
	xml.Unmarshal(respBodyBytes, &permitVar)
	permitsServiceAddResponse.permit = &permitVar
	return &permitsServiceAddResponse, nil
}

type PermitsServiceAddResponse struct {
	permit *Permit
}

func (p *PermitsServiceAddResponse) Permit() *Permit {
	return p.permit
}

//
// Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
// For example to assign a permit `create_vm` to the role with id `123` send a request like this:
// ....
// POST /ovirt-engine/api/roles/123/permits
// ....
// With a request body like this:
// [source,xml]
// ----
// <permit>
//   <name>create_vm</name>
// </permit>
// ----
// This method supports the following parameters:
// `Permit`:: The permit to add.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *PermitsService) Add(
	permit *Permit,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Permit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(permit, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permitVar Permit
	xml.Unmarshal([]byte(ovResp.Body), &permitVar)
	return &permitVar, nil
}

type PermitsServiceListRequest struct {
	permitsService *PermitsService
	header         map[string]string
	query          map[string]string
	max            *int64
}

func (p *PermitsServiceListRequest) Header(key, value string) *PermitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitsServiceListRequest) Query(key, value string) *PermitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitsServiceListRequest) Max(max int64) *PermitsServiceListRequest {
	p.max = &max
	return p
}
func (p *PermitsServiceListRequest) Send() (*PermitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.Connection.URL(), p.permitsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.permitsService.Connection.username, p.permitsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.permitsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var permitsServiceListResponse PermitsServiceListResponse
	var permitsVar Permits
	xml.Unmarshal(respBodyBytes, &permitsVar)
	permitsServiceListResponse.permits = permitsVar.Permits
	return &permitsServiceListResponse, nil
}

type PermitsServiceListResponse struct {
	permits []Permit
}

func (p *PermitsServiceListResponse) Permits() []Permit {
	return p.permits
}

//
// List the permits of the role.
// For example to list the permits of the role with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits
// ....
// [source,xml]
// ----
// <permits>
//   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
//     <name>change_vm_cd</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
//   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
//     <name>connect_to_vm</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
// </permits>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of permits to return. If not specified all the permits are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *PermitsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Permit,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permitsVar Permits
	xml.Unmarshal([]byte(ovResp.Body), &permitsVar)
	return permitsVar.Permits, nil
}

//
// Sub-resource locator method, returns individual permit resource on which the remainder of the URI is dispatched.
//
func (op *PermitsService) PermitService(id string) *PermitService {
	return NewPermitService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermitsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PermitService(path)), nil
	}
	return op.PermitService(path[:index]).Service(path[index+1:])
}

func (op *PermitsService) String() string {
	return fmt.Sprintf("PermitsService:%s", op.Path)
}

//
//
type StorageDomainTemplatesService struct {
	BaseService
}

func NewStorageDomainTemplatesService(connection *Connection, path string) *StorageDomainTemplatesService {
	var result StorageDomainTemplatesService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainTemplatesServiceListRequest struct {
	storageDomainTemplatesService *StorageDomainTemplatesService
	header                        map[string]string
	query                         map[string]string
	max                           *int64
}

func (p *StorageDomainTemplatesServiceListRequest) Header(key, value string) *StorageDomainTemplatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Query(key, value string) *StorageDomainTemplatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Max(max int64) *StorageDomainTemplatesServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainTemplatesServiceListRequest) Send() (*StorageDomainTemplatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplatesService.Connection.URL(), p.storageDomainTemplatesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainTemplatesService.Connection.username, p.storageDomainTemplatesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainTemplatesServiceListResponse StorageDomainTemplatesServiceListResponse
	var templatesVar Templates
	xml.Unmarshal(respBodyBytes, &templatesVar)
	storageDomainTemplatesServiceListResponse.templates = templatesVar.Templates
	return &storageDomainTemplatesServiceListResponse, nil
}

type StorageDomainTemplatesServiceListResponse struct {
	templates []Template
}

func (p *StorageDomainTemplatesServiceListResponse) Templates() []Template {
	return p.templates
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of templates to return. If not specified all the templates are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainTemplatesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Template,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var templatesVar Templates
	xml.Unmarshal([]byte(ovResp.Body), &templatesVar)
	return templatesVar.Templates, nil
}

//
//
func (op *StorageDomainTemplatesService) TemplateService(id string) *StorageDomainTemplateService {
	return NewStorageDomainTemplateService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainTemplatesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TemplateService(path)), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainTemplatesService) String() string {
	return fmt.Sprintf("StorageDomainTemplatesService:%s", op.Path)
}

//
//
type SystemService struct {
	BaseService
}

func NewSystemService(connection *Connection, path string) *SystemService {
	var result SystemService
	result.Connection = connection
	result.Path = path
	return &result
}

type SystemServiceGetRequest struct {
	systemService *SystemService
	header        map[string]string
	query         map[string]string
}

func (p *SystemServiceGetRequest) Header(key, value string) *SystemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemServiceGetRequest) Query(key, value string) *SystemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemServiceGetRequest) Send() (*SystemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemService.Connection.URL(), p.systemService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.systemService.Connection.username, p.systemService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.systemService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var systemServiceGetResponse SystemServiceGetResponse
	var apiVar Api
	xml.Unmarshal(respBodyBytes, &apiVar)
	systemServiceGetResponse.api = &apiVar
	return &systemServiceGetResponse, nil
}

type SystemServiceGetResponse struct {
	api *Api
}

func (p *SystemServiceGetResponse) Api() *Api {
	return p.api
}

//
// Returns basic information describing the API, like the product name, the version number and a summary of the
// number of relevant objects.
// [source]
// ----
// GET /ovirt-engine/api
// ----
// We get following response:
// [source,xml]
// ----
// <api>
//   <link rel="capabilities" href="/api/capabilities"/>
//   <link rel="clusters" href="/api/clusters"/>
//   <link rel="clusters/search" href="/api/clusters?search={query}"/>
//   <link rel="datacenters" href="/api/datacenters"/>
//   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
//   <link rel="events" href="/api/events"/>
//   <link rel="events/search" href="/api/events?search={query}"/>
//   <link rel="hosts" href="/api/hosts"/>
//   <link rel="hosts/search" href="/api/hosts?search={query}"/>
//   <link rel="networks" href="/api/networks"/>
//   <link rel="roles" href="/api/roles"/>
//   <link rel="storagedomains" href="/api/storagedomains"/>
//   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
//   <link rel="tags" href="/api/tags"/>
//   <link rel="templates" href="/api/templates"/>
//   <link rel="templates/search" href="/api/templates?search={query}"/>
//   <link rel="users" href="/api/users"/>
//   <link rel="groups" href="/api/groups"/>
//   <link rel="domains" href="/api/domains"/>
//   <link rel="vmpools" href="/api/vmpools"/>
//   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
//   <link rel="vms" href="/api/vms"/>
//   <link rel="vms/search" href="/api/vms?search={query}"/>
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>4</build>
//       <full_version>4.0.4</full_version>
//       <major>4</major>
//       <minor>0</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//   </special_objects>
//   <summary>
//     <hosts>
//       <active>0</active>
//       <total>0</total>
//     </hosts>
//     <storage_domains>
//       <active>0</active>
//       <total>1</total>
//     </storage_domains>
//     <users>
//       <active>1</active>
//       <total>1</total>
//     </users>
//     <vms>
//       <active>0</active>
//       <total>0</total>
//     </vms>
//   </summary>
//   <time>2016-09-14T12:00:48.132+02:00</time>
// </api>
// ----
// The entry point provides a user with links to the collections in a
// virtualization environment. The `rel` attribute of each collection link
// provides a reference point for each link.
// The entry point also contains other data such as `product_info`,
// `special_objects` and `summary`.
//
func (op *SystemService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Api,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var apiVar Api
	xml.Unmarshal([]byte(ovResp.Body), &apiVar)
	return &apiVar, nil
}

type SystemServiceReloadConfigurationsRequest struct {
	systemService *SystemService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *SystemServiceReloadConfigurationsRequest) Header(key, value string) *SystemServiceReloadConfigurationsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemServiceReloadConfigurationsRequest) Query(key, value string) *SystemServiceReloadConfigurationsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemServiceReloadConfigurationsRequest) Async(async bool) *SystemServiceReloadConfigurationsRequest {
	p.async = &async
	return p
}
func (p *SystemServiceReloadConfigurationsRequest) Send() (*SystemServiceReloadConfigurationsResponse, error) {
}

type SystemServiceReloadConfigurationsResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the reload should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *SystemService) ReloadConfigurations(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "reloadconfigurations", headers, query, wait)
	return err
}

//
// List all known affinity labels.
//
func (op *SystemService) AffinityLabelsService() *AffinityLabelsService {
	return NewAffinityLabelsService(op.Connection, fmt.Sprintf("%s/affinitylabels", op.Path))
}

//
//
func (op *SystemService) BookmarksService() *BookmarksService {
	return NewBookmarksService(op.Connection, fmt.Sprintf("%s/bookmarks", op.Path))
}

//
// Reference to the service that provides information about the cluster levels supported by the system.
//
func (op *SystemService) ClusterLevelsService() *ClusterLevelsService {
	return NewClusterLevelsService(op.Connection, fmt.Sprintf("%s/clusterlevels", op.Path))
}

//
//
func (op *SystemService) ClustersService() *ClustersService {
	return NewClustersService(op.Connection, fmt.Sprintf("%s/clusters", op.Path))
}

//
//
func (op *SystemService) CpuProfilesService() *CpuProfilesService {
	return NewCpuProfilesService(op.Connection, fmt.Sprintf("%s/cpuprofiles", op.Path))
}

//
//
func (op *SystemService) DataCentersService() *DataCentersService {
	return NewDataCentersService(op.Connection, fmt.Sprintf("%s/datacenters", op.Path))
}

//
//
func (op *SystemService) DiskProfilesService() *DiskProfilesService {
	return NewDiskProfilesService(op.Connection, fmt.Sprintf("%s/diskprofiles", op.Path))
}

//
//
func (op *SystemService) DisksService() *DisksService {
	return NewDisksService(op.Connection, fmt.Sprintf("%s/disks", op.Path))
}

//
//
func (op *SystemService) DomainsService() *DomainsService {
	return NewDomainsService(op.Connection, fmt.Sprintf("%s/domains", op.Path))
}

//
//
func (op *SystemService) EventsService() *EventsService {
	return NewEventsService(op.Connection, fmt.Sprintf("%s/events", op.Path))
}

//
//
func (op *SystemService) ExternalHostProvidersService() *ExternalHostProvidersService {
	return NewExternalHostProvidersService(op.Connection, fmt.Sprintf("%s/externalhostproviders", op.Path))
}

//
// Reference to service facilitating import of external virtual machines.
//
func (op *SystemService) ExternalVmImportsService() *ExternalVmImportsService {
	return NewExternalVmImportsService(op.Connection, fmt.Sprintf("%s/externalvmimports", op.Path))
}

//
//
func (op *SystemService) GroupsService() *GroupsService {
	return NewGroupsService(op.Connection, fmt.Sprintf("%s/groups", op.Path))
}

//
//
func (op *SystemService) HostsService() *HostsService {
	return NewHostsService(op.Connection, fmt.Sprintf("%s/hosts", op.Path))
}

//
//
func (op *SystemService) IconsService() *IconsService {
	return NewIconsService(op.Connection, fmt.Sprintf("%s/icons", op.Path))
}

//
// List of all image transfers being performed for image I/O in oVirt.
//
func (op *SystemService) ImageTransfersService() *ImageTransfersService {
	return NewImageTransfersService(op.Connection, fmt.Sprintf("%s/imagetransfers", op.Path))
}

//
//
func (op *SystemService) InstanceTypesService() *InstanceTypesService {
	return NewInstanceTypesService(op.Connection, fmt.Sprintf("%s/instancetypes", op.Path))
}

//
// List all the jobs monitored by the engine.
//
func (op *SystemService) JobsService() *JobsService {
	return NewJobsService(op.Connection, fmt.Sprintf("%s/jobs", op.Path))
}

//
// List the available Katello errata assigned to the engine.
//
func (op *SystemService) KatelloErrataService() *EngineKatelloErrataService {
	return NewEngineKatelloErrataService(op.Connection, fmt.Sprintf("%s/katelloerrata", op.Path))
}

//
//
func (op *SystemService) MacPoolsService() *MacPoolsService {
	return NewMacPoolsService(op.Connection, fmt.Sprintf("%s/macpools", op.Path))
}

//
// Network filters will enhance the admin ability to manage the network packets traffic from/to the participated
// VMs.
//
func (op *SystemService) NetworkFiltersService() *NetworkFiltersService {
	return NewNetworkFiltersService(op.Connection, fmt.Sprintf("%s/networkfilters", op.Path))
}

//
//
func (op *SystemService) NetworksService() *NetworksService {
	return NewNetworksService(op.Connection, fmt.Sprintf("%s/networks", op.Path))
}

//
//
func (op *SystemService) OpenstackImageProvidersService() *OpenstackImageProvidersService {
	return NewOpenstackImageProvidersService(op.Connection, fmt.Sprintf("%s/openstackimageproviders", op.Path))
}

//
//
func (op *SystemService) OpenstackNetworkProvidersService() *OpenstackNetworkProvidersService {
	return NewOpenstackNetworkProvidersService(op.Connection, fmt.Sprintf("%s/openstacknetworkproviders", op.Path))
}

//
//
func (op *SystemService) OpenstackVolumeProvidersService() *OpenstackVolumeProvidersService {
	return NewOpenstackVolumeProvidersService(op.Connection, fmt.Sprintf("%s/openstackvolumeproviders", op.Path))
}

//
//
func (op *SystemService) OperatingSystemsService() *OperatingSystemsService {
	return NewOperatingSystemsService(op.Connection, fmt.Sprintf("%s/operatingsystems", op.Path))
}

//
//
func (op *SystemService) PermissionsService() *SystemPermissionsService {
	return NewSystemPermissionsService(op.Connection, fmt.Sprintf("%s/permissions", op.Path))
}

//
//
func (op *SystemService) RolesService() *RolesService {
	return NewRolesService(op.Connection, fmt.Sprintf("%s/roles", op.Path))
}

//
//
func (op *SystemService) SchedulingPoliciesService() *SchedulingPoliciesService {
	return NewSchedulingPoliciesService(op.Connection, fmt.Sprintf("%s/schedulingpolicies", op.Path))
}

//
//
func (op *SystemService) SchedulingPolicyUnitsService() *SchedulingPolicyUnitsService {
	return NewSchedulingPolicyUnitsService(op.Connection, fmt.Sprintf("%s/schedulingpolicyunits", op.Path))
}

//
//
func (op *SystemService) StorageConnectionsService() *StorageServerConnectionsService {
	return NewStorageServerConnectionsService(op.Connection, fmt.Sprintf("%s/storageconnections", op.Path))
}

//
//
func (op *SystemService) StorageDomainsService() *StorageDomainsService {
	return NewStorageDomainsService(op.Connection, fmt.Sprintf("%s/storagedomains", op.Path))
}

//
//
func (op *SystemService) TagsService() *TagsService {
	return NewTagsService(op.Connection, fmt.Sprintf("%s/tags", op.Path))
}

//
//
func (op *SystemService) TemplatesService() *TemplatesService {
	return NewTemplatesService(op.Connection, fmt.Sprintf("%s/templates", op.Path))
}

//
//
func (op *SystemService) UsersService() *UsersService {
	return NewUsersService(op.Connection, fmt.Sprintf("%s/users", op.Path))
}

//
//
func (op *SystemService) VmPoolsService() *VmPoolsService {
	return NewVmPoolsService(op.Connection, fmt.Sprintf("%s/vmpools", op.Path))
}

//
//
func (op *SystemService) VmsService() *VmsService {
	return NewVmsService(op.Connection, fmt.Sprintf("%s/vms", op.Path))
}

//
//
func (op *SystemService) VnicProfilesService() *VnicProfilesService {
	return NewVnicProfilesService(op.Connection, fmt.Sprintf("%s/vnicprofiles", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "bookmarks" {
		return op.BookmarksService(), nil
	}
	if strings.HasPrefix(path, "bookmarks/") {
		return op.BookmarksService().Service(path[10:])
	}
	if path == "clusterlevels" {
		return op.ClusterLevelsService(), nil
	}
	if strings.HasPrefix(path, "clusterlevels/") {
		return op.ClusterLevelsService().Service(path[14:])
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "datacenters" {
		return op.DataCentersService(), nil
	}
	if strings.HasPrefix(path, "datacenters/") {
		return op.DataCentersService().Service(path[12:])
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "domains" {
		return op.DomainsService(), nil
	}
	if strings.HasPrefix(path, "domains/") {
		return op.DomainsService().Service(path[8:])
	}
	if path == "events" {
		return op.EventsService(), nil
	}
	if strings.HasPrefix(path, "events/") {
		return op.EventsService().Service(path[7:])
	}
	if path == "externalhostproviders" {
		return op.ExternalHostProvidersService(), nil
	}
	if strings.HasPrefix(path, "externalhostproviders/") {
		return op.ExternalHostProvidersService().Service(path[22:])
	}
	if path == "externalvmimports" {
		return op.ExternalVmImportsService(), nil
	}
	if strings.HasPrefix(path, "externalvmimports/") {
		return op.ExternalVmImportsService().Service(path[18:])
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "icons" {
		return op.IconsService(), nil
	}
	if strings.HasPrefix(path, "icons/") {
		return op.IconsService().Service(path[6:])
	}
	if path == "imagetransfers" {
		return op.ImageTransfersService(), nil
	}
	if strings.HasPrefix(path, "imagetransfers/") {
		return op.ImageTransfersService().Service(path[15:])
	}
	if path == "instancetypes" {
		return op.InstanceTypesService(), nil
	}
	if strings.HasPrefix(path, "instancetypes/") {
		return op.InstanceTypesService().Service(path[14:])
	}
	if path == "jobs" {
		return op.JobsService(), nil
	}
	if strings.HasPrefix(path, "jobs/") {
		return op.JobsService().Service(path[5:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "macpools" {
		return op.MacPoolsService(), nil
	}
	if strings.HasPrefix(path, "macpools/") {
		return op.MacPoolsService().Service(path[9:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "openstackimageproviders" {
		return op.OpenstackImageProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackimageproviders/") {
		return op.OpenstackImageProvidersService().Service(path[24:])
	}
	if path == "openstacknetworkproviders" {
		return op.OpenstackNetworkProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstacknetworkproviders/") {
		return op.OpenstackNetworkProvidersService().Service(path[26:])
	}
	if path == "openstackvolumeproviders" {
		return op.OpenstackVolumeProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackvolumeproviders/") {
		return op.OpenstackVolumeProvidersService().Service(path[25:])
	}
	if path == "operatingsystems" {
		return op.OperatingSystemsService(), nil
	}
	if strings.HasPrefix(path, "operatingsystems/") {
		return op.OperatingSystemsService().Service(path[17:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "schedulingpolicies" {
		return op.SchedulingPoliciesService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicies/") {
		return op.SchedulingPoliciesService().Service(path[19:])
	}
	if path == "schedulingpolicyunits" {
		return op.SchedulingPolicyUnitsService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicyunits/") {
		return op.SchedulingPolicyUnitsService().Service(path[22:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	if path == "vmpools" {
		return op.VmPoolsService(), nil
	}
	if strings.HasPrefix(path, "vmpools/") {
		return op.VmPoolsService().Service(path[8:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SystemService) String() string {
	return fmt.Sprintf("SystemService:%s", op.Path)
}

//
//
type ExternalHostService struct {
	BaseService
}

func NewExternalHostService(connection *Connection, path string) *ExternalHostService {
	var result ExternalHostService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostServiceGetRequest struct {
	externalHostService *ExternalHostService
	header              map[string]string
	query               map[string]string
}

func (p *ExternalHostServiceGetRequest) Header(key, value string) *ExternalHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostServiceGetRequest) Query(key, value string) *ExternalHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostServiceGetRequest) Send() (*ExternalHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostService.Connection.URL(), p.externalHostService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostService.Connection.username, p.externalHostService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalHostServiceGetResponse ExternalHostServiceGetResponse
	var hostVar ExternalHost
	xml.Unmarshal(respBodyBytes, &hostVar)
	externalHostServiceGetResponse.host = &hostVar
	return &externalHostServiceGetResponse, nil
}

type ExternalHostServiceGetResponse struct {
	host *ExternalHost
}

func (p *ExternalHostServiceGetResponse) Host() *ExternalHost {
	return p.host
}

//
//
func (op *ExternalHostService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalHost,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostVar ExternalHost
	xml.Unmarshal([]byte(ovResp.Body), &hostVar)
	return &hostVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostService) String() string {
	return fmt.Sprintf("ExternalHostService:%s", op.Path)
}

//
//
type ExternalHostGroupService struct {
	BaseService
}

func NewExternalHostGroupService(connection *Connection, path string) *ExternalHostGroupService {
	var result ExternalHostGroupService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostGroupServiceGetRequest struct {
	externalHostGroupService *ExternalHostGroupService
	header                   map[string]string
	query                    map[string]string
}

func (p *ExternalHostGroupServiceGetRequest) Header(key, value string) *ExternalHostGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostGroupServiceGetRequest) Query(key, value string) *ExternalHostGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostGroupServiceGetRequest) Send() (*ExternalHostGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupService.Connection.URL(), p.externalHostGroupService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostGroupService.Connection.username, p.externalHostGroupService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostGroupService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalHostGroupServiceGetResponse ExternalHostGroupServiceGetResponse
	var groupVar ExternalHostGroup
	xml.Unmarshal(respBodyBytes, &groupVar)
	externalHostGroupServiceGetResponse.group = &groupVar
	return &externalHostGroupServiceGetResponse, nil
}

type ExternalHostGroupServiceGetResponse struct {
	group *ExternalHostGroup
}

func (p *ExternalHostGroupServiceGetResponse) Group() *ExternalHostGroup {
	return p.group
}

//
//
func (op *ExternalHostGroupService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalHostGroup,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupVar ExternalHostGroup
	xml.Unmarshal([]byte(ovResp.Body), &groupVar)
	return &groupVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostGroupService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostGroupService) String() string {
	return fmt.Sprintf("ExternalHostGroupService:%s", op.Path)
}

//
// A service to manage a Katello erratum.
//
type KatelloErratumService struct {
	BaseService
}

func NewKatelloErratumService(connection *Connection, path string) *KatelloErratumService {
	var result KatelloErratumService
	result.Connection = connection
	result.Path = path
	return &result
}

type KatelloErratumServiceGetRequest struct {
	katelloErratumService *KatelloErratumService
	header                map[string]string
	query                 map[string]string
}

func (p *KatelloErratumServiceGetRequest) Header(key, value string) *KatelloErratumServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *KatelloErratumServiceGetRequest) Query(key, value string) *KatelloErratumServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *KatelloErratumServiceGetRequest) Send() (*KatelloErratumServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.katelloErratumService.Connection.URL(), p.katelloErratumService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.katelloErratumService.Connection.username, p.katelloErratumService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.katelloErratumService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var katelloErratumServiceGetResponse KatelloErratumServiceGetResponse
	var erratumVar KatelloErratum
	xml.Unmarshal(respBodyBytes, &erratumVar)
	katelloErratumServiceGetResponse.erratum = &erratumVar
	return &katelloErratumServiceGetResponse, nil
}

type KatelloErratumServiceGetResponse struct {
	erratum *KatelloErratum
}

func (p *KatelloErratumServiceGetResponse) Erratum() *KatelloErratum {
	return p.erratum
}

//
// Retrieves a Katello erratum.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//   <name>RHBA-2013:XYZ</name>
//   <description>The description of the erratum</description>
//   <title>some bug fix update</title>
//   <type>bugfix</type>
//   <issued>2013-11-20T02:00:00.000+02:00</issued>
//   <solution>Few guidelines regarding the solution</solution>
//   <summary>Updated packages that fix one bug are now available for XYZ</summary>
//   <packages>
//     <package>
//       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//     </package>
//     ...
//   </packages>
// </katello_erratum>
// ----
//
func (op *KatelloErratumService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*KatelloErratum,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var erratumVar KatelloErratum
	xml.Unmarshal([]byte(ovResp.Body), &erratumVar)
	return &erratumVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *KatelloErratumService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *KatelloErratumService) String() string {
	return fmt.Sprintf("KatelloErratumService:%s", op.Path)
}

//
//
type ExternalDiscoveredHostService struct {
	BaseService
}

func NewExternalDiscoveredHostService(connection *Connection, path string) *ExternalDiscoveredHostService {
	var result ExternalDiscoveredHostService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalDiscoveredHostServiceGetRequest struct {
	externalDiscoveredHostService *ExternalDiscoveredHostService
	header                        map[string]string
	query                         map[string]string
}

func (p *ExternalDiscoveredHostServiceGetRequest) Header(key, value string) *ExternalDiscoveredHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalDiscoveredHostServiceGetRequest) Query(key, value string) *ExternalDiscoveredHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalDiscoveredHostServiceGetRequest) Send() (*ExternalDiscoveredHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostService.Connection.URL(), p.externalDiscoveredHostService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalDiscoveredHostService.Connection.username, p.externalDiscoveredHostService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalDiscoveredHostServiceGetResponse ExternalDiscoveredHostServiceGetResponse
	var hostVar ExternalDiscoveredHost
	xml.Unmarshal(respBodyBytes, &hostVar)
	externalDiscoveredHostServiceGetResponse.host = &hostVar
	return &externalDiscoveredHostServiceGetResponse, nil
}

type ExternalDiscoveredHostServiceGetResponse struct {
	host *ExternalDiscoveredHost
}

func (p *ExternalDiscoveredHostServiceGetResponse) Host() *ExternalDiscoveredHost {
	return p.host
}

//
//
func (op *ExternalDiscoveredHostService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalDiscoveredHost,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostVar ExternalDiscoveredHost
	xml.Unmarshal([]byte(ovResp.Body), &hostVar)
	return &hostVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalDiscoveredHostService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalDiscoveredHostService) String() string {
	return fmt.Sprintf("ExternalDiscoveredHostService:%s", op.Path)
}

//
// A service to manage Katello errata assigned to the engine.
// The information is retrieved from Katello.
//
type EngineKatelloErrataService struct {
	BaseService
}

func NewEngineKatelloErrataService(connection *Connection, path string) *EngineKatelloErrataService {
	var result EngineKatelloErrataService
	result.Connection = connection
	result.Path = path
	return &result
}

type EngineKatelloErrataServiceListRequest struct {
	engineKatelloErrataService *EngineKatelloErrataService
	header                     map[string]string
	query                      map[string]string
	max                        *int64
}

func (p *EngineKatelloErrataServiceListRequest) Header(key, value string) *EngineKatelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Query(key, value string) *EngineKatelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Max(max int64) *EngineKatelloErrataServiceListRequest {
	p.max = &max
	return p
}
func (p *EngineKatelloErrataServiceListRequest) Send() (*EngineKatelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.engineKatelloErrataService.Connection.URL(), p.engineKatelloErrataService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.engineKatelloErrataService.Connection.username, p.engineKatelloErrataService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.engineKatelloErrataService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var engineKatelloErrataServiceListResponse EngineKatelloErrataServiceListResponse
	var errataVar KatelloErratums
	xml.Unmarshal(respBodyBytes, &errataVar)
	engineKatelloErrataServiceListResponse.errata = errataVar.KatelloErratums
	return &engineKatelloErrataServiceListResponse, nil
}

type EngineKatelloErrataServiceListResponse struct {
	errata []KatelloErratum
}

func (p *EngineKatelloErrataServiceListResponse) Errata() []KatelloErratum {
	return p.errata
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of errata to return. If not specified all the errata are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *EngineKatelloErrataService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]KatelloErratum,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var errataVar KatelloErratums
	xml.Unmarshal([]byte(ovResp.Body), &errataVar)
	return errataVar.KatelloErratums, nil
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *EngineKatelloErrataService) KatelloErratumService(id string) *KatelloErratumService {
	return NewKatelloErratumService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EngineKatelloErrataService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KatelloErratumService(path)), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *EngineKatelloErrataService) String() string {
	return fmt.Sprintf("EngineKatelloErrataService:%s", op.Path)
}

//
//
type ExternalComputeResourceService struct {
	BaseService
}

func NewExternalComputeResourceService(connection *Connection, path string) *ExternalComputeResourceService {
	var result ExternalComputeResourceService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalComputeResourceServiceGetRequest struct {
	externalComputeResourceService *ExternalComputeResourceService
	header                         map[string]string
	query                          map[string]string
}

func (p *ExternalComputeResourceServiceGetRequest) Header(key, value string) *ExternalComputeResourceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalComputeResourceServiceGetRequest) Query(key, value string) *ExternalComputeResourceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalComputeResourceServiceGetRequest) Send() (*ExternalComputeResourceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourceService.Connection.URL(), p.externalComputeResourceService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalComputeResourceService.Connection.username, p.externalComputeResourceService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalComputeResourceService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalComputeResourceServiceGetResponse ExternalComputeResourceServiceGetResponse
	var resourceVar ExternalComputeResource
	xml.Unmarshal(respBodyBytes, &resourceVar)
	externalComputeResourceServiceGetResponse.resource = &resourceVar
	return &externalComputeResourceServiceGetResponse, nil
}

type ExternalComputeResourceServiceGetResponse struct {
	resource *ExternalComputeResource
}

func (p *ExternalComputeResourceServiceGetResponse) Resource() *ExternalComputeResource {
	return p.resource
}

//
//
func (op *ExternalComputeResourceService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalComputeResource,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var resourceVar ExternalComputeResource
	xml.Unmarshal([]byte(ovResp.Body), &resourceVar)
	return &resourceVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalComputeResourceService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalComputeResourceService) String() string {
	return fmt.Sprintf("ExternalComputeResourceService:%s", op.Path)
}

//
//
type ExternalHostGroupsService struct {
	BaseService
}

func NewExternalHostGroupsService(connection *Connection, path string) *ExternalHostGroupsService {
	var result ExternalHostGroupsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostGroupsServiceListRequest struct {
	externalHostGroupsService *ExternalHostGroupsService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *ExternalHostGroupsServiceListRequest) Header(key, value string) *ExternalHostGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Query(key, value string) *ExternalHostGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Max(max int64) *ExternalHostGroupsServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalHostGroupsServiceListRequest) Send() (*ExternalHostGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupsService.Connection.URL(), p.externalHostGroupsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostGroupsService.Connection.username, p.externalHostGroupsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostGroupsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalHostGroupsServiceListResponse ExternalHostGroupsServiceListResponse
	var groupsVar ExternalHostGroups
	xml.Unmarshal(respBodyBytes, &groupsVar)
	externalHostGroupsServiceListResponse.groups = groupsVar.ExternalHostGroups
	return &externalHostGroupsServiceListResponse, nil
}

type ExternalHostGroupsServiceListResponse struct {
	groups []ExternalHostGroup
}

func (p *ExternalHostGroupsServiceListResponse) Groups() []ExternalHostGroup {
	return p.groups
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of groups to return. If not specified all the groups are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalHostGroupsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ExternalHostGroup,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var groupsVar ExternalHostGroups
	xml.Unmarshal([]byte(ovResp.Body), &groupsVar)
	return groupsVar.ExternalHostGroups, nil
}

//
//
func (op *ExternalHostGroupsService) GroupService(id string) *ExternalHostGroupService {
	return NewExternalHostGroupService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostGroupsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.GroupService(path)), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostGroupsService) String() string {
	return fmt.Sprintf("ExternalHostGroupsService:%s", op.Path)
}

//
//
type ExternalHostProviderService struct {
	BaseService
}

func NewExternalHostProviderService(connection *Connection, path string) *ExternalHostProviderService {
	var result ExternalHostProviderService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostProviderServiceGetRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
}

func (p *ExternalHostProviderServiceGetRequest) Header(key, value string) *ExternalHostProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceGetRequest) Query(key, value string) *ExternalHostProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceGetRequest) Send() (*ExternalHostProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.Connection.URL(), p.externalHostProviderService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProviderService.Connection.username, p.externalHostProviderService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalHostProviderServiceGetResponse ExternalHostProviderServiceGetResponse
	var providerVar ExternalHostProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	externalHostProviderServiceGetResponse.provider = &providerVar
	return &externalHostProviderServiceGetResponse, nil
}

type ExternalHostProviderServiceGetResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProviderServiceGetResponse) Provider() *ExternalHostProvider {
	return p.provider
}

//
//
func (op *ExternalHostProviderService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalHostProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar ExternalHostProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type ExternalHostProviderServiceImportCertificatesRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	certificates                []Certificate
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Header(key, value string) *ExternalHostProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Query(key, value string) *ExternalHostProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Certificates(certificates []Certificate) *ExternalHostProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}
func (p *ExternalHostProviderServiceImportCertificatesRequest) Send() (*ExternalHostProviderServiceImportCertificatesResponse, error) {
}

type ExternalHostProviderServiceImportCertificatesResponse struct {
}

//
//
func (op *ExternalHostProviderService) ImportCertificates(
	certificates []Certificate,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Certificates: certificates,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "importcertificates", headers, query, wait)
	return err
}

type ExternalHostProviderServiceRemoveRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *ExternalHostProviderServiceRemoveRequest) Header(key, value string) *ExternalHostProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceRemoveRequest) Query(key, value string) *ExternalHostProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceRemoveRequest) Async(async bool) *ExternalHostProviderServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *ExternalHostProviderServiceRemoveRequest) Send() (*ExternalHostProviderServiceRemoveResponse, error) {
}

type ExternalHostProviderServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalHostProviderService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type ExternalHostProviderServiceTestConnectivityRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Header(key, value string) *ExternalHostProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Query(key, value string) *ExternalHostProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Async(async bool) *ExternalHostProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}
func (p *ExternalHostProviderServiceTestConnectivityRequest) Send() (*ExternalHostProviderServiceTestConnectivityResponse, error) {
}

type ExternalHostProviderServiceTestConnectivityResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the test should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalHostProviderService) TestConnectivity(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "testconnectivity", headers, query, wait)
	return err
}

type ExternalHostProviderServiceUpdateRequest struct {
	externalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	provider                    *ExternalHostProvider
}

func (p *ExternalHostProviderServiceUpdateRequest) Header(key, value string) *ExternalHostProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Query(key, value string) *ExternalHostProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Async(async bool) *ExternalHostProviderServiceUpdateRequest {
	p.async = &async
	return p
}
func (p *ExternalHostProviderServiceUpdateRequest) Provider(provider *ExternalHostProvider) *ExternalHostProviderServiceUpdateRequest {
	p.provider = provider
	return p
}
func (p *ExternalHostProviderServiceUpdateRequest) Send() (*ExternalHostProviderServiceUpdateResponse, error) {
}

type ExternalHostProviderServiceUpdateResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProviderServiceUpdateResponse) Provider() *ExternalHostProvider {
	return p.provider
}

//
//
func (op *ExternalHostProviderService) Update(
	provider *ExternalHostProvider,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalHostProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request
	ovResp, err := op.internalUpdate(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar ExternalHostProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

//
//
func (op *ExternalHostProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.Connection, fmt.Sprintf("%s/certificates", op.Path))
}

//
//
func (op *ExternalHostProviderService) ComputeResourcesService() *ExternalComputeResourcesService {
	return NewExternalComputeResourcesService(op.Connection, fmt.Sprintf("%s/computeresources", op.Path))
}

//
//
func (op *ExternalHostProviderService) DiscoveredHostsService() *ExternalDiscoveredHostsService {
	return NewExternalDiscoveredHostsService(op.Connection, fmt.Sprintf("%s/discoveredhosts", op.Path))
}

//
//
func (op *ExternalHostProviderService) HostGroupsService() *ExternalHostGroupsService {
	return NewExternalHostGroupsService(op.Connection, fmt.Sprintf("%s/hostgroups", op.Path))
}

//
//
func (op *ExternalHostProviderService) HostsService() *ExternalHostsService {
	return NewExternalHostsService(op.Connection, fmt.Sprintf("%s/hosts", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostProviderService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "computeresources" {
		return op.ComputeResourcesService(), nil
	}
	if strings.HasPrefix(path, "computeresources/") {
		return op.ComputeResourcesService().Service(path[17:])
	}
	if path == "discoveredhosts" {
		return op.DiscoveredHostsService(), nil
	}
	if strings.HasPrefix(path, "discoveredhosts/") {
		return op.DiscoveredHostsService().Service(path[16:])
	}
	if path == "hostgroups" {
		return op.HostGroupsService(), nil
	}
	if strings.HasPrefix(path, "hostgroups/") {
		return op.HostGroupsService().Service(path[11:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostProviderService) String() string {
	return fmt.Sprintf("ExternalHostProviderService:%s", op.Path)
}

//
// A service to manage Katello errata.
// The information is retrieved from Katello.
//
type KatelloErrataService struct {
	BaseService
}

func NewKatelloErrataService(connection *Connection, path string) *KatelloErrataService {
	var result KatelloErrataService
	result.Connection = connection
	result.Path = path
	return &result
}

type KatelloErrataServiceListRequest struct {
	katelloErrataService *KatelloErrataService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *KatelloErrataServiceListRequest) Header(key, value string) *KatelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *KatelloErrataServiceListRequest) Query(key, value string) *KatelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *KatelloErrataServiceListRequest) Max(max int64) *KatelloErrataServiceListRequest {
	p.max = &max
	return p
}
func (p *KatelloErrataServiceListRequest) Send() (*KatelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.katelloErrataService.Connection.URL(), p.katelloErrataService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.katelloErrataService.Connection.username, p.katelloErrataService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.katelloErrataService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var katelloErrataServiceListResponse KatelloErrataServiceListResponse
	var errataVar KatelloErratums
	xml.Unmarshal(respBodyBytes, &errataVar)
	katelloErrataServiceListResponse.errata = errataVar.KatelloErratums
	return &katelloErrataServiceListResponse, nil
}

type KatelloErrataServiceListResponse struct {
	errata []KatelloErratum
}

func (p *KatelloErrataServiceListResponse) Errata() []KatelloErratum {
	return p.errata
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of errata to return. If not specified all the errata are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *KatelloErrataService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]KatelloErratum,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var errataVar KatelloErratums
	xml.Unmarshal([]byte(ovResp.Body), &errataVar)
	return errataVar.KatelloErratums, nil
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *KatelloErrataService) KatelloErratumService(id string) *KatelloErratumService {
	return NewKatelloErratumService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *KatelloErrataService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.KatelloErratumService(path)), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *KatelloErrataService) String() string {
	return fmt.Sprintf("KatelloErrataService:%s", op.Path)
}

//
//
type ExternalDiscoveredHostsService struct {
	BaseService
}

func NewExternalDiscoveredHostsService(connection *Connection, path string) *ExternalDiscoveredHostsService {
	var result ExternalDiscoveredHostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalDiscoveredHostsServiceListRequest struct {
	externalDiscoveredHostsService *ExternalDiscoveredHostsService
	header                         map[string]string
	query                          map[string]string
	max                            *int64
}

func (p *ExternalDiscoveredHostsServiceListRequest) Header(key, value string) *ExternalDiscoveredHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Query(key, value string) *ExternalDiscoveredHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Max(max int64) *ExternalDiscoveredHostsServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalDiscoveredHostsServiceListRequest) Send() (*ExternalDiscoveredHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostsService.Connection.URL(), p.externalDiscoveredHostsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalDiscoveredHostsService.Connection.username, p.externalDiscoveredHostsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalDiscoveredHostsServiceListResponse ExternalDiscoveredHostsServiceListResponse
	var hostsVar ExternalDiscoveredHosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	externalDiscoveredHostsServiceListResponse.hosts = hostsVar.ExternalDiscoveredHosts
	return &externalDiscoveredHostsServiceListResponse, nil
}

type ExternalDiscoveredHostsServiceListResponse struct {
	hosts []ExternalDiscoveredHost
}

func (p *ExternalDiscoveredHostsServiceListResponse) Hosts() []ExternalDiscoveredHost {
	return p.hosts
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of hosts to return. If not specified all the hosts are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalDiscoveredHostsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ExternalDiscoveredHost,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostsVar ExternalDiscoveredHosts
	xml.Unmarshal([]byte(ovResp.Body), &hostsVar)
	return hostsVar.ExternalDiscoveredHosts, nil
}

//
//
func (op *ExternalDiscoveredHostsService) HostService(id string) *ExternalDiscoveredHostService {
	return NewExternalDiscoveredHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalDiscoveredHostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *ExternalDiscoveredHostsService) String() string {
	return fmt.Sprintf("ExternalDiscoveredHostsService:%s", op.Path)
}

//
//
type ExternalHostsService struct {
	BaseService
}

func NewExternalHostsService(connection *Connection, path string) *ExternalHostsService {
	var result ExternalHostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostsServiceListRequest struct {
	externalHostsService *ExternalHostsService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *ExternalHostsServiceListRequest) Header(key, value string) *ExternalHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostsServiceListRequest) Query(key, value string) *ExternalHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostsServiceListRequest) Max(max int64) *ExternalHostsServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalHostsServiceListRequest) Send() (*ExternalHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostsService.Connection.URL(), p.externalHostsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostsService.Connection.username, p.externalHostsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalHostsServiceListResponse ExternalHostsServiceListResponse
	var hostsVar ExternalHosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	externalHostsServiceListResponse.hosts = hostsVar.ExternalHosts
	return &externalHostsServiceListResponse, nil
}

type ExternalHostsServiceListResponse struct {
	hosts []ExternalHost
}

func (p *ExternalHostsServiceListResponse) Hosts() []ExternalHost {
	return p.hosts
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of hosts to return. If not specified all the hosts are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalHostsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ExternalHost,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostsVar ExternalHosts
	xml.Unmarshal([]byte(ovResp.Body), &hostsVar)
	return hostsVar.ExternalHosts, nil
}

//
//
func (op *ExternalHostsService) HostService(id string) *ExternalHostService {
	return NewExternalHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostsService) String() string {
	return fmt.Sprintf("ExternalHostsService:%s", op.Path)
}

//
//
type ExternalComputeResourcesService struct {
	BaseService
}

func NewExternalComputeResourcesService(connection *Connection, path string) *ExternalComputeResourcesService {
	var result ExternalComputeResourcesService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalComputeResourcesServiceListRequest struct {
	externalComputeResourcesService *ExternalComputeResourcesService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *ExternalComputeResourcesServiceListRequest) Header(key, value string) *ExternalComputeResourcesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Query(key, value string) *ExternalComputeResourcesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Max(max int64) *ExternalComputeResourcesServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalComputeResourcesServiceListRequest) Send() (*ExternalComputeResourcesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourcesService.Connection.URL(), p.externalComputeResourcesService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalComputeResourcesService.Connection.username, p.externalComputeResourcesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalComputeResourcesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalComputeResourcesServiceListResponse ExternalComputeResourcesServiceListResponse
	var resourcesVar ExternalComputeResources
	xml.Unmarshal(respBodyBytes, &resourcesVar)
	externalComputeResourcesServiceListResponse.resources = resourcesVar.ExternalComputeResources
	return &externalComputeResourcesServiceListResponse, nil
}

type ExternalComputeResourcesServiceListResponse struct {
	resources []ExternalComputeResource
}

func (p *ExternalComputeResourcesServiceListResponse) Resources() []ExternalComputeResource {
	return p.resources
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of resources to return. If not specified all the resources are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalComputeResourcesService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ExternalComputeResource,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var resourcesVar ExternalComputeResources
	xml.Unmarshal([]byte(ovResp.Body), &resourcesVar)
	return resourcesVar.ExternalComputeResources, nil
}

//
//
func (op *ExternalComputeResourcesService) ResourceService(id string) *ExternalComputeResourceService {
	return NewExternalComputeResourceService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalComputeResourcesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ResourceService(path)), nil
	}
	return op.ResourceService(path[:index]).Service(path[index+1:])
}

func (op *ExternalComputeResourcesService) String() string {
	return fmt.Sprintf("ExternalComputeResourcesService:%s", op.Path)
}

//
//
type ExternalHostProvidersService struct {
	BaseService
}

func NewExternalHostProvidersService(connection *Connection, path string) *ExternalHostProvidersService {
	var result ExternalHostProvidersService
	result.Connection = connection
	result.Path = path
	return &result
}

type ExternalHostProvidersServiceAddRequest struct {
	externalHostProvidersService *ExternalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	provider                     *ExternalHostProvider
}

func (p *ExternalHostProvidersServiceAddRequest) Header(key, value string) *ExternalHostProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProvidersServiceAddRequest) Query(key, value string) *ExternalHostProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProvidersServiceAddRequest) Provider(provider *ExternalHostProvider) *ExternalHostProvidersServiceAddRequest {
	p.provider = provider
	return p
}
func (p *ExternalHostProvidersServiceAddRequest) Send() (*ExternalHostProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.Connection.URL(), p.externalHostProvidersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.provider)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProvidersService.Connection.username, p.externalHostProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalHostProvidersServiceAddResponse ExternalHostProvidersServiceAddResponse
	var providerVar ExternalHostProvider
	xml.Unmarshal(respBodyBytes, &providerVar)
	externalHostProvidersServiceAddResponse.provider = &providerVar
	return &externalHostProvidersServiceAddResponse, nil
}

type ExternalHostProvidersServiceAddResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProvidersServiceAddResponse) Provider() *ExternalHostProvider {
	return p.provider
}

//
//
func (op *ExternalHostProvidersService) Add(
	provider *ExternalHostProvider,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*ExternalHostProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(provider, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providerVar ExternalHostProvider
	xml.Unmarshal([]byte(ovResp.Body), &providerVar)
	return &providerVar, nil
}

type ExternalHostProvidersServiceListRequest struct {
	externalHostProvidersService *ExternalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	max                          *int64
}

func (p *ExternalHostProvidersServiceListRequest) Header(key, value string) *ExternalHostProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Query(key, value string) *ExternalHostProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Max(max int64) *ExternalHostProvidersServiceListRequest {
	p.max = &max
	return p
}
func (p *ExternalHostProvidersServiceListRequest) Send() (*ExternalHostProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.Connection.URL(), p.externalHostProvidersService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.externalHostProvidersService.Connection.username, p.externalHostProvidersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var externalHostProvidersServiceListResponse ExternalHostProvidersServiceListResponse
	var providersVar ExternalHostProviders
	xml.Unmarshal(respBodyBytes, &providersVar)
	externalHostProvidersServiceListResponse.providers = providersVar.ExternalHostProviders
	return &externalHostProvidersServiceListResponse, nil
}

type ExternalHostProvidersServiceListResponse struct {
	providers []ExternalHostProvider
}

func (p *ExternalHostProvidersServiceListResponse) Providers() []ExternalHostProvider {
	return p.providers
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of providers to return. If not specified all the providers are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ExternalHostProvidersService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]ExternalHostProvider,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var providersVar ExternalHostProviders
	xml.Unmarshal([]byte(ovResp.Body), &providersVar)
	return providersVar.ExternalHostProviders, nil
}

//
//
func (op *ExternalHostProvidersService) ProviderService(id string) *ExternalHostProviderService {
	return NewExternalHostProviderService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostProvidersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ProviderService(path)), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostProvidersService) String() string {
	return fmt.Sprintf("ExternalHostProvidersService:%s", op.Path)
}

//
// This service manages a single gluster brick.
//
type GlusterBrickService struct {
	BaseService
}

func NewGlusterBrickService(connection *Connection, path string) *GlusterBrickService {
	var result GlusterBrickService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterBrickServiceGetRequest struct {
	glusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
}

func (p *GlusterBrickServiceGetRequest) Header(key, value string) *GlusterBrickServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceGetRequest) Query(key, value string) *GlusterBrickServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceGetRequest) Send() (*GlusterBrickServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBrickService.Connection.URL(), p.glusterBrickService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBrickService.Connection.username, p.glusterBrickService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterBrickServiceGetResponse GlusterBrickServiceGetResponse
	var brickVar GlusterBrick
	xml.Unmarshal(respBodyBytes, &brickVar)
	glusterBrickServiceGetResponse.brick = &brickVar
	return &glusterBrickServiceGetResponse, nil
}

type GlusterBrickServiceGetResponse struct {
	brick *GlusterBrick
}

func (p *GlusterBrickServiceGetResponse) Brick() *GlusterBrick {
	return p.brick
}

//
// Get details of a brick.
// Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
// the equivalent of running `gluster volume status <volumename> <brickname> detail`.
// For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// Which will return a response body like this:
// [source,xml]
// ----
// <brick id="234">
//   <name>host1:/rhgs/data/brick1</name>
//   <brick_dir>/rhgs/data/brick1</brick_dir>
//   <server_id>111</server_id>
//   <status>up</status>
//   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
//   <fs_name>xfs</fs_name>
//   <gluster_clients>
//     <gluster_client>
//       <bytes_read>2818417648</bytes_read>
//       <bytes_written>1384694844</bytes_written>
//       <client_port>1011</client_port>
//       <host_name>client2</host_name>
//     </gluster_client>
//   </gluster_clients>
//   <memory_pools>
//     <memory_pool>
//       <name>data-server:fd_t</name>
//       <alloc_count>1626348</alloc_count>
//       <cold_count>1020</cold_count>
//       <hot_count>4</hot_count>
//       <max_alloc>23</max_alloc>
//       <max_stdalloc>0</max_stdalloc>
//       <padded_size>140</padded_size>
//       <pool_misses>0</pool_misses>
//     </memory_pool>
//   </memory_pools>
//   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
//   <pid>25589</pid>
//   <port>49155</port>
// </brick>
// ----
//
func (op *GlusterBrickService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GlusterBrick,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var brickVar GlusterBrick
	xml.Unmarshal([]byte(ovResp.Body), &brickVar)
	return &brickVar, nil
}

type GlusterBrickServiceRemoveRequest struct {
	glusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *GlusterBrickServiceRemoveRequest) Header(key, value string) *GlusterBrickServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceRemoveRequest) Query(key, value string) *GlusterBrickServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceRemoveRequest) Async(async bool) *GlusterBrickServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterBrickServiceRemoveRequest) Send() (*GlusterBrickServiceRemoveResponse, error) {
}

type GlusterBrickServiceRemoveResponse struct {
}

//
// Removes a brick.
// Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
// removing a single brick without data migration. To remove multiple bricks and with data migration, use
// <<services/gluster_bricks/methods/migrate, migrate>> instead.
// For example, to delete brick `234` from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBrickService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type GlusterBrickServiceReplaceRequest struct {
	glusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
	force               *bool
}

func (p *GlusterBrickServiceReplaceRequest) Header(key, value string) *GlusterBrickServiceReplaceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Query(key, value string) *GlusterBrickServiceReplaceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Async(async bool) *GlusterBrickServiceReplaceRequest {
	p.async = &async
	return p
}
func (p *GlusterBrickServiceReplaceRequest) Force(force bool) *GlusterBrickServiceReplaceRequest {
	p.force = &force
	return p
}
func (p *GlusterBrickServiceReplaceRequest) Send() (*GlusterBrickServiceReplaceResponse, error) {
}

type GlusterBrickServiceReplaceResponse struct {
}

//
// Replaces this brick with a new one.
// IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
// Use <<services/gluster_bricks/methods/add, add brick(s)>> and
// <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
// This method supports the following parameters:
// `Async`:: Indicates if the replacement should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBrickService) Replace(
	async bool,
	force bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
		Force: &force,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "replace", headers, query, wait)
	return err
}

//
//
func (op *GlusterBrickService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterBrickService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterBrickService) String() string {
	return fmt.Sprintf("GlusterBrickService:%s", op.Path)
}

//
// This service manages a collection of gluster volumes available in a cluster.
//
type GlusterVolumesService struct {
	BaseService
}

func NewGlusterVolumesService(connection *Connection, path string) *GlusterVolumesService {
	var result GlusterVolumesService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterVolumesServiceAddRequest struct {
	glusterVolumesService *GlusterVolumesService
	header                map[string]string
	query                 map[string]string
	volume                *GlusterVolume
}

func (p *GlusterVolumesServiceAddRequest) Header(key, value string) *GlusterVolumesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumesServiceAddRequest) Query(key, value string) *GlusterVolumesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumesServiceAddRequest) Volume(volume *GlusterVolume) *GlusterVolumesServiceAddRequest {
	p.volume = volume
	return p
}
func (p *GlusterVolumesServiceAddRequest) Send() (*GlusterVolumesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.Connection.URL(), p.glusterVolumesService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.volume)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumesService.Connection.username, p.glusterVolumesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterVolumesServiceAddResponse GlusterVolumesServiceAddResponse
	var volumeVar GlusterVolume
	xml.Unmarshal(respBodyBytes, &volumeVar)
	glusterVolumesServiceAddResponse.volume = &volumeVar
	return &glusterVolumesServiceAddResponse, nil
}

type GlusterVolumesServiceAddResponse struct {
	volume *GlusterVolume
}

func (p *GlusterVolumesServiceAddResponse) Volume() *GlusterVolume {
	return p.volume
}

//
// Creates a new gluster volume.
// The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
// `bricks` are required.
// For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/glustervolumes
// ----
// With the following request body:
// [source,xml]
// ----
// <gluster_volume>
//   <name>myvolume</name>
//   <volume_type>replicate</volume_type>
//   <replica_count>3</replica_count>
//   <bricks>
//     <brick>
//       <server_id>server1</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server2</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server3</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//   <bricks>
// </gluster_volume>
// ----
// This method supports the following parameters:
// `Volume`:: The gluster volume definition from which to create the volume is passed as input and the newly created
// volume is returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumesService) Add(
	volume *GlusterVolume,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GlusterVolume,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(volume, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var volumeVar GlusterVolume
	xml.Unmarshal([]byte(ovResp.Body), &volumeVar)
	return &volumeVar, nil
}

type GlusterVolumesServiceListRequest struct {
	glusterVolumesService *GlusterVolumesService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	max                   *int64
	search                *string
}

func (p *GlusterVolumesServiceListRequest) Header(key, value string) *GlusterVolumesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumesServiceListRequest) Query(key, value string) *GlusterVolumesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumesServiceListRequest) CaseSensitive(caseSensitive bool) *GlusterVolumesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *GlusterVolumesServiceListRequest) Max(max int64) *GlusterVolumesServiceListRequest {
	p.max = &max
	return p
}
func (p *GlusterVolumesServiceListRequest) Search(search string) *GlusterVolumesServiceListRequest {
	p.search = &search
	return p
}
func (p *GlusterVolumesServiceListRequest) Send() (*GlusterVolumesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.Connection.URL(), p.glusterVolumesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumesService.Connection.username, p.glusterVolumesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterVolumesServiceListResponse GlusterVolumesServiceListResponse
	var volumesVar GlusterVolumes
	xml.Unmarshal(respBodyBytes, &volumesVar)
	glusterVolumesServiceListResponse.volumes = volumesVar.GlusterVolumes
	return &glusterVolumesServiceListResponse, nil
}

type GlusterVolumesServiceListResponse struct {
	volumes []GlusterVolume
}

func (p *GlusterVolumesServiceListResponse) Volumes() []GlusterVolume {
	return p.volumes
}

//
// Lists all gluster volumes in the cluster.
// For example, to list all Gluster Volumes in cluster `456`, send a request like
// this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of volumes to return. If not specified all the volumes are returned.
// `Search`:: A query string used to restrict the returned volumes.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumesService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]GlusterVolume,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var volumesVar GlusterVolumes
	xml.Unmarshal([]byte(ovResp.Body), &volumesVar)
	return volumesVar.GlusterVolumes, nil
}

//
// Reference to a service managing gluster volume.
//
func (op *GlusterVolumesService) VolumeService(id string) *GlusterVolumeService {
	return NewGlusterVolumeService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterVolumesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VolumeService(path)), nil
	}
	return op.VolumeService(path[:index]).Service(path[index+1:])
}

func (op *GlusterVolumesService) String() string {
	return fmt.Sprintf("GlusterVolumesService:%s", op.Path)
}

//
// This service manages a single gluster volume.
//
type GlusterVolumeService struct {
	BaseService
}

func NewGlusterVolumeService(connection *Connection, path string) *GlusterVolumeService {
	var result GlusterVolumeService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterVolumeServiceGetRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
}

func (p *GlusterVolumeServiceGetRequest) Header(key, value string) *GlusterVolumeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceGetRequest) Query(key, value string) *GlusterVolumeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceGetRequest) Send() (*GlusterVolumeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumeService.Connection.URL(), p.glusterVolumeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterVolumeService.Connection.username, p.glusterVolumeService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterVolumeServiceGetResponse GlusterVolumeServiceGetResponse
	var volumeVar GlusterVolume
	xml.Unmarshal(respBodyBytes, &volumeVar)
	glusterVolumeServiceGetResponse.volume = &volumeVar
	return &glusterVolumeServiceGetResponse, nil
}

type GlusterVolumeServiceGetResponse struct {
	volume *GlusterVolume
}

func (p *GlusterVolumeServiceGetResponse) Volume() *GlusterVolume {
	return p.volume
}

//
// Get the gluster volume details.
// For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This GET request will return the following output:
// [source,xml]
// ----
// <gluster_volume id="123">
//  <name>data</name>
//  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
//  <disperse_count>0</disperse_count>
//  <options>
//    <option>
//      <name>storage.owner-gid</name>
//      <value>36</value>
//    </option>
//    <option>
//      <name>performance.io-cache</name>
//      <value>off</value>
//    </option>
//    <option>
//      <name>cluster.data-self-heal-algorithm</name>
//      <value>full</value>
//    </option>
//  </options>
//  <redundancy_count>0</redundancy_count>
//  <replica_count>3</replica_count>
//  <status>up</status>
//  <stripe_count>0</stripe_count>
//  <transport_types>
//    <transport_type>tcp</transport_type>
//  </transport_types>
//  <volume_type>replicate</volume_type>
//  </gluster_volume>
// ----
//
func (op *GlusterVolumeService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GlusterVolume,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var volumeVar GlusterVolume
	xml.Unmarshal([]byte(ovResp.Body), &volumeVar)
	return &volumeVar, nil
}

type GlusterVolumeServiceGetProfileStatisticsRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Header(key, value string) *GlusterVolumeServiceGetProfileStatisticsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Query(key, value string) *GlusterVolumeServiceGetProfileStatisticsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Send() (*GlusterVolumeServiceGetProfileStatisticsResponse, error) {
}

type GlusterVolumeServiceGetProfileStatisticsResponse struct {
	details *GlusterVolumeProfileDetails
}

func (p *GlusterVolumeServiceGetProfileStatisticsResponse) Details() *GlusterVolumeProfileDetails {
	return p.details
}

//
// Get gluster volume profile statistics.
// For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
// ----
//
func (op *GlusterVolumeService) GetProfileStatistics(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GlusterVolumeProfileDetails,
	error) {
	// Populate the action:
	action := &Action{}

	// Send the request and wait for the response:
	ovResp, err := op.internalAction(action, "getprofilestatistics", headers, query, wait)
	if err != nil {
		return nil, err
	}
	var detailsVar GlusterVolumeProfileDetails
	xml.Unmarshal([]byte(ovResp.Body), &detailsVar)
	return &detailsVar, nil
}

type GlusterVolumeServiceRebalanceRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	fixLayout            *bool
	force                *bool
}

func (p *GlusterVolumeServiceRebalanceRequest) Header(key, value string) *GlusterVolumeServiceRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Query(key, value string) *GlusterVolumeServiceRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Async(async bool) *GlusterVolumeServiceRebalanceRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceRebalanceRequest) FixLayout(fixLayout bool) *GlusterVolumeServiceRebalanceRequest {
	p.fixLayout = &fixLayout
	return p
}
func (p *GlusterVolumeServiceRebalanceRequest) Force(force bool) *GlusterVolumeServiceRebalanceRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceRebalanceRequest) Send() (*GlusterVolumeServiceRebalanceResponse, error) {
}

type GlusterVolumeServiceRebalanceResponse struct {
}

//
// Rebalance the gluster volume.
// Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
// shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
// non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
// least one of the bricks in the replica should be online.
// For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
// ----
// This method supports the following parameters:
// `FixLayout`:: If set to true, rebalance will only fix the layout so that new data added to the volume is distributed
// across all the hosts. But it will not migrate/rebalance the existing data. Default is `false`.
// `Force`:: Indicates if the rebalance should be force started. The rebalance command can be executed with the force
// option even when the older clients are connected to the cluster. However, this could lead to a data loss
// situation. Default is `false`.
// `Async`:: Indicates if the rebalance should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) Rebalance(
	async bool,
	fixLayout bool,
	force bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:     &async,
		FixLayout: &fixLayout,
		Force:     &force,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "rebalance", headers, query, wait)
	return err
}

type GlusterVolumeServiceRemoveRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceRemoveRequest) Header(key, value string) *GlusterVolumeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceRemoveRequest) Query(key, value string) *GlusterVolumeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceRemoveRequest) Async(async bool) *GlusterVolumeServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceRemoveRequest) Send() (*GlusterVolumeServiceRemoveResponse, error) {
}

type GlusterVolumeServiceRemoveResponse struct {
}

//
// Removes the gluster volume.
// For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type GlusterVolumeServiceResetAllOptionsRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Header(key, value string) *GlusterVolumeServiceResetAllOptionsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Query(key, value string) *GlusterVolumeServiceResetAllOptionsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Async(async bool) *GlusterVolumeServiceResetAllOptionsRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceResetAllOptionsRequest) Send() (*GlusterVolumeServiceResetAllOptionsResponse, error) {
}

type GlusterVolumeServiceResetAllOptionsResponse struct {
}

//
// Resets all the options set in the gluster volume.
// For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the reset should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) ResetAllOptions(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "resetalloptions", headers, query, wait)
	return err
}

type GlusterVolumeServiceResetOptionRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
	option               *Option
}

func (p *GlusterVolumeServiceResetOptionRequest) Header(key, value string) *GlusterVolumeServiceResetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Query(key, value string) *GlusterVolumeServiceResetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Async(async bool) *GlusterVolumeServiceResetOptionRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceResetOptionRequest) Force(force bool) *GlusterVolumeServiceResetOptionRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceResetOptionRequest) Option(option *Option) *GlusterVolumeServiceResetOptionRequest {
	p.option = option
	return p
}
func (p *GlusterVolumeServiceResetOptionRequest) Send() (*GlusterVolumeServiceResetOptionResponse, error) {
}

type GlusterVolumeServiceResetOptionResponse struct {
}

//
// Resets a particular option in the gluster volume.
// For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1"/>
// </action>
// ----
// This method supports the following parameters:
// `Option`:: Option to reset.
// `Async`:: Indicates if the reset should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) ResetOption(
	async bool,
	force bool,
	option *Option,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Force:  &force,
		Option: option,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "resetoption", headers, query, wait)
	return err
}

type GlusterVolumeServiceSetOptionRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	option               *Option
}

func (p *GlusterVolumeServiceSetOptionRequest) Header(key, value string) *GlusterVolumeServiceSetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Query(key, value string) *GlusterVolumeServiceSetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Async(async bool) *GlusterVolumeServiceSetOptionRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceSetOptionRequest) Option(option *Option) *GlusterVolumeServiceSetOptionRequest {
	p.option = option
	return p
}
func (p *GlusterVolumeServiceSetOptionRequest) Send() (*GlusterVolumeServiceSetOptionResponse, error) {
}

type GlusterVolumeServiceSetOptionResponse struct {
}

//
// Sets a particular option in the gluster volume.
// For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1" value="value1"/>
// </action>
// ----
// This method supports the following parameters:
// `Option`:: Option to set.
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) SetOption(
	async bool,
	option *Option,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Option: option,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "setoption", headers, query, wait)
	return err
}

type GlusterVolumeServiceStartRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *GlusterVolumeServiceStartRequest) Header(key, value string) *GlusterVolumeServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStartRequest) Query(key, value string) *GlusterVolumeServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStartRequest) Async(async bool) *GlusterVolumeServiceStartRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStartRequest) Force(force bool) *GlusterVolumeServiceStartRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceStartRequest) Send() (*GlusterVolumeServiceStartResponse, error) {
}

type GlusterVolumeServiceStartResponse struct {
}

//
// Starts the gluster volume.
// A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
// `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
// ----
// This method supports the following parameters:
// `Force`:: Indicates if the volume should be force started. If a gluster volume is started already but few/all bricks
// are down then force start can be used to bring all the bricks up. Default is `false`.
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) Start(
	async bool,
	force bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
		Force: &force,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "start", headers, query, wait)
	return err
}

type GlusterVolumeServiceStartProfileRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStartProfileRequest) Header(key, value string) *GlusterVolumeServiceStartProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStartProfileRequest) Query(key, value string) *GlusterVolumeServiceStartProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStartProfileRequest) Async(async bool) *GlusterVolumeServiceStartProfileRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStartProfileRequest) Send() (*GlusterVolumeServiceStartProfileResponse, error) {
}

type GlusterVolumeServiceStartProfileResponse struct {
}

//
// Start profiling the gluster volume.
// For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) StartProfile(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "startprofile", headers, query, wait)
	return err
}

type GlusterVolumeServiceStopRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *GlusterVolumeServiceStopRequest) Header(key, value string) *GlusterVolumeServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRequest) Query(key, value string) *GlusterVolumeServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRequest) Async(async bool) *GlusterVolumeServiceStopRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStopRequest) Force(force bool) *GlusterVolumeServiceStopRequest {
	p.force = &force
	return p
}
func (p *GlusterVolumeServiceStopRequest) Send() (*GlusterVolumeServiceStopResponse, error) {
}

type GlusterVolumeServiceStopResponse struct {
}

//
// Stops the gluster volume.
// Stopping a volume will make its data inaccessible.
// For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) Stop(
	async bool,
	force bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
		Force: &force,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "stop", headers, query, wait)
	return err
}

type GlusterVolumeServiceStopProfileRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStopProfileRequest) Header(key, value string) *GlusterVolumeServiceStopProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopProfileRequest) Query(key, value string) *GlusterVolumeServiceStopProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopProfileRequest) Async(async bool) *GlusterVolumeServiceStopProfileRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStopProfileRequest) Send() (*GlusterVolumeServiceStopProfileResponse, error) {
}

type GlusterVolumeServiceStopProfileResponse struct {
}

//
// Stop profiling the gluster volume.
// For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) StopProfile(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "stopprofile", headers, query, wait)
	return err
}

type GlusterVolumeServiceStopRebalanceRequest struct {
	glusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Header(key, value string) *GlusterVolumeServiceStopRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Query(key, value string) *GlusterVolumeServiceStopRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Async(async bool) *GlusterVolumeServiceStopRebalanceRequest {
	p.async = &async
	return p
}
func (p *GlusterVolumeServiceStopRebalanceRequest) Send() (*GlusterVolumeServiceStopRebalanceResponse, error) {
}

type GlusterVolumeServiceStopRebalanceResponse struct {
}

//
// Stop rebalancing the gluster volume.
// For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
// ----
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterVolumeService) StopRebalance(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "stoprebalance", headers, query, wait)
	return err
}

//
// Reference to a service managing gluster bricks.
//
func (op *GlusterVolumeService) GlusterBricksService() *GlusterBricksService {
	return NewGlusterBricksService(op.Connection, fmt.Sprintf("%s/glusterbricks", op.Path))
}

//
//
func (op *GlusterVolumeService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterVolumeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "glusterbricks" {
		return op.GlusterBricksService(), nil
	}
	if strings.HasPrefix(path, "glusterbricks/") {
		return op.GlusterBricksService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterVolumeService) String() string {
	return fmt.Sprintf("GlusterVolumeService:%s", op.Path)
}

//
//
type GlusterHookService struct {
	BaseService
}

func NewGlusterHookService(connection *Connection, path string) *GlusterHookService {
	var result GlusterHookService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterHookServiceDisableRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceDisableRequest) Header(key, value string) *GlusterHookServiceDisableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceDisableRequest) Query(key, value string) *GlusterHookServiceDisableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceDisableRequest) Async(async bool) *GlusterHookServiceDisableRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceDisableRequest) Send() (*GlusterHookServiceDisableResponse, error) {
}

type GlusterHookServiceDisableResponse struct {
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterHookService) Disable(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "disable", headers, query, wait)
	return err
}

type GlusterHookServiceEnableRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceEnableRequest) Header(key, value string) *GlusterHookServiceEnableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceEnableRequest) Query(key, value string) *GlusterHookServiceEnableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceEnableRequest) Async(async bool) *GlusterHookServiceEnableRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceEnableRequest) Send() (*GlusterHookServiceEnableResponse, error) {
}

type GlusterHookServiceEnableResponse struct {
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterHookService) Enable(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async: &async,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "enable", headers, query, wait)
	return err
}

type GlusterHookServiceGetRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
}

func (p *GlusterHookServiceGetRequest) Header(key, value string) *GlusterHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceGetRequest) Query(key, value string) *GlusterHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceGetRequest) Send() (*GlusterHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHookService.Connection.URL(), p.glusterHookService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHookService.Connection.username, p.glusterHookService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHookService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterHookServiceGetResponse GlusterHookServiceGetResponse
	var hookVar GlusterHook
	xml.Unmarshal(respBodyBytes, &hookVar)
	glusterHookServiceGetResponse.hook = &hookVar
	return &glusterHookServiceGetResponse, nil
}

type GlusterHookServiceGetResponse struct {
	hook *GlusterHook
}

func (p *GlusterHookServiceGetResponse) Hook() *GlusterHook {
	return p.hook
}

//
//
func (op *GlusterHookService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GlusterHook,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hookVar GlusterHook
	xml.Unmarshal([]byte(ovResp.Body), &hookVar)
	return &hookVar, nil
}

type GlusterHookServiceRemoveRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceRemoveRequest) Header(key, value string) *GlusterHookServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceRemoveRequest) Query(key, value string) *GlusterHookServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceRemoveRequest) Async(async bool) *GlusterHookServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceRemoveRequest) Send() (*GlusterHookServiceRemoveResponse, error) {
}

type GlusterHookServiceRemoveResponse struct {
}

//
// Removes the this Gluster hook from all servers in cluster and deletes it from the database.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterHookService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type GlusterHookServiceResolveRequest struct {
	glusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
	host               *Host
	resolutionType     *string
}

func (p *GlusterHookServiceResolveRequest) Header(key, value string) *GlusterHookServiceResolveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceResolveRequest) Query(key, value string) *GlusterHookServiceResolveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceResolveRequest) Async(async bool) *GlusterHookServiceResolveRequest {
	p.async = &async
	return p
}
func (p *GlusterHookServiceResolveRequest) Host(host *Host) *GlusterHookServiceResolveRequest {
	p.host = host
	return p
}
func (p *GlusterHookServiceResolveRequest) ResolutionType(resolutionType string) *GlusterHookServiceResolveRequest {
	p.resolutionType = &resolutionType
	return p
}
func (p *GlusterHookServiceResolveRequest) Send() (*GlusterHookServiceResolveResponse, error) {
}

type GlusterHookServiceResolveResponse struct {
}

//
// Resolves missing hook conflict depending on the resolution type.
// For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
// engine maintains a list of all servers where hook is missing.
// For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
// the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
// id is passed as parameter, the hook content from the server is used as the master to copy to other servers
// in cluster.
// This method supports the following parameters:
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterHookService) Resolve(
	async bool,
	host *Host,
	resolutionType string,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:          &async,
		Host:           host,
		ResolutionType: &resolutionType,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "resolve", headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterHookService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterHookService) String() string {
	return fmt.Sprintf("GlusterHookService:%s", op.Path)
}

//
// This service manages the gluster bricks in a gluster volume
//
type GlusterBricksService struct {
	BaseService
}

func NewGlusterBricksService(connection *Connection, path string) *GlusterBricksService {
	var result GlusterBricksService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterBricksServiceActivateRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
}

func (p *GlusterBricksServiceActivateRequest) Header(key, value string) *GlusterBricksServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceActivateRequest) Query(key, value string) *GlusterBricksServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceActivateRequest) Async(async bool) *GlusterBricksServiceActivateRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceActivateRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceActivateRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceActivateRequest) Send() (*GlusterBricksServiceActivateResponse, error) {
}

type GlusterBricksServiceActivateResponse struct {
}

//
// Activate the bricks post data migration of remove brick operation.
// Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
// bricks. The bricks that were previously marked for removal will now be used as normal bricks.
// For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// This method supports the following parameters:
// `Bricks`:: The list of bricks that need to be re-activated.
// `Async`:: Indicates if the activation should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBricksService) Activate(
	async bool,
	bricks []GlusterBrick,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Bricks: bricks,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "activate", headers, query, wait)
	return err
}

type GlusterBricksServiceAddRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	bricks               []GlusterBrick
	replicaCount         *int64
	stripeCount          *int64
}

func (p *GlusterBricksServiceAddRequest) Header(key, value string) *GlusterBricksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceAddRequest) Query(key, value string) *GlusterBricksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceAddRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceAddRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceAddRequest) ReplicaCount(replicaCount int64) *GlusterBricksServiceAddRequest {
	p.replicaCount = &replicaCount
	return p
}
func (p *GlusterBricksServiceAddRequest) StripeCount(stripeCount int64) *GlusterBricksServiceAddRequest {
	p.stripeCount = &stripeCount
	return p
}
func (p *GlusterBricksServiceAddRequest) Send() (*GlusterBricksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	values := make(url.Values)
	if p.replicaCount != nil {
		values["replicaCount"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}
	if p.stripeCount != nil {
		values["stripeCount"] = []string{fmt.Sprintf("%v", *p.stripeCount)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.bricks)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterBricksServiceAddResponse GlusterBricksServiceAddResponse
	var bricksVar GlusterBricks
	xml.Unmarshal(respBodyBytes, &bricksVar)
	glusterBricksServiceAddResponse.bricks = bricksVar.GlusterBricks
	return &glusterBricksServiceAddResponse, nil
}

type GlusterBricksServiceAddResponse struct {
	bricks []GlusterBrick
}

func (p *GlusterBricksServiceAddResponse) Bricks() []GlusterBrick {
	return p.bricks
}

//
// Adds a list of bricks to gluster volume.
// Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
// needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
// equivalent to the number of replica sets.
// For example, to add bricks to gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <server_id>111</server_id>
//     <brick_dir>/export/data/brick3</brick_dir>
//   </brick>
// </bricks>
// ----
// This method supports the following parameters:
// `Bricks`:: The list of bricks to be added to the volume
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBricksService) Add(
	bricks []GlusterBrick,
	replicaCount int64,
	stripeCount int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]GlusterBrick,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["replica_count"] = fmt.Sprintf("%v", replicaCount)
	query["stripe_count"] = fmt.Sprintf("%v", stripeCount)

	// Send the request and get the response
	ovResp, err := op.internalAdd(bricks, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bricksVar GlusterBricks
	xml.Unmarshal([]byte(ovResp.Body), &bricksVar)
	return bricksVar.GlusterBricks, nil
}

type GlusterBricksServiceListRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *GlusterBricksServiceListRequest) Header(key, value string) *GlusterBricksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceListRequest) Query(key, value string) *GlusterBricksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceListRequest) Max(max int64) *GlusterBricksServiceListRequest {
	p.max = &max
	return p
}
func (p *GlusterBricksServiceListRequest) Send() (*GlusterBricksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.Connection.URL(), p.glusterBricksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterBricksService.Connection.username, p.glusterBricksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterBricksServiceListResponse GlusterBricksServiceListResponse
	var bricksVar GlusterBricks
	xml.Unmarshal(respBodyBytes, &bricksVar)
	glusterBricksServiceListResponse.bricks = bricksVar.GlusterBricks
	return &glusterBricksServiceListResponse, nil
}

type GlusterBricksServiceListResponse struct {
	bricks []GlusterBrick
}

func (p *GlusterBricksServiceListResponse) Bricks() []GlusterBrick {
	return p.bricks
}

//
// Lists the bricks of a gluster volume.
// For example, to list bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// Provides an output as below:
// [source,xml]
// ----
// <bricks>
//   <brick id="234">
//     <name>host1:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>111</server_id>
//     <status>up</status>
//   </brick>
//   <brick id="233">
//     <name>host2:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>222</server_id>
//     <status>up</status>
//   </brick>
// </bricks>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of bricks to return. If not specified all the bricks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBricksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]GlusterBrick,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var bricksVar GlusterBricks
	xml.Unmarshal([]byte(ovResp.Body), &bricksVar)
	return bricksVar.GlusterBricks, nil
}

type GlusterBricksServiceMigrateRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
}

func (p *GlusterBricksServiceMigrateRequest) Header(key, value string) *GlusterBricksServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Query(key, value string) *GlusterBricksServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Async(async bool) *GlusterBricksServiceMigrateRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceMigrateRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceMigrateRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceMigrateRequest) Send() (*GlusterBricksServiceMigrateResponse, error) {
}

type GlusterBricksServiceMigrateResponse struct {
}

//
// Start migration of data prior to removing bricks.
// Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
// bricks. Once migration is completed the removal of bricks is confirmed via the API
// <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
// For instance, to delete a brick from a gluster volume with id `123`, send a request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// The migration process can be tracked from the job id returned from the API using
// <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
// This method supports the following parameters:
// `Bricks`:: List of bricks for which data migration needs to be started.
// `Async`:: Indicates if the migration should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBricksService) Migrate(
	async bool,
	bricks []GlusterBrick,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Bricks: bricks,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "migrate", headers, query, wait)
	return err
}

type GlusterBricksServiceRemoveRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
	replicaCount         *int64
}

func (p *GlusterBricksServiceRemoveRequest) Header(key, value string) *GlusterBricksServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Query(key, value string) *GlusterBricksServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Async(async bool) *GlusterBricksServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceRemoveRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceRemoveRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceRemoveRequest) ReplicaCount(replicaCount int64) *GlusterBricksServiceRemoveRequest {
	p.replicaCount = &replicaCount
	return p
}
func (p *GlusterBricksServiceRemoveRequest) Send() (*GlusterBricksServiceRemoveResponse, error) {
}

type GlusterBricksServiceRemoveResponse struct {
}

//
// Removes bricks from gluster volume.
// The recommended way to remove bricks without data loss is to first migrate the data using
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
// bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
// For example, to delete the bricks from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
// This method supports the following parameters:
// `Bricks`:: The list of bricks to be removed
// `ReplicaCount`:: Replica count of volume post add operation.
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBricksService) Remove(
	bricks []GlusterBrick,
	replicaCount int64,
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["bricks"] = fmt.Sprintf("%v", bricks)
	query["replica_count"] = fmt.Sprintf("%v", replicaCount)
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

type GlusterBricksServiceStopMigrateRequest struct {
	glusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               []GlusterBrick
}

func (p *GlusterBricksServiceStopMigrateRequest) Header(key, value string) *GlusterBricksServiceStopMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Query(key, value string) *GlusterBricksServiceStopMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Async(async bool) *GlusterBricksServiceStopMigrateRequest {
	p.async = &async
	return p
}
func (p *GlusterBricksServiceStopMigrateRequest) Bricks(bricks []GlusterBrick) *GlusterBricksServiceStopMigrateRequest {
	p.bricks = bricks
	return p
}
func (p *GlusterBricksServiceStopMigrateRequest) Send() (*GlusterBricksServiceStopMigrateResponse, error) {
}

type GlusterBricksServiceStopMigrateResponse struct {
}

//
// Stops migration of data from bricks for a remove brick operation.
// To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
// continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
// operation.
// For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
// This method supports the following parameters:
// `Bricks`:: List of bricks for which data migration needs to be stopped. This list should match the arguments passed to
// <<services/gluster_bricks/methods/migrate, migrate>>.
// `Async`:: Indicates if the action should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterBricksService) StopMigrate(
	async bool,
	bricks []GlusterBrick,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Populate the action:
	action := &Action{
		Async:  &async,
		Bricks: bricks,
	}

	// Send the request and wait for the response:
	_, err := op.internalAction(action, "stopmigrate", headers, query, wait)
	return err
}

//
// Returns a reference to the service managing a single gluster brick.
//
func (op *GlusterBricksService) BrickService(id string) *GlusterBrickService {
	return NewGlusterBrickService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterBricksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.BrickService(path)), nil
	}
	return op.BrickService(path[:index]).Service(path[index+1:])
}

func (op *GlusterBricksService) String() string {
	return fmt.Sprintf("GlusterBricksService:%s", op.Path)
}

//
//
type GlusterHooksService struct {
	BaseService
}

func NewGlusterHooksService(connection *Connection, path string) *GlusterHooksService {
	var result GlusterHooksService
	result.Connection = connection
	result.Path = path
	return &result
}

type GlusterHooksServiceListRequest struct {
	glusterHooksService *GlusterHooksService
	header              map[string]string
	query               map[string]string
	max                 *int64
}

func (p *GlusterHooksServiceListRequest) Header(key, value string) *GlusterHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHooksServiceListRequest) Query(key, value string) *GlusterHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHooksServiceListRequest) Max(max int64) *GlusterHooksServiceListRequest {
	p.max = &max
	return p
}
func (p *GlusterHooksServiceListRequest) Send() (*GlusterHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHooksService.Connection.URL(), p.glusterHooksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.glusterHooksService.Connection.username, p.glusterHooksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.glusterHooksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var glusterHooksServiceListResponse GlusterHooksServiceListResponse
	var hooksVar GlusterHooks
	xml.Unmarshal(respBodyBytes, &hooksVar)
	glusterHooksServiceListResponse.hooks = hooksVar.GlusterHooks
	return &glusterHooksServiceListResponse, nil
}

type GlusterHooksServiceListResponse struct {
	hooks []GlusterHook
}

func (p *GlusterHooksServiceListResponse) Hooks() []GlusterHook {
	return p.hooks
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of hooks to return. If not specified all the hooks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *GlusterHooksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]GlusterHook,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hooksVar GlusterHooks
	xml.Unmarshal([]byte(ovResp.Body), &hooksVar)
	return hooksVar.GlusterHooks, nil
}

//
//
func (op *GlusterHooksService) HookService(id string) *GlusterHookService {
	return NewGlusterHookService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterHooksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HookService(path)), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *GlusterHooksService) String() string {
	return fmt.Sprintf("GlusterHooksService:%s", op.Path)
}

//
// Manages the collection of disks available in the system.
//
type DisksService struct {
	BaseService
}

func NewDisksService(connection *Connection, path string) *DisksService {
	var result DisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type DisksServiceAddRequest struct {
	disksService *DisksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *DisksServiceAddRequest) Header(key, value string) *DisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceAddRequest) Query(key, value string) *DisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceAddRequest) Disk(disk *Disk) *DisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *DisksServiceAddRequest) Send() (*DisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.disksService.Connection.URL(), p.disksService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.disksService.Connection.username, p.disksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.disksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var disksServiceAddResponse DisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	disksServiceAddResponse.disk = &diskVar
	return &disksServiceAddResponse, nil
}

type DisksServiceAddResponse struct {
	disk *Disk
}

func (p *DisksServiceAddResponse) Disk() *Disk {
	return p.disk
}

//
// Adds a new floating disk.
// There are three types of disks that can be added - disk image, direct LUN and
//  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
// *Adding a new image disk:*
// When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
// and `format` attributes.
// To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
// with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
// *Adding a new direct LUN disk:*
// When adding a new floating direct LUN via the API, there are two flavors that can be used:
// . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
// to retrieve basic information about the LUN (e.g., size and serial).
// . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
// accessed.
// To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
// `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
// send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <alias>mylun</alias>
//   <lun_storage>
//     <host id="123"/>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="456">
//         <address>10.35.10.20</address>
//         <port>3260</port>
//         <target>iqn.2017-01.com.myhost:444</target>
//       </logical_unit>
//     </logical_units>
//   </lun_storage>
// </disk>
// ----
// To create a new floating direct LUN disk without using a host, remove the `host` element.
// *Adding a new Cinder disk:*
// To create a new floating Cinder disk, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <openstack_volume_type>
//     <name>myceph</name>
//   </openstack_volume_type>
//   <storage_domains>
//     <storage_domain>
//       <name>cinderDomain</name>
//     </storage_domain>
//   </storage_domains>
//   <provisioned_size>1073741824</provisioned_size>
//   <interface>virtio</interface>
//   <format>raw</format>
// </disk>
// ----
// This method supports the following parameters:
// `Disk`:: The disk.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DisksService) Add(
	disk *Disk,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type DisksServiceListRequest struct {
	disksService  *DisksService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	max           *int64
	search        *string
}

func (p *DisksServiceListRequest) Header(key, value string) *DisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceListRequest) Query(key, value string) *DisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceListRequest) CaseSensitive(caseSensitive bool) *DisksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *DisksServiceListRequest) Max(max int64) *DisksServiceListRequest {
	p.max = &max
	return p
}
func (p *DisksServiceListRequest) Search(search string) *DisksServiceListRequest {
	p.search = &search
	return p
}
func (p *DisksServiceListRequest) Send() (*DisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.disksService.Connection.URL(), p.disksService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.disksService.Connection.username, p.disksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.disksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var disksServiceListResponse DisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	disksServiceListResponse.disks = disksVar.Disks
	return &disksServiceListResponse, nil
}

type DisksServiceListResponse struct {
	disks []Disk
}

func (p *DisksServiceListResponse) Disks() []Disk {
	return p.disks
}

//
// Get list of disks.
// [source]
// ----
// GET /ovirt-engine/api/disks
// ----
// You will get a XML response which will look like this one:
// [source,xml]
// ----
// <disks>
//   <disk id="123">
//     <actions>...</actions>
//     <name>MyDisk</name>
//     <description>MyDisk description</description>
//     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
//     <actual_size>5345845248</actual_size>
//     <alias>MyDisk alias</alias>
//     ...
//     <status>ok</status>
//     <storage_type>image</storage_type>
//     <wipe_after_delete>false</wipe_after_delete>
//     <disk_profile id="123"/>
//     <quota id="123"/>
//     <storage_domains>...</storage_domains>
//   </disk>
//   ...
// </disks>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of disks to return. If not specified all the disks are returned.
// `Search`:: A query string used to restrict the returned disks.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DisksService) List(
	caseSensitive bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var disksVar Disks
	xml.Unmarshal([]byte(ovResp.Body), &disksVar)
	return disksVar.Disks, nil
}

//
// Reference to a service managing a specific disk.
//
func (op *DisksService) DiskService(id string) *DiskService {
	return NewDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *DisksService) String() string {
	return fmt.Sprintf("DisksService:%s", op.Path)
}

//
//
type InstanceTypeWatchdogsService struct {
	BaseService
}

func NewInstanceTypeWatchdogsService(connection *Connection, path string) *InstanceTypeWatchdogsService {
	var result InstanceTypeWatchdogsService
	result.Connection = connection
	result.Path = path
	return &result
}

type InstanceTypeWatchdogsServiceAddRequest struct {
	instanceTypeWatchdogsService *InstanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	watchdog                     *Watchdog
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Header(key, value string) *InstanceTypeWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Query(key, value string) *InstanceTypeWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *InstanceTypeWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}
func (p *InstanceTypeWatchdogsServiceAddRequest) Send() (*InstanceTypeWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.Connection.URL(), p.instanceTypeWatchdogsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.watchdog)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogsService.Connection.username, p.instanceTypeWatchdogsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeWatchdogsServiceAddResponse InstanceTypeWatchdogsServiceAddResponse
	var watchdogVar Watchdog
	xml.Unmarshal(respBodyBytes, &watchdogVar)
	instanceTypeWatchdogsServiceAddResponse.watchdog = &watchdogVar
	return &instanceTypeWatchdogsServiceAddResponse, nil
}

type InstanceTypeWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogsServiceAddResponse) Watchdog() *Watchdog {
	return p.watchdog
}

//
// Add new watchdog to the instance type.
//
func (op *InstanceTypeWatchdogsService) Add(
	watchdog *Watchdog,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(watchdog, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogVar Watchdog
	xml.Unmarshal([]byte(ovResp.Body), &watchdogVar)
	return &watchdogVar, nil
}

type InstanceTypeWatchdogsServiceListRequest struct {
	instanceTypeWatchdogsService *InstanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	max                          *int64
	search                       *string
}

func (p *InstanceTypeWatchdogsServiceListRequest) Header(key, value string) *InstanceTypeWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Query(key, value string) *InstanceTypeWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Max(max int64) *InstanceTypeWatchdogsServiceListRequest {
	p.max = &max
	return p
}
func (p *InstanceTypeWatchdogsServiceListRequest) Search(search string) *InstanceTypeWatchdogsServiceListRequest {
	p.search = &search
	return p
}
func (p *InstanceTypeWatchdogsServiceListRequest) Send() (*InstanceTypeWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.Connection.URL(), p.instanceTypeWatchdogsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.instanceTypeWatchdogsService.Connection.username, p.instanceTypeWatchdogsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var instanceTypeWatchdogsServiceListResponse InstanceTypeWatchdogsServiceListResponse
	var watchdogsVar Watchdogs
	xml.Unmarshal(respBodyBytes, &watchdogsVar)
	instanceTypeWatchdogsServiceListResponse.watchdogs = watchdogsVar.Watchdogs
	return &instanceTypeWatchdogsServiceListResponse, nil
}

type InstanceTypeWatchdogsServiceListResponse struct {
	watchdogs []Watchdog
}

func (p *InstanceTypeWatchdogsServiceListResponse) Watchdogs() []Watchdog {
	return p.watchdogs
}

//
// Lists all the configured watchdogs of the instance type.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of watchdogs to return. If not specified all the watchdogs are
// returned.
// `Search`:: A query string used to restrict the returned templates.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *InstanceTypeWatchdogsService) List(
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Watchdog,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var watchdogsVar Watchdogs
	xml.Unmarshal([]byte(ovResp.Body), &watchdogsVar)
	return watchdogsVar.Watchdogs, nil
}

//
//
func (op *InstanceTypeWatchdogsService) WatchdogService(id string) *InstanceTypeWatchdogService {
	return NewInstanceTypeWatchdogService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeWatchdogsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.WatchdogService(path)), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeWatchdogsService) String() string {
	return fmt.Sprintf("InstanceTypeWatchdogsService:%s", op.Path)
}

//
// A service to manage jobs.
//
type JobsService struct {
	BaseService
}

func NewJobsService(connection *Connection, path string) *JobsService {
	var result JobsService
	result.Connection = connection
	result.Path = path
	return &result
}

type JobsServiceAddRequest struct {
	jobsService *JobsService
	header      map[string]string
	query       map[string]string
	job         *Job
}

func (p *JobsServiceAddRequest) Header(key, value string) *JobsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobsServiceAddRequest) Query(key, value string) *JobsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobsServiceAddRequest) Job(job *Job) *JobsServiceAddRequest {
	p.job = job
	return p
}
func (p *JobsServiceAddRequest) Send() (*JobsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.Connection.URL(), p.jobsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.job)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobsService.Connection.username, p.jobsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var jobsServiceAddResponse JobsServiceAddResponse
	var jobVar Job
	xml.Unmarshal(respBodyBytes, &jobVar)
	jobsServiceAddResponse.job = &jobVar
	return &jobsServiceAddResponse, nil
}

type JobsServiceAddResponse struct {
	job *Job
}

func (p *JobsServiceAddResponse) Job() *Job {
	return p.job
}

//
// Add an external job.
// For example, to add a job with the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs
// ----
// With the following request body:
// [source,xml]
// ----
// <job>
//   <description>Doing some work</description>
//   <auto_cleared>true</auto_cleared>
// </job>
// ----
// The response should look like:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Doing some work</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <external>true</external>
//   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
//   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
//   <status>started</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
// This method supports the following parameters:
// `Job`:: Job that will be added.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *JobsService) Add(
	job *Job,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Job,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(job, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var jobVar Job
	xml.Unmarshal([]byte(ovResp.Body), &jobVar)
	return &jobVar, nil
}

type JobsServiceListRequest struct {
	jobsService *JobsService
	header      map[string]string
	query       map[string]string
	max         *int64
}

func (p *JobsServiceListRequest) Header(key, value string) *JobsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobsServiceListRequest) Query(key, value string) *JobsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobsServiceListRequest) Max(max int64) *JobsServiceListRequest {
	p.max = &max
	return p
}
func (p *JobsServiceListRequest) Send() (*JobsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.Connection.URL(), p.jobsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.jobsService.Connection.username, p.jobsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.jobsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var jobsServiceListResponse JobsServiceListResponse
	var jobsVar Jobs
	xml.Unmarshal(respBodyBytes, &jobsVar)
	jobsServiceListResponse.jobs = jobsVar.Jobs
	return &jobsServiceListResponse, nil
}

type JobsServiceListResponse struct {
	jobs []Job
}

func (p *JobsServiceListResponse) Jobs() []Job {
	return p.jobs
}

//
// Retrieves the representation of the jobs.
// [source]
// ----
// GET /ovirt-engine/api/jobs
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <jobs>
//   <job href="/ovirt-engine/api/jobs/123" id="123">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//     </actions>
//     <description>Adding Disk</description>
//     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//     <auto_cleared>true</auto_cleared>
//     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//     <external>false</external>
//     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//     <status>failed</status>
//     <owner href="/ovirt-engine/api/users/456" id="456"/>
//   </job>
//   ...
// </jobs>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of jobs to return. If not specified all the jobs are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *JobsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Job,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var jobsVar Jobs
	xml.Unmarshal([]byte(ovResp.Body), &jobsVar)
	return jobsVar.Jobs, nil
}

//
// Reference to the job service.
//
func (op *JobsService) JobService(id string) *JobService {
	return NewJobService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *JobsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.JobService(path)), nil
	}
	return op.JobService(path[:index]).Service(path[index+1:])
}

func (op *JobsService) String() string {
	return fmt.Sprintf("JobsService:%s", op.Path)
}

//
// A service to manage icons.
//
type IconsService struct {
	BaseService
}

func NewIconsService(connection *Connection, path string) *IconsService {
	var result IconsService
	result.Connection = connection
	result.Path = path
	return &result
}

type IconsServiceListRequest struct {
	iconsService *IconsService
	header       map[string]string
	query        map[string]string
	max          *int64
}

func (p *IconsServiceListRequest) Header(key, value string) *IconsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IconsServiceListRequest) Query(key, value string) *IconsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IconsServiceListRequest) Max(max int64) *IconsServiceListRequest {
	p.max = &max
	return p
}
func (p *IconsServiceListRequest) Send() (*IconsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iconsService.Connection.URL(), p.iconsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.iconsService.Connection.username, p.iconsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.iconsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var iconsServiceListResponse IconsServiceListResponse
	var iconsVar Icons
	xml.Unmarshal(respBodyBytes, &iconsVar)
	iconsServiceListResponse.icons = iconsVar.Icons
	return &iconsServiceListResponse, nil
}

type IconsServiceListResponse struct {
	icons []Icon
}

func (p *IconsServiceListResponse) Icons() []Icon {
	return p.icons
}

//
// Get a list of icons.
// [source]
// ----
// GET /ovirt-engine/api/icons
// ----
// You will get a XML response which is similar to this one:
// [source,xml]
// ----
// <icons>
//   <icon id="123">
//     <data>...</data>
//     <media_type>image/png</media_type>
//   </icon>
//   ...
// </icons>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of icons to return. If not specified all the icons are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *IconsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Icon,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var iconsVar Icons
	xml.Unmarshal([]byte(ovResp.Body), &iconsVar)
	return iconsVar.Icons, nil
}

//
// Reference to the service that manages an specific icon.
//
func (op *IconsService) IconService(id string) *IconService {
	return NewIconService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IconsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.IconService(path)), nil
	}
	return op.IconService(path[:index]).Service(path[index+1:])
}

func (op *IconsService) String() string {
	return fmt.Sprintf("IconsService:%s", op.Path)
}

//
// This service manages the virtual machine templates available in the system.
//
type TemplatesService struct {
	BaseService
}

func NewTemplatesService(connection *Connection, path string) *TemplatesService {
	var result TemplatesService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplatesServiceAddRequest struct {
	templatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	clonePermissions *bool
	template         *Template
}

func (p *TemplatesServiceAddRequest) Header(key, value string) *TemplatesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceAddRequest) Query(key, value string) *TemplatesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceAddRequest) ClonePermissions(clonePermissions bool) *TemplatesServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}
func (p *TemplatesServiceAddRequest) Template(template *Template) *TemplatesServiceAddRequest {
	p.template = template
	return p
}
func (p *TemplatesServiceAddRequest) Send() (*TemplatesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.Connection.URL(), p.templatesService.Path)
	values := make(url.Values)
	if p.clonePermissions != nil {
		values["clonePermissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.template)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templatesService.Connection.username, p.templatesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templatesServiceAddResponse TemplatesServiceAddResponse
	var templateVar Template
	xml.Unmarshal(respBodyBytes, &templateVar)
	templatesServiceAddResponse.template = &templateVar
	return &templatesServiceAddResponse, nil
}

type TemplatesServiceAddResponse struct {
	template *Template
}

func (p *TemplatesServiceAddResponse) Template() *Template {
	return p.template
}

//
// Creates a new template.
// This requires the `name` and `vm` elements. Identify the virtual machine with the `id` `name` attributes.
// [source]
// ----
// POST /ovirt-engine/api/templates
// ----
// With a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
// </template>
// ----
// The template can be created as a sub version of an existing template.This requires the `name` and `vm` attributes
// for the new template, and the `base_template` and `version_name` attributes for the new template version. The
// `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
// `template` section. Identify the virtual machine with the `id` or `name` attributes.
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
//   <version>
//     <base_template id="456"/>
//     <version_name>mytemplate_001</version_name>
//   </version>
// </template>
// ----
// This method supports the following parameters:
// `Template`:: The information about the template or template version.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplatesService) Add(
	template *Template,
	clonePermissions bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Template,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["clone_permissions"] = fmt.Sprintf("%v", clonePermissions)

	// Send the request and get the response
	ovResp, err := op.internalAdd(template, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var templateVar Template
	xml.Unmarshal([]byte(ovResp.Body), &templateVar)
	return &templateVar, nil
}

type TemplatesServiceListRequest struct {
	templatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	caseSensitive    *bool
	filter           *bool
	max              *int64
	search           *string
}

func (p *TemplatesServiceListRequest) Header(key, value string) *TemplatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceListRequest) Query(key, value string) *TemplatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceListRequest) CaseSensitive(caseSensitive bool) *TemplatesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *TemplatesServiceListRequest) Filter(filter bool) *TemplatesServiceListRequest {
	p.filter = &filter
	return p
}
func (p *TemplatesServiceListRequest) Max(max int64) *TemplatesServiceListRequest {
	p.max = &max
	return p
}
func (p *TemplatesServiceListRequest) Search(search string) *TemplatesServiceListRequest {
	p.search = &search
	return p
}
func (p *TemplatesServiceListRequest) Send() (*TemplatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.Connection.URL(), p.templatesService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templatesService.Connection.username, p.templatesService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templatesService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templatesServiceListResponse TemplatesServiceListResponse
	var templatesVar Templates
	xml.Unmarshal(respBodyBytes, &templatesVar)
	templatesServiceListResponse.templates = templatesVar.Templates
	return &templatesServiceListResponse, nil
}

type TemplatesServiceListResponse struct {
	templates []Template
}

func (p *TemplatesServiceListResponse) Templates() []Template {
	return p.templates
}

//
// Returns the list of virtual machine templates.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/templates
// ----
// Will return the list of virtual machines and virtual machine templates.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of templates to return. If not specified all the templates are returned.
// `Search`:: A query string used to restrict the returned templates.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplatesService) List(
	caseSensitive bool,
	filter bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Template,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var templatesVar Templates
	xml.Unmarshal([]byte(ovResp.Body), &templatesVar)
	return templatesVar.Templates, nil
}

//
// Returns a reference to the service that manages a specific virtual machine template.
//
func (op *TemplatesService) TemplateService(id string) *TemplateService {
	return NewTemplateService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplatesService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.TemplateService(path)), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *TemplatesService) String() string {
	return fmt.Sprintf("TemplatesService:%s", op.Path)
}

//
//
type FilterService struct {
	BaseService
}

func NewFilterService(connection *Connection, path string) *FilterService {
	var result FilterService
	result.Connection = connection
	result.Path = path
	return &result
}

type FilterServiceGetRequest struct {
	filterService *FilterService
	header        map[string]string
	query         map[string]string
	filter        *bool
}

func (p *FilterServiceGetRequest) Header(key, value string) *FilterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilterServiceGetRequest) Query(key, value string) *FilterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilterServiceGetRequest) Filter(filter bool) *FilterServiceGetRequest {
	p.filter = &filter
	return p
}
func (p *FilterServiceGetRequest) Send() (*FilterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filterService.Connection.URL(), p.filterService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filterService.Connection.username, p.filterService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filterService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var filterServiceGetResponse FilterServiceGetResponse
	var resultVar Filter
	xml.Unmarshal(respBodyBytes, &resultVar)
	filterServiceGetResponse.result = &resultVar
	return &filterServiceGetResponse, nil
}

type FilterServiceGetResponse struct {
	result *Filter
}

func (p *FilterServiceGetResponse) Result() *Filter {
	return p.result
}

//
// This method supports the following parameters:
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *FilterService) Get(
	filter bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Filter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var resultVar Filter
	xml.Unmarshal([]byte(ovResp.Body), &resultVar)
	return &resultVar, nil
}

type FilterServiceRemoveRequest struct {
	filterService *FilterService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *FilterServiceRemoveRequest) Header(key, value string) *FilterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilterServiceRemoveRequest) Query(key, value string) *FilterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilterServiceRemoveRequest) Async(async bool) *FilterServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *FilterServiceRemoveRequest) Send() (*FilterServiceRemoveResponse, error) {
}

type FilterServiceRemoveResponse struct {
}

//
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *FilterService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FilterService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FilterService) String() string {
	return fmt.Sprintf("FilterService:%s", op.Path)
}

//
// This service is used to list and manipulate affinity labels that are
// assigned to supported entities when accessed using entities/affinitylabels.
//
type AssignedAffinityLabelsService struct {
	BaseService
}

func NewAssignedAffinityLabelsService(connection *Connection, path string) *AssignedAffinityLabelsService {
	var result AssignedAffinityLabelsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedAffinityLabelsServiceAddRequest struct {
	assignedAffinityLabelsService *AssignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
	label                         *AffinityLabel
}

func (p *AssignedAffinityLabelsServiceAddRequest) Header(key, value string) *AssignedAffinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceAddRequest) Query(key, value string) *AssignedAffinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceAddRequest) Label(label *AffinityLabel) *AssignedAffinityLabelsServiceAddRequest {
	p.label = label
	return p
}
func (p *AssignedAffinityLabelsServiceAddRequest) Send() (*AssignedAffinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.Connection.URL(), p.assignedAffinityLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.label)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedAffinityLabelsService.Connection.username, p.assignedAffinityLabelsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedAffinityLabelsServiceAddResponse AssignedAffinityLabelsServiceAddResponse
	var labelVar AffinityLabel
	xml.Unmarshal(respBodyBytes, &labelVar)
	assignedAffinityLabelsServiceAddResponse.label = &labelVar
	return &assignedAffinityLabelsServiceAddResponse, nil
}

type AssignedAffinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AssignedAffinityLabelsServiceAddResponse) Label() *AffinityLabel {
	return p.label
}

//
// Attaches a label to an entity.
//
func (op *AssignedAffinityLabelsService) Add(
	label *AffinityLabel,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*AffinityLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(label, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar AffinityLabel
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return &labelVar, nil
}

type AssignedAffinityLabelsServiceListRequest struct {
	assignedAffinityLabelsService *AssignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
}

func (p *AssignedAffinityLabelsServiceListRequest) Header(key, value string) *AssignedAffinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceListRequest) Query(key, value string) *AssignedAffinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceListRequest) Send() (*AssignedAffinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.Connection.URL(), p.assignedAffinityLabelsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedAffinityLabelsService.Connection.username, p.assignedAffinityLabelsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedAffinityLabelsServiceListResponse AssignedAffinityLabelsServiceListResponse
	var labelVar AffinityLabels
	xml.Unmarshal(respBodyBytes, &labelVar)
	assignedAffinityLabelsServiceListResponse.label = labelVar.AffinityLabels
	return &assignedAffinityLabelsServiceListResponse, nil
}

type AssignedAffinityLabelsServiceListResponse struct {
	label []AffinityLabel
}

func (p *AssignedAffinityLabelsServiceListResponse) Label() []AffinityLabel {
	return p.label
}

//
// Lists all labels that are attached to an entity.
//
func (op *AssignedAffinityLabelsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]AffinityLabel,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var labelVar AffinityLabels
	xml.Unmarshal([]byte(ovResp.Body), &labelVar)
	return labelVar.AffinityLabels, nil
}

//
// Link to the specific entity-label assignment to allow
// removal.
//
func (op *AssignedAffinityLabelsService) LabelService(id string) *AssignedAffinityLabelService {
	return NewAssignedAffinityLabelService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedAffinityLabelsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.LabelService(path)), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AssignedAffinityLabelsService) String() string {
	return fmt.Sprintf("AssignedAffinityLabelsService:%s", op.Path)
}

//
//
type SnapshotCdromService struct {
	BaseService
}

func NewSnapshotCdromService(connection *Connection, path string) *SnapshotCdromService {
	var result SnapshotCdromService
	result.Connection = connection
	result.Path = path
	return &result
}

type SnapshotCdromServiceGetRequest struct {
	snapshotCdromService *SnapshotCdromService
	header               map[string]string
	query                map[string]string
}

func (p *SnapshotCdromServiceGetRequest) Header(key, value string) *SnapshotCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotCdromServiceGetRequest) Query(key, value string) *SnapshotCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotCdromServiceGetRequest) Send() (*SnapshotCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromService.Connection.URL(), p.snapshotCdromService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.snapshotCdromService.Connection.username, p.snapshotCdromService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.snapshotCdromService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var snapshotCdromServiceGetResponse SnapshotCdromServiceGetResponse
	var cdromVar Cdrom
	xml.Unmarshal(respBodyBytes, &cdromVar)
	snapshotCdromServiceGetResponse.cdrom = &cdromVar
	return &snapshotCdromServiceGetResponse, nil
}

type SnapshotCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *SnapshotCdromServiceGetResponse) Cdrom() *Cdrom {
	return p.cdrom
}

//
//
func (op *SnapshotCdromService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Cdrom,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var cdromVar Cdrom
	xml.Unmarshal([]byte(ovResp.Body), &cdromVar)
	return &cdromVar, nil
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotCdromService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotCdromService) String() string {
	return fmt.Sprintf("SnapshotCdromService:%s", op.Path)
}

//
//
type HostNumaNodeService struct {
	BaseService
}

func NewHostNumaNodeService(connection *Connection, path string) *HostNumaNodeService {
	var result HostNumaNodeService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostNumaNodeServiceGetRequest struct {
	hostNumaNodeService *HostNumaNodeService
	header              map[string]string
	query               map[string]string
}

func (p *HostNumaNodeServiceGetRequest) Header(key, value string) *HostNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNumaNodeServiceGetRequest) Query(key, value string) *HostNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNumaNodeServiceGetRequest) Send() (*HostNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodeService.Connection.URL(), p.hostNumaNodeService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostNumaNodeService.Connection.username, p.hostNumaNodeService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostNumaNodeService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostNumaNodeServiceGetResponse HostNumaNodeServiceGetResponse
	var nodeVar NumaNode
	xml.Unmarshal(respBodyBytes, &nodeVar)
	hostNumaNodeServiceGetResponse.node = &nodeVar
	return &hostNumaNodeServiceGetResponse, nil
}

type HostNumaNodeServiceGetResponse struct {
	node *NumaNode
}

func (p *HostNumaNodeServiceGetResponse) Node() *NumaNode {
	return p.node
}

//
//
func (op *HostNumaNodeService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*NumaNode,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var nodeVar NumaNode
	xml.Unmarshal([]byte(ovResp.Body), &nodeVar)
	return &nodeVar, nil
}

//
//
func (op *HostNumaNodeService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.Connection, fmt.Sprintf("%s/statistics", op.Path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNumaNodeService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostNumaNodeService) String() string {
	return fmt.Sprintf("HostNumaNodeService:%s", op.Path)
}

//
//
type TemplateGraphicsConsoleService struct {
	BaseService
}

func NewTemplateGraphicsConsoleService(connection *Connection, path string) *TemplateGraphicsConsoleService {
	var result TemplateGraphicsConsoleService
	result.Connection = connection
	result.Path = path
	return &result
}

type TemplateGraphicsConsoleServiceGetRequest struct {
	templateGraphicsConsoleService *TemplateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Header(key, value string) *TemplateGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Query(key, value string) *TemplateGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Send() (*TemplateGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsoleService.Connection.URL(), p.templateGraphicsConsoleService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.templateGraphicsConsoleService.Connection.username, p.templateGraphicsConsoleService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsoleService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var templateGraphicsConsoleServiceGetResponse TemplateGraphicsConsoleServiceGetResponse
	var consoleVar GraphicsConsole
	xml.Unmarshal(respBodyBytes, &consoleVar)
	templateGraphicsConsoleServiceGetResponse.console = &consoleVar
	return &templateGraphicsConsoleServiceGetResponse, nil
}

type TemplateGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *TemplateGraphicsConsoleServiceGetResponse) Console() *GraphicsConsole {
	return p.console
}

//
// Gets graphics console configuration of the template.
//
func (op *TemplateGraphicsConsoleService) Get(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*GraphicsConsole,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var consoleVar GraphicsConsole
	xml.Unmarshal([]byte(ovResp.Body), &consoleVar)
	return &consoleVar, nil
}

type TemplateGraphicsConsoleServiceRemoveRequest struct {
	templateGraphicsConsoleService *TemplateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Header(key, value string) *TemplateGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Query(key, value string) *TemplateGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Async(async bool) *TemplateGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}
func (p *TemplateGraphicsConsoleServiceRemoveRequest) Send() (*TemplateGraphicsConsoleServiceRemoveResponse, error) {
}

type TemplateGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the template.
// This method supports the following parameters:
// `Async`:: Indicates if the remove should be performed asynchronously.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *TemplateGraphicsConsoleService) Remove(
	async bool,
	headers map[string]string,
	query map[string]string,
	wait bool) error {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["async"] = fmt.Sprintf("%v", async)

	// Send the request and wait for the response:
	_, err := op.internalRemove(headers, query, wait)
	return err
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateGraphicsConsoleService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateGraphicsConsoleService) String() string {
	return fmt.Sprintf("TemplateGraphicsConsoleService:%s", op.Path)
}

//
// This service represents list of hosts that have a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type AffinityLabelHostsService struct {
	BaseService
}

func NewAffinityLabelHostsService(connection *Connection, path string) *AffinityLabelHostsService {
	var result AffinityLabelHostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AffinityLabelHostsServiceAddRequest struct {
	affinityLabelHostsService *AffinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
	host                      *Host
}

func (p *AffinityLabelHostsServiceAddRequest) Header(key, value string) *AffinityLabelHostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostsServiceAddRequest) Query(key, value string) *AffinityLabelHostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostsServiceAddRequest) Host(host *Host) *AffinityLabelHostsServiceAddRequest {
	p.host = host
	return p
}
func (p *AffinityLabelHostsServiceAddRequest) Send() (*AffinityLabelHostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.Connection.URL(), p.affinityLabelHostsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.host)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelHostsService.Connection.username, p.affinityLabelHostsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelHostsServiceAddResponse AffinityLabelHostsServiceAddResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	affinityLabelHostsServiceAddResponse.host = &hostVar
	return &affinityLabelHostsServiceAddResponse, nil
}

type AffinityLabelHostsServiceAddResponse struct {
	host *Host
}

func (p *AffinityLabelHostsServiceAddResponse) Host() *Host {
	return p.host
}

//
// Add a label to a host.
//
func (op *AffinityLabelHostsService) Add(
	host *Host,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Host,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(host, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostVar Host
	xml.Unmarshal([]byte(ovResp.Body), &hostVar)
	return &hostVar, nil
}

type AffinityLabelHostsServiceListRequest struct {
	affinityLabelHostsService *AffinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
}

func (p *AffinityLabelHostsServiceListRequest) Header(key, value string) *AffinityLabelHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostsServiceListRequest) Query(key, value string) *AffinityLabelHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostsServiceListRequest) Send() (*AffinityLabelHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.Connection.URL(), p.affinityLabelHostsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.affinityLabelHostsService.Connection.username, p.affinityLabelHostsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var affinityLabelHostsServiceListResponse AffinityLabelHostsServiceListResponse
	var hostsVar Hosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	affinityLabelHostsServiceListResponse.hosts = hostsVar.Hosts
	return &affinityLabelHostsServiceListResponse, nil
}

type AffinityLabelHostsServiceListResponse struct {
	hosts []Host
}

func (p *AffinityLabelHostsServiceListResponse) Hosts() []Host {
	return p.hosts
}

//
// List all hosts with the label.
//
func (op *AffinityLabelHostsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Host,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostsVar Hosts
	xml.Unmarshal([]byte(ovResp.Body), &hostsVar)
	return hostsVar.Hosts, nil
}

//
// A link to the specific label-host assignment to
// allow label removal.
//
func (op *AffinityLabelHostsService) HostService(id string) *AffinityLabelHostService {
	return NewAffinityLabelHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelHostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelHostsService) String() string {
	return fmt.Sprintf("AffinityLabelHostsService:%s", op.Path)
}

//
//
type DiskSnapshotsService struct {
	BaseService
}

func NewDiskSnapshotsService(connection *Connection, path string) *DiskSnapshotsService {
	var result DiskSnapshotsService
	result.Connection = connection
	result.Path = path
	return &result
}

type DiskSnapshotsServiceListRequest struct {
	diskSnapshotsService *DiskSnapshotsService
	header               map[string]string
	query                map[string]string
	max                  *int64
}

func (p *DiskSnapshotsServiceListRequest) Header(key, value string) *DiskSnapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotsServiceListRequest) Query(key, value string) *DiskSnapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotsServiceListRequest) Max(max int64) *DiskSnapshotsServiceListRequest {
	p.max = &max
	return p
}
func (p *DiskSnapshotsServiceListRequest) Send() (*DiskSnapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotsService.Connection.URL(), p.diskSnapshotsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.diskSnapshotsService.Connection.username, p.diskSnapshotsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.diskSnapshotsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var diskSnapshotsServiceListResponse DiskSnapshotsServiceListResponse
	var snapshotsVar DiskSnapshots
	xml.Unmarshal(respBodyBytes, &snapshotsVar)
	diskSnapshotsServiceListResponse.snapshots = snapshotsVar.DiskSnapshots
	return &diskSnapshotsServiceListResponse, nil
}

type DiskSnapshotsServiceListResponse struct {
	snapshots []DiskSnapshot
}

func (p *DiskSnapshotsServiceListResponse) Snapshots() []DiskSnapshot {
	return p.snapshots
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of snapshots to return. If not specified all the snapshots are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *DiskSnapshotsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]DiskSnapshot,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var snapshotsVar DiskSnapshots
	xml.Unmarshal([]byte(ovResp.Body), &snapshotsVar)
	return snapshotsVar.DiskSnapshots, nil
}

//
//
func (op *DiskSnapshotsService) SnapshotService(id string) *DiskSnapshotService {
	return NewDiskSnapshotService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskSnapshotsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.SnapshotService(path)), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *DiskSnapshotsService) String() string {
	return fmt.Sprintf("DiskSnapshotsService:%s", op.Path)
}

//
// Lists the virtual machines of an export storage domain.
// For example, to retrieve the virtual machines that are available in the storage domain with identifier `123` send the
// following request:
// [source]
// ----
// GET /ovirt-engine/api/storagedomains/123/vms
// ----
// This will return the following response body:
// [source,xml]
// ----
// <vms>
//   <vm id="456" href="/api/storagedomains/123/vms/456">
//     <name>vm1</name>
//     ...
//     <storage_domain id="123" href="/api/storagedomains/123"/>
//     <actions>
//       <link rel="import" href="/api/storagedomains/123/vms/456/import"/>
//     </actions>
//   </vm>
// </vms>
// ----
// Virtual machines and templates in these collections have a similar representation to their counterparts in the
// top-level <<types/vm, Vm>> and <<types/template, Template>> collections, except they also contain a
// <<types/storage_domain, StorageDomain>> reference and an <<services/storage_domain_vm/methods/import, import>>
// action.
//
type StorageDomainVmsService struct {
	BaseService
}

func NewStorageDomainVmsService(connection *Connection, path string) *StorageDomainVmsService {
	var result StorageDomainVmsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainVmsServiceListRequest struct {
	storageDomainVmsService *StorageDomainVmsService
	header                  map[string]string
	query                   map[string]string
	max                     *int64
}

func (p *StorageDomainVmsServiceListRequest) Header(key, value string) *StorageDomainVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmsServiceListRequest) Query(key, value string) *StorageDomainVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmsServiceListRequest) Max(max int64) *StorageDomainVmsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainVmsServiceListRequest) Send() (*StorageDomainVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmsService.Connection.URL(), p.storageDomainVmsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainVmsService.Connection.username, p.storageDomainVmsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainVmsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainVmsServiceListResponse StorageDomainVmsServiceListResponse
	var vmVar Vms
	xml.Unmarshal(respBodyBytes, &vmVar)
	storageDomainVmsServiceListResponse.vm = vmVar.Vms
	return &storageDomainVmsServiceListResponse, nil
}

type StorageDomainVmsServiceListResponse struct {
	vm []Vm
}

func (p *StorageDomainVmsServiceListResponse) Vm() []Vm {
	return p.vm
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of virtual machines to return. If not specified all the virtual machines are
// returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainVmsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Vm,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var vmVar Vms
	xml.Unmarshal([]byte(ovResp.Body), &vmVar)
	return vmVar.Vms, nil
}

//
//
func (op *StorageDomainVmsService) VmService(id string) *StorageDomainVmService {
	return NewStorageDomainVmService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.VmService(path)), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainVmsService) String() string {
	return fmt.Sprintf("StorageDomainVmsService:%s", op.Path)
}

//
// A service that manages hosts.
//
type HostsService struct {
	BaseService
}

func NewHostsService(connection *Connection, path string) *HostsService {
	var result HostsService
	result.Connection = connection
	result.Path = path
	return &result
}

type HostsServiceAddRequest struct {
	hostsService         *HostsService
	header               map[string]string
	query                map[string]string
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *HostsServiceAddRequest) Header(key, value string) *HostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceAddRequest) Query(key, value string) *HostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceAddRequest) DeployHostedEngine(deployHostedEngine bool) *HostsServiceAddRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}
func (p *HostsServiceAddRequest) Host(host *Host) *HostsServiceAddRequest {
	p.host = host
	return p
}
func (p *HostsServiceAddRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostsServiceAddRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}
func (p *HostsServiceAddRequest) Send() (*HostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.Connection.URL(), p.hostsService.Path)
	values := make(url.Values)
	if p.deployHostedEngine != nil {
		values["deployHostedEngine"] = []string{fmt.Sprintf("%v", *p.deployHostedEngine)}
	}
	if p.undeployHostedEngine != nil {
		values["undeployHostedEngine"] = []string{fmt.Sprintf("%v", *p.undeployHostedEngine)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.host)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostsService.Connection.username, p.hostsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostsServiceAddResponse HostsServiceAddResponse
	var hostVar Host
	xml.Unmarshal(respBodyBytes, &hostVar)
	hostsServiceAddResponse.host = &hostVar
	return &hostsServiceAddResponse, nil
}

type HostsServiceAddResponse struct {
	host *Host
}

func (p *HostsServiceAddResponse) Host() *Host {
	return p.host
}

//
// Creates a new host.
// The host is created based on the attributes of the `host` parameter. The `name`, `address` and `root_password`
// properties are required.
// For example, to add a host send the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With the following request body:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>myrootpassword</root_password>
// </host>
// ----
// NOTE: The `root_password` element is only included in the client-provided initial representation and is not
// exposed in the representations returned from subsequent requests.
// To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
// [source]
// ----
// POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
// ----
// This method supports the following parameters:
// `Host`:: The host definition from which to create the new host is passed as parameter, and the newly created host
// is returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostsService) Add(
	host *Host,
	deployHostedEngine bool,
	undeployHostedEngine bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Host,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["deploy_hosted_engine"] = fmt.Sprintf("%v", deployHostedEngine)
	query["undeploy_hosted_engine"] = fmt.Sprintf("%v", undeployHostedEngine)

	// Send the request and get the response
	ovResp, err := op.internalAdd(host, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostVar Host
	xml.Unmarshal([]byte(ovResp.Body), &hostVar)
	return &hostVar, nil
}

type HostsServiceListRequest struct {
	hostsService  *HostsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	filter        *bool
	max           *int64
	search        *string
}

func (p *HostsServiceListRequest) Header(key, value string) *HostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceListRequest) Query(key, value string) *HostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceListRequest) CaseSensitive(caseSensitive bool) *HostsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *HostsServiceListRequest) Filter(filter bool) *HostsServiceListRequest {
	p.filter = &filter
	return p
}
func (p *HostsServiceListRequest) Max(max int64) *HostsServiceListRequest {
	p.max = &max
	return p
}
func (p *HostsServiceListRequest) Search(search string) *HostsServiceListRequest {
	p.search = &search
	return p
}
func (p *HostsServiceListRequest) Send() (*HostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.Connection.URL(), p.hostsService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.hostsService.Connection.username, p.hostsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.hostsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var hostsServiceListResponse HostsServiceListResponse
	var hostsVar Hosts
	xml.Unmarshal(respBodyBytes, &hostsVar)
	hostsServiceListResponse.hosts = hostsVar.Hosts
	return &hostsServiceListResponse, nil
}

type HostsServiceListResponse struct {
	hosts []Host
}

func (p *HostsServiceListResponse) Hosts() []Host {
	return p.hosts
}

//
// Get a list of all available hosts.
// For example, to list the hosts send the following request:
// ....
// GET /ovirt-engine/api/hosts
// ....
// The response body will be something like this:
// [source,xml]
// ----
// <hosts>
//   <host href="/ovirt-engine/api/hosts/123" id="123">
//     ...
//   </host>
//   <host href="/ovirt-engine/api/hosts/456" id="456">
//     ...
//   </host>
//   ...
// </host>
// ----
// This method supports the following parameters:
// `Max`:: Sets the maximum number of hosts to return. If not specified all the hosts are returned.
// `Search`:: A query string used to restrict the returned hosts.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *HostsService) List(
	caseSensitive bool,
	filter bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Host,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var hostsVar Hosts
	xml.Unmarshal([]byte(ovResp.Body), &hostsVar)
	return hostsVar.Hosts, nil
}

//
// A Reference to service managing a specific host.
//
func (op *HostsService) HostService(id string) *HostService {
	return NewHostService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.HostService(path)), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *HostsService) String() string {
	return fmt.Sprintf("HostsService:%s", op.Path)
}

//
// Manages the collection of disks available inside an specific storage domain.
//
type StorageDomainDisksService struct {
	BaseService
}

func NewStorageDomainDisksService(connection *Connection, path string) *StorageDomainDisksService {
	var result StorageDomainDisksService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageDomainDisksServiceAddRequest struct {
	storageDomainDisksService *StorageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	disk                      *Disk
	unregistered              *bool
}

func (p *StorageDomainDisksServiceAddRequest) Header(key, value string) *StorageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Query(key, value string) *StorageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Disk(disk *Disk) *StorageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}
func (p *StorageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *StorageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}
func (p *StorageDomainDisksServiceAddRequest) Send() (*StorageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.Connection.URL(), p.storageDomainDisksService.Path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.disk)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDisksService.Connection.username, p.storageDomainDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainDisksServiceAddResponse StorageDomainDisksServiceAddResponse
	var diskVar Disk
	xml.Unmarshal(respBodyBytes, &diskVar)
	storageDomainDisksServiceAddResponse.disk = &diskVar
	return &storageDomainDisksServiceAddResponse, nil
}

type StorageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *StorageDomainDisksServiceAddResponse) Disk() *Disk {
	return p.disk
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
// This method supports the following parameters:
// `Disk`:: The disk to add or register.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainDisksService) Add(
	disk *Disk,
	unregistered bool,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["unregistered"] = fmt.Sprintf("%v", unregistered)

	// Send the request and get the response
	ovResp, err := op.internalAdd(disk, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var diskVar Disk
	xml.Unmarshal([]byte(ovResp.Body), &diskVar)
	return &diskVar, nil
}

type StorageDomainDisksServiceListRequest struct {
	storageDomainDisksService *StorageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	max                       *int64
}

func (p *StorageDomainDisksServiceListRequest) Header(key, value string) *StorageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDisksServiceListRequest) Query(key, value string) *StorageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDisksServiceListRequest) Max(max int64) *StorageDomainDisksServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageDomainDisksServiceListRequest) Send() (*StorageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.Connection.URL(), p.storageDomainDisksService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageDomainDisksService.Connection.username, p.storageDomainDisksService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageDomainDisksServiceListResponse StorageDomainDisksServiceListResponse
	var disksVar Disks
	xml.Unmarshal(respBodyBytes, &disksVar)
	storageDomainDisksServiceListResponse.disks = disksVar.Disks
	return &storageDomainDisksServiceListResponse, nil
}

type StorageDomainDisksServiceListResponse struct {
	disks []Disk
}

func (p *StorageDomainDisksServiceListResponse) Disks() []Disk {
	return p.disks
}

//
// Retrieve the list of disks that are available in the storage domain.
// This method supports the following parameters:
// `Max`:: Sets the maximum number of disks to return. If not specified all the disks are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageDomainDisksService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Disk,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var disksVar Disks
	xml.Unmarshal([]byte(ovResp.Body), &disksVar)
	return disksVar.Disks, nil
}

//
// Reference to the service that manages a specific disk.
//
func (op *StorageDomainDisksService) DiskService(id string) *StorageDomainDiskService {
	return NewStorageDomainDiskService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainDisksService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.DiskService(path)), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainDisksService) String() string {
	return fmt.Sprintf("StorageDomainDisksService:%s", op.Path)
}

//
//
type FiltersService struct {
	BaseService
}

func NewFiltersService(connection *Connection, path string) *FiltersService {
	var result FiltersService
	result.Connection = connection
	result.Path = path
	return &result
}

type FiltersServiceAddRequest struct {
	filtersService *FiltersService
	header         map[string]string
	query          map[string]string
	filter         *Filter
}

func (p *FiltersServiceAddRequest) Header(key, value string) *FiltersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FiltersServiceAddRequest) Query(key, value string) *FiltersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FiltersServiceAddRequest) Filter(filter *Filter) *FiltersServiceAddRequest {
	p.filter = filter
	return p
}
func (p *FiltersServiceAddRequest) Send() (*FiltersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.Connection.URL(), p.filtersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.filter)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filtersService.Connection.username, p.filtersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filtersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var filtersServiceAddResponse FiltersServiceAddResponse
	var filterVar Filter
	xml.Unmarshal(respBodyBytes, &filterVar)
	filtersServiceAddResponse.filter = &filterVar
	return &filtersServiceAddResponse, nil
}

type FiltersServiceAddResponse struct {
	filter *Filter
}

func (p *FiltersServiceAddResponse) Filter() *Filter {
	return p.filter
}

//
//
func (op *FiltersService) Add(
	filter *Filter,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Filter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(filter, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var filterVar Filter
	xml.Unmarshal([]byte(ovResp.Body), &filterVar)
	return &filterVar, nil
}

type FiltersServiceListRequest struct {
	filtersService *FiltersService
	header         map[string]string
	query          map[string]string
	filter         *bool
	max            *int64
}

func (p *FiltersServiceListRequest) Header(key, value string) *FiltersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FiltersServiceListRequest) Query(key, value string) *FiltersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FiltersServiceListRequest) Filter(filter bool) *FiltersServiceListRequest {
	p.filter = &filter
	return p
}
func (p *FiltersServiceListRequest) Max(max int64) *FiltersServiceListRequest {
	p.max = &max
	return p
}
func (p *FiltersServiceListRequest) Send() (*FiltersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.Connection.URL(), p.filtersService.Path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.filtersService.Connection.username, p.filtersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.filtersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var filtersServiceListResponse FiltersServiceListResponse
	var filtersVar Filters
	xml.Unmarshal(respBodyBytes, &filtersVar)
	filtersServiceListResponse.filters = filtersVar.Filters
	return &filtersServiceListResponse, nil
}

type FiltersServiceListResponse struct {
	filters []Filter
}

func (p *FiltersServiceListResponse) Filters() []Filter {
	return p.filters
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of filters to return. If not specified all the filters are returned.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *FiltersService) List(
	filter bool,
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Filter,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var filtersVar Filters
	xml.Unmarshal([]byte(ovResp.Body), &filtersVar)
	return filtersVar.Filters, nil
}

//
//
func (op *FiltersService) FilterService(id string) *FilterService {
	return NewFilterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FiltersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.FilterService(path)), nil
	}
	return op.FilterService(path[:index]).Service(path[index+1:])
}

func (op *FiltersService) String() string {
	return fmt.Sprintf("FiltersService:%s", op.Path)
}

//
//
type StorageServerConnectionsService struct {
	BaseService
}

func NewStorageServerConnectionsService(connection *Connection, path string) *StorageServerConnectionsService {
	var result StorageServerConnectionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type StorageServerConnectionsServiceAddRequest struct {
	storageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddRequest) Header(key, value string) *StorageServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddRequest) Query(key, value string) *StorageServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}
func (p *StorageServerConnectionsServiceAddRequest) Send() (*StorageServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.Connection.URL(), p.storageServerConnectionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.connection)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionsService.Connection.username, p.storageServerConnectionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageServerConnectionsServiceAddResponse StorageServerConnectionsServiceAddResponse
	var connectionVar StorageConnection
	xml.Unmarshal(respBodyBytes, &connectionVar)
	storageServerConnectionsServiceAddResponse.connection = &connectionVar
	return &storageServerConnectionsServiceAddResponse, nil
}

type StorageServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddResponse) Connection() *StorageConnection {
	return p.connection
}

//
// Creates a new storage connection.
// For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
// `/export/mydata` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageconnections
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <type>nfs</type>
//   <address>mynfs.example.com</address>
//   <path>/export/mydata</path>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
func (op *StorageServerConnectionsService) Add(
	connection *StorageConnection,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*StorageConnection,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(connection, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var connectionVar StorageConnection
	xml.Unmarshal([]byte(ovResp.Body), &connectionVar)
	return &connectionVar, nil
}

type StorageServerConnectionsServiceListRequest struct {
	storageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	max                             *int64
}

func (p *StorageServerConnectionsServiceListRequest) Header(key, value string) *StorageServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Query(key, value string) *StorageServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Max(max int64) *StorageServerConnectionsServiceListRequest {
	p.max = &max
	return p
}
func (p *StorageServerConnectionsServiceListRequest) Send() (*StorageServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.Connection.URL(), p.storageServerConnectionsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.storageServerConnectionsService.Connection.username, p.storageServerConnectionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var storageServerConnectionsServiceListResponse StorageServerConnectionsServiceListResponse
	var connectionsVar StorageConnections
	xml.Unmarshal(respBodyBytes, &connectionsVar)
	storageServerConnectionsServiceListResponse.connections = connectionsVar.StorageConnections
	return &storageServerConnectionsServiceListResponse, nil
}

type StorageServerConnectionsServiceListResponse struct {
	connections []StorageConnection
}

func (p *StorageServerConnectionsServiceListResponse) Connections() []StorageConnection {
	return p.connections
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of connections to return. If not specified all the connections are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *StorageServerConnectionsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]StorageConnection,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var connectionsVar StorageConnections
	xml.Unmarshal([]byte(ovResp.Body), &connectionsVar)
	return connectionsVar.StorageConnections, nil
}

//
//
func (op *StorageServerConnectionsService) StorageConnectionService(id string) *StorageServerConnectionService {
	return NewStorageServerConnectionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.StorageConnectionService(path)), nil
	}
	return op.StorageConnectionService(path[:index]).Service(path[index+1:])
}

func (op *StorageServerConnectionsService) String() string {
	return fmt.Sprintf("StorageServerConnectionsService:%s", op.Path)
}

//
//
type FenceAgentsService struct {
	BaseService
}

func NewFenceAgentsService(connection *Connection, path string) *FenceAgentsService {
	var result FenceAgentsService
	result.Connection = connection
	result.Path = path
	return &result
}

type FenceAgentsServiceAddRequest struct {
	fenceAgentsService *FenceAgentsService
	header             map[string]string
	query              map[string]string
	agent              *Agent
}

func (p *FenceAgentsServiceAddRequest) Header(key, value string) *FenceAgentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentsServiceAddRequest) Query(key, value string) *FenceAgentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentsServiceAddRequest) Agent(agent *Agent) *FenceAgentsServiceAddRequest {
	p.agent = agent
	return p
}
func (p *FenceAgentsServiceAddRequest) Send() (*FenceAgentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.Connection.URL(), p.fenceAgentsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.agent)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentsService.Connection.username, p.fenceAgentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var fenceAgentsServiceAddResponse FenceAgentsServiceAddResponse
	var agentVar Agent
	xml.Unmarshal(respBodyBytes, &agentVar)
	fenceAgentsServiceAddResponse.agent = &agentVar
	return &fenceAgentsServiceAddResponse, nil
}

type FenceAgentsServiceAddResponse struct {
	agent *Agent
}

func (p *FenceAgentsServiceAddResponse) Agent() *Agent {
	return p.agent
}

//
//
func (op *FenceAgentsService) Add(
	agent *Agent,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Agent,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(agent, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var agentVar Agent
	xml.Unmarshal([]byte(ovResp.Body), &agentVar)
	return &agentVar, nil
}

type FenceAgentsServiceListRequest struct {
	fenceAgentsService *FenceAgentsService
	header             map[string]string
	query              map[string]string
	max                *int64
}

func (p *FenceAgentsServiceListRequest) Header(key, value string) *FenceAgentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentsServiceListRequest) Query(key, value string) *FenceAgentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentsServiceListRequest) Max(max int64) *FenceAgentsServiceListRequest {
	p.max = &max
	return p
}
func (p *FenceAgentsServiceListRequest) Send() (*FenceAgentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.Connection.URL(), p.fenceAgentsService.Path)
	values := make(url.Values)
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.fenceAgentsService.Connection.username, p.fenceAgentsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var fenceAgentsServiceListResponse FenceAgentsServiceListResponse
	var agentsVar Agents
	xml.Unmarshal(respBodyBytes, &agentsVar)
	fenceAgentsServiceListResponse.agents = agentsVar.Agents
	return &fenceAgentsServiceListResponse, nil
}

type FenceAgentsServiceListResponse struct {
	agents []Agent
}

func (p *FenceAgentsServiceListResponse) Agents() []Agent {
	return p.agents
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of agents to return. If not specified all the agents are returned.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *FenceAgentsService) List(
	max int64,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Agent,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["max"] = fmt.Sprintf("%v", max)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var agentsVar Agents
	xml.Unmarshal([]byte(ovResp.Body), &agentsVar)
	return agentsVar.Agents, nil
}

//
//
func (op *FenceAgentsService) AgentService(id string) *FenceAgentService {
	return NewFenceAgentService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FenceAgentsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.AgentService(path)), nil
	}
	return op.AgentService(path[:index]).Service(path[index+1:])
}

func (op *FenceAgentsService) String() string {
	return fmt.Sprintf("FenceAgentsService:%s", op.Path)
}

//
// A service to manage clusters.
//
type ClustersService struct {
	BaseService
}

func NewClustersService(connection *Connection, path string) *ClustersService {
	var result ClustersService
	result.Connection = connection
	result.Path = path
	return &result
}

type ClustersServiceAddRequest struct {
	clustersService *ClustersService
	header          map[string]string
	query           map[string]string
	cluster         *Cluster
}

func (p *ClustersServiceAddRequest) Header(key, value string) *ClustersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClustersServiceAddRequest) Query(key, value string) *ClustersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClustersServiceAddRequest) Cluster(cluster *Cluster) *ClustersServiceAddRequest {
	p.cluster = cluster
	return p
}
func (p *ClustersServiceAddRequest) Send() (*ClustersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.Connection.URL(), p.clustersService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.cluster)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clustersService.Connection.username, p.clustersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clustersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var clustersServiceAddResponse ClustersServiceAddResponse
	var clusterVar Cluster
	xml.Unmarshal(respBodyBytes, &clusterVar)
	clustersServiceAddResponse.cluster = &clusterVar
	return &clustersServiceAddResponse, nil
}

type ClustersServiceAddResponse struct {
	cluster *Cluster
}

func (p *ClustersServiceAddResponse) Cluster() *Cluster {
	return p.cluster
}

//
// Creates a new cluster.
// This requires the `name`, `cpu.type` and `data_center` attributes. Identify the data center with either the `id`
// or `name` attributes.
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <data_center id="123"/>
// </cluster>
// ----
//
func (op *ClustersService) Add(
	cluster *Cluster,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Cluster,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(cluster, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var clusterVar Cluster
	xml.Unmarshal([]byte(ovResp.Body), &clusterVar)
	return &clusterVar, nil
}

type ClustersServiceListRequest struct {
	clustersService *ClustersService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	filter          *bool
	max             *int64
	search          *string
}

func (p *ClustersServiceListRequest) Header(key, value string) *ClustersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClustersServiceListRequest) Query(key, value string) *ClustersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClustersServiceListRequest) CaseSensitive(caseSensitive bool) *ClustersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}
func (p *ClustersServiceListRequest) Filter(filter bool) *ClustersServiceListRequest {
	p.filter = &filter
	return p
}
func (p *ClustersServiceListRequest) Max(max int64) *ClustersServiceListRequest {
	p.max = &max
	return p
}
func (p *ClustersServiceListRequest) Search(search string) *ClustersServiceListRequest {
	p.search = &search
	return p
}
func (p *ClustersServiceListRequest) Send() (*ClustersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.Connection.URL(), p.clustersService.Path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["caseSensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}
	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}
	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.clustersService.Connection.username, p.clustersService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.clustersService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var clustersServiceListResponse ClustersServiceListResponse
	var clustersVar Clusters
	xml.Unmarshal(respBodyBytes, &clustersVar)
	clustersServiceListResponse.clusters = clustersVar.Clusters
	return &clustersServiceListResponse, nil
}

type ClustersServiceListResponse struct {
	clusters []Cluster
}

func (p *ClustersServiceListResponse) Clusters() []Cluster {
	return p.clusters
}

//
// This method supports the following parameters:
// `Max`:: Sets the maximum number of clusters to return. If not specified all the clusters are returned.
// `Search`:: A query string used to restrict the returned clusters.
// `CaseSensitive`:: Indicates if the search performed using the `search` parameter should be performed taking case into
// account. The default value is `true`, which means that case is taken into account. If you want to search
// ignoring case set it to `false`.
// `Filter`:: Indicates if the results should be filtered according to the permissions of the user.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *ClustersService) List(
	caseSensitive bool,
	filter bool,
	max int64,
	search string,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Cluster,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}
	query["case_sensitive"] = fmt.Sprintf("%v", caseSensitive)
	query["filter"] = fmt.Sprintf("%v", filter)
	query["max"] = fmt.Sprintf("%v", max)
	query["search"] = fmt.Sprintf("%v", search)

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var clustersVar Clusters
	xml.Unmarshal([]byte(ovResp.Body), &clustersVar)
	return clustersVar.Clusters, nil
}

//
// Reference to the service that manages a specific cluster.
//
func (op *ClustersService) ClusterService(id string) *ClusterService {
	return NewClusterService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClustersService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.ClusterService(path)), nil
	}
	return op.ClusterService(path[:index]).Service(path[index+1:])
}

func (op *ClustersService) String() string {
	return fmt.Sprintf("ClustersService:%s", op.Path)
}

//
// Represents a permission sub-collection, scoped by user, group or some entity type.
//
type AssignedPermissionsService struct {
	BaseService
}

func NewAssignedPermissionsService(connection *Connection, path string) *AssignedPermissionsService {
	var result AssignedPermissionsService
	result.Connection = connection
	result.Path = path
	return &result
}

type AssignedPermissionsServiceAddRequest struct {
	assignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddRequest) Header(key, value string) *AssignedPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddRequest) Query(key, value string) *AssignedPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddRequest {
	p.permission = permission
	return p
}
func (p *AssignedPermissionsServiceAddRequest) Send() (*AssignedPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.Connection.URL(), p.assignedPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body *bytes.Buffer
	xmlBytes, err := xml.Marshal(p.permission)
	if err != nil {
		return nil, err
	}
	body = bytes.NewBuffer(xmlBytes)
	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedPermissionsService.Connection.username, p.assignedPermissionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedPermissionsServiceAddResponse AssignedPermissionsServiceAddResponse
	var permissionVar Permission
	xml.Unmarshal(respBodyBytes, &permissionVar)
	assignedPermissionsServiceAddResponse.permission = &permissionVar
	return &assignedPermissionsServiceAddResponse, nil
}

type AssignedPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddResponse) Permission() *Permission {
	return p.permission
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
// This method supports the following parameters:
// `Permission`:: The permission.
// `headers`:: Additional HTTP headers.
// `query`:: Additional URL query parameters.
// `wait`:: If `True` wait for the response.
//
func (op *AssignedPermissionsService) Add(
	permission *Permission,
	headers map[string]string,
	query map[string]string,
	wait bool) (
	*Permission,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and get the response
	ovResp, err := op.internalAdd(permission, headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permissionVar Permission
	xml.Unmarshal([]byte(ovResp.Body), &permissionVar)
	return &permissionVar, nil
}

type AssignedPermissionsServiceListRequest struct {
	assignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
}

func (p *AssignedPermissionsServiceListRequest) Header(key, value string) *AssignedPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceListRequest) Query(key, value string) *AssignedPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceListRequest) Send() (*AssignedPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.Connection.URL(), p.assignedPermissionsService.Path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("POST", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	rawAuthStr := fmt.Sprintf("%s:%s", p.assignedPermissionsService.Connection.username, p.assignedPermissionsService.Connection.username)
	// Generate base64(username:password)
	auth := fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(rawAuthStr)))
	req.Header.Add("Authorization", auth)
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.Connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	respBodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var assignedPermissionsServiceListResponse AssignedPermissionsServiceListResponse
	var permissionsVar Permissions
	xml.Unmarshal(respBodyBytes, &permissionsVar)
	assignedPermissionsServiceListResponse.permissions = permissionsVar.Permissions
	return &assignedPermissionsServiceListResponse, nil
}

type AssignedPermissionsServiceListResponse struct {
	permissions []Permission
}

func (p *AssignedPermissionsServiceListResponse) Permissions() []Permission {
	return p.permissions
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
//
func (op *AssignedPermissionsService) List(
	headers map[string]string,
	query map[string]string,
	wait bool) (
	[]Permission,
	error) {
	// Build the URL:
	if query == nil {
		query = make(map[string]string)
	}

	// Send the request and wait for the response:
	ovResp, err := op.internalGet(headers, query, wait)
	if err != nil {
		return nil, err
	}
	var permissionsVar Permissions
	xml.Unmarshal([]byte(ovResp.Body), &permissionsVar)
	return permissionsVar.Permissions, nil
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *AssignedPermissionsService) PermissionService(id string) *PermissionService {
	return NewPermissionService(op.Connection, fmt.Sprintf("%s/%s", op.Path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedPermissionsService) Service(path string) (interface{}, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return *(op.PermissionService(path)), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *AssignedPermissionsService) String() string {
	return fmt.Sprintf("AssignedPermissionsService:%s", op.Path)
}
